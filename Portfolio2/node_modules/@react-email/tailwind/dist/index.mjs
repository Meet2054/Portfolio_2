import * as Ys from "react";
import qS from "react";
var Bt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function nd(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function GS(t) {
  if (t.__esModule)
    return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function a() {
      return this instanceof a ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function(a) {
    var c = Object.getOwnPropertyDescriptor(t, a);
    Object.defineProperty(n, a, c.get ? c : {
      enumerable: !0,
      get: function() {
        return t[a];
      }
    });
  }), n;
}
var Ve = {}, zS = {}, vu = {};
vu.byteLength = bO;
vu.toByteArray = vO;
vu.fromByteArray = SO;
var is = [], ai = [], mO = typeof Uint8Array < "u" ? Uint8Array : Array, Bp = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var ao = 0, yO = Bp.length; ao < yO; ++ao)
  is[ao] = Bp[ao], ai[Bp.charCodeAt(ao)] = ao;
ai["-".charCodeAt(0)] = 62;
ai["_".charCodeAt(0)] = 63;
function KS(t) {
  var e = t.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n = t.indexOf("=");
  n === -1 && (n = e);
  var a = n === e ? 0 : 4 - n % 4;
  return [n, a];
}
function bO(t) {
  var e = KS(t), n = e[0], a = e[1];
  return (n + a) * 3 / 4 - a;
}
function gO(t, e, n) {
  return (e + n) * 3 / 4 - n;
}
function vO(t) {
  var e, n = KS(t), a = n[0], c = n[1], u = new mO(gO(t, a, c)), r = 0, l = c > 0 ? a - 4 : a, i;
  for (i = 0; i < l; i += 4)
    e = ai[t.charCodeAt(i)] << 18 | ai[t.charCodeAt(i + 1)] << 12 | ai[t.charCodeAt(i + 2)] << 6 | ai[t.charCodeAt(i + 3)], u[r++] = e >> 16 & 255, u[r++] = e >> 8 & 255, u[r++] = e & 255;
  return c === 2 && (e = ai[t.charCodeAt(i)] << 2 | ai[t.charCodeAt(i + 1)] >> 4, u[r++] = e & 255), c === 1 && (e = ai[t.charCodeAt(i)] << 10 | ai[t.charCodeAt(i + 1)] << 4 | ai[t.charCodeAt(i + 2)] >> 2, u[r++] = e >> 8 & 255, u[r++] = e & 255), u;
}
function EO(t) {
  return is[t >> 18 & 63] + is[t >> 12 & 63] + is[t >> 6 & 63] + is[t & 63];
}
function _O(t, e, n) {
  for (var a, c = [], u = e; u < n; u += 3)
    a = (t[u] << 16 & 16711680) + (t[u + 1] << 8 & 65280) + (t[u + 2] & 255), c.push(EO(a));
  return c.join("");
}
function SO(t) {
  for (var e, n = t.length, a = n % 3, c = [], u = 16383, r = 0, l = n - a; r < l; r += u)
    c.push(_O(t, r, r + u > l ? l : r + u));
  return a === 1 ? (e = t[n - 1], c.push(
    is[e >> 2] + is[e << 4 & 63] + "=="
  )) : a === 2 && (e = (t[n - 2] << 8) + t[n - 1], c.push(
    is[e >> 10] + is[e >> 4 & 63] + is[e << 2 & 63] + "="
  )), c.join("");
}
var id = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
id.read = function(t, e, n, a, c) {
  var u, r, l = c * 8 - a - 1, i = (1 << l) - 1, f = i >> 1, d = -7, s = n ? c - 1 : 0, o = n ? -1 : 1, m = t[e + s];
  for (s += o, u = m & (1 << -d) - 1, m >>= -d, d += l; d > 0; u = u * 256 + t[e + s], s += o, d -= 8)
    ;
  for (r = u & (1 << -d) - 1, u >>= -d, d += a; d > 0; r = r * 256 + t[e + s], s += o, d -= 8)
    ;
  if (u === 0)
    u = 1 - f;
  else {
    if (u === i)
      return r ? NaN : (m ? -1 : 1) * (1 / 0);
    r = r + Math.pow(2, a), u = u - f;
  }
  return (m ? -1 : 1) * r * Math.pow(2, u - a);
};
id.write = function(t, e, n, a, c, u) {
  var r, l, i, f = u * 8 - c - 1, d = (1 << f) - 1, s = d >> 1, o = c === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, m = a ? 0 : u - 1, h = a ? 1 : -1, y = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (l = isNaN(e) ? 1 : 0, r = d) : (r = Math.floor(Math.log(e) / Math.LN2), e * (i = Math.pow(2, -r)) < 1 && (r--, i *= 2), r + s >= 1 ? e += o / i : e += o * Math.pow(2, 1 - s), e * i >= 2 && (r++, i /= 2), r + s >= d ? (l = 0, r = d) : r + s >= 1 ? (l = (e * i - 1) * Math.pow(2, c), r = r + s) : (l = e * Math.pow(2, s - 1) * Math.pow(2, c), r = 0)); c >= 8; t[n + m] = l & 255, m += h, l /= 256, c -= 8)
    ;
  for (r = r << c | l, f += c; f > 0; t[n + m] = r & 255, m += h, r /= 256, f -= 8)
    ;
  t[n + m - h] |= y * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(t) {
  const e = vu, n = id, a = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  t.Buffer = l, t.SlowBuffer = S, t.INSPECT_MAX_BYTES = 50;
  const c = 2147483647;
  t.kMaxLength = c, l.TYPED_ARRAY_SUPPORT = u(), !l.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function u() {
    try {
      const me = new Uint8Array(1), se = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(se, Uint8Array.prototype), Object.setPrototypeOf(me, se), me.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(l.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (l.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(l.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (l.isBuffer(this))
        return this.byteOffset;
    }
  });
  function r(me) {
    if (me > c)
      throw new RangeError('The value "' + me + '" is invalid for option "size"');
    const se = new Uint8Array(me);
    return Object.setPrototypeOf(se, l.prototype), se;
  }
  function l(me, se, Z) {
    if (typeof me == "number") {
      if (typeof se == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return s(me);
    }
    return i(me, se, Z);
  }
  l.poolSize = 8192;
  function i(me, se, Z) {
    if (typeof me == "string")
      return o(me, se);
    if (ArrayBuffer.isView(me))
      return h(me);
    if (me == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof me
      );
    if (we(me, ArrayBuffer) || me && we(me.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (we(me, SharedArrayBuffer) || me && we(me.buffer, SharedArrayBuffer)))
      return y(me, se, Z);
    if (typeof me == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const pe = me.valueOf && me.valueOf();
    if (pe != null && pe !== me)
      return l.from(pe, se, Z);
    const be = b(me);
    if (be)
      return be;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof me[Symbol.toPrimitive] == "function")
      return l.from(me[Symbol.toPrimitive]("string"), se, Z);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof me
    );
  }
  l.from = function(me, se, Z) {
    return i(me, se, Z);
  }, Object.setPrototypeOf(l.prototype, Uint8Array.prototype), Object.setPrototypeOf(l, Uint8Array);
  function f(me) {
    if (typeof me != "number")
      throw new TypeError('"size" argument must be of type number');
    if (me < 0)
      throw new RangeError('The value "' + me + '" is invalid for option "size"');
  }
  function d(me, se, Z) {
    return f(me), me <= 0 ? r(me) : se !== void 0 ? typeof Z == "string" ? r(me).fill(se, Z) : r(me).fill(se) : r(me);
  }
  l.alloc = function(me, se, Z) {
    return d(me, se, Z);
  };
  function s(me) {
    return f(me), r(me < 0 ? 0 : E(me) | 0);
  }
  l.allocUnsafe = function(me) {
    return s(me);
  }, l.allocUnsafeSlow = function(me) {
    return s(me);
  };
  function o(me, se) {
    if ((typeof se != "string" || se === "") && (se = "utf8"), !l.isEncoding(se))
      throw new TypeError("Unknown encoding: " + se);
    const Z = g(me, se) | 0;
    let pe = r(Z);
    const be = pe.write(me, se);
    return be !== Z && (pe = pe.slice(0, be)), pe;
  }
  function m(me) {
    const se = me.length < 0 ? 0 : E(me.length) | 0, Z = r(se);
    for (let pe = 0; pe < se; pe += 1)
      Z[pe] = me[pe] & 255;
    return Z;
  }
  function h(me) {
    if (we(me, Uint8Array)) {
      const se = new Uint8Array(me);
      return y(se.buffer, se.byteOffset, se.byteLength);
    }
    return m(me);
  }
  function y(me, se, Z) {
    if (se < 0 || me.byteLength < se)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (me.byteLength < se + (Z || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let pe;
    return se === void 0 && Z === void 0 ? pe = new Uint8Array(me) : Z === void 0 ? pe = new Uint8Array(me, se) : pe = new Uint8Array(me, se, Z), Object.setPrototypeOf(pe, l.prototype), pe;
  }
  function b(me) {
    if (l.isBuffer(me)) {
      const se = E(me.length) | 0, Z = r(se);
      return Z.length === 0 || me.copy(Z, 0, 0, se), Z;
    }
    if (me.length !== void 0)
      return typeof me.length != "number" || De(me.length) ? r(0) : m(me);
    if (me.type === "Buffer" && Array.isArray(me.data))
      return m(me.data);
  }
  function E(me) {
    if (me >= c)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + c.toString(16) + " bytes");
    return me | 0;
  }
  function S(me) {
    return +me != me && (me = 0), l.alloc(+me);
  }
  l.isBuffer = function(se) {
    return se != null && se._isBuffer === !0 && se !== l.prototype;
  }, l.compare = function(se, Z) {
    if (we(se, Uint8Array) && (se = l.from(se, se.offset, se.byteLength)), we(Z, Uint8Array) && (Z = l.from(Z, Z.offset, Z.byteLength)), !l.isBuffer(se) || !l.isBuffer(Z))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (se === Z)
      return 0;
    let pe = se.length, be = Z.length;
    for (let _e = 0, Ie = Math.min(pe, be); _e < Ie; ++_e)
      if (se[_e] !== Z[_e]) {
        pe = se[_e], be = Z[_e];
        break;
      }
    return pe < be ? -1 : be < pe ? 1 : 0;
  }, l.isEncoding = function(se) {
    switch (String(se).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, l.concat = function(se, Z) {
    if (!Array.isArray(se))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (se.length === 0)
      return l.alloc(0);
    let pe;
    if (Z === void 0)
      for (Z = 0, pe = 0; pe < se.length; ++pe)
        Z += se[pe].length;
    const be = l.allocUnsafe(Z);
    let _e = 0;
    for (pe = 0; pe < se.length; ++pe) {
      let Ie = se[pe];
      if (we(Ie, Uint8Array))
        _e + Ie.length > be.length ? (l.isBuffer(Ie) || (Ie = l.from(Ie)), Ie.copy(be, _e)) : Uint8Array.prototype.set.call(
          be,
          Ie,
          _e
        );
      else if (l.isBuffer(Ie))
        Ie.copy(be, _e);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      _e += Ie.length;
    }
    return be;
  };
  function g(me, se) {
    if (l.isBuffer(me))
      return me.length;
    if (ArrayBuffer.isView(me) || we(me, ArrayBuffer))
      return me.byteLength;
    if (typeof me != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof me
      );
    const Z = me.length, pe = arguments.length > 2 && arguments[2] === !0;
    if (!pe && Z === 0)
      return 0;
    let be = !1;
    for (; ; )
      switch (se) {
        case "ascii":
        case "latin1":
        case "binary":
          return Z;
        case "utf8":
        case "utf-8":
          return re(me).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Z * 2;
        case "hex":
          return Z >>> 1;
        case "base64":
          return ue(me).length;
        default:
          if (be)
            return pe ? -1 : re(me).length;
          se = ("" + se).toLowerCase(), be = !0;
      }
  }
  l.byteLength = g;
  function P(me, se, Z) {
    let pe = !1;
    if ((se === void 0 || se < 0) && (se = 0), se > this.length || ((Z === void 0 || Z > this.length) && (Z = this.length), Z <= 0) || (Z >>>= 0, se >>>= 0, Z <= se))
      return "";
    for (me || (me = "utf8"); ; )
      switch (me) {
        case "hex":
          return U(this, se, Z);
        case "utf8":
        case "utf-8":
          return v(this, se, Z);
        case "ascii":
          return G(this, se, Z);
        case "latin1":
        case "binary":
          return W(this, se, Z);
        case "base64":
          return T(this, se, Z);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return M(this, se, Z);
        default:
          if (pe)
            throw new TypeError("Unknown encoding: " + me);
          me = (me + "").toLowerCase(), pe = !0;
      }
  }
  l.prototype._isBuffer = !0;
  function R(me, se, Z) {
    const pe = me[se];
    me[se] = me[Z], me[Z] = pe;
  }
  l.prototype.swap16 = function() {
    const se = this.length;
    if (se % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let Z = 0; Z < se; Z += 2)
      R(this, Z, Z + 1);
    return this;
  }, l.prototype.swap32 = function() {
    const se = this.length;
    if (se % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let Z = 0; Z < se; Z += 4)
      R(this, Z, Z + 3), R(this, Z + 1, Z + 2);
    return this;
  }, l.prototype.swap64 = function() {
    const se = this.length;
    if (se % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let Z = 0; Z < se; Z += 8)
      R(this, Z, Z + 7), R(this, Z + 1, Z + 6), R(this, Z + 2, Z + 5), R(this, Z + 3, Z + 4);
    return this;
  }, l.prototype.toString = function() {
    const se = this.length;
    return se === 0 ? "" : arguments.length === 0 ? v(this, 0, se) : P.apply(this, arguments);
  }, l.prototype.toLocaleString = l.prototype.toString, l.prototype.equals = function(se) {
    if (!l.isBuffer(se))
      throw new TypeError("Argument must be a Buffer");
    return this === se ? !0 : l.compare(this, se) === 0;
  }, l.prototype.inspect = function() {
    let se = "";
    const Z = t.INSPECT_MAX_BYTES;
    return se = this.toString("hex", 0, Z).replace(/(.{2})/g, "$1 ").trim(), this.length > Z && (se += " ... "), "<Buffer " + se + ">";
  }, a && (l.prototype[a] = l.prototype.inspect), l.prototype.compare = function(se, Z, pe, be, _e) {
    if (we(se, Uint8Array) && (se = l.from(se, se.offset, se.byteLength)), !l.isBuffer(se))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof se
      );
    if (Z === void 0 && (Z = 0), pe === void 0 && (pe = se ? se.length : 0), be === void 0 && (be = 0), _e === void 0 && (_e = this.length), Z < 0 || pe > se.length || be < 0 || _e > this.length)
      throw new RangeError("out of range index");
    if (be >= _e && Z >= pe)
      return 0;
    if (be >= _e)
      return -1;
    if (Z >= pe)
      return 1;
    if (Z >>>= 0, pe >>>= 0, be >>>= 0, _e >>>= 0, this === se)
      return 0;
    let Ie = _e - be, We = pe - Z;
    const tt = Math.min(Ie, We), Ye = this.slice(be, _e), ht = se.slice(Z, pe);
    for (let ct = 0; ct < tt; ++ct)
      if (Ye[ct] !== ht[ct]) {
        Ie = Ye[ct], We = ht[ct];
        break;
      }
    return Ie < We ? -1 : We < Ie ? 1 : 0;
  };
  function N(me, se, Z, pe, be) {
    if (me.length === 0)
      return -1;
    if (typeof Z == "string" ? (pe = Z, Z = 0) : Z > 2147483647 ? Z = 2147483647 : Z < -2147483648 && (Z = -2147483648), Z = +Z, De(Z) && (Z = be ? 0 : me.length - 1), Z < 0 && (Z = me.length + Z), Z >= me.length) {
      if (be)
        return -1;
      Z = me.length - 1;
    } else if (Z < 0)
      if (be)
        Z = 0;
      else
        return -1;
    if (typeof se == "string" && (se = l.from(se, pe)), l.isBuffer(se))
      return se.length === 0 ? -1 : C(me, se, Z, pe, be);
    if (typeof se == "number")
      return se = se & 255, typeof Uint8Array.prototype.indexOf == "function" ? be ? Uint8Array.prototype.indexOf.call(me, se, Z) : Uint8Array.prototype.lastIndexOf.call(me, se, Z) : C(me, [se], Z, pe, be);
    throw new TypeError("val must be string, number or Buffer");
  }
  function C(me, se, Z, pe, be) {
    let _e = 1, Ie = me.length, We = se.length;
    if (pe !== void 0 && (pe = String(pe).toLowerCase(), pe === "ucs2" || pe === "ucs-2" || pe === "utf16le" || pe === "utf-16le")) {
      if (me.length < 2 || se.length < 2)
        return -1;
      _e = 2, Ie /= 2, We /= 2, Z /= 2;
    }
    function tt(ht, ct) {
      return _e === 1 ? ht[ct] : ht.readUInt16BE(ct * _e);
    }
    let Ye;
    if (be) {
      let ht = -1;
      for (Ye = Z; Ye < Ie; Ye++)
        if (tt(me, Ye) === tt(se, ht === -1 ? 0 : Ye - ht)) {
          if (ht === -1 && (ht = Ye), Ye - ht + 1 === We)
            return ht * _e;
        } else
          ht !== -1 && (Ye -= Ye - ht), ht = -1;
    } else
      for (Z + We > Ie && (Z = Ie - We), Ye = Z; Ye >= 0; Ye--) {
        let ht = !0;
        for (let ct = 0; ct < We; ct++)
          if (tt(me, Ye + ct) !== tt(se, ct)) {
            ht = !1;
            break;
          }
        if (ht)
          return Ye;
      }
    return -1;
  }
  l.prototype.includes = function(se, Z, pe) {
    return this.indexOf(se, Z, pe) !== -1;
  }, l.prototype.indexOf = function(se, Z, pe) {
    return N(this, se, Z, pe, !0);
  }, l.prototype.lastIndexOf = function(se, Z, pe) {
    return N(this, se, Z, pe, !1);
  };
  function I(me, se, Z, pe) {
    Z = Number(Z) || 0;
    const be = me.length - Z;
    pe ? (pe = Number(pe), pe > be && (pe = be)) : pe = be;
    const _e = se.length;
    pe > _e / 2 && (pe = _e / 2);
    let Ie;
    for (Ie = 0; Ie < pe; ++Ie) {
      const We = parseInt(se.substr(Ie * 2, 2), 16);
      if (De(We))
        return Ie;
      me[Z + Ie] = We;
    }
    return Ie;
  }
  function D(me, se, Z, pe) {
    return ie(re(se, me.length - Z), me, Z, pe);
  }
  function j(me, se, Z, pe) {
    return ie(ae(se), me, Z, pe);
  }
  function F(me, se, Z, pe) {
    return ie(ue(se), me, Z, pe);
  }
  function _(me, se, Z, pe) {
    return ie(le(se, me.length - Z), me, Z, pe);
  }
  l.prototype.write = function(se, Z, pe, be) {
    if (Z === void 0)
      be = "utf8", pe = this.length, Z = 0;
    else if (pe === void 0 && typeof Z == "string")
      be = Z, pe = this.length, Z = 0;
    else if (isFinite(Z))
      Z = Z >>> 0, isFinite(pe) ? (pe = pe >>> 0, be === void 0 && (be = "utf8")) : (be = pe, pe = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const _e = this.length - Z;
    if ((pe === void 0 || pe > _e) && (pe = _e), se.length > 0 && (pe < 0 || Z < 0) || Z > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    be || (be = "utf8");
    let Ie = !1;
    for (; ; )
      switch (be) {
        case "hex":
          return I(this, se, Z, pe);
        case "utf8":
        case "utf-8":
          return D(this, se, Z, pe);
        case "ascii":
        case "latin1":
        case "binary":
          return j(this, se, Z, pe);
        case "base64":
          return F(this, se, Z, pe);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return _(this, se, Z, pe);
        default:
          if (Ie)
            throw new TypeError("Unknown encoding: " + be);
          be = ("" + be).toLowerCase(), Ie = !0;
      }
  }, l.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function T(me, se, Z) {
    return se === 0 && Z === me.length ? e.fromByteArray(me) : e.fromByteArray(me.slice(se, Z));
  }
  function v(me, se, Z) {
    Z = Math.min(me.length, Z);
    const pe = [];
    let be = se;
    for (; be < Z; ) {
      const _e = me[be];
      let Ie = null, We = _e > 239 ? 4 : _e > 223 ? 3 : _e > 191 ? 2 : 1;
      if (be + We <= Z) {
        let tt, Ye, ht, ct;
        switch (We) {
          case 1:
            _e < 128 && (Ie = _e);
            break;
          case 2:
            tt = me[be + 1], (tt & 192) === 128 && (ct = (_e & 31) << 6 | tt & 63, ct > 127 && (Ie = ct));
            break;
          case 3:
            tt = me[be + 1], Ye = me[be + 2], (tt & 192) === 128 && (Ye & 192) === 128 && (ct = (_e & 15) << 12 | (tt & 63) << 6 | Ye & 63, ct > 2047 && (ct < 55296 || ct > 57343) && (Ie = ct));
            break;
          case 4:
            tt = me[be + 1], Ye = me[be + 2], ht = me[be + 3], (tt & 192) === 128 && (Ye & 192) === 128 && (ht & 192) === 128 && (ct = (_e & 15) << 18 | (tt & 63) << 12 | (Ye & 63) << 6 | ht & 63, ct > 65535 && ct < 1114112 && (Ie = ct));
        }
      }
      Ie === null ? (Ie = 65533, We = 1) : Ie > 65535 && (Ie -= 65536, pe.push(Ie >>> 10 & 1023 | 55296), Ie = 56320 | Ie & 1023), pe.push(Ie), be += We;
    }
    return O(pe);
  }
  const w = 4096;
  function O(me) {
    const se = me.length;
    if (se <= w)
      return String.fromCharCode.apply(String, me);
    let Z = "", pe = 0;
    for (; pe < se; )
      Z += String.fromCharCode.apply(
        String,
        me.slice(pe, pe += w)
      );
    return Z;
  }
  function G(me, se, Z) {
    let pe = "";
    Z = Math.min(me.length, Z);
    for (let be = se; be < Z; ++be)
      pe += String.fromCharCode(me[be] & 127);
    return pe;
  }
  function W(me, se, Z) {
    let pe = "";
    Z = Math.min(me.length, Z);
    for (let be = se; be < Z; ++be)
      pe += String.fromCharCode(me[be]);
    return pe;
  }
  function U(me, se, Z) {
    const pe = me.length;
    (!se || se < 0) && (se = 0), (!Z || Z < 0 || Z > pe) && (Z = pe);
    let be = "";
    for (let _e = se; _e < Z; ++_e)
      be += Ee[me[_e]];
    return be;
  }
  function M(me, se, Z) {
    const pe = me.slice(se, Z);
    let be = "";
    for (let _e = 0; _e < pe.length - 1; _e += 2)
      be += String.fromCharCode(pe[_e] + pe[_e + 1] * 256);
    return be;
  }
  l.prototype.slice = function(se, Z) {
    const pe = this.length;
    se = ~~se, Z = Z === void 0 ? pe : ~~Z, se < 0 ? (se += pe, se < 0 && (se = 0)) : se > pe && (se = pe), Z < 0 ? (Z += pe, Z < 0 && (Z = 0)) : Z > pe && (Z = pe), Z < se && (Z = se);
    const be = this.subarray(se, Z);
    return Object.setPrototypeOf(be, l.prototype), be;
  };
  function B(me, se, Z) {
    if (me % 1 !== 0 || me < 0)
      throw new RangeError("offset is not uint");
    if (me + se > Z)
      throw new RangeError("Trying to access beyond buffer length");
  }
  l.prototype.readUintLE = l.prototype.readUIntLE = function(se, Z, pe) {
    se = se >>> 0, Z = Z >>> 0, pe || B(se, Z, this.length);
    let be = this[se], _e = 1, Ie = 0;
    for (; ++Ie < Z && (_e *= 256); )
      be += this[se + Ie] * _e;
    return be;
  }, l.prototype.readUintBE = l.prototype.readUIntBE = function(se, Z, pe) {
    se = se >>> 0, Z = Z >>> 0, pe || B(se, Z, this.length);
    let be = this[se + --Z], _e = 1;
    for (; Z > 0 && (_e *= 256); )
      be += this[se + --Z] * _e;
    return be;
  }, l.prototype.readUint8 = l.prototype.readUInt8 = function(se, Z) {
    return se = se >>> 0, Z || B(se, 1, this.length), this[se];
  }, l.prototype.readUint16LE = l.prototype.readUInt16LE = function(se, Z) {
    return se = se >>> 0, Z || B(se, 2, this.length), this[se] | this[se + 1] << 8;
  }, l.prototype.readUint16BE = l.prototype.readUInt16BE = function(se, Z) {
    return se = se >>> 0, Z || B(se, 2, this.length), this[se] << 8 | this[se + 1];
  }, l.prototype.readUint32LE = l.prototype.readUInt32LE = function(se, Z) {
    return se = se >>> 0, Z || B(se, 4, this.length), (this[se] | this[se + 1] << 8 | this[se + 2] << 16) + this[se + 3] * 16777216;
  }, l.prototype.readUint32BE = l.prototype.readUInt32BE = function(se, Z) {
    return se = se >>> 0, Z || B(se, 4, this.length), this[se] * 16777216 + (this[se + 1] << 16 | this[se + 2] << 8 | this[se + 3]);
  }, l.prototype.readBigUInt64LE = Ae(function(se) {
    se = se >>> 0, ye(se, "offset");
    const Z = this[se], pe = this[se + 7];
    (Z === void 0 || pe === void 0) && ve(se, this.length - 8);
    const be = Z + this[++se] * 2 ** 8 + this[++se] * 2 ** 16 + this[++se] * 2 ** 24, _e = this[++se] + this[++se] * 2 ** 8 + this[++se] * 2 ** 16 + pe * 2 ** 24;
    return BigInt(be) + (BigInt(_e) << BigInt(32));
  }), l.prototype.readBigUInt64BE = Ae(function(se) {
    se = se >>> 0, ye(se, "offset");
    const Z = this[se], pe = this[se + 7];
    (Z === void 0 || pe === void 0) && ve(se, this.length - 8);
    const be = Z * 2 ** 24 + this[++se] * 2 ** 16 + this[++se] * 2 ** 8 + this[++se], _e = this[++se] * 2 ** 24 + this[++se] * 2 ** 16 + this[++se] * 2 ** 8 + pe;
    return (BigInt(be) << BigInt(32)) + BigInt(_e);
  }), l.prototype.readIntLE = function(se, Z, pe) {
    se = se >>> 0, Z = Z >>> 0, pe || B(se, Z, this.length);
    let be = this[se], _e = 1, Ie = 0;
    for (; ++Ie < Z && (_e *= 256); )
      be += this[se + Ie] * _e;
    return _e *= 128, be >= _e && (be -= Math.pow(2, 8 * Z)), be;
  }, l.prototype.readIntBE = function(se, Z, pe) {
    se = se >>> 0, Z = Z >>> 0, pe || B(se, Z, this.length);
    let be = Z, _e = 1, Ie = this[se + --be];
    for (; be > 0 && (_e *= 256); )
      Ie += this[se + --be] * _e;
    return _e *= 128, Ie >= _e && (Ie -= Math.pow(2, 8 * Z)), Ie;
  }, l.prototype.readInt8 = function(se, Z) {
    return se = se >>> 0, Z || B(se, 1, this.length), this[se] & 128 ? (255 - this[se] + 1) * -1 : this[se];
  }, l.prototype.readInt16LE = function(se, Z) {
    se = se >>> 0, Z || B(se, 2, this.length);
    const pe = this[se] | this[se + 1] << 8;
    return pe & 32768 ? pe | 4294901760 : pe;
  }, l.prototype.readInt16BE = function(se, Z) {
    se = se >>> 0, Z || B(se, 2, this.length);
    const pe = this[se + 1] | this[se] << 8;
    return pe & 32768 ? pe | 4294901760 : pe;
  }, l.prototype.readInt32LE = function(se, Z) {
    return se = se >>> 0, Z || B(se, 4, this.length), this[se] | this[se + 1] << 8 | this[se + 2] << 16 | this[se + 3] << 24;
  }, l.prototype.readInt32BE = function(se, Z) {
    return se = se >>> 0, Z || B(se, 4, this.length), this[se] << 24 | this[se + 1] << 16 | this[se + 2] << 8 | this[se + 3];
  }, l.prototype.readBigInt64LE = Ae(function(se) {
    se = se >>> 0, ye(se, "offset");
    const Z = this[se], pe = this[se + 7];
    (Z === void 0 || pe === void 0) && ve(se, this.length - 8);
    const be = this[se + 4] + this[se + 5] * 2 ** 8 + this[se + 6] * 2 ** 16 + (pe << 24);
    return (BigInt(be) << BigInt(32)) + BigInt(Z + this[++se] * 2 ** 8 + this[++se] * 2 ** 16 + this[++se] * 2 ** 24);
  }), l.prototype.readBigInt64BE = Ae(function(se) {
    se = se >>> 0, ye(se, "offset");
    const Z = this[se], pe = this[se + 7];
    (Z === void 0 || pe === void 0) && ve(se, this.length - 8);
    const be = (Z << 24) + // Overflow
    this[++se] * 2 ** 16 + this[++se] * 2 ** 8 + this[++se];
    return (BigInt(be) << BigInt(32)) + BigInt(this[++se] * 2 ** 24 + this[++se] * 2 ** 16 + this[++se] * 2 ** 8 + pe);
  }), l.prototype.readFloatLE = function(se, Z) {
    return se = se >>> 0, Z || B(se, 4, this.length), n.read(this, se, !0, 23, 4);
  }, l.prototype.readFloatBE = function(se, Z) {
    return se = se >>> 0, Z || B(se, 4, this.length), n.read(this, se, !1, 23, 4);
  }, l.prototype.readDoubleLE = function(se, Z) {
    return se = se >>> 0, Z || B(se, 8, this.length), n.read(this, se, !0, 52, 8);
  }, l.prototype.readDoubleBE = function(se, Z) {
    return se = se >>> 0, Z || B(se, 8, this.length), n.read(this, se, !1, 52, 8);
  };
  function k(me, se, Z, pe, be, _e) {
    if (!l.isBuffer(me))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (se > be || se < _e)
      throw new RangeError('"value" argument is out of bounds');
    if (Z + pe > me.length)
      throw new RangeError("Index out of range");
  }
  l.prototype.writeUintLE = l.prototype.writeUIntLE = function(se, Z, pe, be) {
    if (se = +se, Z = Z >>> 0, pe = pe >>> 0, !be) {
      const We = Math.pow(2, 8 * pe) - 1;
      k(this, se, Z, pe, We, 0);
    }
    let _e = 1, Ie = 0;
    for (this[Z] = se & 255; ++Ie < pe && (_e *= 256); )
      this[Z + Ie] = se / _e & 255;
    return Z + pe;
  }, l.prototype.writeUintBE = l.prototype.writeUIntBE = function(se, Z, pe, be) {
    if (se = +se, Z = Z >>> 0, pe = pe >>> 0, !be) {
      const We = Math.pow(2, 8 * pe) - 1;
      k(this, se, Z, pe, We, 0);
    }
    let _e = pe - 1, Ie = 1;
    for (this[Z + _e] = se & 255; --_e >= 0 && (Ie *= 256); )
      this[Z + _e] = se / Ie & 255;
    return Z + pe;
  }, l.prototype.writeUint8 = l.prototype.writeUInt8 = function(se, Z, pe) {
    return se = +se, Z = Z >>> 0, pe || k(this, se, Z, 1, 255, 0), this[Z] = se & 255, Z + 1;
  }, l.prototype.writeUint16LE = l.prototype.writeUInt16LE = function(se, Z, pe) {
    return se = +se, Z = Z >>> 0, pe || k(this, se, Z, 2, 65535, 0), this[Z] = se & 255, this[Z + 1] = se >>> 8, Z + 2;
  }, l.prototype.writeUint16BE = l.prototype.writeUInt16BE = function(se, Z, pe) {
    return se = +se, Z = Z >>> 0, pe || k(this, se, Z, 2, 65535, 0), this[Z] = se >>> 8, this[Z + 1] = se & 255, Z + 2;
  }, l.prototype.writeUint32LE = l.prototype.writeUInt32LE = function(se, Z, pe) {
    return se = +se, Z = Z >>> 0, pe || k(this, se, Z, 4, 4294967295, 0), this[Z + 3] = se >>> 24, this[Z + 2] = se >>> 16, this[Z + 1] = se >>> 8, this[Z] = se & 255, Z + 4;
  }, l.prototype.writeUint32BE = l.prototype.writeUInt32BE = function(se, Z, pe) {
    return se = +se, Z = Z >>> 0, pe || k(this, se, Z, 4, 4294967295, 0), this[Z] = se >>> 24, this[Z + 1] = se >>> 16, this[Z + 2] = se >>> 8, this[Z + 3] = se & 255, Z + 4;
  };
  function K(me, se, Z, pe, be) {
    ne(se, pe, be, me, Z, 7);
    let _e = Number(se & BigInt(4294967295));
    me[Z++] = _e, _e = _e >> 8, me[Z++] = _e, _e = _e >> 8, me[Z++] = _e, _e = _e >> 8, me[Z++] = _e;
    let Ie = Number(se >> BigInt(32) & BigInt(4294967295));
    return me[Z++] = Ie, Ie = Ie >> 8, me[Z++] = Ie, Ie = Ie >> 8, me[Z++] = Ie, Ie = Ie >> 8, me[Z++] = Ie, Z;
  }
  function te(me, se, Z, pe, be) {
    ne(se, pe, be, me, Z, 7);
    let _e = Number(se & BigInt(4294967295));
    me[Z + 7] = _e, _e = _e >> 8, me[Z + 6] = _e, _e = _e >> 8, me[Z + 5] = _e, _e = _e >> 8, me[Z + 4] = _e;
    let Ie = Number(se >> BigInt(32) & BigInt(4294967295));
    return me[Z + 3] = Ie, Ie = Ie >> 8, me[Z + 2] = Ie, Ie = Ie >> 8, me[Z + 1] = Ie, Ie = Ie >> 8, me[Z] = Ie, Z + 8;
  }
  l.prototype.writeBigUInt64LE = Ae(function(se, Z = 0) {
    return K(this, se, Z, BigInt(0), BigInt("0xffffffffffffffff"));
  }), l.prototype.writeBigUInt64BE = Ae(function(se, Z = 0) {
    return te(this, se, Z, BigInt(0), BigInt("0xffffffffffffffff"));
  }), l.prototype.writeIntLE = function(se, Z, pe, be) {
    if (se = +se, Z = Z >>> 0, !be) {
      const tt = Math.pow(2, 8 * pe - 1);
      k(this, se, Z, pe, tt - 1, -tt);
    }
    let _e = 0, Ie = 1, We = 0;
    for (this[Z] = se & 255; ++_e < pe && (Ie *= 256); )
      se < 0 && We === 0 && this[Z + _e - 1] !== 0 && (We = 1), this[Z + _e] = (se / Ie >> 0) - We & 255;
    return Z + pe;
  }, l.prototype.writeIntBE = function(se, Z, pe, be) {
    if (se = +se, Z = Z >>> 0, !be) {
      const tt = Math.pow(2, 8 * pe - 1);
      k(this, se, Z, pe, tt - 1, -tt);
    }
    let _e = pe - 1, Ie = 1, We = 0;
    for (this[Z + _e] = se & 255; --_e >= 0 && (Ie *= 256); )
      se < 0 && We === 0 && this[Z + _e + 1] !== 0 && (We = 1), this[Z + _e] = (se / Ie >> 0) - We & 255;
    return Z + pe;
  }, l.prototype.writeInt8 = function(se, Z, pe) {
    return se = +se, Z = Z >>> 0, pe || k(this, se, Z, 1, 127, -128), se < 0 && (se = 255 + se + 1), this[Z] = se & 255, Z + 1;
  }, l.prototype.writeInt16LE = function(se, Z, pe) {
    return se = +se, Z = Z >>> 0, pe || k(this, se, Z, 2, 32767, -32768), this[Z] = se & 255, this[Z + 1] = se >>> 8, Z + 2;
  }, l.prototype.writeInt16BE = function(se, Z, pe) {
    return se = +se, Z = Z >>> 0, pe || k(this, se, Z, 2, 32767, -32768), this[Z] = se >>> 8, this[Z + 1] = se & 255, Z + 2;
  }, l.prototype.writeInt32LE = function(se, Z, pe) {
    return se = +se, Z = Z >>> 0, pe || k(this, se, Z, 4, 2147483647, -2147483648), this[Z] = se & 255, this[Z + 1] = se >>> 8, this[Z + 2] = se >>> 16, this[Z + 3] = se >>> 24, Z + 4;
  }, l.prototype.writeInt32BE = function(se, Z, pe) {
    return se = +se, Z = Z >>> 0, pe || k(this, se, Z, 4, 2147483647, -2147483648), se < 0 && (se = 4294967295 + se + 1), this[Z] = se >>> 24, this[Z + 1] = se >>> 16, this[Z + 2] = se >>> 8, this[Z + 3] = se & 255, Z + 4;
  }, l.prototype.writeBigInt64LE = Ae(function(se, Z = 0) {
    return K(this, se, Z, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), l.prototype.writeBigInt64BE = Ae(function(se, Z = 0) {
    return te(this, se, Z, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function z(me, se, Z, pe, be, _e) {
    if (Z + pe > me.length)
      throw new RangeError("Index out of range");
    if (Z < 0)
      throw new RangeError("Index out of range");
  }
  function q(me, se, Z, pe, be) {
    return se = +se, Z = Z >>> 0, be || z(me, se, Z, 4), n.write(me, se, Z, pe, 23, 4), Z + 4;
  }
  l.prototype.writeFloatLE = function(se, Z, pe) {
    return q(this, se, Z, !0, pe);
  }, l.prototype.writeFloatBE = function(se, Z, pe) {
    return q(this, se, Z, !1, pe);
  };
  function $(me, se, Z, pe, be) {
    return se = +se, Z = Z >>> 0, be || z(me, se, Z, 8), n.write(me, se, Z, pe, 52, 8), Z + 8;
  }
  l.prototype.writeDoubleLE = function(se, Z, pe) {
    return $(this, se, Z, !0, pe);
  }, l.prototype.writeDoubleBE = function(se, Z, pe) {
    return $(this, se, Z, !1, pe);
  }, l.prototype.copy = function(se, Z, pe, be) {
    if (!l.isBuffer(se))
      throw new TypeError("argument should be a Buffer");
    if (pe || (pe = 0), !be && be !== 0 && (be = this.length), Z >= se.length && (Z = se.length), Z || (Z = 0), be > 0 && be < pe && (be = pe), be === pe || se.length === 0 || this.length === 0)
      return 0;
    if (Z < 0)
      throw new RangeError("targetStart out of bounds");
    if (pe < 0 || pe >= this.length)
      throw new RangeError("Index out of range");
    if (be < 0)
      throw new RangeError("sourceEnd out of bounds");
    be > this.length && (be = this.length), se.length - Z < be - pe && (be = se.length - Z + pe);
    const _e = be - pe;
    return this === se && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(Z, pe, be) : Uint8Array.prototype.set.call(
      se,
      this.subarray(pe, be),
      Z
    ), _e;
  }, l.prototype.fill = function(se, Z, pe, be) {
    if (typeof se == "string") {
      if (typeof Z == "string" ? (be = Z, Z = 0, pe = this.length) : typeof pe == "string" && (be = pe, pe = this.length), be !== void 0 && typeof be != "string")
        throw new TypeError("encoding must be a string");
      if (typeof be == "string" && !l.isEncoding(be))
        throw new TypeError("Unknown encoding: " + be);
      if (se.length === 1) {
        const Ie = se.charCodeAt(0);
        (be === "utf8" && Ie < 128 || be === "latin1") && (se = Ie);
      }
    } else
      typeof se == "number" ? se = se & 255 : typeof se == "boolean" && (se = Number(se));
    if (Z < 0 || this.length < Z || this.length < pe)
      throw new RangeError("Out of range index");
    if (pe <= Z)
      return this;
    Z = Z >>> 0, pe = pe === void 0 ? this.length : pe >>> 0, se || (se = 0);
    let _e;
    if (typeof se == "number")
      for (_e = Z; _e < pe; ++_e)
        this[_e] = se;
    else {
      const Ie = l.isBuffer(se) ? se : l.from(se, be), We = Ie.length;
      if (We === 0)
        throw new TypeError('The value "' + se + '" is invalid for argument "value"');
      for (_e = 0; _e < pe - Z; ++_e)
        this[_e + Z] = Ie[_e % We];
    }
    return this;
  };
  const Y = {};
  function H(me, se, Z) {
    Y[me] = class extends Z {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: se.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${me}]`, this.stack, delete this.name;
      }
      get code() {
        return me;
      }
      set code(be) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: be,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${me}]: ${this.message}`;
      }
    };
  }
  H(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(me) {
      return me ? `${me} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), H(
    "ERR_INVALID_ARG_TYPE",
    function(me, se) {
      return `The "${me}" argument must be of type number. Received type ${typeof se}`;
    },
    TypeError
  ), H(
    "ERR_OUT_OF_RANGE",
    function(me, se, Z) {
      let pe = `The value of "${me}" is out of range.`, be = Z;
      return Number.isInteger(Z) && Math.abs(Z) > 2 ** 32 ? be = Q(String(Z)) : typeof Z == "bigint" && (be = String(Z), (Z > BigInt(2) ** BigInt(32) || Z < -(BigInt(2) ** BigInt(32))) && (be = Q(be)), be += "n"), pe += ` It must be ${se}. Received ${be}`, pe;
    },
    RangeError
  );
  function Q(me) {
    let se = "", Z = me.length;
    const pe = me[0] === "-" ? 1 : 0;
    for (; Z >= pe + 4; Z -= 3)
      se = `_${me.slice(Z - 3, Z)}${se}`;
    return `${me.slice(0, Z)}${se}`;
  }
  function X(me, se, Z) {
    ye(se, "offset"), (me[se] === void 0 || me[se + Z] === void 0) && ve(se, me.length - (Z + 1));
  }
  function ne(me, se, Z, pe, be, _e) {
    if (me > Z || me < se) {
      const Ie = typeof se == "bigint" ? "n" : "";
      let We;
      throw _e > 3 ? se === 0 || se === BigInt(0) ? We = `>= 0${Ie} and < 2${Ie} ** ${(_e + 1) * 8}${Ie}` : We = `>= -(2${Ie} ** ${(_e + 1) * 8 - 1}${Ie}) and < 2 ** ${(_e + 1) * 8 - 1}${Ie}` : We = `>= ${se}${Ie} and <= ${Z}${Ie}`, new Y.ERR_OUT_OF_RANGE("value", We, me);
    }
    X(pe, be, _e);
  }
  function ye(me, se) {
    if (typeof me != "number")
      throw new Y.ERR_INVALID_ARG_TYPE(se, "number", me);
  }
  function ve(me, se, Z) {
    throw Math.floor(me) !== me ? (ye(me, Z), new Y.ERR_OUT_OF_RANGE(Z || "offset", "an integer", me)) : se < 0 ? new Y.ERR_BUFFER_OUT_OF_BOUNDS() : new Y.ERR_OUT_OF_RANGE(
      Z || "offset",
      `>= ${Z ? 1 : 0} and <= ${se}`,
      me
    );
  }
  const de = /[^+/0-9A-Za-z-_]/g;
  function oe(me) {
    if (me = me.split("=")[0], me = me.trim().replace(de, ""), me.length < 2)
      return "";
    for (; me.length % 4 !== 0; )
      me = me + "=";
    return me;
  }
  function re(me, se) {
    se = se || 1 / 0;
    let Z;
    const pe = me.length;
    let be = null;
    const _e = [];
    for (let Ie = 0; Ie < pe; ++Ie) {
      if (Z = me.charCodeAt(Ie), Z > 55295 && Z < 57344) {
        if (!be) {
          if (Z > 56319) {
            (se -= 3) > -1 && _e.push(239, 191, 189);
            continue;
          } else if (Ie + 1 === pe) {
            (se -= 3) > -1 && _e.push(239, 191, 189);
            continue;
          }
          be = Z;
          continue;
        }
        if (Z < 56320) {
          (se -= 3) > -1 && _e.push(239, 191, 189), be = Z;
          continue;
        }
        Z = (be - 55296 << 10 | Z - 56320) + 65536;
      } else
        be && (se -= 3) > -1 && _e.push(239, 191, 189);
      if (be = null, Z < 128) {
        if ((se -= 1) < 0)
          break;
        _e.push(Z);
      } else if (Z < 2048) {
        if ((se -= 2) < 0)
          break;
        _e.push(
          Z >> 6 | 192,
          Z & 63 | 128
        );
      } else if (Z < 65536) {
        if ((se -= 3) < 0)
          break;
        _e.push(
          Z >> 12 | 224,
          Z >> 6 & 63 | 128,
          Z & 63 | 128
        );
      } else if (Z < 1114112) {
        if ((se -= 4) < 0)
          break;
        _e.push(
          Z >> 18 | 240,
          Z >> 12 & 63 | 128,
          Z >> 6 & 63 | 128,
          Z & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return _e;
  }
  function ae(me) {
    const se = [];
    for (let Z = 0; Z < me.length; ++Z)
      se.push(me.charCodeAt(Z) & 255);
    return se;
  }
  function le(me, se) {
    let Z, pe, be;
    const _e = [];
    for (let Ie = 0; Ie < me.length && !((se -= 2) < 0); ++Ie)
      Z = me.charCodeAt(Ie), pe = Z >> 8, be = Z % 256, _e.push(be), _e.push(pe);
    return _e;
  }
  function ue(me) {
    return e.toByteArray(oe(me));
  }
  function ie(me, se, Z, pe) {
    let be;
    for (be = 0; be < pe && !(be + Z >= se.length || be >= me.length); ++be)
      se[be + Z] = me[be];
    return be;
  }
  function we(me, se) {
    return me instanceof se || me != null && me.constructor != null && me.constructor.name != null && me.constructor.name === se.name;
  }
  function De(me) {
    return me !== me;
  }
  const Ee = function() {
    const me = "0123456789abcdef", se = new Array(256);
    for (let Z = 0; Z < 16; ++Z) {
      const pe = Z * 16;
      for (let be = 0; be < 16; ++be)
        se[pe + be] = me[Z] + me[be];
    }
    return se;
  }();
  function Ae(me) {
    return typeof BigInt > "u" ? Me : me;
  }
  function Me() {
    throw new Error("BigInt not supported");
  }
})(zS);
var YS = { exports: {} }, zr = YS.exports = {}, ts, rs;
function Mm() {
  throw new Error("setTimeout has not been defined");
}
function Lm() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? ts = setTimeout : ts = Mm;
  } catch {
    ts = Mm;
  }
  try {
    typeof clearTimeout == "function" ? rs = clearTimeout : rs = Lm;
  } catch {
    rs = Lm;
  }
})();
function XS(t) {
  if (ts === setTimeout)
    return setTimeout(t, 0);
  if ((ts === Mm || !ts) && setTimeout)
    return ts = setTimeout, setTimeout(t, 0);
  try {
    return ts(t, 0);
  } catch {
    try {
      return ts.call(null, t, 0);
    } catch {
      return ts.call(this, t, 0);
    }
  }
}
function wO(t) {
  if (rs === clearTimeout)
    return clearTimeout(t);
  if ((rs === Lm || !rs) && clearTimeout)
    return rs = clearTimeout, clearTimeout(t);
  try {
    return rs(t);
  } catch {
    try {
      return rs.call(null, t);
    } catch {
      return rs.call(this, t);
    }
  }
}
var Ns = [], wo = !1, Na, Xc = -1;
function TO() {
  !wo || !Na || (wo = !1, Na.length ? Ns = Na.concat(Ns) : Xc = -1, Ns.length && JS());
}
function JS() {
  if (!wo) {
    var t = XS(TO);
    wo = !0;
    for (var e = Ns.length; e; ) {
      for (Na = Ns, Ns = []; ++Xc < e; )
        Na && Na[Xc].run();
      Xc = -1, e = Ns.length;
    }
    Na = null, wo = !1, wO(t);
  }
}
zr.nextTick = function(t) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var n = 1; n < arguments.length; n++)
      e[n - 1] = arguments[n];
  Ns.push(new QS(t, e)), Ns.length === 1 && !wo && XS(JS);
};
function QS(t, e) {
  this.fun = t, this.array = e;
}
QS.prototype.run = function() {
  this.fun.apply(null, this.array);
};
zr.title = "browser";
zr.browser = !0;
zr.env = {};
zr.argv = [];
zr.version = "";
zr.versions = {
  node: "18.18.2"
  // fake node version
};
function Vs() {
}
zr.on = Vs;
zr.addListener = Vs;
zr.once = Vs;
zr.off = Vs;
zr.removeListener = Vs;
zr.removeAllListeners = Vs;
zr.emit = Vs;
zr.prependListener = Vs;
zr.prependOnceListener = Vs;
zr.listeners = function(t) {
  return [];
};
zr.binding = function(t) {
  throw new Error("process.binding is not supported");
};
zr.cwd = function() {
  return "/";
};
zr.chdir = function(t) {
  throw new Error("process.chdir is not supported");
};
zr.umask = function() {
  return 0;
};
var sd = YS.exports;
(function(t) {
  Object.defineProperty(t, Symbol.toStringTag, { value: "Module" });
  const e = zS, n = sd, a = (r) => r && r.__esModule ? r : { default: r }, c = a(n), u = globalThis || void 0 || self;
  Object.defineProperty(t, "Buffer", { enumerable: !0, get: () => e.Buffer }), Object.defineProperty(t, "process", { enumerable: !0, get: () => c.default }), t.global = u;
})(Ve);
var jm = { exports: {} }, Sl = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ng;
function AO() {
  if (Ng)
    return Sl;
  Ng = 1;
  var t = qS, e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), a = Object.prototype.hasOwnProperty, c = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, u = { key: !0, ref: !0, __self: !0, __source: !0 };
  function r(l, i, f) {
    var d, s = {}, o = null, m = null;
    f !== void 0 && (o = "" + f), i.key !== void 0 && (o = "" + i.key), i.ref !== void 0 && (m = i.ref);
    for (d in i)
      a.call(i, d) && !u.hasOwnProperty(d) && (s[d] = i[d]);
    if (l && l.defaultProps)
      for (d in i = l.defaultProps, i)
        s[d] === void 0 && (s[d] = i[d]);
    return { $$typeof: e, type: l, key: o, ref: m, props: s, _owner: c.current };
  }
  return Sl.Fragment = n, Sl.jsx = r, Sl.jsxs = r, Sl;
}
var wl = {}, Rg;
function xO() {
  return Rg || (Rg = 1, Ve.process.env.NODE_ENV !== "production" && function() {
    var t = qS, e = Symbol.for("react.element"), n = Symbol.for("react.portal"), a = Symbol.for("react.fragment"), c = Symbol.for("react.strict_mode"), u = Symbol.for("react.profiler"), r = Symbol.for("react.provider"), l = Symbol.for("react.context"), i = Symbol.for("react.forward_ref"), f = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), s = Symbol.for("react.memo"), o = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), h = Symbol.iterator, y = "@@iterator";
    function b(Ne) {
      if (Ne === null || typeof Ne != "object")
        return null;
      var Je = h && Ne[h] || Ne[y];
      return typeof Je == "function" ? Je : null;
    }
    var E = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function S(Ne) {
      {
        for (var Je = arguments.length, ft = new Array(Je > 1 ? Je - 1 : 0), rt = 1; rt < Je; rt++)
          ft[rt - 1] = arguments[rt];
        g("error", Ne, ft);
      }
    }
    function g(Ne, Je, ft) {
      {
        var rt = E.ReactDebugCurrentFrame, At = rt.getStackAddendum();
        At !== "" && (Je += "%s", ft = ft.concat([At]));
        var Nt = ft.map(function(Tt) {
          return String(Tt);
        });
        Nt.unshift("Warning: " + Je), Function.prototype.apply.call(console[Ne], console, Nt);
      }
    }
    var P = !1, R = !1, N = !1, C = !1, I = !1, D;
    D = Symbol.for("react.module.reference");
    function j(Ne) {
      return !!(typeof Ne == "string" || typeof Ne == "function" || Ne === a || Ne === u || I || Ne === c || Ne === f || Ne === d || C || Ne === m || P || R || N || typeof Ne == "object" && Ne !== null && (Ne.$$typeof === o || Ne.$$typeof === s || Ne.$$typeof === r || Ne.$$typeof === l || Ne.$$typeof === i || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Ne.$$typeof === D || Ne.getModuleId !== void 0));
    }
    function F(Ne, Je, ft) {
      var rt = Ne.displayName;
      if (rt)
        return rt;
      var At = Je.displayName || Je.name || "";
      return At !== "" ? ft + "(" + At + ")" : ft;
    }
    function _(Ne) {
      return Ne.displayName || "Context";
    }
    function T(Ne) {
      if (Ne == null)
        return null;
      if (typeof Ne.tag == "number" && S("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Ne == "function")
        return Ne.displayName || Ne.name || null;
      if (typeof Ne == "string")
        return Ne;
      switch (Ne) {
        case a:
          return "Fragment";
        case n:
          return "Portal";
        case u:
          return "Profiler";
        case c:
          return "StrictMode";
        case f:
          return "Suspense";
        case d:
          return "SuspenseList";
      }
      if (typeof Ne == "object")
        switch (Ne.$$typeof) {
          case l:
            var Je = Ne;
            return _(Je) + ".Consumer";
          case r:
            var ft = Ne;
            return _(ft._context) + ".Provider";
          case i:
            return F(Ne, Ne.render, "ForwardRef");
          case s:
            var rt = Ne.displayName || null;
            return rt !== null ? rt : T(Ne.type) || "Memo";
          case o: {
            var At = Ne, Nt = At._payload, Tt = At._init;
            try {
              return T(Tt(Nt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var v = Object.assign, w = 0, O, G, W, U, M, B, k;
    function K() {
    }
    K.__reactDisabledLog = !0;
    function te() {
      {
        if (w === 0) {
          O = console.log, G = console.info, W = console.warn, U = console.error, M = console.group, B = console.groupCollapsed, k = console.groupEnd;
          var Ne = {
            configurable: !0,
            enumerable: !0,
            value: K,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Ne,
            log: Ne,
            warn: Ne,
            error: Ne,
            group: Ne,
            groupCollapsed: Ne,
            groupEnd: Ne
          });
        }
        w++;
      }
    }
    function z() {
      {
        if (w--, w === 0) {
          var Ne = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: v({}, Ne, {
              value: O
            }),
            info: v({}, Ne, {
              value: G
            }),
            warn: v({}, Ne, {
              value: W
            }),
            error: v({}, Ne, {
              value: U
            }),
            group: v({}, Ne, {
              value: M
            }),
            groupCollapsed: v({}, Ne, {
              value: B
            }),
            groupEnd: v({}, Ne, {
              value: k
            })
          });
        }
        w < 0 && S("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var q = E.ReactCurrentDispatcher, $;
    function Y(Ne, Je, ft) {
      {
        if ($ === void 0)
          try {
            throw Error();
          } catch (At) {
            var rt = At.stack.trim().match(/\n( *(at )?)/);
            $ = rt && rt[1] || "";
          }
        return `
` + $ + Ne;
      }
    }
    var H = !1, Q;
    {
      var X = typeof WeakMap == "function" ? WeakMap : Map;
      Q = new X();
    }
    function ne(Ne, Je) {
      if (!Ne || H)
        return "";
      {
        var ft = Q.get(Ne);
        if (ft !== void 0)
          return ft;
      }
      var rt;
      H = !0;
      var At = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Nt;
      Nt = q.current, q.current = null, te();
      try {
        if (Je) {
          var Tt = function() {
            throw Error();
          };
          if (Object.defineProperty(Tt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Tt, []);
            } catch (_r) {
              rt = _r;
            }
            Reflect.construct(Ne, [], Tt);
          } else {
            try {
              Tt.call();
            } catch (_r) {
              rt = _r;
            }
            Ne.call(Tt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (_r) {
            rt = _r;
          }
          Ne();
        }
      } catch (_r) {
        if (_r && rt && typeof _r.stack == "string") {
          for (var Ot = _r.stack.split(`
`), cr = rt.stack.split(`
`), Wt = Ot.length - 1, Jt = cr.length - 1; Wt >= 1 && Jt >= 0 && Ot[Wt] !== cr[Jt]; )
            Jt--;
          for (; Wt >= 1 && Jt >= 0; Wt--, Jt--)
            if (Ot[Wt] !== cr[Jt]) {
              if (Wt !== 1 || Jt !== 1)
                do
                  if (Wt--, Jt--, Jt < 0 || Ot[Wt] !== cr[Jt]) {
                    var pr = `
` + Ot[Wt].replace(" at new ", " at ");
                    return Ne.displayName && pr.includes("<anonymous>") && (pr = pr.replace("<anonymous>", Ne.displayName)), typeof Ne == "function" && Q.set(Ne, pr), pr;
                  }
                while (Wt >= 1 && Jt >= 0);
              break;
            }
        }
      } finally {
        H = !1, q.current = Nt, z(), Error.prepareStackTrace = At;
      }
      var $r = Ne ? Ne.displayName || Ne.name : "", Ur = $r ? Y($r) : "";
      return typeof Ne == "function" && Q.set(Ne, Ur), Ur;
    }
    function ye(Ne, Je, ft) {
      return ne(Ne, !1);
    }
    function ve(Ne) {
      var Je = Ne.prototype;
      return !!(Je && Je.isReactComponent);
    }
    function de(Ne, Je, ft) {
      if (Ne == null)
        return "";
      if (typeof Ne == "function")
        return ne(Ne, ve(Ne));
      if (typeof Ne == "string")
        return Y(Ne);
      switch (Ne) {
        case f:
          return Y("Suspense");
        case d:
          return Y("SuspenseList");
      }
      if (typeof Ne == "object")
        switch (Ne.$$typeof) {
          case i:
            return ye(Ne.render);
          case s:
            return de(Ne.type, Je, ft);
          case o: {
            var rt = Ne, At = rt._payload, Nt = rt._init;
            try {
              return de(Nt(At), Je, ft);
            } catch {
            }
          }
        }
      return "";
    }
    var oe = Object.prototype.hasOwnProperty, re = {}, ae = E.ReactDebugCurrentFrame;
    function le(Ne) {
      if (Ne) {
        var Je = Ne._owner, ft = de(Ne.type, Ne._source, Je ? Je.type : null);
        ae.setExtraStackFrame(ft);
      } else
        ae.setExtraStackFrame(null);
    }
    function ue(Ne, Je, ft, rt, At) {
      {
        var Nt = Function.call.bind(oe);
        for (var Tt in Ne)
          if (Nt(Ne, Tt)) {
            var Ot = void 0;
            try {
              if (typeof Ne[Tt] != "function") {
                var cr = Error((rt || "React class") + ": " + ft + " type `" + Tt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Ne[Tt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw cr.name = "Invariant Violation", cr;
              }
              Ot = Ne[Tt](Je, Tt, rt, ft, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Wt) {
              Ot = Wt;
            }
            Ot && !(Ot instanceof Error) && (le(At), S("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", rt || "React class", ft, Tt, typeof Ot), le(null)), Ot instanceof Error && !(Ot.message in re) && (re[Ot.message] = !0, le(At), S("Failed %s type: %s", ft, Ot.message), le(null));
          }
      }
    }
    var ie = Array.isArray;
    function we(Ne) {
      return ie(Ne);
    }
    function De(Ne) {
      {
        var Je = typeof Symbol == "function" && Symbol.toStringTag, ft = Je && Ne[Symbol.toStringTag] || Ne.constructor.name || "Object";
        return ft;
      }
    }
    function Ee(Ne) {
      try {
        return Ae(Ne), !1;
      } catch {
        return !0;
      }
    }
    function Ae(Ne) {
      return "" + Ne;
    }
    function Me(Ne) {
      if (Ee(Ne))
        return S("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", De(Ne)), Ae(Ne);
    }
    var me = E.ReactCurrentOwner, se = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Z, pe, be;
    be = {};
    function _e(Ne) {
      if (oe.call(Ne, "ref")) {
        var Je = Object.getOwnPropertyDescriptor(Ne, "ref").get;
        if (Je && Je.isReactWarning)
          return !1;
      }
      return Ne.ref !== void 0;
    }
    function Ie(Ne) {
      if (oe.call(Ne, "key")) {
        var Je = Object.getOwnPropertyDescriptor(Ne, "key").get;
        if (Je && Je.isReactWarning)
          return !1;
      }
      return Ne.key !== void 0;
    }
    function We(Ne, Je) {
      if (typeof Ne.ref == "string" && me.current && Je && me.current.stateNode !== Je) {
        var ft = T(me.current.type);
        be[ft] || (S('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', T(me.current.type), Ne.ref), be[ft] = !0);
      }
    }
    function tt(Ne, Je) {
      {
        var ft = function() {
          Z || (Z = !0, S("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Je));
        };
        ft.isReactWarning = !0, Object.defineProperty(Ne, "key", {
          get: ft,
          configurable: !0
        });
      }
    }
    function Ye(Ne, Je) {
      {
        var ft = function() {
          pe || (pe = !0, S("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Je));
        };
        ft.isReactWarning = !0, Object.defineProperty(Ne, "ref", {
          get: ft,
          configurable: !0
        });
      }
    }
    var ht = function(Ne, Je, ft, rt, At, Nt, Tt) {
      var Ot = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: Ne,
        key: Je,
        ref: ft,
        props: Tt,
        // Record the component responsible for creating this element.
        _owner: Nt
      };
      return Ot._store = {}, Object.defineProperty(Ot._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ot, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: rt
      }), Object.defineProperty(Ot, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: At
      }), Object.freeze && (Object.freeze(Ot.props), Object.freeze(Ot)), Ot;
    };
    function ct(Ne, Je, ft, rt, At) {
      {
        var Nt, Tt = {}, Ot = null, cr = null;
        ft !== void 0 && (Me(ft), Ot = "" + ft), Ie(Je) && (Me(Je.key), Ot = "" + Je.key), _e(Je) && (cr = Je.ref, We(Je, At));
        for (Nt in Je)
          oe.call(Je, Nt) && !se.hasOwnProperty(Nt) && (Tt[Nt] = Je[Nt]);
        if (Ne && Ne.defaultProps) {
          var Wt = Ne.defaultProps;
          for (Nt in Wt)
            Tt[Nt] === void 0 && (Tt[Nt] = Wt[Nt]);
        }
        if (Ot || cr) {
          var Jt = typeof Ne == "function" ? Ne.displayName || Ne.name || "Unknown" : Ne;
          Ot && tt(Tt, Jt), cr && Ye(Tt, Jt);
        }
        return ht(Ne, Ot, cr, At, rt, me.current, Tt);
      }
    }
    var st = E.ReactCurrentOwner, Xe = E.ReactDebugCurrentFrame;
    function Ke(Ne) {
      if (Ne) {
        var Je = Ne._owner, ft = de(Ne.type, Ne._source, Je ? Je.type : null);
        Xe.setExtraStackFrame(ft);
      } else
        Xe.setExtraStackFrame(null);
    }
    var Ce;
    Ce = !1;
    function xe(Ne) {
      return typeof Ne == "object" && Ne !== null && Ne.$$typeof === e;
    }
    function He() {
      {
        if (st.current) {
          var Ne = T(st.current.type);
          if (Ne)
            return `

Check the render method of \`` + Ne + "`.";
        }
        return "";
      }
    }
    function Be(Ne) {
      {
        if (Ne !== void 0) {
          var Je = Ne.fileName.replace(/^.*[\\\/]/, ""), ft = Ne.lineNumber;
          return `

Check your code at ` + Je + ":" + ft + ".";
        }
        return "";
      }
    }
    var Ze = {};
    function nt(Ne) {
      {
        var Je = He();
        if (!Je) {
          var ft = typeof Ne == "string" ? Ne : Ne.displayName || Ne.name;
          ft && (Je = `

Check the top-level render call using <` + ft + ">.");
        }
        return Je;
      }
    }
    function $e(Ne, Je) {
      {
        if (!Ne._store || Ne._store.validated || Ne.key != null)
          return;
        Ne._store.validated = !0;
        var ft = nt(Je);
        if (Ze[ft])
          return;
        Ze[ft] = !0;
        var rt = "";
        Ne && Ne._owner && Ne._owner !== st.current && (rt = " It was passed a child from " + T(Ne._owner.type) + "."), Ke(Ne), S('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ft, rt), Ke(null);
      }
    }
    function ut(Ne, Je) {
      {
        if (typeof Ne != "object")
          return;
        if (we(Ne))
          for (var ft = 0; ft < Ne.length; ft++) {
            var rt = Ne[ft];
            xe(rt) && $e(rt, Je);
          }
        else if (xe(Ne))
          Ne._store && (Ne._store.validated = !0);
        else if (Ne) {
          var At = b(Ne);
          if (typeof At == "function" && At !== Ne.entries)
            for (var Nt = At.call(Ne), Tt; !(Tt = Nt.next()).done; )
              xe(Tt.value) && $e(Tt.value, Je);
        }
      }
    }
    function vt(Ne) {
      {
        var Je = Ne.type;
        if (Je == null || typeof Je == "string")
          return;
        var ft;
        if (typeof Je == "function")
          ft = Je.propTypes;
        else if (typeof Je == "object" && (Je.$$typeof === i || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Je.$$typeof === s))
          ft = Je.propTypes;
        else
          return;
        if (ft) {
          var rt = T(Je);
          ue(ft, Ne.props, "prop", rt, Ne);
        } else if (Je.PropTypes !== void 0 && !Ce) {
          Ce = !0;
          var At = T(Je);
          S("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", At || "Unknown");
        }
        typeof Je.getDefaultProps == "function" && !Je.getDefaultProps.isReactClassApproved && S("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yt(Ne) {
      {
        for (var Je = Object.keys(Ne.props), ft = 0; ft < Je.length; ft++) {
          var rt = Je[ft];
          if (rt !== "children" && rt !== "key") {
            Ke(Ne), S("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", rt), Ke(null);
            break;
          }
        }
        Ne.ref !== null && (Ke(Ne), S("Invalid attribute `ref` supplied to `React.Fragment`."), Ke(null));
      }
    }
    function et(Ne, Je, ft, rt, At, Nt) {
      {
        var Tt = j(Ne);
        if (!Tt) {
          var Ot = "";
          (Ne === void 0 || typeof Ne == "object" && Ne !== null && Object.keys(Ne).length === 0) && (Ot += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var cr = Be(At);
          cr ? Ot += cr : Ot += He();
          var Wt;
          Ne === null ? Wt = "null" : we(Ne) ? Wt = "array" : Ne !== void 0 && Ne.$$typeof === e ? (Wt = "<" + (T(Ne.type) || "Unknown") + " />", Ot = " Did you accidentally export a JSX literal instead of a component?") : Wt = typeof Ne, S("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Wt, Ot);
        }
        var Jt = ct(Ne, Je, ft, At, Nt);
        if (Jt == null)
          return Jt;
        if (Tt) {
          var pr = Je.children;
          if (pr !== void 0)
            if (rt)
              if (we(pr)) {
                for (var $r = 0; $r < pr.length; $r++)
                  ut(pr[$r], Ne);
                Object.freeze && Object.freeze(pr);
              } else
                S("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ut(pr, Ne);
        }
        return Ne === a ? yt(Jt) : vt(Jt), Jt;
      }
    }
    function bt(Ne, Je, ft) {
      return et(Ne, Je, ft, !0);
    }
    function lt(Ne, Je, ft) {
      return et(Ne, Je, ft, !1);
    }
    var Et = lt, wt = bt;
    wl.Fragment = a, wl.jsx = Et, wl.jsxs = wt;
  }()), wl;
}
Ve.process.env.NODE_ENV === "production" ? jm.exports = AO() : jm.exports = xO();
var Gl = jm.exports;
function PO(t) {
  let e = t;
  const n = [];
  for (const a of t.matchAll(
    /@media\s*\(.*\)\s*{\s*\..*\s*{[\s\S]*?}\s*}/gm
  )) {
    const [c] = a;
    e = e.replace(c, ""), n.push(c);
  }
  return [e, n];
}
function* Mg(t) {
  for (const [e, n, a] of t.matchAll(
    /\s*\.([\S]+)\s*{([^}]*)}/gm
  ))
    yield {
      value: e,
      selector: n,
      content: a
    };
}
const CO = (t) => {
  if (typeof t == "string")
    return t;
  if (typeof t == "object")
    return JSON.stringify(t);
}, Jc = (t) => {
  if (typeof t == "string" || typeof t == "number")
    return String(t);
  if (Array.isArray(t))
    return t.map(Jc).join("");
  if (Ys.isValidElement(t)) {
    const { type: e, props: n } = t;
    if (typeof e == "function") {
      const l = e(n);
      return Jc(l);
    }
    let a = Object.keys(n || {}).filter((r) => r !== "children").map((r) => `${r}="${CO(n[r])}"`).join(" ");
    a = a.trim().length > 0 ? ` ${a}` : "";
    const c = n && "children" in n ? n.children : "", u = c ? Jc(c) : "";
    return typeof t.type == "symbol" ? u : `<${t.type.toString()}${a}>${u}</${t.type.toString()}>`;
  }
  return "";
};
var ad = { exports: {} }, ZS = {}, Fm = { exports: {} }, Ka = {}, Es = {};
Object.defineProperty(Es, "__esModule", { value: !0 });
Es.constants = void 0;
Es.constants = {
  O_RDONLY: 0,
  O_WRONLY: 1,
  O_RDWR: 2,
  S_IFMT: 61440,
  S_IFREG: 32768,
  S_IFDIR: 16384,
  S_IFCHR: 8192,
  S_IFBLK: 24576,
  S_IFIFO: 4096,
  S_IFLNK: 40960,
  S_IFSOCK: 49152,
  O_CREAT: 64,
  O_EXCL: 128,
  O_NOCTTY: 256,
  O_TRUNC: 512,
  O_APPEND: 1024,
  O_DIRECTORY: 65536,
  O_NOATIME: 262144,
  O_NOFOLLOW: 131072,
  O_SYNC: 1052672,
  O_SYMLINK: 2097152,
  O_DIRECT: 16384,
  O_NONBLOCK: 2048,
  S_IRWXU: 448,
  S_IRUSR: 256,
  S_IWUSR: 128,
  S_IXUSR: 64,
  S_IRWXG: 56,
  S_IRGRP: 32,
  S_IWGRP: 16,
  S_IXGRP: 8,
  S_IRWXO: 7,
  S_IROTH: 4,
  S_IWOTH: 2,
  S_IXOTH: 1,
  F_OK: 0,
  R_OK: 4,
  W_OK: 2,
  X_OK: 1,
  UV_FS_SYMLINK_DIR: 1,
  UV_FS_SYMLINK_JUNCTION: 2,
  UV_FS_COPYFILE_EXCL: 1,
  UV_FS_COPYFILE_FICLONE: 2,
  UV_FS_COPYFILE_FICLONE_FORCE: 4,
  COPYFILE_EXCL: 1,
  COPYFILE_FICLONE: 2,
  COPYFILE_FICLONE_FORCE: 4
};
Object.defineProperty(Ka, "__esModule", { value: !0 });
Ka.Stats = void 0;
const IO = Es, { S_IFMT: OO, S_IFDIR: kO, S_IFREG: DO, S_IFBLK: NO, S_IFCHR: RO, S_IFLNK: MO, S_IFIFO: LO, S_IFSOCK: jO } = IO.constants;
class od {
  static build(e, n = !1) {
    const a = new od(), { uid: c, gid: u, atime: r, mtime: l, ctime: i } = e, f = n ? (s) => BigInt(s) : (s) => s;
    a.uid = f(c), a.gid = f(u), a.rdev = f(0), a.blksize = f(4096), a.ino = f(e.ino), a.size = f(e.getSize()), a.blocks = f(1), a.atime = r, a.mtime = l, a.ctime = i, a.birthtime = i, a.atimeMs = f(r.getTime()), a.mtimeMs = f(l.getTime());
    const d = f(i.getTime());
    if (a.ctimeMs = d, a.birthtimeMs = d, n) {
      a.atimeNs = BigInt(r.getTime()) * BigInt(1e6), a.mtimeNs = BigInt(l.getTime()) * BigInt(1e6);
      const s = BigInt(i.getTime()) * BigInt(1e6);
      a.ctimeNs = s, a.birthtimeNs = s;
    }
    return a.dev = f(0), a.mode = f(e.mode), a.nlink = f(e.nlink), a;
  }
  _checkModeProperty(e) {
    return (Number(this.mode) & OO) === e;
  }
  isDirectory() {
    return this._checkModeProperty(kO);
  }
  isFile() {
    return this._checkModeProperty(DO);
  }
  isBlockDevice() {
    return this._checkModeProperty(NO);
  }
  isCharacterDevice() {
    return this._checkModeProperty(RO);
  }
  isSymbolicLink() {
    return this._checkModeProperty(MO);
  }
  isFIFO() {
    return this._checkModeProperty(LO);
  }
  isSocket() {
    return this._checkModeProperty(jO);
  }
}
Ka.Stats = od;
Ka.default = od;
var Jo = {}, Eu = {}, _u = {}, fa = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(t) {
  var e = vu, n = id, a = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  t.Buffer = l, t.SlowBuffer = S, t.INSPECT_MAX_BYTES = 50;
  var c = 2147483647;
  t.kMaxLength = c, l.TYPED_ARRAY_SUPPORT = u(), !l.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function u() {
    try {
      var oe = new Uint8Array(1), re = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(re, Uint8Array.prototype), Object.setPrototypeOf(oe, re), oe.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(l.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (l.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(l.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (l.isBuffer(this))
        return this.byteOffset;
    }
  });
  function r(oe) {
    if (oe > c)
      throw new RangeError('The value "' + oe + '" is invalid for option "size"');
    var re = new Uint8Array(oe);
    return Object.setPrototypeOf(re, l.prototype), re;
  }
  function l(oe, re, ae) {
    if (typeof oe == "number") {
      if (typeof re == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return s(oe);
    }
    return i(oe, re, ae);
  }
  l.poolSize = 8192;
  function i(oe, re, ae) {
    if (typeof oe == "string")
      return o(oe, re);
    if (ArrayBuffer.isView(oe))
      return h(oe);
    if (oe == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof oe
      );
    if (ye(oe, ArrayBuffer) || oe && ye(oe.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ye(oe, SharedArrayBuffer) || oe && ye(oe.buffer, SharedArrayBuffer)))
      return y(oe, re, ae);
    if (typeof oe == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    var le = oe.valueOf && oe.valueOf();
    if (le != null && le !== oe)
      return l.from(le, re, ae);
    var ue = b(oe);
    if (ue)
      return ue;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof oe[Symbol.toPrimitive] == "function")
      return l.from(
        oe[Symbol.toPrimitive]("string"),
        re,
        ae
      );
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof oe
    );
  }
  l.from = function(oe, re, ae) {
    return i(oe, re, ae);
  }, Object.setPrototypeOf(l.prototype, Uint8Array.prototype), Object.setPrototypeOf(l, Uint8Array);
  function f(oe) {
    if (typeof oe != "number")
      throw new TypeError('"size" argument must be of type number');
    if (oe < 0)
      throw new RangeError('The value "' + oe + '" is invalid for option "size"');
  }
  function d(oe, re, ae) {
    return f(oe), oe <= 0 ? r(oe) : re !== void 0 ? typeof ae == "string" ? r(oe).fill(re, ae) : r(oe).fill(re) : r(oe);
  }
  l.alloc = function(oe, re, ae) {
    return d(oe, re, ae);
  };
  function s(oe) {
    return f(oe), r(oe < 0 ? 0 : E(oe) | 0);
  }
  l.allocUnsafe = function(oe) {
    return s(oe);
  }, l.allocUnsafeSlow = function(oe) {
    return s(oe);
  };
  function o(oe, re) {
    if ((typeof re != "string" || re === "") && (re = "utf8"), !l.isEncoding(re))
      throw new TypeError("Unknown encoding: " + re);
    var ae = g(oe, re) | 0, le = r(ae), ue = le.write(oe, re);
    return ue !== ae && (le = le.slice(0, ue)), le;
  }
  function m(oe) {
    for (var re = oe.length < 0 ? 0 : E(oe.length) | 0, ae = r(re), le = 0; le < re; le += 1)
      ae[le] = oe[le] & 255;
    return ae;
  }
  function h(oe) {
    if (ye(oe, Uint8Array)) {
      var re = new Uint8Array(oe);
      return y(re.buffer, re.byteOffset, re.byteLength);
    }
    return m(oe);
  }
  function y(oe, re, ae) {
    if (re < 0 || oe.byteLength < re)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (oe.byteLength < re + (ae || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var le;
    return re === void 0 && ae === void 0 ? le = new Uint8Array(oe) : ae === void 0 ? le = new Uint8Array(oe, re) : le = new Uint8Array(oe, re, ae), Object.setPrototypeOf(le, l.prototype), le;
  }
  function b(oe) {
    if (l.isBuffer(oe)) {
      var re = E(oe.length) | 0, ae = r(re);
      return ae.length === 0 || oe.copy(ae, 0, 0, re), ae;
    }
    if (oe.length !== void 0)
      return typeof oe.length != "number" || ve(oe.length) ? r(0) : m(oe);
    if (oe.type === "Buffer" && Array.isArray(oe.data))
      return m(oe.data);
  }
  function E(oe) {
    if (oe >= c)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + c.toString(16) + " bytes");
    return oe | 0;
  }
  function S(oe) {
    return +oe != oe && (oe = 0), l.alloc(+oe);
  }
  l.isBuffer = function(re) {
    return re != null && re._isBuffer === !0 && re !== l.prototype;
  }, l.compare = function(re, ae) {
    if (ye(re, Uint8Array) && (re = l.from(re, re.offset, re.byteLength)), ye(ae, Uint8Array) && (ae = l.from(ae, ae.offset, ae.byteLength)), !l.isBuffer(re) || !l.isBuffer(ae))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (re === ae)
      return 0;
    for (var le = re.length, ue = ae.length, ie = 0, we = Math.min(le, ue); ie < we; ++ie)
      if (re[ie] !== ae[ie]) {
        le = re[ie], ue = ae[ie];
        break;
      }
    return le < ue ? -1 : ue < le ? 1 : 0;
  }, l.isEncoding = function(re) {
    switch (String(re).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, l.concat = function(re, ae) {
    if (!Array.isArray(re))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (re.length === 0)
      return l.alloc(0);
    var le;
    if (ae === void 0)
      for (ae = 0, le = 0; le < re.length; ++le)
        ae += re[le].length;
    var ue = l.allocUnsafe(ae), ie = 0;
    for (le = 0; le < re.length; ++le) {
      var we = re[le];
      if (ye(we, Uint8Array))
        ie + we.length > ue.length ? l.from(we).copy(ue, ie) : Uint8Array.prototype.set.call(
          ue,
          we,
          ie
        );
      else if (l.isBuffer(we))
        we.copy(ue, ie);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      ie += we.length;
    }
    return ue;
  };
  function g(oe, re) {
    if (l.isBuffer(oe))
      return oe.length;
    if (ArrayBuffer.isView(oe) || ye(oe, ArrayBuffer))
      return oe.byteLength;
    if (typeof oe != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof oe
      );
    var ae = oe.length, le = arguments.length > 2 && arguments[2] === !0;
    if (!le && ae === 0)
      return 0;
    for (var ue = !1; ; )
      switch (re) {
        case "ascii":
        case "latin1":
        case "binary":
          return ae;
        case "utf8":
        case "utf-8":
          return Y(oe).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ae * 2;
        case "hex":
          return ae >>> 1;
        case "base64":
          return X(oe).length;
        default:
          if (ue)
            return le ? -1 : Y(oe).length;
          re = ("" + re).toLowerCase(), ue = !0;
      }
  }
  l.byteLength = g;
  function P(oe, re, ae) {
    var le = !1;
    if ((re === void 0 || re < 0) && (re = 0), re > this.length || ((ae === void 0 || ae > this.length) && (ae = this.length), ae <= 0) || (ae >>>= 0, re >>>= 0, ae <= re))
      return "";
    for (oe || (oe = "utf8"); ; )
      switch (oe) {
        case "hex":
          return U(this, re, ae);
        case "utf8":
        case "utf-8":
          return v(this, re, ae);
        case "ascii":
          return G(this, re, ae);
        case "latin1":
        case "binary":
          return W(this, re, ae);
        case "base64":
          return T(this, re, ae);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return M(this, re, ae);
        default:
          if (le)
            throw new TypeError("Unknown encoding: " + oe);
          oe = (oe + "").toLowerCase(), le = !0;
      }
  }
  l.prototype._isBuffer = !0;
  function R(oe, re, ae) {
    var le = oe[re];
    oe[re] = oe[ae], oe[ae] = le;
  }
  l.prototype.swap16 = function() {
    var re = this.length;
    if (re % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var ae = 0; ae < re; ae += 2)
      R(this, ae, ae + 1);
    return this;
  }, l.prototype.swap32 = function() {
    var re = this.length;
    if (re % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var ae = 0; ae < re; ae += 4)
      R(this, ae, ae + 3), R(this, ae + 1, ae + 2);
    return this;
  }, l.prototype.swap64 = function() {
    var re = this.length;
    if (re % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var ae = 0; ae < re; ae += 8)
      R(this, ae, ae + 7), R(this, ae + 1, ae + 6), R(this, ae + 2, ae + 5), R(this, ae + 3, ae + 4);
    return this;
  }, l.prototype.toString = function() {
    var re = this.length;
    return re === 0 ? "" : arguments.length === 0 ? v(this, 0, re) : P.apply(this, arguments);
  }, l.prototype.toLocaleString = l.prototype.toString, l.prototype.equals = function(re) {
    if (!l.isBuffer(re))
      throw new TypeError("Argument must be a Buffer");
    return this === re ? !0 : l.compare(this, re) === 0;
  }, l.prototype.inspect = function() {
    var re = "", ae = t.INSPECT_MAX_BYTES;
    return re = this.toString("hex", 0, ae).replace(/(.{2})/g, "$1 ").trim(), this.length > ae && (re += " ... "), "<Buffer " + re + ">";
  }, a && (l.prototype[a] = l.prototype.inspect), l.prototype.compare = function(re, ae, le, ue, ie) {
    if (ye(re, Uint8Array) && (re = l.from(re, re.offset, re.byteLength)), !l.isBuffer(re))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof re
      );
    if (ae === void 0 && (ae = 0), le === void 0 && (le = re ? re.length : 0), ue === void 0 && (ue = 0), ie === void 0 && (ie = this.length), ae < 0 || le > re.length || ue < 0 || ie > this.length)
      throw new RangeError("out of range index");
    if (ue >= ie && ae >= le)
      return 0;
    if (ue >= ie)
      return -1;
    if (ae >= le)
      return 1;
    if (ae >>>= 0, le >>>= 0, ue >>>= 0, ie >>>= 0, this === re)
      return 0;
    for (var we = ie - ue, De = le - ae, Ee = Math.min(we, De), Ae = this.slice(ue, ie), Me = re.slice(ae, le), me = 0; me < Ee; ++me)
      if (Ae[me] !== Me[me]) {
        we = Ae[me], De = Me[me];
        break;
      }
    return we < De ? -1 : De < we ? 1 : 0;
  };
  function N(oe, re, ae, le, ue) {
    if (oe.length === 0)
      return -1;
    if (typeof ae == "string" ? (le = ae, ae = 0) : ae > 2147483647 ? ae = 2147483647 : ae < -2147483648 && (ae = -2147483648), ae = +ae, ve(ae) && (ae = ue ? 0 : oe.length - 1), ae < 0 && (ae = oe.length + ae), ae >= oe.length) {
      if (ue)
        return -1;
      ae = oe.length - 1;
    } else if (ae < 0)
      if (ue)
        ae = 0;
      else
        return -1;
    if (typeof re == "string" && (re = l.from(re, le)), l.isBuffer(re))
      return re.length === 0 ? -1 : C(oe, re, ae, le, ue);
    if (typeof re == "number")
      return re = re & 255, typeof Uint8Array.prototype.indexOf == "function" ? ue ? Uint8Array.prototype.indexOf.call(oe, re, ae) : Uint8Array.prototype.lastIndexOf.call(oe, re, ae) : C(oe, [re], ae, le, ue);
    throw new TypeError("val must be string, number or Buffer");
  }
  function C(oe, re, ae, le, ue) {
    var ie = 1, we = oe.length, De = re.length;
    if (le !== void 0 && (le = String(le).toLowerCase(), le === "ucs2" || le === "ucs-2" || le === "utf16le" || le === "utf-16le")) {
      if (oe.length < 2 || re.length < 2)
        return -1;
      ie = 2, we /= 2, De /= 2, ae /= 2;
    }
    function Ee(Z, pe) {
      return ie === 1 ? Z[pe] : Z.readUInt16BE(pe * ie);
    }
    var Ae;
    if (ue) {
      var Me = -1;
      for (Ae = ae; Ae < we; Ae++)
        if (Ee(oe, Ae) === Ee(re, Me === -1 ? 0 : Ae - Me)) {
          if (Me === -1 && (Me = Ae), Ae - Me + 1 === De)
            return Me * ie;
        } else
          Me !== -1 && (Ae -= Ae - Me), Me = -1;
    } else
      for (ae + De > we && (ae = we - De), Ae = ae; Ae >= 0; Ae--) {
        for (var me = !0, se = 0; se < De; se++)
          if (Ee(oe, Ae + se) !== Ee(re, se)) {
            me = !1;
            break;
          }
        if (me)
          return Ae;
      }
    return -1;
  }
  l.prototype.includes = function(re, ae, le) {
    return this.indexOf(re, ae, le) !== -1;
  }, l.prototype.indexOf = function(re, ae, le) {
    return N(this, re, ae, le, !0);
  }, l.prototype.lastIndexOf = function(re, ae, le) {
    return N(this, re, ae, le, !1);
  };
  function I(oe, re, ae, le) {
    ae = Number(ae) || 0;
    var ue = oe.length - ae;
    le ? (le = Number(le), le > ue && (le = ue)) : le = ue;
    var ie = re.length;
    le > ie / 2 && (le = ie / 2);
    for (var we = 0; we < le; ++we) {
      var De = parseInt(re.substr(we * 2, 2), 16);
      if (ve(De))
        return we;
      oe[ae + we] = De;
    }
    return we;
  }
  function D(oe, re, ae, le) {
    return ne(Y(re, oe.length - ae), oe, ae, le);
  }
  function j(oe, re, ae, le) {
    return ne(H(re), oe, ae, le);
  }
  function F(oe, re, ae, le) {
    return ne(X(re), oe, ae, le);
  }
  function _(oe, re, ae, le) {
    return ne(Q(re, oe.length - ae), oe, ae, le);
  }
  l.prototype.write = function(re, ae, le, ue) {
    if (ae === void 0)
      ue = "utf8", le = this.length, ae = 0;
    else if (le === void 0 && typeof ae == "string")
      ue = ae, le = this.length, ae = 0;
    else if (isFinite(ae))
      ae = ae >>> 0, isFinite(le) ? (le = le >>> 0, ue === void 0 && (ue = "utf8")) : (ue = le, le = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    var ie = this.length - ae;
    if ((le === void 0 || le > ie) && (le = ie), re.length > 0 && (le < 0 || ae < 0) || ae > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    ue || (ue = "utf8");
    for (var we = !1; ; )
      switch (ue) {
        case "hex":
          return I(this, re, ae, le);
        case "utf8":
        case "utf-8":
          return D(this, re, ae, le);
        case "ascii":
        case "latin1":
        case "binary":
          return j(this, re, ae, le);
        case "base64":
          return F(this, re, ae, le);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return _(this, re, ae, le);
        default:
          if (we)
            throw new TypeError("Unknown encoding: " + ue);
          ue = ("" + ue).toLowerCase(), we = !0;
      }
  }, l.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function T(oe, re, ae) {
    return re === 0 && ae === oe.length ? e.fromByteArray(oe) : e.fromByteArray(oe.slice(re, ae));
  }
  function v(oe, re, ae) {
    ae = Math.min(oe.length, ae);
    for (var le = [], ue = re; ue < ae; ) {
      var ie = oe[ue], we = null, De = ie > 239 ? 4 : ie > 223 ? 3 : ie > 191 ? 2 : 1;
      if (ue + De <= ae) {
        var Ee, Ae, Me, me;
        switch (De) {
          case 1:
            ie < 128 && (we = ie);
            break;
          case 2:
            Ee = oe[ue + 1], (Ee & 192) === 128 && (me = (ie & 31) << 6 | Ee & 63, me > 127 && (we = me));
            break;
          case 3:
            Ee = oe[ue + 1], Ae = oe[ue + 2], (Ee & 192) === 128 && (Ae & 192) === 128 && (me = (ie & 15) << 12 | (Ee & 63) << 6 | Ae & 63, me > 2047 && (me < 55296 || me > 57343) && (we = me));
            break;
          case 4:
            Ee = oe[ue + 1], Ae = oe[ue + 2], Me = oe[ue + 3], (Ee & 192) === 128 && (Ae & 192) === 128 && (Me & 192) === 128 && (me = (ie & 15) << 18 | (Ee & 63) << 12 | (Ae & 63) << 6 | Me & 63, me > 65535 && me < 1114112 && (we = me));
        }
      }
      we === null ? (we = 65533, De = 1) : we > 65535 && (we -= 65536, le.push(we >>> 10 & 1023 | 55296), we = 56320 | we & 1023), le.push(we), ue += De;
    }
    return O(le);
  }
  var w = 4096;
  function O(oe) {
    var re = oe.length;
    if (re <= w)
      return String.fromCharCode.apply(String, oe);
    for (var ae = "", le = 0; le < re; )
      ae += String.fromCharCode.apply(
        String,
        oe.slice(le, le += w)
      );
    return ae;
  }
  function G(oe, re, ae) {
    var le = "";
    ae = Math.min(oe.length, ae);
    for (var ue = re; ue < ae; ++ue)
      le += String.fromCharCode(oe[ue] & 127);
    return le;
  }
  function W(oe, re, ae) {
    var le = "";
    ae = Math.min(oe.length, ae);
    for (var ue = re; ue < ae; ++ue)
      le += String.fromCharCode(oe[ue]);
    return le;
  }
  function U(oe, re, ae) {
    var le = oe.length;
    (!re || re < 0) && (re = 0), (!ae || ae < 0 || ae > le) && (ae = le);
    for (var ue = "", ie = re; ie < ae; ++ie)
      ue += de[oe[ie]];
    return ue;
  }
  function M(oe, re, ae) {
    for (var le = oe.slice(re, ae), ue = "", ie = 0; ie < le.length - 1; ie += 2)
      ue += String.fromCharCode(le[ie] + le[ie + 1] * 256);
    return ue;
  }
  l.prototype.slice = function(re, ae) {
    var le = this.length;
    re = ~~re, ae = ae === void 0 ? le : ~~ae, re < 0 ? (re += le, re < 0 && (re = 0)) : re > le && (re = le), ae < 0 ? (ae += le, ae < 0 && (ae = 0)) : ae > le && (ae = le), ae < re && (ae = re);
    var ue = this.subarray(re, ae);
    return Object.setPrototypeOf(ue, l.prototype), ue;
  };
  function B(oe, re, ae) {
    if (oe % 1 !== 0 || oe < 0)
      throw new RangeError("offset is not uint");
    if (oe + re > ae)
      throw new RangeError("Trying to access beyond buffer length");
  }
  l.prototype.readUintLE = l.prototype.readUIntLE = function(re, ae, le) {
    re = re >>> 0, ae = ae >>> 0, le || B(re, ae, this.length);
    for (var ue = this[re], ie = 1, we = 0; ++we < ae && (ie *= 256); )
      ue += this[re + we] * ie;
    return ue;
  }, l.prototype.readUintBE = l.prototype.readUIntBE = function(re, ae, le) {
    re = re >>> 0, ae = ae >>> 0, le || B(re, ae, this.length);
    for (var ue = this[re + --ae], ie = 1; ae > 0 && (ie *= 256); )
      ue += this[re + --ae] * ie;
    return ue;
  }, l.prototype.readUint8 = l.prototype.readUInt8 = function(re, ae) {
    return re = re >>> 0, ae || B(re, 1, this.length), this[re];
  }, l.prototype.readUint16LE = l.prototype.readUInt16LE = function(re, ae) {
    return re = re >>> 0, ae || B(re, 2, this.length), this[re] | this[re + 1] << 8;
  }, l.prototype.readUint16BE = l.prototype.readUInt16BE = function(re, ae) {
    return re = re >>> 0, ae || B(re, 2, this.length), this[re] << 8 | this[re + 1];
  }, l.prototype.readUint32LE = l.prototype.readUInt32LE = function(re, ae) {
    return re = re >>> 0, ae || B(re, 4, this.length), (this[re] | this[re + 1] << 8 | this[re + 2] << 16) + this[re + 3] * 16777216;
  }, l.prototype.readUint32BE = l.prototype.readUInt32BE = function(re, ae) {
    return re = re >>> 0, ae || B(re, 4, this.length), this[re] * 16777216 + (this[re + 1] << 16 | this[re + 2] << 8 | this[re + 3]);
  }, l.prototype.readIntLE = function(re, ae, le) {
    re = re >>> 0, ae = ae >>> 0, le || B(re, ae, this.length);
    for (var ue = this[re], ie = 1, we = 0; ++we < ae && (ie *= 256); )
      ue += this[re + we] * ie;
    return ie *= 128, ue >= ie && (ue -= Math.pow(2, 8 * ae)), ue;
  }, l.prototype.readIntBE = function(re, ae, le) {
    re = re >>> 0, ae = ae >>> 0, le || B(re, ae, this.length);
    for (var ue = ae, ie = 1, we = this[re + --ue]; ue > 0 && (ie *= 256); )
      we += this[re + --ue] * ie;
    return ie *= 128, we >= ie && (we -= Math.pow(2, 8 * ae)), we;
  }, l.prototype.readInt8 = function(re, ae) {
    return re = re >>> 0, ae || B(re, 1, this.length), this[re] & 128 ? (255 - this[re] + 1) * -1 : this[re];
  }, l.prototype.readInt16LE = function(re, ae) {
    re = re >>> 0, ae || B(re, 2, this.length);
    var le = this[re] | this[re + 1] << 8;
    return le & 32768 ? le | 4294901760 : le;
  }, l.prototype.readInt16BE = function(re, ae) {
    re = re >>> 0, ae || B(re, 2, this.length);
    var le = this[re + 1] | this[re] << 8;
    return le & 32768 ? le | 4294901760 : le;
  }, l.prototype.readInt32LE = function(re, ae) {
    return re = re >>> 0, ae || B(re, 4, this.length), this[re] | this[re + 1] << 8 | this[re + 2] << 16 | this[re + 3] << 24;
  }, l.prototype.readInt32BE = function(re, ae) {
    return re = re >>> 0, ae || B(re, 4, this.length), this[re] << 24 | this[re + 1] << 16 | this[re + 2] << 8 | this[re + 3];
  }, l.prototype.readFloatLE = function(re, ae) {
    return re = re >>> 0, ae || B(re, 4, this.length), n.read(this, re, !0, 23, 4);
  }, l.prototype.readFloatBE = function(re, ae) {
    return re = re >>> 0, ae || B(re, 4, this.length), n.read(this, re, !1, 23, 4);
  }, l.prototype.readDoubleLE = function(re, ae) {
    return re = re >>> 0, ae || B(re, 8, this.length), n.read(this, re, !0, 52, 8);
  }, l.prototype.readDoubleBE = function(re, ae) {
    return re = re >>> 0, ae || B(re, 8, this.length), n.read(this, re, !1, 52, 8);
  };
  function k(oe, re, ae, le, ue, ie) {
    if (!l.isBuffer(oe))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (re > ue || re < ie)
      throw new RangeError('"value" argument is out of bounds');
    if (ae + le > oe.length)
      throw new RangeError("Index out of range");
  }
  l.prototype.writeUintLE = l.prototype.writeUIntLE = function(re, ae, le, ue) {
    if (re = +re, ae = ae >>> 0, le = le >>> 0, !ue) {
      var ie = Math.pow(2, 8 * le) - 1;
      k(this, re, ae, le, ie, 0);
    }
    var we = 1, De = 0;
    for (this[ae] = re & 255; ++De < le && (we *= 256); )
      this[ae + De] = re / we & 255;
    return ae + le;
  }, l.prototype.writeUintBE = l.prototype.writeUIntBE = function(re, ae, le, ue) {
    if (re = +re, ae = ae >>> 0, le = le >>> 0, !ue) {
      var ie = Math.pow(2, 8 * le) - 1;
      k(this, re, ae, le, ie, 0);
    }
    var we = le - 1, De = 1;
    for (this[ae + we] = re & 255; --we >= 0 && (De *= 256); )
      this[ae + we] = re / De & 255;
    return ae + le;
  }, l.prototype.writeUint8 = l.prototype.writeUInt8 = function(re, ae, le) {
    return re = +re, ae = ae >>> 0, le || k(this, re, ae, 1, 255, 0), this[ae] = re & 255, ae + 1;
  }, l.prototype.writeUint16LE = l.prototype.writeUInt16LE = function(re, ae, le) {
    return re = +re, ae = ae >>> 0, le || k(this, re, ae, 2, 65535, 0), this[ae] = re & 255, this[ae + 1] = re >>> 8, ae + 2;
  }, l.prototype.writeUint16BE = l.prototype.writeUInt16BE = function(re, ae, le) {
    return re = +re, ae = ae >>> 0, le || k(this, re, ae, 2, 65535, 0), this[ae] = re >>> 8, this[ae + 1] = re & 255, ae + 2;
  }, l.prototype.writeUint32LE = l.prototype.writeUInt32LE = function(re, ae, le) {
    return re = +re, ae = ae >>> 0, le || k(this, re, ae, 4, 4294967295, 0), this[ae + 3] = re >>> 24, this[ae + 2] = re >>> 16, this[ae + 1] = re >>> 8, this[ae] = re & 255, ae + 4;
  }, l.prototype.writeUint32BE = l.prototype.writeUInt32BE = function(re, ae, le) {
    return re = +re, ae = ae >>> 0, le || k(this, re, ae, 4, 4294967295, 0), this[ae] = re >>> 24, this[ae + 1] = re >>> 16, this[ae + 2] = re >>> 8, this[ae + 3] = re & 255, ae + 4;
  }, l.prototype.writeIntLE = function(re, ae, le, ue) {
    if (re = +re, ae = ae >>> 0, !ue) {
      var ie = Math.pow(2, 8 * le - 1);
      k(this, re, ae, le, ie - 1, -ie);
    }
    var we = 0, De = 1, Ee = 0;
    for (this[ae] = re & 255; ++we < le && (De *= 256); )
      re < 0 && Ee === 0 && this[ae + we - 1] !== 0 && (Ee = 1), this[ae + we] = (re / De >> 0) - Ee & 255;
    return ae + le;
  }, l.prototype.writeIntBE = function(re, ae, le, ue) {
    if (re = +re, ae = ae >>> 0, !ue) {
      var ie = Math.pow(2, 8 * le - 1);
      k(this, re, ae, le, ie - 1, -ie);
    }
    var we = le - 1, De = 1, Ee = 0;
    for (this[ae + we] = re & 255; --we >= 0 && (De *= 256); )
      re < 0 && Ee === 0 && this[ae + we + 1] !== 0 && (Ee = 1), this[ae + we] = (re / De >> 0) - Ee & 255;
    return ae + le;
  }, l.prototype.writeInt8 = function(re, ae, le) {
    return re = +re, ae = ae >>> 0, le || k(this, re, ae, 1, 127, -128), re < 0 && (re = 255 + re + 1), this[ae] = re & 255, ae + 1;
  }, l.prototype.writeInt16LE = function(re, ae, le) {
    return re = +re, ae = ae >>> 0, le || k(this, re, ae, 2, 32767, -32768), this[ae] = re & 255, this[ae + 1] = re >>> 8, ae + 2;
  }, l.prototype.writeInt16BE = function(re, ae, le) {
    return re = +re, ae = ae >>> 0, le || k(this, re, ae, 2, 32767, -32768), this[ae] = re >>> 8, this[ae + 1] = re & 255, ae + 2;
  }, l.prototype.writeInt32LE = function(re, ae, le) {
    return re = +re, ae = ae >>> 0, le || k(this, re, ae, 4, 2147483647, -2147483648), this[ae] = re & 255, this[ae + 1] = re >>> 8, this[ae + 2] = re >>> 16, this[ae + 3] = re >>> 24, ae + 4;
  }, l.prototype.writeInt32BE = function(re, ae, le) {
    return re = +re, ae = ae >>> 0, le || k(this, re, ae, 4, 2147483647, -2147483648), re < 0 && (re = 4294967295 + re + 1), this[ae] = re >>> 24, this[ae + 1] = re >>> 16, this[ae + 2] = re >>> 8, this[ae + 3] = re & 255, ae + 4;
  };
  function K(oe, re, ae, le, ue, ie) {
    if (ae + le > oe.length)
      throw new RangeError("Index out of range");
    if (ae < 0)
      throw new RangeError("Index out of range");
  }
  function te(oe, re, ae, le, ue) {
    return re = +re, ae = ae >>> 0, ue || K(oe, re, ae, 4), n.write(oe, re, ae, le, 23, 4), ae + 4;
  }
  l.prototype.writeFloatLE = function(re, ae, le) {
    return te(this, re, ae, !0, le);
  }, l.prototype.writeFloatBE = function(re, ae, le) {
    return te(this, re, ae, !1, le);
  };
  function z(oe, re, ae, le, ue) {
    return re = +re, ae = ae >>> 0, ue || K(oe, re, ae, 8), n.write(oe, re, ae, le, 52, 8), ae + 8;
  }
  l.prototype.writeDoubleLE = function(re, ae, le) {
    return z(this, re, ae, !0, le);
  }, l.prototype.writeDoubleBE = function(re, ae, le) {
    return z(this, re, ae, !1, le);
  }, l.prototype.copy = function(re, ae, le, ue) {
    if (!l.isBuffer(re))
      throw new TypeError("argument should be a Buffer");
    if (le || (le = 0), !ue && ue !== 0 && (ue = this.length), ae >= re.length && (ae = re.length), ae || (ae = 0), ue > 0 && ue < le && (ue = le), ue === le || re.length === 0 || this.length === 0)
      return 0;
    if (ae < 0)
      throw new RangeError("targetStart out of bounds");
    if (le < 0 || le >= this.length)
      throw new RangeError("Index out of range");
    if (ue < 0)
      throw new RangeError("sourceEnd out of bounds");
    ue > this.length && (ue = this.length), re.length - ae < ue - le && (ue = re.length - ae + le);
    var ie = ue - le;
    return this === re && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(ae, le, ue) : Uint8Array.prototype.set.call(
      re,
      this.subarray(le, ue),
      ae
    ), ie;
  }, l.prototype.fill = function(re, ae, le, ue) {
    if (typeof re == "string") {
      if (typeof ae == "string" ? (ue = ae, ae = 0, le = this.length) : typeof le == "string" && (ue = le, le = this.length), ue !== void 0 && typeof ue != "string")
        throw new TypeError("encoding must be a string");
      if (typeof ue == "string" && !l.isEncoding(ue))
        throw new TypeError("Unknown encoding: " + ue);
      if (re.length === 1) {
        var ie = re.charCodeAt(0);
        (ue === "utf8" && ie < 128 || ue === "latin1") && (re = ie);
      }
    } else
      typeof re == "number" ? re = re & 255 : typeof re == "boolean" && (re = Number(re));
    if (ae < 0 || this.length < ae || this.length < le)
      throw new RangeError("Out of range index");
    if (le <= ae)
      return this;
    ae = ae >>> 0, le = le === void 0 ? this.length : le >>> 0, re || (re = 0);
    var we;
    if (typeof re == "number")
      for (we = ae; we < le; ++we)
        this[we] = re;
    else {
      var De = l.isBuffer(re) ? re : l.from(re, ue), Ee = De.length;
      if (Ee === 0)
        throw new TypeError('The value "' + re + '" is invalid for argument "value"');
      for (we = 0; we < le - ae; ++we)
        this[we + ae] = De[we % Ee];
    }
    return this;
  };
  var q = /[^+/0-9A-Za-z-_]/g;
  function $(oe) {
    if (oe = oe.split("=")[0], oe = oe.trim().replace(q, ""), oe.length < 2)
      return "";
    for (; oe.length % 4 !== 0; )
      oe = oe + "=";
    return oe;
  }
  function Y(oe, re) {
    re = re || 1 / 0;
    for (var ae, le = oe.length, ue = null, ie = [], we = 0; we < le; ++we) {
      if (ae = oe.charCodeAt(we), ae > 55295 && ae < 57344) {
        if (!ue) {
          if (ae > 56319) {
            (re -= 3) > -1 && ie.push(239, 191, 189);
            continue;
          } else if (we + 1 === le) {
            (re -= 3) > -1 && ie.push(239, 191, 189);
            continue;
          }
          ue = ae;
          continue;
        }
        if (ae < 56320) {
          (re -= 3) > -1 && ie.push(239, 191, 189), ue = ae;
          continue;
        }
        ae = (ue - 55296 << 10 | ae - 56320) + 65536;
      } else
        ue && (re -= 3) > -1 && ie.push(239, 191, 189);
      if (ue = null, ae < 128) {
        if ((re -= 1) < 0)
          break;
        ie.push(ae);
      } else if (ae < 2048) {
        if ((re -= 2) < 0)
          break;
        ie.push(
          ae >> 6 | 192,
          ae & 63 | 128
        );
      } else if (ae < 65536) {
        if ((re -= 3) < 0)
          break;
        ie.push(
          ae >> 12 | 224,
          ae >> 6 & 63 | 128,
          ae & 63 | 128
        );
      } else if (ae < 1114112) {
        if ((re -= 4) < 0)
          break;
        ie.push(
          ae >> 18 | 240,
          ae >> 12 & 63 | 128,
          ae >> 6 & 63 | 128,
          ae & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return ie;
  }
  function H(oe) {
    for (var re = [], ae = 0; ae < oe.length; ++ae)
      re.push(oe.charCodeAt(ae) & 255);
    return re;
  }
  function Q(oe, re) {
    for (var ae, le, ue, ie = [], we = 0; we < oe.length && !((re -= 2) < 0); ++we)
      ae = oe.charCodeAt(we), le = ae >> 8, ue = ae % 256, ie.push(ue), ie.push(le);
    return ie;
  }
  function X(oe) {
    return e.toByteArray($(oe));
  }
  function ne(oe, re, ae, le) {
    for (var ue = 0; ue < le && !(ue + ae >= re.length || ue >= oe.length); ++ue)
      re[ue + ae] = oe[ue];
    return ue;
  }
  function ye(oe, re) {
    return oe instanceof re || oe != null && oe.constructor != null && oe.constructor.name != null && oe.constructor.name === re.name;
  }
  function ve(oe) {
    return oe !== oe;
  }
  var de = function() {
    for (var oe = "0123456789abcdef", re = new Array(256), ae = 0; ae < 16; ++ae)
      for (var le = ae * 16, ue = 0; ue < 16; ++ue)
        re[le + ue] = oe[ae] + oe[ue];
    return re;
  }();
})(fa);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.bufferFrom = t.bufferAllocUnsafe = t.Buffer = void 0;
  const e = fa;
  Object.defineProperty(t, "Buffer", { enumerable: !0, get: function() {
    return e.Buffer;
  } });
  function n(u, ...r) {
    return new e.Buffer(u, ...r);
  }
  const a = e.Buffer.allocUnsafe || n;
  t.bufferAllocUnsafe = a;
  const c = e.Buffer.from || n;
  t.bufferFrom = c;
})(_u);
var I0 = {}, $p = { exports: {} }, Up = {}, mi = {}, ew = {}, O0 = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var e = {}, n = Symbol("test"), a = Object(n);
  if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(a) !== "[object Symbol]")
    return !1;
  var c = 42;
  e[n] = c;
  for (n in e)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
    return !1;
  var u = Object.getOwnPropertySymbols(e);
  if (u.length !== 1 || u[0] !== n || !Object.prototype.propertyIsEnumerable.call(e, n))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var r = Object.getOwnPropertyDescriptor(e, n);
    if (r.value !== c || r.enumerable !== !0)
      return !1;
  }
  return !0;
}, FO = O0, k0 = function() {
  return FO() && !!Symbol.toStringTag;
}, Lg = typeof Symbol < "u" && Symbol, BO = O0, $O = function() {
  return typeof Lg != "function" || typeof Symbol != "function" || typeof Lg("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : BO();
}, jg = {
  foo: {}
}, UO = Object, VO = function() {
  return { __proto__: jg }.foo === jg.foo && !({ __proto__: null } instanceof UO);
}, WO = "Function.prototype.bind called on incompatible ", Vp = Array.prototype.slice, HO = Object.prototype.toString, qO = "[object Function]", GO = function(e) {
  var n = this;
  if (typeof n != "function" || HO.call(n) !== qO)
    throw new TypeError(WO + n);
  for (var a = Vp.call(arguments, 1), c, u = function() {
    if (this instanceof c) {
      var d = n.apply(
        this,
        a.concat(Vp.call(arguments))
      );
      return Object(d) === d ? d : this;
    } else
      return n.apply(
        e,
        a.concat(Vp.call(arguments))
      );
  }, r = Math.max(0, n.length - a.length), l = [], i = 0; i < r; i++)
    l.push("$" + i);
  if (c = Function("binder", "return function (" + l.join(",") + "){ return binder.apply(this,arguments); }")(u), n.prototype) {
    var f = function() {
    };
    f.prototype = n.prototype, c.prototype = new f(), f.prototype = null;
  }
  return c;
}, zO = GO, D0 = Function.prototype.bind || zO, KO = D0, YO = KO.call(Function.call, Object.prototype.hasOwnProperty), ir, Do = SyntaxError, tw = Function, To = TypeError, Wp = function(t) {
  try {
    return tw('"use strict"; return (' + t + ").constructor;")();
  } catch {
  }
}, ja = Object.getOwnPropertyDescriptor;
if (ja)
  try {
    ja({}, "");
  } catch {
    ja = null;
  }
var Hp = function() {
  throw new To();
}, XO = ja ? function() {
  try {
    return arguments.callee, Hp;
  } catch {
    try {
      return ja(arguments, "callee").get;
    } catch {
      return Hp;
    }
  }
}() : Hp, oo = $O(), JO = VO(), on = Object.getPrototypeOf || (JO ? function(t) {
  return t.__proto__;
} : null), vo = {}, QO = typeof Uint8Array > "u" || !on ? ir : on(Uint8Array), Fa = {
  "%AggregateError%": typeof AggregateError > "u" ? ir : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? ir : ArrayBuffer,
  "%ArrayIteratorPrototype%": oo && on ? on([][Symbol.iterator]()) : ir,
  "%AsyncFromSyncIteratorPrototype%": ir,
  "%AsyncFunction%": vo,
  "%AsyncGenerator%": vo,
  "%AsyncGeneratorFunction%": vo,
  "%AsyncIteratorPrototype%": vo,
  "%Atomics%": typeof Atomics > "u" ? ir : Atomics,
  "%BigInt%": typeof BigInt > "u" ? ir : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? ir : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? ir : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? ir : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? ir : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? ir : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? ir : FinalizationRegistry,
  "%Function%": tw,
  "%GeneratorFunction%": vo,
  "%Int8Array%": typeof Int8Array > "u" ? ir : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? ir : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? ir : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": oo && on ? on(on([][Symbol.iterator]())) : ir,
  "%JSON%": typeof JSON == "object" ? JSON : ir,
  "%Map%": typeof Map > "u" ? ir : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !oo || !on ? ir : on((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? ir : Promise,
  "%Proxy%": typeof Proxy > "u" ? ir : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? ir : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? ir : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !oo || !on ? ir : on((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? ir : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": oo && on ? on(""[Symbol.iterator]()) : ir,
  "%Symbol%": oo ? Symbol : ir,
  "%SyntaxError%": Do,
  "%ThrowTypeError%": XO,
  "%TypedArray%": QO,
  "%TypeError%": To,
  "%Uint8Array%": typeof Uint8Array > "u" ? ir : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? ir : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? ir : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? ir : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap > "u" ? ir : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? ir : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? ir : WeakSet
};
if (on)
  try {
    null.error;
  } catch (t) {
    var ZO = on(on(t));
    Fa["%Error.prototype%"] = ZO;
  }
var ek = function t(e) {
  var n;
  if (e === "%AsyncFunction%")
    n = Wp("async function () {}");
  else if (e === "%GeneratorFunction%")
    n = Wp("function* () {}");
  else if (e === "%AsyncGeneratorFunction%")
    n = Wp("async function* () {}");
  else if (e === "%AsyncGenerator%") {
    var a = t("%AsyncGeneratorFunction%");
    a && (n = a.prototype);
  } else if (e === "%AsyncIteratorPrototype%") {
    var c = t("%AsyncGenerator%");
    c && on && (n = on(c.prototype));
  }
  return Fa[e] = n, n;
}, Fg = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, Su = D0, Sf = YO, tk = Su.call(Function.call, Array.prototype.concat), rk = Su.call(Function.apply, Array.prototype.splice), Bg = Su.call(Function.call, String.prototype.replace), wf = Su.call(Function.call, String.prototype.slice), nk = Su.call(Function.call, RegExp.prototype.exec), ik = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, sk = /\\(\\)?/g, ak = function(e) {
  var n = wf(e, 0, 1), a = wf(e, -1);
  if (n === "%" && a !== "%")
    throw new Do("invalid intrinsic syntax, expected closing `%`");
  if (a === "%" && n !== "%")
    throw new Do("invalid intrinsic syntax, expected opening `%`");
  var c = [];
  return Bg(e, ik, function(u, r, l, i) {
    c[c.length] = l ? Bg(i, sk, "$1") : r || u;
  }), c;
}, ok = function(e, n) {
  var a = e, c;
  if (Sf(Fg, a) && (c = Fg[a], a = "%" + c[0] + "%"), Sf(Fa, a)) {
    var u = Fa[a];
    if (u === vo && (u = ek(a)), typeof u > "u" && !n)
      throw new To("intrinsic " + e + " exists, but is not available. Please file an issue!");
    return {
      alias: c,
      name: a,
      value: u
    };
  }
  throw new Do("intrinsic " + e + " does not exist!");
}, Qo = function(e, n) {
  if (typeof e != "string" || e.length === 0)
    throw new To("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof n != "boolean")
    throw new To('"allowMissing" argument must be a boolean');
  if (nk(/^%?[^%]*%?$/, e) === null)
    throw new Do("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var a = ak(e), c = a.length > 0 ? a[0] : "", u = ok("%" + c + "%", n), r = u.name, l = u.value, i = !1, f = u.alias;
  f && (c = f[0], rk(a, tk([0, 1], f)));
  for (var d = 1, s = !0; d < a.length; d += 1) {
    var o = a[d], m = wf(o, 0, 1), h = wf(o, -1);
    if ((m === '"' || m === "'" || m === "`" || h === '"' || h === "'" || h === "`") && m !== h)
      throw new Do("property names with quotes must have matching quotes");
    if ((o === "constructor" || !s) && (i = !0), c += "." + o, r = "%" + c + "%", Sf(Fa, r))
      l = Fa[r];
    else if (l != null) {
      if (!(o in l)) {
        if (!n)
          throw new To("base intrinsic for " + e + " exists, but the property is not available.");
        return;
      }
      if (ja && d + 1 >= a.length) {
        var y = ja(l, o);
        s = !!y, s && "get" in y && !("originalValue" in y.get) ? l = y.get : l = l[o];
      } else
        s = Sf(l, o), l = l[o];
      s && !i && (Fa[r] = l);
    }
  }
  return l;
}, rw = { exports: {} };
(function(t) {
  var e = D0, n = Qo, a = n("%Function.prototype.apply%"), c = n("%Function.prototype.call%"), u = n("%Reflect.apply%", !0) || e.call(c, a), r = n("%Object.getOwnPropertyDescriptor%", !0), l = n("%Object.defineProperty%", !0), i = n("%Math.max%");
  if (l)
    try {
      l({}, "a", { value: 1 });
    } catch {
      l = null;
    }
  t.exports = function(s) {
    var o = u(e, c, arguments);
    if (r && l) {
      var m = r(o, "length");
      m.configurable && l(
        o,
        "length",
        { value: 1 + i(0, s.length - (arguments.length - 1)) }
      );
    }
    return o;
  };
  var f = function() {
    return u(e, a, arguments);
  };
  l ? l(t.exports, "apply", { value: f }) : t.exports.apply = f;
})(rw);
var ld = rw.exports, nw = Qo, iw = ld, lk = iw(nw("String.prototype.indexOf")), wu = function(e, n) {
  var a = nw(e, !!n);
  return typeof a == "function" && lk(e, ".prototype.") > -1 ? iw(a) : a;
}, uk = k0(), ck = wu, Bm = ck("Object.prototype.toString"), ud = function(e) {
  return uk && e && typeof e == "object" && Symbol.toStringTag in e ? !1 : Bm(e) === "[object Arguments]";
}, sw = function(e) {
  return ud(e) ? !0 : e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && Bm(e) !== "[object Array]" && Bm(e.callee) === "[object Function]";
}, fk = function() {
  return ud(arguments);
}();
ud.isLegacyArguments = sw;
var dk = fk ? ud : sw, pk = Object.prototype.toString, hk = Function.prototype.toString, mk = /^\s*(?:function)?\*/, aw = k0(), qp = Object.getPrototypeOf, yk = function() {
  if (!aw)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, Gp, bk = function(e) {
  if (typeof e != "function")
    return !1;
  if (mk.test(hk.call(e)))
    return !0;
  if (!aw) {
    var n = pk.call(e);
    return n === "[object GeneratorFunction]";
  }
  if (!qp)
    return !1;
  if (typeof Gp > "u") {
    var a = yk();
    Gp = a ? qp(a) : !1;
  }
  return qp(e) === Gp;
}, ow = Function.prototype.toString, Eo = typeof Reflect == "object" && Reflect !== null && Reflect.apply, $m, Qc;
if (typeof Eo == "function" && typeof Object.defineProperty == "function")
  try {
    $m = Object.defineProperty({}, "length", {
      get: function() {
        throw Qc;
      }
    }), Qc = {}, Eo(function() {
      throw 42;
    }, null, $m);
  } catch (t) {
    t !== Qc && (Eo = null);
  }
else
  Eo = null;
var gk = /^\s*class\b/, Um = function(e) {
  try {
    var n = ow.call(e);
    return gk.test(n);
  } catch {
    return !1;
  }
}, zp = function(e) {
  try {
    return Um(e) ? !1 : (ow.call(e), !0);
  } catch {
    return !1;
  }
}, Zc = Object.prototype.toString, vk = "[object Object]", Ek = "[object Function]", _k = "[object GeneratorFunction]", Sk = "[object HTMLAllCollection]", wk = "[object HTML document.all class]", Tk = "[object HTMLCollection]", Ak = typeof Symbol == "function" && !!Symbol.toStringTag, xk = !(0 in [,]), Vm = function() {
  return !1;
};
if (typeof document == "object") {
  var Pk = document.all;
  Zc.call(Pk) === Zc.call(document.all) && (Vm = function(e) {
    if ((xk || !e) && (typeof e > "u" || typeof e == "object"))
      try {
        var n = Zc.call(e);
        return (n === Sk || n === wk || n === Tk || n === vk) && e("") == null;
      } catch {
      }
    return !1;
  });
}
var Ck = Eo ? function(e) {
  if (Vm(e))
    return !0;
  if (!e || typeof e != "function" && typeof e != "object")
    return !1;
  try {
    Eo(e, null, $m);
  } catch (n) {
    if (n !== Qc)
      return !1;
  }
  return !Um(e) && zp(e);
} : function(e) {
  if (Vm(e))
    return !0;
  if (!e || typeof e != "function" && typeof e != "object")
    return !1;
  if (Ak)
    return zp(e);
  if (Um(e))
    return !1;
  var n = Zc.call(e);
  return n !== Ek && n !== _k && !/^\[object HTML/.test(n) ? !1 : zp(e);
}, Ik = Ck, Ok = Object.prototype.toString, lw = Object.prototype.hasOwnProperty, kk = function(e, n, a) {
  for (var c = 0, u = e.length; c < u; c++)
    lw.call(e, c) && (a == null ? n(e[c], c, e) : n.call(a, e[c], c, e));
}, Dk = function(e, n, a) {
  for (var c = 0, u = e.length; c < u; c++)
    a == null ? n(e.charAt(c), c, e) : n.call(a, e.charAt(c), c, e);
}, Nk = function(e, n, a) {
  for (var c in e)
    lw.call(e, c) && (a == null ? n(e[c], c, e) : n.call(a, e[c], c, e));
}, Rk = function(e, n, a) {
  if (!Ik(n))
    throw new TypeError("iterator must be a function");
  var c;
  arguments.length >= 3 && (c = a), Ok.call(e) === "[object Array]" ? kk(e, n, c) : typeof e == "string" ? Dk(e, n, c) : Nk(e, n, c);
}, Mk = Rk, Kp = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
], Lk = typeof globalThis > "u" ? Bt : globalThis, jk = function() {
  for (var e = [], n = 0; n < Kp.length; n++)
    typeof Lk[Kp[n]] == "function" && (e[e.length] = Kp[n]);
  return e;
}, Fk = Qo, ef = Fk("%Object.getOwnPropertyDescriptor%", !0);
if (ef)
  try {
    ef([], "length");
  } catch {
    ef = null;
  }
var uw = ef, Tf = Mk, Bk = jk, $g = ld, N0 = wu, tf = uw, $k = N0("Object.prototype.toString"), cw = k0(), Ug = typeof globalThis > "u" ? Bt : globalThis, Wm = Bk(), R0 = N0("String.prototype.slice"), Yp = Object.getPrototypeOf, Uk = N0("Array.prototype.indexOf", !0) || function(e, n) {
  for (var a = 0; a < e.length; a += 1)
    if (e[a] === n)
      return a;
  return -1;
}, Af = { __proto__: null };
cw && tf && Yp ? Tf(Wm, function(t) {
  var e = new Ug[t]();
  if (Symbol.toStringTag in e) {
    var n = Yp(e), a = tf(n, Symbol.toStringTag);
    if (!a) {
      var c = Yp(n);
      a = tf(c, Symbol.toStringTag);
    }
    Af["$" + t] = $g(a.get);
  }
}) : Tf(Wm, function(t) {
  var e = new Ug[t]();
  Af["$" + t] = $g(e.slice);
});
var Vk = function(e) {
  var n = !1;
  return Tf(Af, function(a, c) {
    if (!n)
      try {
        "$" + a(e) === c && (n = R0(c, 1));
      } catch {
      }
  }), n;
}, Wk = function(e) {
  var n = !1;
  return Tf(Af, function(a, c) {
    if (!n)
      try {
        a(e), n = R0(c, 1);
      } catch {
      }
  }), n;
}, fw = function(e) {
  if (!e || typeof e != "object")
    return !1;
  if (!cw) {
    var n = R0($k(e), 8, -1);
    return Uk(Wm, n) > -1 ? n : n !== "Object" ? !1 : Wk(e);
  }
  return tf ? Vk(e) : null;
}, Hk = fw, qk = function(e) {
  return !!Hk(e);
};
(function(t) {
  var e = dk, n = bk, a = fw, c = qk;
  function u(le) {
    return le.call.bind(le);
  }
  var r = typeof BigInt < "u", l = typeof Symbol < "u", i = u(Object.prototype.toString), f = u(Number.prototype.valueOf), d = u(String.prototype.valueOf), s = u(Boolean.prototype.valueOf);
  if (r)
    var o = u(BigInt.prototype.valueOf);
  if (l)
    var m = u(Symbol.prototype.valueOf);
  function h(le, ue) {
    if (typeof le != "object")
      return !1;
    try {
      return ue(le), !0;
    } catch {
      return !1;
    }
  }
  t.isArgumentsObject = e, t.isGeneratorFunction = n, t.isTypedArray = c;
  function y(le) {
    return typeof Promise < "u" && le instanceof Promise || le !== null && typeof le == "object" && typeof le.then == "function" && typeof le.catch == "function";
  }
  t.isPromise = y;
  function b(le) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(le) : c(le) || K(le);
  }
  t.isArrayBufferView = b;
  function E(le) {
    return a(le) === "Uint8Array";
  }
  t.isUint8Array = E;
  function S(le) {
    return a(le) === "Uint8ClampedArray";
  }
  t.isUint8ClampedArray = S;
  function g(le) {
    return a(le) === "Uint16Array";
  }
  t.isUint16Array = g;
  function P(le) {
    return a(le) === "Uint32Array";
  }
  t.isUint32Array = P;
  function R(le) {
    return a(le) === "Int8Array";
  }
  t.isInt8Array = R;
  function N(le) {
    return a(le) === "Int16Array";
  }
  t.isInt16Array = N;
  function C(le) {
    return a(le) === "Int32Array";
  }
  t.isInt32Array = C;
  function I(le) {
    return a(le) === "Float32Array";
  }
  t.isFloat32Array = I;
  function D(le) {
    return a(le) === "Float64Array";
  }
  t.isFloat64Array = D;
  function j(le) {
    return a(le) === "BigInt64Array";
  }
  t.isBigInt64Array = j;
  function F(le) {
    return a(le) === "BigUint64Array";
  }
  t.isBigUint64Array = F;
  function _(le) {
    return i(le) === "[object Map]";
  }
  _.working = typeof Map < "u" && _(/* @__PURE__ */ new Map());
  function T(le) {
    return typeof Map > "u" ? !1 : _.working ? _(le) : le instanceof Map;
  }
  t.isMap = T;
  function v(le) {
    return i(le) === "[object Set]";
  }
  v.working = typeof Set < "u" && v(/* @__PURE__ */ new Set());
  function w(le) {
    return typeof Set > "u" ? !1 : v.working ? v(le) : le instanceof Set;
  }
  t.isSet = w;
  function O(le) {
    return i(le) === "[object WeakMap]";
  }
  O.working = typeof WeakMap < "u" && O(/* @__PURE__ */ new WeakMap());
  function G(le) {
    return typeof WeakMap > "u" ? !1 : O.working ? O(le) : le instanceof WeakMap;
  }
  t.isWeakMap = G;
  function W(le) {
    return i(le) === "[object WeakSet]";
  }
  W.working = typeof WeakSet < "u" && W(/* @__PURE__ */ new WeakSet());
  function U(le) {
    return W(le);
  }
  t.isWeakSet = U;
  function M(le) {
    return i(le) === "[object ArrayBuffer]";
  }
  M.working = typeof ArrayBuffer < "u" && M(new ArrayBuffer());
  function B(le) {
    return typeof ArrayBuffer > "u" ? !1 : M.working ? M(le) : le instanceof ArrayBuffer;
  }
  t.isArrayBuffer = B;
  function k(le) {
    return i(le) === "[object DataView]";
  }
  k.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && k(new DataView(new ArrayBuffer(1), 0, 1));
  function K(le) {
    return typeof DataView > "u" ? !1 : k.working ? k(le) : le instanceof DataView;
  }
  t.isDataView = K;
  var te = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function z(le) {
    return i(le) === "[object SharedArrayBuffer]";
  }
  function q(le) {
    return typeof te > "u" ? !1 : (typeof z.working > "u" && (z.working = z(new te())), z.working ? z(le) : le instanceof te);
  }
  t.isSharedArrayBuffer = q;
  function $(le) {
    return i(le) === "[object AsyncFunction]";
  }
  t.isAsyncFunction = $;
  function Y(le) {
    return i(le) === "[object Map Iterator]";
  }
  t.isMapIterator = Y;
  function H(le) {
    return i(le) === "[object Set Iterator]";
  }
  t.isSetIterator = H;
  function Q(le) {
    return i(le) === "[object Generator]";
  }
  t.isGeneratorObject = Q;
  function X(le) {
    return i(le) === "[object WebAssembly.Module]";
  }
  t.isWebAssemblyCompiledModule = X;
  function ne(le) {
    return h(le, f);
  }
  t.isNumberObject = ne;
  function ye(le) {
    return h(le, d);
  }
  t.isStringObject = ye;
  function ve(le) {
    return h(le, s);
  }
  t.isBooleanObject = ve;
  function de(le) {
    return r && h(le, o);
  }
  t.isBigIntObject = de;
  function oe(le) {
    return l && h(le, m);
  }
  t.isSymbolObject = oe;
  function re(le) {
    return ne(le) || ye(le) || ve(le) || de(le) || oe(le);
  }
  t.isBoxedPrimitive = re;
  function ae(le) {
    return typeof Uint8Array < "u" && (B(le) || q(le));
  }
  t.isAnyArrayBuffer = ae, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(le) {
    Object.defineProperty(t, le, {
      enumerable: !1,
      value: function() {
        throw new Error(le + " is not supported in userland");
      }
    });
  });
})(ew);
var Gk = function(e) {
  return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
}, Hm = { exports: {} };
typeof Object.create == "function" ? Hm.exports = function(e, n) {
  n && (e.super_ = n, e.prototype = Object.create(n.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : Hm.exports = function(e, n) {
  if (n) {
    e.super_ = n;
    var a = function() {
    };
    a.prototype = n.prototype, e.prototype = new a(), e.prototype.constructor = e;
  }
};
var Zt = Hm.exports;
(function(t) {
  var e = Object.getOwnPropertyDescriptors || function(K) {
    for (var te = Object.keys(K), z = {}, q = 0; q < te.length; q++)
      z[te[q]] = Object.getOwnPropertyDescriptor(K, te[q]);
    return z;
  }, n = /%[sdj%]/g;
  t.format = function(k) {
    if (!R(k)) {
      for (var K = [], te = 0; te < arguments.length; te++)
        K.push(r(arguments[te]));
      return K.join(" ");
    }
    for (var te = 1, z = arguments, q = z.length, $ = String(k).replace(n, function(H) {
      if (H === "%%")
        return "%";
      if (te >= q)
        return H;
      switch (H) {
        case "%s":
          return String(z[te++]);
        case "%d":
          return Number(z[te++]);
        case "%j":
          try {
            return JSON.stringify(z[te++]);
          } catch {
            return "[Circular]";
          }
        default:
          return H;
      }
    }), Y = z[te]; te < q; Y = z[++te])
      S(Y) || !D(Y) ? $ += " " + Y : $ += " " + r(Y);
    return $;
  }, t.deprecate = function(k, K) {
    if (typeof Ve.process < "u" && Ve.process.noDeprecation === !0)
      return k;
    if (typeof Ve.process > "u")
      return function() {
        return t.deprecate(k, K).apply(this, arguments);
      };
    var te = !1;
    function z() {
      if (!te) {
        if (Ve.process.throwDeprecation)
          throw new Error(K);
        Ve.process.traceDeprecation ? console.trace(K) : console.error(K), te = !0;
      }
      return k.apply(this, arguments);
    }
    return z;
  };
  var a = {}, c = /^$/;
  if (Ve.process.env.NODE_DEBUG) {
    var u = Ve.process.env.NODE_DEBUG;
    u = u.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), c = new RegExp("^" + u + "$", "i");
  }
  t.debuglog = function(k) {
    if (k = k.toUpperCase(), !a[k])
      if (c.test(k)) {
        var K = Ve.process.pid;
        a[k] = function() {
          var te = t.format.apply(t, arguments);
          console.error("%s %d: %s", k, K, te);
        };
      } else
        a[k] = function() {
        };
    return a[k];
  };
  function r(k, K) {
    var te = {
      seen: [],
      stylize: i
    };
    return arguments.length >= 3 && (te.depth = arguments[2]), arguments.length >= 4 && (te.colors = arguments[3]), E(K) ? te.showHidden = K : K && t._extend(te, K), C(te.showHidden) && (te.showHidden = !1), C(te.depth) && (te.depth = 2), C(te.colors) && (te.colors = !1), C(te.customInspect) && (te.customInspect = !0), te.colors && (te.stylize = l), d(te, k, te.depth);
  }
  t.inspect = r, r.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, r.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function l(k, K) {
    var te = r.styles[K];
    return te ? "\x1B[" + r.colors[te][0] + "m" + k + "\x1B[" + r.colors[te][1] + "m" : k;
  }
  function i(k, K) {
    return k;
  }
  function f(k) {
    var K = {};
    return k.forEach(function(te, z) {
      K[te] = !0;
    }), K;
  }
  function d(k, K, te) {
    if (k.customInspect && K && _(K.inspect) && // Filter out the util module, it's inspect function is special
    K.inspect !== t.inspect && // Also filter out any prototype objects using the circular check.
    !(K.constructor && K.constructor.prototype === K)) {
      var z = K.inspect(te, k);
      return R(z) || (z = d(k, z, te)), z;
    }
    var q = s(k, K);
    if (q)
      return q;
    var $ = Object.keys(K), Y = f($);
    if (k.showHidden && ($ = Object.getOwnPropertyNames(K)), F(K) && ($.indexOf("message") >= 0 || $.indexOf("description") >= 0))
      return o(K);
    if ($.length === 0) {
      if (_(K)) {
        var H = K.name ? ": " + K.name : "";
        return k.stylize("[Function" + H + "]", "special");
      }
      if (I(K))
        return k.stylize(RegExp.prototype.toString.call(K), "regexp");
      if (j(K))
        return k.stylize(Date.prototype.toString.call(K), "date");
      if (F(K))
        return o(K);
    }
    var Q = "", X = !1, ne = ["{", "}"];
    if (b(K) && (X = !0, ne = ["[", "]"]), _(K)) {
      var ye = K.name ? ": " + K.name : "";
      Q = " [Function" + ye + "]";
    }
    if (I(K) && (Q = " " + RegExp.prototype.toString.call(K)), j(K) && (Q = " " + Date.prototype.toUTCString.call(K)), F(K) && (Q = " " + o(K)), $.length === 0 && (!X || K.length == 0))
      return ne[0] + Q + ne[1];
    if (te < 0)
      return I(K) ? k.stylize(RegExp.prototype.toString.call(K), "regexp") : k.stylize("[Object]", "special");
    k.seen.push(K);
    var ve;
    return X ? ve = m(k, K, te, Y, $) : ve = $.map(function(de) {
      return h(k, K, te, Y, de, X);
    }), k.seen.pop(), y(ve, Q, ne);
  }
  function s(k, K) {
    if (C(K))
      return k.stylize("undefined", "undefined");
    if (R(K)) {
      var te = "'" + JSON.stringify(K).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return k.stylize(te, "string");
    }
    if (P(K))
      return k.stylize("" + K, "number");
    if (E(K))
      return k.stylize("" + K, "boolean");
    if (S(K))
      return k.stylize("null", "null");
  }
  function o(k) {
    return "[" + Error.prototype.toString.call(k) + "]";
  }
  function m(k, K, te, z, q) {
    for (var $ = [], Y = 0, H = K.length; Y < H; ++Y)
      W(K, String(Y)) ? $.push(h(
        k,
        K,
        te,
        z,
        String(Y),
        !0
      )) : $.push("");
    return q.forEach(function(Q) {
      Q.match(/^\d+$/) || $.push(h(
        k,
        K,
        te,
        z,
        Q,
        !0
      ));
    }), $;
  }
  function h(k, K, te, z, q, $) {
    var Y, H, Q;
    if (Q = Object.getOwnPropertyDescriptor(K, q) || { value: K[q] }, Q.get ? Q.set ? H = k.stylize("[Getter/Setter]", "special") : H = k.stylize("[Getter]", "special") : Q.set && (H = k.stylize("[Setter]", "special")), W(z, q) || (Y = "[" + q + "]"), H || (k.seen.indexOf(Q.value) < 0 ? (S(te) ? H = d(k, Q.value, null) : H = d(k, Q.value, te - 1), H.indexOf(`
`) > -1 && ($ ? H = H.split(`
`).map(function(X) {
      return "  " + X;
    }).join(`
`).slice(2) : H = `
` + H.split(`
`).map(function(X) {
      return "   " + X;
    }).join(`
`))) : H = k.stylize("[Circular]", "special")), C(Y)) {
      if ($ && q.match(/^\d+$/))
        return H;
      Y = JSON.stringify("" + q), Y.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Y = Y.slice(1, -1), Y = k.stylize(Y, "name")) : (Y = Y.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Y = k.stylize(Y, "string"));
    }
    return Y + ": " + H;
  }
  function y(k, K, te) {
    var z = k.reduce(function(q, $) {
      return $.indexOf(`
`) >= 0, q + $.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return z > 60 ? te[0] + (K === "" ? "" : K + `
 `) + " " + k.join(`,
  `) + " " + te[1] : te[0] + K + " " + k.join(", ") + " " + te[1];
  }
  t.types = ew;
  function b(k) {
    return Array.isArray(k);
  }
  t.isArray = b;
  function E(k) {
    return typeof k == "boolean";
  }
  t.isBoolean = E;
  function S(k) {
    return k === null;
  }
  t.isNull = S;
  function g(k) {
    return k == null;
  }
  t.isNullOrUndefined = g;
  function P(k) {
    return typeof k == "number";
  }
  t.isNumber = P;
  function R(k) {
    return typeof k == "string";
  }
  t.isString = R;
  function N(k) {
    return typeof k == "symbol";
  }
  t.isSymbol = N;
  function C(k) {
    return k === void 0;
  }
  t.isUndefined = C;
  function I(k) {
    return D(k) && v(k) === "[object RegExp]";
  }
  t.isRegExp = I, t.types.isRegExp = I;
  function D(k) {
    return typeof k == "object" && k !== null;
  }
  t.isObject = D;
  function j(k) {
    return D(k) && v(k) === "[object Date]";
  }
  t.isDate = j, t.types.isDate = j;
  function F(k) {
    return D(k) && (v(k) === "[object Error]" || k instanceof Error);
  }
  t.isError = F, t.types.isNativeError = F;
  function _(k) {
    return typeof k == "function";
  }
  t.isFunction = _;
  function T(k) {
    return k === null || typeof k == "boolean" || typeof k == "number" || typeof k == "string" || typeof k == "symbol" || // ES6 symbol
    typeof k > "u";
  }
  t.isPrimitive = T, t.isBuffer = Gk;
  function v(k) {
    return Object.prototype.toString.call(k);
  }
  function w(k) {
    return k < 10 ? "0" + k.toString(10) : k.toString(10);
  }
  var O = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function G() {
    var k = /* @__PURE__ */ new Date(), K = [
      w(k.getHours()),
      w(k.getMinutes()),
      w(k.getSeconds())
    ].join(":");
    return [k.getDate(), O[k.getMonth()], K].join(" ");
  }
  t.log = function() {
    console.log("%s - %s", G(), t.format.apply(t, arguments));
  }, t.inherits = Zt, t._extend = function(k, K) {
    if (!K || !D(K))
      return k;
    for (var te = Object.keys(K), z = te.length; z--; )
      k[te[z]] = K[te[z]];
    return k;
  };
  function W(k, K) {
    return Object.prototype.hasOwnProperty.call(k, K);
  }
  var U = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  t.promisify = function(K) {
    if (typeof K != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (U && K[U]) {
      var te = K[U];
      if (typeof te != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(te, U, {
        value: te,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), te;
    }
    function te() {
      for (var z, q, $ = new Promise(function(Q, X) {
        z = Q, q = X;
      }), Y = [], H = 0; H < arguments.length; H++)
        Y.push(arguments[H]);
      Y.push(function(Q, X) {
        Q ? q(Q) : z(X);
      });
      try {
        K.apply(this, Y);
      } catch (Q) {
        q(Q);
      }
      return $;
    }
    return Object.setPrototypeOf(te, Object.getPrototypeOf(K)), U && Object.defineProperty(te, U, {
      value: te,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      te,
      e(K)
    );
  }, t.promisify.custom = U;
  function M(k, K) {
    if (!k) {
      var te = new Error("Promise was rejected with a falsy value");
      te.reason = k, k = te;
    }
    return K(k);
  }
  function B(k) {
    if (typeof k != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function K() {
      for (var te = [], z = 0; z < arguments.length; z++)
        te.push(arguments[z]);
      var q = te.pop();
      if (typeof q != "function")
        throw new TypeError("The last argument must be of type Function");
      var $ = this, Y = function() {
        return q.apply($, arguments);
      };
      k.apply(this, te).then(
        function(H) {
          Ve.process.nextTick(Y.bind(null, null, H));
        },
        function(H) {
          Ve.process.nextTick(M.bind(null, H, Y));
        }
      );
    }
    return Object.setPrototypeOf(K, Object.getPrototypeOf(k)), Object.defineProperties(
      K,
      e(k)
    ), K;
  }
  t.callbackify = B;
})(mi);
var Vg;
function dw() {
  if (Vg)
    return Up;
  Vg = 1;
  function t(R) {
    "@babel/helpers - typeof";
    return t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(N) {
      return typeof N;
    } : function(N) {
      return N && typeof Symbol == "function" && N.constructor === Symbol && N !== Symbol.prototype ? "symbol" : typeof N;
    }, t(R);
  }
  function e(R, N) {
    for (var C = 0; C < N.length; C++) {
      var I = N[C];
      I.enumerable = I.enumerable || !1, I.configurable = !0, "value" in I && (I.writable = !0), Object.defineProperty(R, a(I.key), I);
    }
  }
  function n(R, N, C) {
    return N && e(R.prototype, N), C && e(R, C), Object.defineProperty(R, "prototype", { writable: !1 }), R;
  }
  function a(R) {
    var N = c(R, "string");
    return t(N) === "symbol" ? N : String(N);
  }
  function c(R, N) {
    if (t(R) !== "object" || R === null)
      return R;
    var C = R[Symbol.toPrimitive];
    if (C !== void 0) {
      var I = C.call(R, N || "default");
      if (t(I) !== "object")
        return I;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (N === "string" ? String : Number)(R);
  }
  function u(R, N) {
    if (!(R instanceof N))
      throw new TypeError("Cannot call a class as a function");
  }
  function r(R, N) {
    if (typeof N != "function" && N !== null)
      throw new TypeError("Super expression must either be null or a function");
    R.prototype = Object.create(N && N.prototype, { constructor: { value: R, writable: !0, configurable: !0 } }), Object.defineProperty(R, "prototype", { writable: !1 }), N && l(R, N);
  }
  function l(R, N) {
    return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(I, D) {
      return I.__proto__ = D, I;
    }, l(R, N);
  }
  function i(R) {
    var N = s();
    return function() {
      var I = o(R), D;
      if (N) {
        var j = o(this).constructor;
        D = Reflect.construct(I, arguments, j);
      } else
        D = I.apply(this, arguments);
      return f(this, D);
    };
  }
  function f(R, N) {
    if (N && (t(N) === "object" || typeof N == "function"))
      return N;
    if (N !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return d(R);
  }
  function d(R) {
    if (R === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return R;
  }
  function s() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function o(R) {
    return o = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(C) {
      return C.__proto__ || Object.getPrototypeOf(C);
    }, o(R);
  }
  var m = {}, h, y;
  function b(R, N, C) {
    C || (C = Error);
    function I(j, F, _) {
      return typeof N == "string" ? N : N(j, F, _);
    }
    var D = /* @__PURE__ */ function(j) {
      r(_, j);
      var F = i(_);
      function _(T, v, w) {
        var O;
        return u(this, _), O = F.call(this, I(T, v, w)), O.code = R, O;
      }
      return n(_);
    }(C);
    m[R] = D;
  }
  function E(R, N) {
    if (Array.isArray(R)) {
      var C = R.length;
      return R = R.map(function(I) {
        return String(I);
      }), C > 2 ? "one of ".concat(N, " ").concat(R.slice(0, C - 1).join(", "), ", or ") + R[C - 1] : C === 2 ? "one of ".concat(N, " ").concat(R[0], " or ").concat(R[1]) : "of ".concat(N, " ").concat(R[0]);
    } else
      return "of ".concat(N, " ").concat(String(R));
  }
  function S(R, N, C) {
    return R.substr(!C || C < 0 ? 0 : +C, N.length) === N;
  }
  function g(R, N, C) {
    return (C === void 0 || C > R.length) && (C = R.length), R.substring(C - N.length, C) === N;
  }
  function P(R, N, C) {
    return typeof C != "number" && (C = 0), C + N.length > R.length ? !1 : R.indexOf(N, C) !== -1;
  }
  return b("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), b("ERR_INVALID_ARG_TYPE", function(R, N, C) {
    h === void 0 && (h = ru()), h(typeof R == "string", "'name' must be a string");
    var I;
    typeof N == "string" && S(N, "not ") ? (I = "must not be", N = N.replace(/^not /, "")) : I = "must be";
    var D;
    if (g(R, " argument"))
      D = "The ".concat(R, " ").concat(I, " ").concat(E(N, "type"));
    else {
      var j = P(R, ".") ? "property" : "argument";
      D = 'The "'.concat(R, '" ').concat(j, " ").concat(I, " ").concat(E(N, "type"));
    }
    return D += ". Received type ".concat(t(C)), D;
  }, TypeError), b("ERR_INVALID_ARG_VALUE", function(R, N) {
    var C = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
    y === void 0 && (y = mi);
    var I = y.inspect(N);
    return I.length > 128 && (I = "".concat(I.slice(0, 128), "...")), "The argument '".concat(R, "' ").concat(C, ". Received ").concat(I);
  }, TypeError), b("ERR_INVALID_RETURN_VALUE", function(R, N, C) {
    var I;
    return C && C.constructor && C.constructor.name ? I = "instance of ".concat(C.constructor.name) : I = "type ".concat(t(C)), "Expected ".concat(R, ' to be returned from the "').concat(N, '"') + " function but got ".concat(I, ".");
  }, TypeError), b("ERR_MISSING_ARGS", function() {
    for (var R = arguments.length, N = new Array(R), C = 0; C < R; C++)
      N[C] = arguments[C];
    h === void 0 && (h = ru()), h(N.length > 0, "At least one arg needs to be specified");
    var I = "The ", D = N.length;
    switch (N = N.map(function(j) {
      return '"'.concat(j, '"');
    }), D) {
      case 1:
        I += "".concat(N[0], " argument");
        break;
      case 2:
        I += "".concat(N[0], " and ").concat(N[1], " arguments");
        break;
      default:
        I += N.slice(0, D - 1).join(", "), I += ", and ".concat(N[D - 1], " arguments");
        break;
    }
    return "".concat(I, " must be specified");
  }, TypeError), Up.codes = m, Up;
}
var Xp, Wg;
function zk() {
  if (Wg)
    return Xp;
  Wg = 1;
  function t(U, M) {
    var B = Object.keys(U);
    if (Object.getOwnPropertySymbols) {
      var k = Object.getOwnPropertySymbols(U);
      M && (k = k.filter(function(K) {
        return Object.getOwnPropertyDescriptor(U, K).enumerable;
      })), B.push.apply(B, k);
    }
    return B;
  }
  function e(U) {
    for (var M = 1; M < arguments.length; M++) {
      var B = arguments[M] != null ? arguments[M] : {};
      M % 2 ? t(Object(B), !0).forEach(function(k) {
        n(U, k, B[k]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(U, Object.getOwnPropertyDescriptors(B)) : t(Object(B)).forEach(function(k) {
        Object.defineProperty(U, k, Object.getOwnPropertyDescriptor(B, k));
      });
    }
    return U;
  }
  function n(U, M, B) {
    return M = r(M), M in U ? Object.defineProperty(U, M, { value: B, enumerable: !0, configurable: !0, writable: !0 }) : U[M] = B, U;
  }
  function a(U, M) {
    if (!(U instanceof M))
      throw new TypeError("Cannot call a class as a function");
  }
  function c(U, M) {
    for (var B = 0; B < M.length; B++) {
      var k = M[B];
      k.enumerable = k.enumerable || !1, k.configurable = !0, "value" in k && (k.writable = !0), Object.defineProperty(U, r(k.key), k);
    }
  }
  function u(U, M, B) {
    return M && c(U.prototype, M), B && c(U, B), Object.defineProperty(U, "prototype", { writable: !1 }), U;
  }
  function r(U) {
    var M = l(U, "string");
    return S(M) === "symbol" ? M : String(M);
  }
  function l(U, M) {
    if (S(U) !== "object" || U === null)
      return U;
    var B = U[Symbol.toPrimitive];
    if (B !== void 0) {
      var k = B.call(U, M || "default");
      if (S(k) !== "object")
        return k;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (M === "string" ? String : Number)(U);
  }
  function i(U, M) {
    if (typeof M != "function" && M !== null)
      throw new TypeError("Super expression must either be null or a function");
    U.prototype = Object.create(M && M.prototype, { constructor: { value: U, writable: !0, configurable: !0 } }), Object.defineProperty(U, "prototype", { writable: !1 }), M && b(U, M);
  }
  function f(U) {
    var M = h();
    return function() {
      var k = E(U), K;
      if (M) {
        var te = E(this).constructor;
        K = Reflect.construct(k, arguments, te);
      } else
        K = k.apply(this, arguments);
      return d(this, K);
    };
  }
  function d(U, M) {
    if (M && (S(M) === "object" || typeof M == "function"))
      return M;
    if (M !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return s(U);
  }
  function s(U) {
    if (U === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return U;
  }
  function o(U) {
    var M = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return o = function(k) {
      if (k === null || !y(k))
        return k;
      if (typeof k != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (typeof M < "u") {
        if (M.has(k))
          return M.get(k);
        M.set(k, K);
      }
      function K() {
        return m(k, arguments, E(this).constructor);
      }
      return K.prototype = Object.create(k.prototype, { constructor: { value: K, enumerable: !1, writable: !0, configurable: !0 } }), b(K, k);
    }, o(U);
  }
  function m(U, M, B) {
    return h() ? m = Reflect.construct.bind() : m = function(K, te, z) {
      var q = [null];
      q.push.apply(q, te);
      var $ = Function.bind.apply(K, q), Y = new $();
      return z && b(Y, z.prototype), Y;
    }, m.apply(null, arguments);
  }
  function h() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function y(U) {
    return Function.toString.call(U).indexOf("[native code]") !== -1;
  }
  function b(U, M) {
    return b = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(k, K) {
      return k.__proto__ = K, k;
    }, b(U, M);
  }
  function E(U) {
    return E = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(B) {
      return B.__proto__ || Object.getPrototypeOf(B);
    }, E(U);
  }
  function S(U) {
    "@babel/helpers - typeof";
    return S = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(M) {
      return typeof M;
    } : function(M) {
      return M && typeof Symbol == "function" && M.constructor === Symbol && M !== Symbol.prototype ? "symbol" : typeof M;
    }, S(U);
  }
  var g = mi, P = g.inspect, R = dw(), N = R.codes.ERR_INVALID_ARG_TYPE;
  function C(U, M, B) {
    return (B === void 0 || B > U.length) && (B = U.length), U.substring(B - M.length, B) === M;
  }
  function I(U, M) {
    if (M = Math.floor(M), U.length == 0 || M == 0)
      return "";
    var B = U.length * M;
    for (M = Math.floor(Math.log(M) / Math.log(2)); M; )
      U += U, M--;
    return U += U.substring(0, B - U.length), U;
  }
  var D = "", j = "", F = "", _ = "", T = {
    deepStrictEqual: "Expected values to be strictly deep-equal:",
    strictEqual: "Expected values to be strictly equal:",
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: "Expected values to be loosely deep-equal:",
    equal: "Expected values to be loosely equal:",
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notEqual: 'Expected "actual" to be loosely unequal to:',
    notIdentical: "Values identical but not reference-equal:"
  }, v = 10;
  function w(U) {
    var M = Object.keys(U), B = Object.create(Object.getPrototypeOf(U));
    return M.forEach(function(k) {
      B[k] = U[k];
    }), Object.defineProperty(B, "message", {
      value: U.message
    }), B;
  }
  function O(U) {
    return P(U, {
      compact: !1,
      customInspect: !1,
      depth: 1e3,
      maxArrayLength: 1 / 0,
      // Assert compares only enumerable properties (with a few exceptions).
      showHidden: !1,
      // Having a long line as error is better than wrapping the line for
      // comparison for now.
      // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
      // have meta information about the inspected properties (i.e., know where
      // in what line the property starts and ends).
      breakLength: 1 / 0,
      // Assert does not detect proxies currently.
      showProxy: !1,
      sorted: !0,
      // Inspect getters as we also check them when comparing entries.
      getters: !0
    });
  }
  function G(U, M, B) {
    var k = "", K = "", te = 0, z = "", q = !1, $ = O(U), Y = $.split(`
`), H = O(M).split(`
`), Q = 0, X = "";
    if (B === "strictEqual" && S(U) === "object" && S(M) === "object" && U !== null && M !== null && (B = "strictEqualObject"), Y.length === 1 && H.length === 1 && Y[0] !== H[0]) {
      var ne = Y[0].length + H[0].length;
      if (ne <= v) {
        if ((S(U) !== "object" || U === null) && (S(M) !== "object" || M === null) && (U !== 0 || M !== 0))
          return "".concat(T[B], `

`) + "".concat(Y[0], " !== ").concat(H[0], `
`);
      } else if (B !== "strictEqualObject") {
        var ye = Ve.process.stderr && Ve.process.stderr.isTTY ? Ve.process.stderr.columns : 80;
        if (ne < ye) {
          for (; Y[0][Q] === H[0][Q]; )
            Q++;
          Q > 2 && (X = `
  `.concat(I(" ", Q), "^"), Q = 0);
        }
      }
    }
    for (var ve = Y[Y.length - 1], de = H[H.length - 1]; ve === de && (Q++ < 2 ? z = `
  `.concat(ve).concat(z) : k = ve, Y.pop(), H.pop(), !(Y.length === 0 || H.length === 0)); )
      ve = Y[Y.length - 1], de = H[H.length - 1];
    var oe = Math.max(Y.length, H.length);
    if (oe === 0) {
      var re = $.split(`
`);
      if (re.length > 30)
        for (re[26] = "".concat(D, "...").concat(_); re.length > 27; )
          re.pop();
      return "".concat(T.notIdentical, `

`).concat(re.join(`
`), `
`);
    }
    Q > 3 && (z = `
`.concat(D, "...").concat(_).concat(z), q = !0), k !== "" && (z = `
  `.concat(k).concat(z), k = "");
    var ae = 0, le = T[B] + `
`.concat(j, "+ actual").concat(_, " ").concat(F, "- expected").concat(_), ue = " ".concat(D, "...").concat(_, " Lines skipped");
    for (Q = 0; Q < oe; Q++) {
      var ie = Q - te;
      if (Y.length < Q + 1)
        ie > 1 && Q > 2 && (ie > 4 ? (K += `
`.concat(D, "...").concat(_), q = !0) : ie > 3 && (K += `
  `.concat(H[Q - 2]), ae++), K += `
  `.concat(H[Q - 1]), ae++), te = Q, k += `
`.concat(F, "-").concat(_, " ").concat(H[Q]), ae++;
      else if (H.length < Q + 1)
        ie > 1 && Q > 2 && (ie > 4 ? (K += `
`.concat(D, "...").concat(_), q = !0) : ie > 3 && (K += `
  `.concat(Y[Q - 2]), ae++), K += `
  `.concat(Y[Q - 1]), ae++), te = Q, K += `
`.concat(j, "+").concat(_, " ").concat(Y[Q]), ae++;
      else {
        var we = H[Q], De = Y[Q], Ee = De !== we && (!C(De, ",") || De.slice(0, -1) !== we);
        Ee && C(we, ",") && we.slice(0, -1) === De && (Ee = !1, De += ","), Ee ? (ie > 1 && Q > 2 && (ie > 4 ? (K += `
`.concat(D, "...").concat(_), q = !0) : ie > 3 && (K += `
  `.concat(Y[Q - 2]), ae++), K += `
  `.concat(Y[Q - 1]), ae++), te = Q, K += `
`.concat(j, "+").concat(_, " ").concat(De), k += `
`.concat(F, "-").concat(_, " ").concat(we), ae += 2) : (K += k, k = "", (ie === 1 || Q === 0) && (K += `
  `.concat(De), ae++));
      }
      if (ae > 20 && Q < oe - 2)
        return "".concat(le).concat(ue, `
`).concat(K, `
`).concat(D, "...").concat(_).concat(k, `
`) + "".concat(D, "...").concat(_);
    }
    return "".concat(le).concat(q ? ue : "", `
`).concat(K).concat(k).concat(z).concat(X);
  }
  var W = /* @__PURE__ */ function(U, M) {
    i(k, U);
    var B = f(k);
    function k(K) {
      var te;
      if (a(this, k), S(K) !== "object" || K === null)
        throw new N("options", "Object", K);
      var z = K.message, q = K.operator, $ = K.stackStartFn, Y = K.actual, H = K.expected, Q = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, z != null)
        te = B.call(this, String(z));
      else if (Ve.process.stderr && Ve.process.stderr.isTTY && (Ve.process.stderr && Ve.process.stderr.getColorDepth && Ve.process.stderr.getColorDepth() !== 1 ? (D = "\x1B[34m", j = "\x1B[32m", _ = "\x1B[39m", F = "\x1B[31m") : (D = "", j = "", _ = "", F = "")), S(Y) === "object" && Y !== null && S(H) === "object" && H !== null && "stack" in Y && Y instanceof Error && "stack" in H && H instanceof Error && (Y = w(Y), H = w(H)), q === "deepStrictEqual" || q === "strictEqual")
        te = B.call(this, G(Y, H, q));
      else if (q === "notDeepStrictEqual" || q === "notStrictEqual") {
        var X = T[q], ne = O(Y).split(`
`);
        if (q === "notStrictEqual" && S(Y) === "object" && Y !== null && (X = T.notStrictEqualObject), ne.length > 30)
          for (ne[26] = "".concat(D, "...").concat(_); ne.length > 27; )
            ne.pop();
        ne.length === 1 ? te = B.call(this, "".concat(X, " ").concat(ne[0])) : te = B.call(this, "".concat(X, `

`).concat(ne.join(`
`), `
`));
      } else {
        var ye = O(Y), ve = "", de = T[q];
        q === "notDeepEqual" || q === "notEqual" ? (ye = "".concat(T[q], `

`).concat(ye), ye.length > 1024 && (ye = "".concat(ye.slice(0, 1021), "..."))) : (ve = "".concat(O(H)), ye.length > 512 && (ye = "".concat(ye.slice(0, 509), "...")), ve.length > 512 && (ve = "".concat(ve.slice(0, 509), "...")), q === "deepEqual" || q === "equal" ? ye = "".concat(de, `

`).concat(ye, `

should equal

`) : ve = " ".concat(q, " ").concat(ve)), te = B.call(this, "".concat(ye).concat(ve));
      }
      return Error.stackTraceLimit = Q, te.generatedMessage = !z, Object.defineProperty(s(te), "name", {
        value: "AssertionError [ERR_ASSERTION]",
        enumerable: !1,
        writable: !0,
        configurable: !0
      }), te.code = "ERR_ASSERTION", te.actual = Y, te.expected = H, te.operator = q, Error.captureStackTrace && Error.captureStackTrace(s(te), $), te.stack, te.name = "AssertionError", d(te);
    }
    return u(k, [{
      key: "toString",
      value: function() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      }
    }, {
      key: M,
      value: function(te, z) {
        return P(this, e(e({}, z), {}, {
          customInspect: !1,
          depth: 0
        }));
      }
    }]), k;
  }(/* @__PURE__ */ o(Error), P.custom);
  return Xp = W, Xp;
}
var Jp, Hg;
function pw() {
  if (Hg)
    return Jp;
  Hg = 1;
  var t = Object.prototype.toString;
  return Jp = function(n) {
    var a = t.call(n), c = a === "[object Arguments]";
    return c || (c = a !== "[object Array]" && n !== null && typeof n == "object" && typeof n.length == "number" && n.length >= 0 && t.call(n.callee) === "[object Function]"), c;
  }, Jp;
}
var Qp, qg;
function Kk() {
  if (qg)
    return Qp;
  qg = 1;
  var t;
  if (!Object.keys) {
    var e = Object.prototype.hasOwnProperty, n = Object.prototype.toString, a = pw(), c = Object.prototype.propertyIsEnumerable, u = !c.call({ toString: null }, "toString"), r = c.call(function() {
    }, "prototype"), l = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], i = function(o) {
      var m = o.constructor;
      return m && m.prototype === o;
    }, f = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, d = function() {
      if (typeof window > "u")
        return !1;
      for (var o in window)
        try {
          if (!f["$" + o] && e.call(window, o) && window[o] !== null && typeof window[o] == "object")
            try {
              i(window[o]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), s = function(o) {
      if (typeof window > "u" || !d)
        return i(o);
      try {
        return i(o);
      } catch {
        return !1;
      }
    };
    t = function(m) {
      var h = m !== null && typeof m == "object", y = n.call(m) === "[object Function]", b = a(m), E = h && n.call(m) === "[object String]", S = [];
      if (!h && !y && !b)
        throw new TypeError("Object.keys called on a non-object");
      var g = r && y;
      if (E && m.length > 0 && !e.call(m, 0))
        for (var P = 0; P < m.length; ++P)
          S.push(String(P));
      if (b && m.length > 0)
        for (var R = 0; R < m.length; ++R)
          S.push(String(R));
      else
        for (var N in m)
          !(g && N === "prototype") && e.call(m, N) && S.push(String(N));
      if (u)
        for (var C = s(m), I = 0; I < l.length; ++I)
          !(C && l[I] === "constructor") && e.call(m, l[I]) && S.push(l[I]);
      return S;
    };
  }
  return Qp = t, Qp;
}
var Zp, Gg;
function hw() {
  if (Gg)
    return Zp;
  Gg = 1;
  var t = Array.prototype.slice, e = pw(), n = Object.keys, a = n ? function(r) {
    return n(r);
  } : Kk(), c = Object.keys;
  return a.shim = function() {
    if (Object.keys) {
      var r = function() {
        var l = Object.keys(arguments);
        return l && l.length === arguments.length;
      }(1, 2);
      r || (Object.keys = function(i) {
        return e(i) ? c(t.call(i)) : c(i);
      });
    } else
      Object.keys = a;
    return Object.keys || a;
  }, Zp = a, Zp;
}
var eh, zg;
function Yk() {
  if (zg)
    return eh;
  zg = 1;
  var t = hw(), e = O0(), n = wu, a = Object, c = n("Array.prototype.push"), u = n("Object.prototype.propertyIsEnumerable"), r = e ? Object.getOwnPropertySymbols : null;
  return eh = function(i, f) {
    if (i == null)
      throw new TypeError("target must be an object");
    var d = a(i);
    if (arguments.length === 1)
      return d;
    for (var s = 1; s < arguments.length; ++s) {
      var o = a(arguments[s]), m = t(o), h = e && (Object.getOwnPropertySymbols || r);
      if (h)
        for (var y = h(o), b = 0; b < y.length; ++b) {
          var E = y[b];
          u(o, E) && c(m, E);
        }
      for (var S = 0; S < m.length; ++S) {
        var g = m[S];
        if (u(o, g)) {
          var P = o[g];
          d[g] = P;
        }
      }
    }
    return d;
  }, eh;
}
var th, Kg;
function Xk() {
  if (Kg)
    return th;
  Kg = 1;
  var t = Yk(), e = function() {
    if (!Object.assign)
      return !1;
    for (var a = "abcdefghijklmnopqrst", c = a.split(""), u = {}, r = 0; r < c.length; ++r)
      u[c[r]] = c[r];
    var l = Object.assign({}, u), i = "";
    for (var f in l)
      i += f;
    return a !== i;
  }, n = function() {
    if (!Object.assign || !Object.preventExtensions)
      return !1;
    var a = Object.preventExtensions({ 1: 2 });
    try {
      Object.assign(a, "xy");
    } catch {
      return a[1] === "y";
    }
    return !1;
  };
  return th = function() {
    return !Object.assign || e() || n() ? t : Object.assign;
  }, th;
}
var rh, Yg;
function mw() {
  if (Yg)
    return rh;
  Yg = 1;
  var t = function(e) {
    return e !== e;
  };
  return rh = function(n, a) {
    return n === 0 && a === 0 ? 1 / n === 1 / a : !!(n === a || t(n) && t(a));
  }, rh;
}
var nh, Xg;
function M0() {
  if (Xg)
    return nh;
  Xg = 1;
  var t = mw();
  return nh = function() {
    return typeof Object.is == "function" ? Object.is : t;
  }, nh;
}
var ih, Jg;
function yw() {
  if (Jg)
    return ih;
  Jg = 1;
  var t = Qo, e = t("%Object.defineProperty%", !0), n = function() {
    if (e)
      try {
        return e({}, "a", { value: 1 }), !0;
      } catch {
        return !1;
      }
    return !1;
  };
  return n.hasArrayLengthDefineBug = function() {
    if (!n())
      return null;
    try {
      return e([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, ih = n, ih;
}
var sh, Qg;
function Jk() {
  if (Qg)
    return sh;
  Qg = 1;
  var t = yw()(), e = Qo, n = t && e("%Object.defineProperty%", !0), a = e("%SyntaxError%"), c = e("%TypeError%"), u = uw;
  return sh = function(l, i, f) {
    if (!l || typeof l != "object" && typeof l != "function")
      throw new c("`obj` must be an object or a function`");
    if (typeof i != "string" && typeof i != "symbol")
      throw new c("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new c("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new c("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new c("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new c("`loose`, if provided, must be a boolean");
    var d = arguments.length > 3 ? arguments[3] : null, s = arguments.length > 4 ? arguments[4] : null, o = arguments.length > 5 ? arguments[5] : null, m = arguments.length > 6 ? arguments[6] : !1, h = !!u && u(l, i);
    if (n)
      n(l, i, {
        configurable: o === null && h ? h.configurable : !o,
        enumerable: d === null && h ? h.enumerable : !d,
        value: f,
        writable: s === null && h ? h.writable : !s
      });
    else if (m || !d && !s && !o)
      l[i] = f;
    else
      throw new a("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, sh;
}
var ah, Zg;
function cd() {
  if (Zg)
    return ah;
  Zg = 1;
  var t = hw(), e = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", n = Object.prototype.toString, a = Array.prototype.concat, c = Jk(), u = function(f) {
    return typeof f == "function" && n.call(f) === "[object Function]";
  }, r = yw()(), l = function(f, d, s, o) {
    if (d in f) {
      if (o === !0) {
        if (f[d] === s)
          return;
      } else if (!u(o) || !o())
        return;
    }
    r ? c(f, d, s, !0) : c(f, d, s);
  }, i = function(f, d) {
    var s = arguments.length > 2 ? arguments[2] : {}, o = t(d);
    e && (o = a.call(o, Object.getOwnPropertySymbols(d)));
    for (var m = 0; m < o.length; m += 1)
      l(f, o[m], d[o[m]], s[o[m]]);
  };
  return i.supportsDescriptors = !!r, ah = i, ah;
}
var oh, ev;
function Qk() {
  if (ev)
    return oh;
  ev = 1;
  var t = M0(), e = cd();
  return oh = function() {
    var a = t();
    return e(Object, { is: a }, {
      is: function() {
        return Object.is !== a;
      }
    }), a;
  }, oh;
}
var lh, tv;
function Zk() {
  if (tv)
    return lh;
  tv = 1;
  var t = cd(), e = ld, n = mw(), a = M0(), c = Qk(), u = e(a(), Object);
  return t(u, {
    getPolyfill: a,
    implementation: n,
    shim: c
  }), lh = u, lh;
}
var uh, rv;
function bw() {
  return rv || (rv = 1, uh = function(e) {
    return e !== e;
  }), uh;
}
var ch, nv;
function gw() {
  if (nv)
    return ch;
  nv = 1;
  var t = bw();
  return ch = function() {
    return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : t;
  }, ch;
}
var fh, iv;
function e3() {
  if (iv)
    return fh;
  iv = 1;
  var t = cd(), e = gw();
  return fh = function() {
    var a = e();
    return t(Number, { isNaN: a }, {
      isNaN: function() {
        return Number.isNaN !== a;
      }
    }), a;
  }, fh;
}
var dh, sv;
function t3() {
  if (sv)
    return dh;
  sv = 1;
  var t = ld, e = cd(), n = bw(), a = gw(), c = e3(), u = t(a(), Number);
  return e(u, {
    getPolyfill: a,
    implementation: n,
    shim: c
  }), dh = u, dh;
}
var ph, av;
function r3() {
  if (av)
    return ph;
  av = 1;
  function t(Ee, Ae) {
    return u(Ee) || c(Ee, Ae) || n(Ee, Ae) || e();
  }
  function e() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function n(Ee, Ae) {
    if (Ee) {
      if (typeof Ee == "string")
        return a(Ee, Ae);
      var Me = Object.prototype.toString.call(Ee).slice(8, -1);
      if (Me === "Object" && Ee.constructor && (Me = Ee.constructor.name), Me === "Map" || Me === "Set")
        return Array.from(Ee);
      if (Me === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Me))
        return a(Ee, Ae);
    }
  }
  function a(Ee, Ae) {
    (Ae == null || Ae > Ee.length) && (Ae = Ee.length);
    for (var Me = 0, me = new Array(Ae); Me < Ae; Me++)
      me[Me] = Ee[Me];
    return me;
  }
  function c(Ee, Ae) {
    var Me = Ee == null ? null : typeof Symbol < "u" && Ee[Symbol.iterator] || Ee["@@iterator"];
    if (Me != null) {
      var me, se, Z, pe, be = [], _e = !0, Ie = !1;
      try {
        if (Z = (Me = Me.call(Ee)).next, Ae === 0) {
          if (Object(Me) !== Me)
            return;
          _e = !1;
        } else
          for (; !(_e = (me = Z.call(Me)).done) && (be.push(me.value), be.length !== Ae); _e = !0)
            ;
      } catch (We) {
        Ie = !0, se = We;
      } finally {
        try {
          if (!_e && Me.return != null && (pe = Me.return(), Object(pe) !== pe))
            return;
        } finally {
          if (Ie)
            throw se;
        }
      }
      return be;
    }
  }
  function u(Ee) {
    if (Array.isArray(Ee))
      return Ee;
  }
  function r(Ee) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Ae) {
      return typeof Ae;
    } : function(Ae) {
      return Ae && typeof Symbol == "function" && Ae.constructor === Symbol && Ae !== Symbol.prototype ? "symbol" : typeof Ae;
    }, r(Ee);
  }
  var l = /a/g.flags !== void 0, i = function(Ae) {
    var Me = [];
    return Ae.forEach(function(me) {
      return Me.push(me);
    }), Me;
  }, f = function(Ae) {
    var Me = [];
    return Ae.forEach(function(me, se) {
      return Me.push([se, me]);
    }), Me;
  }, d = Object.is ? Object.is : Zk(), s = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
  }, o = Number.isNaN ? Number.isNaN : t3();
  function m(Ee) {
    return Ee.call.bind(Ee);
  }
  var h = m(Object.prototype.hasOwnProperty), y = m(Object.prototype.propertyIsEnumerable), b = m(Object.prototype.toString), E = mi.types, S = E.isAnyArrayBuffer, g = E.isArrayBufferView, P = E.isDate, R = E.isMap, N = E.isRegExp, C = E.isSet, I = E.isNativeError, D = E.isBoxedPrimitive, j = E.isNumberObject, F = E.isStringObject, _ = E.isBooleanObject, T = E.isBigIntObject, v = E.isSymbolObject, w = E.isFloat32Array, O = E.isFloat64Array;
  function G(Ee) {
    if (Ee.length === 0 || Ee.length > 10)
      return !0;
    for (var Ae = 0; Ae < Ee.length; Ae++) {
      var Me = Ee.charCodeAt(Ae);
      if (Me < 48 || Me > 57)
        return !0;
    }
    return Ee.length === 10 && Ee >= Math.pow(2, 32);
  }
  function W(Ee) {
    return Object.keys(Ee).filter(G).concat(s(Ee).filter(Object.prototype.propertyIsEnumerable.bind(Ee)));
  }
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  function U(Ee, Ae) {
    if (Ee === Ae)
      return 0;
    for (var Me = Ee.length, me = Ae.length, se = 0, Z = Math.min(Me, me); se < Z; ++se)
      if (Ee[se] !== Ae[se]) {
        Me = Ee[se], me = Ae[se];
        break;
      }
    return Me < me ? -1 : me < Me ? 1 : 0;
  }
  var M = !0, B = !1, k = 0, K = 1, te = 2, z = 3;
  function q(Ee, Ae) {
    return l ? Ee.source === Ae.source && Ee.flags === Ae.flags : RegExp.prototype.toString.call(Ee) === RegExp.prototype.toString.call(Ae);
  }
  function $(Ee, Ae) {
    if (Ee.byteLength !== Ae.byteLength)
      return !1;
    for (var Me = 0; Me < Ee.byteLength; Me++)
      if (Ee[Me] !== Ae[Me])
        return !1;
    return !0;
  }
  function Y(Ee, Ae) {
    return Ee.byteLength !== Ae.byteLength ? !1 : U(new Uint8Array(Ee.buffer, Ee.byteOffset, Ee.byteLength), new Uint8Array(Ae.buffer, Ae.byteOffset, Ae.byteLength)) === 0;
  }
  function H(Ee, Ae) {
    return Ee.byteLength === Ae.byteLength && U(new Uint8Array(Ee), new Uint8Array(Ae)) === 0;
  }
  function Q(Ee, Ae) {
    return j(Ee) ? j(Ae) && d(Number.prototype.valueOf.call(Ee), Number.prototype.valueOf.call(Ae)) : F(Ee) ? F(Ae) && String.prototype.valueOf.call(Ee) === String.prototype.valueOf.call(Ae) : _(Ee) ? _(Ae) && Boolean.prototype.valueOf.call(Ee) === Boolean.prototype.valueOf.call(Ae) : T(Ee) ? T(Ae) && BigInt.prototype.valueOf.call(Ee) === BigInt.prototype.valueOf.call(Ae) : v(Ae) && Symbol.prototype.valueOf.call(Ee) === Symbol.prototype.valueOf.call(Ae);
  }
  function X(Ee, Ae, Me, me) {
    if (Ee === Ae)
      return Ee !== 0 ? !0 : Me ? d(Ee, Ae) : !0;
    if (Me) {
      if (r(Ee) !== "object")
        return typeof Ee == "number" && o(Ee) && o(Ae);
      if (r(Ae) !== "object" || Ee === null || Ae === null || Object.getPrototypeOf(Ee) !== Object.getPrototypeOf(Ae))
        return !1;
    } else {
      if (Ee === null || r(Ee) !== "object")
        return Ae === null || r(Ae) !== "object" ? Ee == Ae : !1;
      if (Ae === null || r(Ae) !== "object")
        return !1;
    }
    var se = b(Ee), Z = b(Ae);
    if (se !== Z)
      return !1;
    if (Array.isArray(Ee)) {
      if (Ee.length !== Ae.length)
        return !1;
      var pe = W(Ee), be = W(Ae);
      return pe.length !== be.length ? !1 : ye(Ee, Ae, Me, me, K, pe);
    }
    if (se === "[object Object]" && (!R(Ee) && R(Ae) || !C(Ee) && C(Ae)))
      return !1;
    if (P(Ee)) {
      if (!P(Ae) || Date.prototype.getTime.call(Ee) !== Date.prototype.getTime.call(Ae))
        return !1;
    } else if (N(Ee)) {
      if (!N(Ae) || !q(Ee, Ae))
        return !1;
    } else if (I(Ee) || Ee instanceof Error) {
      if (Ee.message !== Ae.message || Ee.name !== Ae.name)
        return !1;
    } else if (g(Ee)) {
      if (!Me && (w(Ee) || O(Ee))) {
        if (!$(Ee, Ae))
          return !1;
      } else if (!Y(Ee, Ae))
        return !1;
      var _e = W(Ee), Ie = W(Ae);
      return _e.length !== Ie.length ? !1 : ye(Ee, Ae, Me, me, k, _e);
    } else {
      if (C(Ee))
        return !C(Ae) || Ee.size !== Ae.size ? !1 : ye(Ee, Ae, Me, me, te);
      if (R(Ee))
        return !R(Ae) || Ee.size !== Ae.size ? !1 : ye(Ee, Ae, Me, me, z);
      if (S(Ee)) {
        if (!H(Ee, Ae))
          return !1;
      } else if (D(Ee) && !Q(Ee, Ae))
        return !1;
    }
    return ye(Ee, Ae, Me, me, k);
  }
  function ne(Ee, Ae) {
    return Ae.filter(function(Me) {
      return y(Ee, Me);
    });
  }
  function ye(Ee, Ae, Me, me, se, Z) {
    if (arguments.length === 5) {
      Z = Object.keys(Ee);
      var pe = Object.keys(Ae);
      if (Z.length !== pe.length)
        return !1;
    }
    for (var be = 0; be < Z.length; be++)
      if (!h(Ae, Z[be]))
        return !1;
    if (Me && arguments.length === 5) {
      var _e = s(Ee);
      if (_e.length !== 0) {
        var Ie = 0;
        for (be = 0; be < _e.length; be++) {
          var We = _e[be];
          if (y(Ee, We)) {
            if (!y(Ae, We))
              return !1;
            Z.push(We), Ie++;
          } else if (y(Ae, We))
            return !1;
        }
        var tt = s(Ae);
        if (_e.length !== tt.length && ne(Ae, tt).length !== Ie)
          return !1;
      } else {
        var Ye = s(Ae);
        if (Ye.length !== 0 && ne(Ae, Ye).length !== 0)
          return !1;
      }
    }
    if (Z.length === 0 && (se === k || se === K && Ee.length === 0 || Ee.size === 0))
      return !0;
    if (me === void 0)
      me = {
        val1: /* @__PURE__ */ new Map(),
        val2: /* @__PURE__ */ new Map(),
        position: 0
      };
    else {
      var ht = me.val1.get(Ee);
      if (ht !== void 0) {
        var ct = me.val2.get(Ae);
        if (ct !== void 0)
          return ht === ct;
      }
      me.position++;
    }
    me.val1.set(Ee, me.position), me.val2.set(Ae, me.position);
    var st = ie(Ee, Ae, Me, Z, me, se);
    return me.val1.delete(Ee), me.val2.delete(Ae), st;
  }
  function ve(Ee, Ae, Me, me) {
    for (var se = i(Ee), Z = 0; Z < se.length; Z++) {
      var pe = se[Z];
      if (X(Ae, pe, Me, me))
        return Ee.delete(pe), !0;
    }
    return !1;
  }
  function de(Ee) {
    switch (r(Ee)) {
      case "undefined":
        return null;
      case "object":
        return;
      case "symbol":
        return !1;
      case "string":
        Ee = +Ee;
      case "number":
        if (o(Ee))
          return !1;
    }
    return !0;
  }
  function oe(Ee, Ae, Me) {
    var me = de(Me);
    return me ?? (Ae.has(me) && !Ee.has(me));
  }
  function re(Ee, Ae, Me, me, se) {
    var Z = de(Me);
    if (Z != null)
      return Z;
    var pe = Ae.get(Z);
    return pe === void 0 && !Ae.has(Z) || !X(me, pe, !1, se) ? !1 : !Ee.has(Z) && X(me, pe, !1, se);
  }
  function ae(Ee, Ae, Me, me) {
    for (var se = null, Z = i(Ee), pe = 0; pe < Z.length; pe++) {
      var be = Z[pe];
      if (r(be) === "object" && be !== null)
        se === null && (se = /* @__PURE__ */ new Set()), se.add(be);
      else if (!Ae.has(be)) {
        if (Me || !oe(Ee, Ae, be))
          return !1;
        se === null && (se = /* @__PURE__ */ new Set()), se.add(be);
      }
    }
    if (se !== null) {
      for (var _e = i(Ae), Ie = 0; Ie < _e.length; Ie++) {
        var We = _e[Ie];
        if (r(We) === "object" && We !== null) {
          if (!ve(se, We, Me, me))
            return !1;
        } else if (!Me && !Ee.has(We) && !ve(se, We, Me, me))
          return !1;
      }
      return se.size === 0;
    }
    return !0;
  }
  function le(Ee, Ae, Me, me, se, Z) {
    for (var pe = i(Ee), be = 0; be < pe.length; be++) {
      var _e = pe[be];
      if (X(Me, _e, se, Z) && X(me, Ae.get(_e), se, Z))
        return Ee.delete(_e), !0;
    }
    return !1;
  }
  function ue(Ee, Ae, Me, me) {
    for (var se = null, Z = f(Ee), pe = 0; pe < Z.length; pe++) {
      var be = t(Z[pe], 2), _e = be[0], Ie = be[1];
      if (r(_e) === "object" && _e !== null)
        se === null && (se = /* @__PURE__ */ new Set()), se.add(_e);
      else {
        var We = Ae.get(_e);
        if (We === void 0 && !Ae.has(_e) || !X(Ie, We, Me, me)) {
          if (Me || !re(Ee, Ae, _e, Ie, me))
            return !1;
          se === null && (se = /* @__PURE__ */ new Set()), se.add(_e);
        }
      }
    }
    if (se !== null) {
      for (var tt = f(Ae), Ye = 0; Ye < tt.length; Ye++) {
        var ht = t(tt[Ye], 2), ct = ht[0], st = ht[1];
        if (r(ct) === "object" && ct !== null) {
          if (!le(se, Ee, ct, st, Me, me))
            return !1;
        } else if (!Me && (!Ee.has(ct) || !X(Ee.get(ct), st, !1, me)) && !le(se, Ee, ct, st, !1, me))
          return !1;
      }
      return se.size === 0;
    }
    return !0;
  }
  function ie(Ee, Ae, Me, me, se, Z) {
    var pe = 0;
    if (Z === te) {
      if (!ae(Ee, Ae, Me, se))
        return !1;
    } else if (Z === z) {
      if (!ue(Ee, Ae, Me, se))
        return !1;
    } else if (Z === K)
      for (; pe < Ee.length; pe++)
        if (h(Ee, pe)) {
          if (!h(Ae, pe) || !X(Ee[pe], Ae[pe], Me, se))
            return !1;
        } else {
          if (h(Ae, pe))
            return !1;
          for (var be = Object.keys(Ee); pe < be.length; pe++) {
            var _e = be[pe];
            if (!h(Ae, _e) || !X(Ee[_e], Ae[_e], Me, se))
              return !1;
          }
          return be.length === Object.keys(Ae).length;
        }
    for (pe = 0; pe < me.length; pe++) {
      var Ie = me[pe];
      if (!X(Ee[Ie], Ae[Ie], Me, se))
        return !1;
    }
    return !0;
  }
  function we(Ee, Ae) {
    return X(Ee, Ae, B);
  }
  function De(Ee, Ae) {
    return X(Ee, Ae, M);
  }
  return ph = {
    isDeepEqual: we,
    isDeepStrictEqual: De
  }, ph;
}
var ov;
function ru() {
  if (ov)
    return $p.exports;
  ov = 1;
  function t($) {
    "@babel/helpers - typeof";
    return t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Y) {
      return typeof Y;
    } : function(Y) {
      return Y && typeof Symbol == "function" && Y.constructor === Symbol && Y !== Symbol.prototype ? "symbol" : typeof Y;
    }, t($);
  }
  function e($, Y) {
    for (var H = 0; H < Y.length; H++) {
      var Q = Y[H];
      Q.enumerable = Q.enumerable || !1, Q.configurable = !0, "value" in Q && (Q.writable = !0), Object.defineProperty($, a(Q.key), Q);
    }
  }
  function n($, Y, H) {
    return Y && e($.prototype, Y), H && e($, H), Object.defineProperty($, "prototype", { writable: !1 }), $;
  }
  function a($) {
    var Y = c($, "string");
    return t(Y) === "symbol" ? Y : String(Y);
  }
  function c($, Y) {
    if (t($) !== "object" || $ === null)
      return $;
    var H = $[Symbol.toPrimitive];
    if (H !== void 0) {
      var Q = H.call($, Y || "default");
      if (t(Q) !== "object")
        return Q;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (Y === "string" ? String : Number)($);
  }
  function u($, Y) {
    if (!($ instanceof Y))
      throw new TypeError("Cannot call a class as a function");
  }
  var r = dw(), l = r.codes, i = l.ERR_AMBIGUOUS_ARGUMENT, f = l.ERR_INVALID_ARG_TYPE, d = l.ERR_INVALID_ARG_VALUE, s = l.ERR_INVALID_RETURN_VALUE, o = l.ERR_MISSING_ARGS, m = zk(), h = mi, y = h.inspect, b = mi.types, E = b.isPromise, S = b.isRegExp, g = Xk()(), P = M0()(), R = wu("RegExp.prototype.test"), N, C;
  function I() {
    var $ = r3();
    N = $.isDeepEqual, C = $.isDeepStrictEqual;
  }
  var D = !1, j = $p.exports = w, F = {};
  function _($) {
    throw $.message instanceof Error ? $.message : new m($);
  }
  function T($, Y, H, Q, X) {
    var ne = arguments.length, ye;
    if (ne === 0)
      ye = "Failed";
    else if (ne === 1)
      H = $, $ = void 0;
    else {
      if (D === !1) {
        D = !0;
        var ve = Ve.process.emitWarning ? Ve.process.emitWarning : console.warn.bind(console);
        ve("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      ne === 2 && (Q = "!=");
    }
    if (H instanceof Error)
      throw H;
    var de = {
      actual: $,
      expected: Y,
      operator: Q === void 0 ? "fail" : Q,
      stackStartFn: X || T
    };
    H !== void 0 && (de.message = H);
    var oe = new m(de);
    throw ye && (oe.message = ye, oe.generatedMessage = !0), oe;
  }
  j.fail = T, j.AssertionError = m;
  function v($, Y, H, Q) {
    if (!H) {
      var X = !1;
      if (Y === 0)
        X = !0, Q = "No value argument passed to `assert.ok()`";
      else if (Q instanceof Error)
        throw Q;
      var ne = new m({
        actual: H,
        expected: !0,
        message: Q,
        operator: "==",
        stackStartFn: $
      });
      throw ne.generatedMessage = X, ne;
    }
  }
  function w() {
    for (var $ = arguments.length, Y = new Array($), H = 0; H < $; H++)
      Y[H] = arguments[H];
    v.apply(void 0, [w, Y.length].concat(Y));
  }
  j.ok = w, j.equal = function $(Y, H, Q) {
    if (arguments.length < 2)
      throw new o("actual", "expected");
    Y != H && _({
      actual: Y,
      expected: H,
      message: Q,
      operator: "==",
      stackStartFn: $
    });
  }, j.notEqual = function $(Y, H, Q) {
    if (arguments.length < 2)
      throw new o("actual", "expected");
    Y == H && _({
      actual: Y,
      expected: H,
      message: Q,
      operator: "!=",
      stackStartFn: $
    });
  }, j.deepEqual = function $(Y, H, Q) {
    if (arguments.length < 2)
      throw new o("actual", "expected");
    N === void 0 && I(), N(Y, H) || _({
      actual: Y,
      expected: H,
      message: Q,
      operator: "deepEqual",
      stackStartFn: $
    });
  }, j.notDeepEqual = function $(Y, H, Q) {
    if (arguments.length < 2)
      throw new o("actual", "expected");
    N === void 0 && I(), N(Y, H) && _({
      actual: Y,
      expected: H,
      message: Q,
      operator: "notDeepEqual",
      stackStartFn: $
    });
  }, j.deepStrictEqual = function $(Y, H, Q) {
    if (arguments.length < 2)
      throw new o("actual", "expected");
    N === void 0 && I(), C(Y, H) || _({
      actual: Y,
      expected: H,
      message: Q,
      operator: "deepStrictEqual",
      stackStartFn: $
    });
  }, j.notDeepStrictEqual = O;
  function O($, Y, H) {
    if (arguments.length < 2)
      throw new o("actual", "expected");
    N === void 0 && I(), C($, Y) && _({
      actual: $,
      expected: Y,
      message: H,
      operator: "notDeepStrictEqual",
      stackStartFn: O
    });
  }
  j.strictEqual = function $(Y, H, Q) {
    if (arguments.length < 2)
      throw new o("actual", "expected");
    P(Y, H) || _({
      actual: Y,
      expected: H,
      message: Q,
      operator: "strictEqual",
      stackStartFn: $
    });
  }, j.notStrictEqual = function $(Y, H, Q) {
    if (arguments.length < 2)
      throw new o("actual", "expected");
    P(Y, H) && _({
      actual: Y,
      expected: H,
      message: Q,
      operator: "notStrictEqual",
      stackStartFn: $
    });
  };
  var G = /* @__PURE__ */ n(function $(Y, H, Q) {
    var X = this;
    u(this, $), H.forEach(function(ne) {
      ne in Y && (Q !== void 0 && typeof Q[ne] == "string" && S(Y[ne]) && R(Y[ne], Q[ne]) ? X[ne] = Q[ne] : X[ne] = Y[ne]);
    });
  });
  function W($, Y, H, Q, X, ne) {
    if (!(H in $) || !C($[H], Y[H])) {
      if (!Q) {
        var ye = new G($, X), ve = new G(Y, X, $), de = new m({
          actual: ye,
          expected: ve,
          operator: "deepStrictEqual",
          stackStartFn: ne
        });
        throw de.actual = $, de.expected = Y, de.operator = ne.name, de;
      }
      _({
        actual: $,
        expected: Y,
        message: Q,
        operator: ne.name,
        stackStartFn: ne
      });
    }
  }
  function U($, Y, H, Q) {
    if (typeof Y != "function") {
      if (S(Y))
        return R(Y, $);
      if (arguments.length === 2)
        throw new f("expected", ["Function", "RegExp"], Y);
      if (t($) !== "object" || $ === null) {
        var X = new m({
          actual: $,
          expected: Y,
          message: H,
          operator: "deepStrictEqual",
          stackStartFn: Q
        });
        throw X.operator = Q.name, X;
      }
      var ne = Object.keys(Y);
      if (Y instanceof Error)
        ne.push("name", "message");
      else if (ne.length === 0)
        throw new d("error", Y, "may not be an empty object");
      return N === void 0 && I(), ne.forEach(function(ye) {
        typeof $[ye] == "string" && S(Y[ye]) && R(Y[ye], $[ye]) || W($, Y, ye, H, ne, Q);
      }), !0;
    }
    return Y.prototype !== void 0 && $ instanceof Y ? !0 : Error.isPrototypeOf(Y) ? !1 : Y.call({}, $) === !0;
  }
  function M($) {
    if (typeof $ != "function")
      throw new f("fn", "Function", $);
    try {
      $();
    } catch (Y) {
      return Y;
    }
    return F;
  }
  function B($) {
    return E($) || $ !== null && t($) === "object" && typeof $.then == "function" && typeof $.catch == "function";
  }
  function k($) {
    return Promise.resolve().then(function() {
      var Y;
      if (typeof $ == "function") {
        if (Y = $(), !B(Y))
          throw new s("instance of Promise", "promiseFn", Y);
      } else if (B($))
        Y = $;
      else
        throw new f("promiseFn", ["Function", "Promise"], $);
      return Promise.resolve().then(function() {
        return Y;
      }).then(function() {
        return F;
      }).catch(function(H) {
        return H;
      });
    });
  }
  function K($, Y, H, Q) {
    if (typeof H == "string") {
      if (arguments.length === 4)
        throw new f("error", ["Object", "Error", "Function", "RegExp"], H);
      if (t(Y) === "object" && Y !== null) {
        if (Y.message === H)
          throw new i("error/message", 'The error message "'.concat(Y.message, '" is identical to the message.'));
      } else if (Y === H)
        throw new i("error/message", 'The error "'.concat(Y, '" is identical to the message.'));
      Q = H, H = void 0;
    } else if (H != null && t(H) !== "object" && typeof H != "function")
      throw new f("error", ["Object", "Error", "Function", "RegExp"], H);
    if (Y === F) {
      var X = "";
      H && H.name && (X += " (".concat(H.name, ")")), X += Q ? ": ".concat(Q) : ".";
      var ne = $.name === "rejects" ? "rejection" : "exception";
      _({
        actual: void 0,
        expected: H,
        operator: $.name,
        message: "Missing expected ".concat(ne).concat(X),
        stackStartFn: $
      });
    }
    if (H && !U(Y, H, Q, $))
      throw Y;
  }
  function te($, Y, H, Q) {
    if (Y !== F) {
      if (typeof H == "string" && (Q = H, H = void 0), !H || U(Y, H)) {
        var X = Q ? ": ".concat(Q) : ".", ne = $.name === "doesNotReject" ? "rejection" : "exception";
        _({
          actual: Y,
          expected: H,
          operator: $.name,
          message: "Got unwanted ".concat(ne).concat(X, `
`) + 'Actual message: "'.concat(Y && Y.message, '"'),
          stackStartFn: $
        });
      }
      throw Y;
    }
  }
  j.throws = function $(Y) {
    for (var H = arguments.length, Q = new Array(H > 1 ? H - 1 : 0), X = 1; X < H; X++)
      Q[X - 1] = arguments[X];
    K.apply(void 0, [$, M(Y)].concat(Q));
  }, j.rejects = function $(Y) {
    for (var H = arguments.length, Q = new Array(H > 1 ? H - 1 : 0), X = 1; X < H; X++)
      Q[X - 1] = arguments[X];
    return k(Y).then(function(ne) {
      return K.apply(void 0, [$, ne].concat(Q));
    });
  }, j.doesNotThrow = function $(Y) {
    for (var H = arguments.length, Q = new Array(H > 1 ? H - 1 : 0), X = 1; X < H; X++)
      Q[X - 1] = arguments[X];
    te.apply(void 0, [$, M(Y)].concat(Q));
  }, j.doesNotReject = function $(Y) {
    for (var H = arguments.length, Q = new Array(H > 1 ? H - 1 : 0), X = 1; X < H; X++)
      Q[X - 1] = arguments[X];
    return k(Y).then(function(ne) {
      return te.apply(void 0, [$, ne].concat(Q));
    });
  }, j.ifError = function $(Y) {
    if (Y != null) {
      var H = "ifError got unwanted exception: ";
      t(Y) === "object" && typeof Y.message == "string" ? Y.message.length === 0 && Y.constructor ? H += Y.constructor.name : H += Y.message : H += y(Y);
      var Q = new m({
        actual: Y,
        expected: null,
        operator: "ifError",
        message: H,
        stackStartFn: $
      }), X = Y.stack;
      if (typeof X == "string") {
        var ne = X.split(`
`);
        ne.shift();
        for (var ye = Q.stack.split(`
`), ve = 0; ve < ne.length; ve++) {
          var de = ye.indexOf(ne[ve]);
          if (de !== -1) {
            ye = ye.slice(0, de);
            break;
          }
        }
        Q.stack = "".concat(ye.join(`
`), `
`).concat(ne.join(`
`));
      }
      throw Q;
    }
  };
  function z($, Y, H, Q, X) {
    if (!S(Y))
      throw new f("regexp", "RegExp", Y);
    var ne = X === "match";
    if (typeof $ != "string" || R(Y, $) !== ne) {
      if (H instanceof Error)
        throw H;
      var ye = !H;
      H = H || (typeof $ != "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(t($), " (").concat(y($), ")") : (ne ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(y(Y), `. Input:

`).concat(y($), `
`));
      var ve = new m({
        actual: $,
        expected: Y,
        message: H,
        operator: X,
        stackStartFn: Q
      });
      throw ve.generatedMessage = ye, ve;
    }
  }
  j.match = function $(Y, H, Q) {
    z(Y, H, Q, $, "match");
  }, j.doesNotMatch = function $(Y, H, Q) {
    z(Y, H, Q, $, "doesNotMatch");
  };
  function q() {
    for (var $ = arguments.length, Y = new Array($), H = 0; H < $; H++)
      Y[H] = arguments[H];
    v.apply(void 0, [q, Y.length].concat(Y));
  }
  return j.strict = g(q, j, {
    equal: j.strictEqual,
    deepEqual: j.deepStrictEqual,
    notEqual: j.notStrictEqual,
    notDeepEqual: j.notDeepStrictEqual
  }), j.strict.strict = j.strict, $p.exports;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.E = t.AssertionError = t.message = t.RangeError = t.TypeError = t.Error = void 0;
  const e = ru(), n = mi, a = typeof Symbol > "u" ? "_kCode" : Symbol("code"), c = {};
  function u(h) {
    return class extends h {
      constructor(b, ...E) {
        super(i(b, E)), this.code = b, this[a] = b, this.name = `${super.name} [${this[a]}]`;
      }
    };
  }
  const r = typeof globalThis < "u" ? globalThis : Bt;
  class l extends r.Error {
    constructor(y) {
      if (typeof y != "object" || y === null)
        throw new t.TypeError("ERR_INVALID_ARG_TYPE", "options", "object");
      y.message ? super(y.message) : super(`${n.inspect(y.actual).slice(0, 128)} ${y.operator} ${n.inspect(y.expected).slice(0, 128)}`), this.generatedMessage = !y.message, this.name = "AssertionError [ERR_ASSERTION]", this.code = "ERR_ASSERTION", this.actual = y.actual, this.expected = y.expected, this.operator = y.operator, t.Error.captureStackTrace(this, y.stackStartFunction);
    }
  }
  t.AssertionError = l;
  function i(h, y) {
    e.strictEqual(typeof h, "string");
    const b = c[h];
    e(b, `An invalid error message key was used: ${h}.`);
    let E;
    if (typeof b == "function")
      E = b;
    else {
      if (E = n.format, y === void 0 || y.length === 0)
        return b;
      y.unshift(b);
    }
    return String(E.apply(null, y));
  }
  t.message = i;
  function f(h, y) {
    c[h] = typeof y == "function" ? y : String(y);
  }
  t.E = f, t.Error = u(r.Error), t.TypeError = u(r.TypeError), t.RangeError = u(r.RangeError), f("ERR_ARG_NOT_ITERABLE", "%s must be iterable"), f("ERR_ASSERTION", "%s"), f("ERR_BUFFER_OUT_OF_BOUNDS", m), f("ERR_CHILD_CLOSED_BEFORE_REPLY", "Child closed before reply received"), f("ERR_CONSOLE_WRITABLE_STREAM", "Console expects a writable stream instance for %s"), f("ERR_CPU_USAGE", "Unable to obtain cpu usage %s"), f("ERR_DNS_SET_SERVERS_FAILED", (h, y) => `c-ares failed to set servers: "${h}" [${y}]`), f("ERR_FALSY_VALUE_REJECTION", "Promise was rejected with falsy value"), f("ERR_ENCODING_NOT_SUPPORTED", (h) => `The "${h}" encoding is not supported`), f("ERR_ENCODING_INVALID_ENCODED_DATA", (h) => `The encoded data was not valid for encoding ${h}`), f("ERR_HTTP_HEADERS_SENT", "Cannot render headers after they are sent to the client"), f("ERR_HTTP_INVALID_STATUS_CODE", "Invalid status code: %s"), f("ERR_HTTP_TRAILER_INVALID", "Trailers are invalid with this transfer encoding"), f("ERR_INDEX_OUT_OF_RANGE", "Index out of range"), f("ERR_INVALID_ARG_TYPE", d), f("ERR_INVALID_ARRAY_LENGTH", (h, y, b) => (e.strictEqual(typeof b, "number"), `The array "${h}" (length ${b}) must be of length ${y}.`)), f("ERR_INVALID_BUFFER_SIZE", "Buffer size must be a multiple of %s"), f("ERR_INVALID_CALLBACK", "Callback must be a function"), f("ERR_INVALID_CHAR", "Invalid character in %s"), f("ERR_INVALID_CURSOR_POS", "Cannot set cursor row without setting its column"), f("ERR_INVALID_FD", '"fd" must be a positive integer: %s'), f("ERR_INVALID_FILE_URL_HOST", 'File URL host must be "localhost" or empty on %s'), f("ERR_INVALID_FILE_URL_PATH", "File URL path %s"), f("ERR_INVALID_HANDLE_TYPE", "This handle type cannot be sent"), f("ERR_INVALID_IP_ADDRESS", "Invalid IP address: %s"), f("ERR_INVALID_OPT_VALUE", (h, y) => `The value "${String(y)}" is invalid for option "${h}"`), f("ERR_INVALID_OPT_VALUE_ENCODING", (h) => `The value "${String(h)}" is invalid for option "encoding"`), f("ERR_INVALID_REPL_EVAL_CONFIG", 'Cannot specify both "breakEvalOnSigint" and "eval" for REPL'), f("ERR_INVALID_SYNC_FORK_INPUT", "Asynchronous forks do not support Buffer, Uint8Array or string input: %s"), f("ERR_INVALID_THIS", 'Value of "this" must be of type %s'), f("ERR_INVALID_TUPLE", "%s must be an iterable %s tuple"), f("ERR_INVALID_URL", "Invalid URL: %s"), f("ERR_INVALID_URL_SCHEME", (h) => `The URL must be ${o(h, "scheme")}`), f("ERR_IPC_CHANNEL_CLOSED", "Channel closed"), f("ERR_IPC_DISCONNECTED", "IPC channel is already disconnected"), f("ERR_IPC_ONE_PIPE", "Child process can have only one IPC pipe"), f("ERR_IPC_SYNC_FORK", "IPC cannot be used with synchronous forks"), f("ERR_MISSING_ARGS", s), f("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), f("ERR_NAPI_CONS_FUNCTION", "Constructor must be a function"), f("ERR_NAPI_CONS_PROTOTYPE_OBJECT", "Constructor.prototype must be an object"), f("ERR_NO_CRYPTO", "Node.js is not compiled with OpenSSL crypto support"), f("ERR_NO_LONGER_SUPPORTED", "%s is no longer supported"), f("ERR_PARSE_HISTORY_DATA", "Could not parse history data in %s"), f("ERR_SOCKET_ALREADY_BOUND", "Socket is already bound"), f("ERR_SOCKET_BAD_PORT", "Port should be > 0 and < 65536"), f("ERR_SOCKET_BAD_TYPE", "Bad socket type specified. Valid types are: udp4, udp6"), f("ERR_SOCKET_CANNOT_SEND", "Unable to send data"), f("ERR_SOCKET_CLOSED", "Socket is closed"), f("ERR_SOCKET_DGRAM_NOT_RUNNING", "Not running"), f("ERR_STDERR_CLOSE", "process.stderr cannot be closed"), f("ERR_STDOUT_CLOSE", "process.stdout cannot be closed"), f("ERR_STREAM_WRAP", "Stream has StringDecoder set or is in objectMode"), f("ERR_TLS_CERT_ALTNAME_INVALID", "Hostname/IP does not match certificate's altnames: %s"), f("ERR_TLS_DH_PARAM_SIZE", (h) => `DH parameter size ${h} is less than 2048`), f("ERR_TLS_HANDSHAKE_TIMEOUT", "TLS handshake timeout"), f("ERR_TLS_RENEGOTIATION_FAILED", "Failed to renegotiate"), f("ERR_TLS_REQUIRED_SERVER_NAME", '"servername" is required parameter for Server.addContext'), f("ERR_TLS_SESSION_ATTACK", "TSL session renegotiation attack detected"), f("ERR_TRANSFORM_ALREADY_TRANSFORMING", "Calling transform done when still transforming"), f("ERR_TRANSFORM_WITH_LENGTH_0", "Calling transform done when writableState.length != 0"), f("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s"), f("ERR_UNKNOWN_SIGNAL", "Unknown signal: %s"), f("ERR_UNKNOWN_STDIN_TYPE", "Unknown stdin file type"), f("ERR_UNKNOWN_STREAM_TYPE", "Unknown stream file type"), f("ERR_V8BREAKITERATOR", "Full ICU data not installed. See https://github.com/nodejs/node/wiki/Intl");
  function d(h, y, b) {
    e(h, "name is required");
    let E;
    y.includes("not ") ? (E = "must not be", y = y.split("not ")[1]) : E = "must be";
    let S;
    if (Array.isArray(h))
      S = `The ${h.map((P) => `"${P}"`).join(", ")} arguments ${E} ${o(y, "type")}`;
    else if (h.includes(" argument"))
      S = `The ${h} ${E} ${o(y, "type")}`;
    else {
      const g = h.includes(".") ? "property" : "argument";
      S = `The "${h}" ${g} ${E} ${o(y, "type")}`;
    }
    return arguments.length >= 3 && (S += `. Received type ${b !== null ? typeof b : "null"}`), S;
  }
  function s(...h) {
    e(h.length > 0, "At least one arg needs to be specified");
    let y = "The ";
    const b = h.length;
    switch (h = h.map((E) => `"${E}"`), b) {
      case 1:
        y += `${h[0]} argument`;
        break;
      case 2:
        y += `${h[0]} and ${h[1]} arguments`;
        break;
      default:
        y += h.slice(0, b - 1).join(", "), y += `, and ${h[b - 1]} arguments`;
        break;
    }
    return `${y} must be specified`;
  }
  function o(h, y) {
    if (e(h, "expected is required"), e(typeof y == "string", "thing is required"), Array.isArray(h)) {
      const b = h.length;
      return e(b > 0, "At least one expected value needs to be specified"), h = h.map((E) => String(E)), b > 2 ? `one of ${y} ${h.slice(0, b - 1).join(", ")}, or ` + h[b - 1] : b === 2 ? `one of ${y} ${h[0]} or ${h[1]}` : `of ${y} ${h[0]}`;
    } else
      return `of ${y} ${String(h)}`;
  }
  function m(h, y) {
    return y ? "Attempt to write outside buffer bounds" : `"${h}" is outside of buffer bounds`;
  }
})(I0);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.strToEncoding = t.assertEncoding = t.ENCODING_UTF8 = void 0;
  const e = _u, n = I0;
  t.ENCODING_UTF8 = "utf8";
  function a(u) {
    if (u && !e.Buffer.isEncoding(u))
      throw new n.TypeError("ERR_INVALID_OPT_VALUE_ENCODING", u);
  }
  t.assertEncoding = a;
  function c(u, r) {
    return !r || r === t.ENCODING_UTF8 ? u : r === "buffer" ? new e.Buffer(u) : new e.Buffer(u).toString(r);
  }
  t.strToEncoding = c;
})(Eu);
Object.defineProperty(Jo, "__esModule", { value: !0 });
Jo.Dirent = void 0;
const n3 = Es, i3 = Eu, { S_IFMT: s3, S_IFDIR: a3, S_IFREG: o3, S_IFBLK: l3, S_IFCHR: u3, S_IFLNK: c3, S_IFIFO: f3, S_IFSOCK: d3 } = n3.constants;
class fd {
  constructor() {
    this.name = "", this.mode = 0;
  }
  static build(e, n) {
    const a = new fd(), { mode: c } = e.getNode();
    return a.name = (0, i3.strToEncoding)(e.getName(), n), a.mode = c, a;
  }
  _checkModeProperty(e) {
    return (this.mode & s3) === e;
  }
  isDirectory() {
    return this._checkModeProperty(a3);
  }
  isFile() {
    return this._checkModeProperty(o3);
  }
  isBlockDevice() {
    return this._checkModeProperty(l3);
  }
  isCharacterDevice() {
    return this._checkModeProperty(u3);
  }
  isSymbolicLink() {
    return this._checkModeProperty(c3);
  }
  isFIFO() {
    return this._checkModeProperty(f3);
  }
  isSocket() {
    return this._checkModeProperty(d3);
  }
}
Jo.Dirent = fd;
Jo.default = fd;
var ln = {};
function Ji(t) {
  if (typeof t != "string")
    throw new TypeError("Path must be a string. Received " + JSON.stringify(t));
}
function lv(t, e) {
  for (var n = "", a = 0, c = -1, u = 0, r, l = 0; l <= t.length; ++l) {
    if (l < t.length)
      r = t.charCodeAt(l);
    else {
      if (r === 47)
        break;
      r = 47;
    }
    if (r === 47) {
      if (!(c === l - 1 || u === 1))
        if (c !== l - 1 && u === 2) {
          if (n.length < 2 || a !== 2 || n.charCodeAt(n.length - 1) !== 46 || n.charCodeAt(n.length - 2) !== 46) {
            if (n.length > 2) {
              var i = n.lastIndexOf("/");
              if (i !== n.length - 1) {
                i === -1 ? (n = "", a = 0) : (n = n.slice(0, i), a = n.length - 1 - n.lastIndexOf("/")), c = l, u = 0;
                continue;
              }
            } else if (n.length === 2 || n.length === 1) {
              n = "", a = 0, c = l, u = 0;
              continue;
            }
          }
          e && (n.length > 0 ? n += "/.." : n = "..", a = 2);
        } else
          n.length > 0 ? n += "/" + t.slice(c + 1, l) : n = t.slice(c + 1, l), a = l - c - 1;
      c = l, u = 0;
    } else
      r === 46 && u !== -1 ? ++u : u = -1;
  }
  return n;
}
function p3(t, e) {
  var n = e.dir || e.root, a = e.base || (e.name || "") + (e.ext || "");
  return n ? n === e.root ? n + a : n + t + a : a;
}
var Ao = {
  // path.resolve([from ...], to)
  resolve: function() {
    for (var e = "", n = !1, a, c = arguments.length - 1; c >= -1 && !n; c--) {
      var u;
      c >= 0 ? u = arguments[c] : (a === void 0 && (a = Ve.process.cwd()), u = a), Ji(u), u.length !== 0 && (e = u + "/" + e, n = u.charCodeAt(0) === 47);
    }
    return e = lv(e, !n), n ? e.length > 0 ? "/" + e : "/" : e.length > 0 ? e : ".";
  },
  normalize: function(e) {
    if (Ji(e), e.length === 0)
      return ".";
    var n = e.charCodeAt(0) === 47, a = e.charCodeAt(e.length - 1) === 47;
    return e = lv(e, !n), e.length === 0 && !n && (e = "."), e.length > 0 && a && (e += "/"), n ? "/" + e : e;
  },
  isAbsolute: function(e) {
    return Ji(e), e.length > 0 && e.charCodeAt(0) === 47;
  },
  join: function() {
    if (arguments.length === 0)
      return ".";
    for (var e, n = 0; n < arguments.length; ++n) {
      var a = arguments[n];
      Ji(a), a.length > 0 && (e === void 0 ? e = a : e += "/" + a);
    }
    return e === void 0 ? "." : Ao.normalize(e);
  },
  relative: function(e, n) {
    if (Ji(e), Ji(n), e === n || (e = Ao.resolve(e), n = Ao.resolve(n), e === n))
      return "";
    for (var a = 1; a < e.length && e.charCodeAt(a) === 47; ++a)
      ;
    for (var c = e.length, u = c - a, r = 1; r < n.length && n.charCodeAt(r) === 47; ++r)
      ;
    for (var l = n.length, i = l - r, f = u < i ? u : i, d = -1, s = 0; s <= f; ++s) {
      if (s === f) {
        if (i > f) {
          if (n.charCodeAt(r + s) === 47)
            return n.slice(r + s + 1);
          if (s === 0)
            return n.slice(r + s);
        } else
          u > f && (e.charCodeAt(a + s) === 47 ? d = s : s === 0 && (d = 0));
        break;
      }
      var o = e.charCodeAt(a + s), m = n.charCodeAt(r + s);
      if (o !== m)
        break;
      o === 47 && (d = s);
    }
    var h = "";
    for (s = a + d + 1; s <= c; ++s)
      (s === c || e.charCodeAt(s) === 47) && (h.length === 0 ? h += ".." : h += "/..");
    return h.length > 0 ? h + n.slice(r + d) : (r += d, n.charCodeAt(r) === 47 && ++r, n.slice(r));
  },
  _makeLong: function(e) {
    return e;
  },
  dirname: function(e) {
    if (Ji(e), e.length === 0)
      return ".";
    for (var n = e.charCodeAt(0), a = n === 47, c = -1, u = !0, r = e.length - 1; r >= 1; --r)
      if (n = e.charCodeAt(r), n === 47) {
        if (!u) {
          c = r;
          break;
        }
      } else
        u = !1;
    return c === -1 ? a ? "/" : "." : a && c === 1 ? "//" : e.slice(0, c);
  },
  basename: function(e, n) {
    if (n !== void 0 && typeof n != "string")
      throw new TypeError('"ext" argument must be a string');
    Ji(e);
    var a = 0, c = -1, u = !0, r;
    if (n !== void 0 && n.length > 0 && n.length <= e.length) {
      if (n.length === e.length && n === e)
        return "";
      var l = n.length - 1, i = -1;
      for (r = e.length - 1; r >= 0; --r) {
        var f = e.charCodeAt(r);
        if (f === 47) {
          if (!u) {
            a = r + 1;
            break;
          }
        } else
          i === -1 && (u = !1, i = r + 1), l >= 0 && (f === n.charCodeAt(l) ? --l === -1 && (c = r) : (l = -1, c = i));
      }
      return a === c ? c = i : c === -1 && (c = e.length), e.slice(a, c);
    } else {
      for (r = e.length - 1; r >= 0; --r)
        if (e.charCodeAt(r) === 47) {
          if (!u) {
            a = r + 1;
            break;
          }
        } else
          c === -1 && (u = !1, c = r + 1);
      return c === -1 ? "" : e.slice(a, c);
    }
  },
  extname: function(e) {
    Ji(e);
    for (var n = -1, a = 0, c = -1, u = !0, r = 0, l = e.length - 1; l >= 0; --l) {
      var i = e.charCodeAt(l);
      if (i === 47) {
        if (!u) {
          a = l + 1;
          break;
        }
        continue;
      }
      c === -1 && (u = !1, c = l + 1), i === 46 ? n === -1 ? n = l : r !== 1 && (r = 1) : n !== -1 && (r = -1);
    }
    return n === -1 || c === -1 || // We saw a non-dot character immediately before the dot
    r === 0 || // The (right-most) trimmed path component is exactly '..'
    r === 1 && n === c - 1 && n === a + 1 ? "" : e.slice(n, c);
  },
  format: function(e) {
    if (e === null || typeof e != "object")
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e);
    return p3("/", e);
  },
  parse: function(e) {
    Ji(e);
    var n = { root: "", dir: "", base: "", ext: "", name: "" };
    if (e.length === 0)
      return n;
    var a = e.charCodeAt(0), c = a === 47, u;
    c ? (n.root = "/", u = 1) : u = 0;
    for (var r = -1, l = 0, i = -1, f = !0, d = e.length - 1, s = 0; d >= u; --d) {
      if (a = e.charCodeAt(d), a === 47) {
        if (!f) {
          l = d + 1;
          break;
        }
        continue;
      }
      i === -1 && (f = !1, i = d + 1), a === 46 ? r === -1 ? r = d : s !== 1 && (s = 1) : r !== -1 && (s = -1);
    }
    return r === -1 || i === -1 || // We saw a non-dot character immediately before the dot
    s === 0 || // The (right-most) trimmed path component is exactly '..'
    s === 1 && r === i - 1 && r === l + 1 ? i !== -1 && (l === 0 && c ? n.base = n.name = e.slice(1, i) : n.base = n.name = e.slice(l, i)) : (l === 0 && c ? (n.name = e.slice(1, r), n.base = e.slice(1, i)) : (n.name = e.slice(l, r), n.base = e.slice(l, i)), n.ext = e.slice(r, i)), l > 0 ? n.dir = e.slice(0, l - 1) : c && (n.dir = "/"), n;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
Ao.posix = Ao;
var Lr = Ao, vw = {}, Zo = {};
Object.defineProperty(Zo, "__esModule", { value: !0 });
Zo.createProcess = void 0;
const h3 = () => {
  if (typeof Ve.process < "u")
    return Ve.process;
  try {
    return sd;
  } catch {
    return;
  }
};
function Ew() {
  const t = h3() || {};
  return t.cwd || (t.cwd = () => "/"), t.emitWarning || (t.emitWarning = (e, n) => {
    console.warn(`${n}${n ? ": " : ""}${e}`);
  }), t.env || (t.env = {}), t;
}
Zo.createProcess = Ew;
Zo.default = Ew();
var L0 = { exports: {} }, xo = typeof Reflect == "object" ? Reflect : null, uv = xo && typeof xo.apply == "function" ? xo.apply : function(e, n, a) {
  return Function.prototype.apply.call(e, n, a);
}, rf;
xo && typeof xo.ownKeys == "function" ? rf = xo.ownKeys : Object.getOwnPropertySymbols ? rf = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : rf = function(e) {
  return Object.getOwnPropertyNames(e);
};
function m3(t) {
  console && console.warn && console.warn(t);
}
var _w = Number.isNaN || function(e) {
  return e !== e;
};
function gr() {
  gr.init.call(this);
}
L0.exports = gr;
L0.exports.once = v3;
gr.EventEmitter = gr;
gr.prototype._events = void 0;
gr.prototype._eventsCount = 0;
gr.prototype._maxListeners = void 0;
var cv = 10;
function dd(t) {
  if (typeof t != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
}
Object.defineProperty(gr, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return cv;
  },
  set: function(t) {
    if (typeof t != "number" || t < 0 || _w(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    cv = t;
  }
});
gr.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
gr.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || _w(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function Sw(t) {
  return t._maxListeners === void 0 ? gr.defaultMaxListeners : t._maxListeners;
}
gr.prototype.getMaxListeners = function() {
  return Sw(this);
};
gr.prototype.emit = function(e) {
  for (var n = [], a = 1; a < arguments.length; a++)
    n.push(arguments[a]);
  var c = e === "error", u = this._events;
  if (u !== void 0)
    c = c && u.error === void 0;
  else if (!c)
    return !1;
  if (c) {
    var r;
    if (n.length > 0 && (r = n[0]), r instanceof Error)
      throw r;
    var l = new Error("Unhandled error." + (r ? " (" + r.message + ")" : ""));
    throw l.context = r, l;
  }
  var i = u[e];
  if (i === void 0)
    return !1;
  if (typeof i == "function")
    uv(i, this, n);
  else
    for (var f = i.length, d = Pw(i, f), a = 0; a < f; ++a)
      uv(d[a], this, n);
  return !0;
};
function ww(t, e, n, a) {
  var c, u, r;
  if (dd(n), u = t._events, u === void 0 ? (u = t._events = /* @__PURE__ */ Object.create(null), t._eventsCount = 0) : (u.newListener !== void 0 && (t.emit(
    "newListener",
    e,
    n.listener ? n.listener : n
  ), u = t._events), r = u[e]), r === void 0)
    r = u[e] = n, ++t._eventsCount;
  else if (typeof r == "function" ? r = u[e] = a ? [n, r] : [r, n] : a ? r.unshift(n) : r.push(n), c = Sw(t), c > 0 && r.length > c && !r.warned) {
    r.warned = !0;
    var l = new Error("Possible EventEmitter memory leak detected. " + r.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    l.name = "MaxListenersExceededWarning", l.emitter = t, l.type = e, l.count = r.length, m3(l);
  }
  return t;
}
gr.prototype.addListener = function(e, n) {
  return ww(this, e, n, !1);
};
gr.prototype.on = gr.prototype.addListener;
gr.prototype.prependListener = function(e, n) {
  return ww(this, e, n, !0);
};
function y3() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function Tw(t, e, n) {
  var a = { fired: !1, wrapFn: void 0, target: t, type: e, listener: n }, c = y3.bind(a);
  return c.listener = n, a.wrapFn = c, c;
}
gr.prototype.once = function(e, n) {
  return dd(n), this.on(e, Tw(this, e, n)), this;
};
gr.prototype.prependOnceListener = function(e, n) {
  return dd(n), this.prependListener(e, Tw(this, e, n)), this;
};
gr.prototype.removeListener = function(e, n) {
  var a, c, u, r, l;
  if (dd(n), c = this._events, c === void 0)
    return this;
  if (a = c[e], a === void 0)
    return this;
  if (a === n || a.listener === n)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete c[e], c.removeListener && this.emit("removeListener", e, a.listener || n));
  else if (typeof a != "function") {
    for (u = -1, r = a.length - 1; r >= 0; r--)
      if (a[r] === n || a[r].listener === n) {
        l = a[r].listener, u = r;
        break;
      }
    if (u < 0)
      return this;
    u === 0 ? a.shift() : b3(a, u), a.length === 1 && (c[e] = a[0]), c.removeListener !== void 0 && this.emit("removeListener", e, l || n);
  }
  return this;
};
gr.prototype.off = gr.prototype.removeListener;
gr.prototype.removeAllListeners = function(e) {
  var n, a, c;
  if (a = this._events, a === void 0)
    return this;
  if (a.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : a[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete a[e]), this;
  if (arguments.length === 0) {
    var u = Object.keys(a), r;
    for (c = 0; c < u.length; ++c)
      r = u[c], r !== "removeListener" && this.removeAllListeners(r);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (n = a[e], typeof n == "function")
    this.removeListener(e, n);
  else if (n !== void 0)
    for (c = n.length - 1; c >= 0; c--)
      this.removeListener(e, n[c]);
  return this;
};
function Aw(t, e, n) {
  var a = t._events;
  if (a === void 0)
    return [];
  var c = a[e];
  return c === void 0 ? [] : typeof c == "function" ? n ? [c.listener || c] : [c] : n ? g3(c) : Pw(c, c.length);
}
gr.prototype.listeners = function(e) {
  return Aw(this, e, !0);
};
gr.prototype.rawListeners = function(e) {
  return Aw(this, e, !1);
};
gr.listenerCount = function(t, e) {
  return typeof t.listenerCount == "function" ? t.listenerCount(e) : xw.call(t, e);
};
gr.prototype.listenerCount = xw;
function xw(t) {
  var e = this._events;
  if (e !== void 0) {
    var n = e[t];
    if (typeof n == "function")
      return 1;
    if (n !== void 0)
      return n.length;
  }
  return 0;
}
gr.prototype.eventNames = function() {
  return this._eventsCount > 0 ? rf(this._events) : [];
};
function Pw(t, e) {
  for (var n = new Array(e), a = 0; a < e; ++a)
    n[a] = t[a];
  return n;
}
function b3(t, e) {
  for (; e + 1 < t.length; e++)
    t[e] = t[e + 1];
  t.pop();
}
function g3(t) {
  for (var e = new Array(t.length), n = 0; n < e.length; ++n)
    e[n] = t[n].listener || t[n];
  return e;
}
function v3(t, e) {
  return new Promise(function(n, a) {
    function c(r) {
      t.removeListener(e, u), a(r);
    }
    function u() {
      typeof t.removeListener == "function" && t.removeListener("error", c), n([].slice.call(arguments));
    }
    Cw(t, e, u, { once: !0 }), e !== "error" && E3(t, c, { once: !0 });
  });
}
function E3(t, e, n) {
  typeof t.on == "function" && Cw(t, "error", e, n);
}
function Cw(t, e, n, a) {
  if (typeof t.on == "function")
    a.once ? t.once(e, n) : t.on(e, n);
  else if (typeof t.addEventListener == "function")
    t.addEventListener(e, function c(u) {
      a.once && t.removeEventListener(e, c), n(u);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
}
var Tu = L0.exports;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.File = t.Link = t.Node = t.SEP = void 0;
  const e = Zo, n = _u, a = Es, c = Tu, u = Ka, { S_IFMT: r, S_IFDIR: l, S_IFREG: i, S_IFLNK: f, O_APPEND: d } = a.constants, s = () => {
    var b, E;
    return (E = (b = e.default.getuid) === null || b === void 0 ? void 0 : b.call(e.default)) !== null && E !== void 0 ? E : 0;
  }, o = () => {
    var b, E;
    return (E = (b = e.default.getgid) === null || b === void 0 ? void 0 : b.call(e.default)) !== null && E !== void 0 ? E : 0;
  };
  t.SEP = "/";
  class m extends c.EventEmitter {
    constructor(E, S = 438) {
      super(), this._uid = s(), this._gid = o(), this._atime = /* @__PURE__ */ new Date(), this._mtime = /* @__PURE__ */ new Date(), this._ctime = /* @__PURE__ */ new Date(), this._perm = 438, this.mode = i, this._nlink = 1, this._perm = S, this.mode |= S, this.ino = E;
    }
    set ctime(E) {
      this._ctime = E;
    }
    get ctime() {
      return this._ctime;
    }
    set uid(E) {
      this._uid = E, this.ctime = /* @__PURE__ */ new Date();
    }
    get uid() {
      return this._uid;
    }
    set gid(E) {
      this._gid = E, this.ctime = /* @__PURE__ */ new Date();
    }
    get gid() {
      return this._gid;
    }
    set atime(E) {
      this._atime = E, this.ctime = /* @__PURE__ */ new Date();
    }
    get atime() {
      return this._atime;
    }
    set mtime(E) {
      this._mtime = E, this.ctime = /* @__PURE__ */ new Date();
    }
    get mtime() {
      return this._mtime;
    }
    set perm(E) {
      this._perm = E, this.ctime = /* @__PURE__ */ new Date();
    }
    get perm() {
      return this._perm;
    }
    set nlink(E) {
      this._nlink = E, this.ctime = /* @__PURE__ */ new Date();
    }
    get nlink() {
      return this._nlink;
    }
    getString(E = "utf8") {
      return this.atime = /* @__PURE__ */ new Date(), this.getBuffer().toString(E);
    }
    setString(E) {
      this.buf = (0, n.bufferFrom)(E, "utf8"), this.touch();
    }
    getBuffer() {
      return this.atime = /* @__PURE__ */ new Date(), this.buf || this.setBuffer((0, n.bufferAllocUnsafe)(0)), (0, n.bufferFrom)(this.buf);
    }
    setBuffer(E) {
      this.buf = (0, n.bufferFrom)(E), this.touch();
    }
    getSize() {
      return this.buf ? this.buf.length : 0;
    }
    setModeProperty(E) {
      this.mode = this.mode & ~r | E;
    }
    setIsFile() {
      this.setModeProperty(i);
    }
    setIsDirectory() {
      this.setModeProperty(l);
    }
    setIsSymlink() {
      this.setModeProperty(f);
    }
    isFile() {
      return (this.mode & r) === i;
    }
    isDirectory() {
      return (this.mode & r) === l;
    }
    isSymlink() {
      return (this.mode & r) === f;
    }
    makeSymlink(E) {
      this.symlink = E, this.setIsSymlink();
    }
    write(E, S = 0, g = E.length, P = 0) {
      if (this.buf || (this.buf = (0, n.bufferAllocUnsafe)(0)), P + g > this.buf.length) {
        const R = (0, n.bufferAllocUnsafe)(P + g);
        this.buf.copy(R, 0, 0, this.buf.length), this.buf = R;
      }
      return E.copy(this.buf, P, S, S + g), this.touch(), g;
    }
    // Returns the number of bytes read.
    read(E, S = 0, g = E.byteLength, P = 0) {
      this.atime = /* @__PURE__ */ new Date(), this.buf || (this.buf = (0, n.bufferAllocUnsafe)(0));
      let R = g;
      R > E.byteLength && (R = E.byteLength), R + P > this.buf.length && (R = this.buf.length - P);
      const N = E instanceof Ve.Buffer ? E : Ve.Buffer.from(E.buffer);
      return this.buf.copy(N, S, P, P + R), R;
    }
    truncate(E = 0) {
      if (!E)
        this.buf = (0, n.bufferAllocUnsafe)(0);
      else if (this.buf || (this.buf = (0, n.bufferAllocUnsafe)(0)), E <= this.buf.length)
        this.buf = this.buf.slice(0, E);
      else {
        const S = (0, n.bufferAllocUnsafe)(E);
        this.buf.copy(S), S.fill(0, this.buf.length), this.buf = S;
      }
      this.touch();
    }
    chmod(E) {
      this.perm = E, this.mode = this.mode & -512 | E, this.touch();
    }
    chown(E, S) {
      this.uid = E, this.gid = S, this.touch();
    }
    touch() {
      this.mtime = /* @__PURE__ */ new Date(), this.emit("change", this);
    }
    canRead(E = s(), S = o()) {
      return !!(this.perm & 4 || S === this.gid && this.perm & 32 || E === this.uid && this.perm & 256);
    }
    canWrite(E = s(), S = o()) {
      return !!(this.perm & 2 || S === this.gid && this.perm & 16 || E === this.uid && this.perm & 128);
    }
    del() {
      this.emit("delete", this);
    }
    toJSON() {
      return {
        ino: this.ino,
        uid: this.uid,
        gid: this.gid,
        atime: this.atime.getTime(),
        mtime: this.mtime.getTime(),
        ctime: this.ctime.getTime(),
        perm: this.perm,
        mode: this.mode,
        nlink: this.nlink,
        symlink: this.symlink,
        data: this.getString()
      };
    }
  }
  t.Node = m;
  class h extends c.EventEmitter {
    get steps() {
      return this._steps;
    }
    // Recursively sync children steps, e.g. in case of dir rename
    set steps(E) {
      this._steps = E;
      for (const [S, g] of this.children.entries())
        S === "." || S === ".." || g == null || g.syncSteps();
    }
    constructor(E, S, g) {
      super(), this.children = /* @__PURE__ */ new Map(), this._steps = [], this.ino = 0, this.length = 0, this.vol = E, this.parent = S, this.name = g, this.syncSteps();
    }
    setNode(E) {
      this.node = E, this.ino = E.ino;
    }
    getNode() {
      return this.node;
    }
    createChild(E, S = this.vol.createNode()) {
      const g = new h(this.vol, this, E);
      return g.setNode(S), S.isDirectory() && (g.children.set(".", g), g.getNode().nlink++), this.setChild(E, g), g;
    }
    setChild(E, S = new h(this.vol, this, E)) {
      return this.children.set(E, S), S.parent = this, this.length++, S.getNode().isDirectory() && (S.children.set("..", this), this.getNode().nlink++), this.getNode().mtime = /* @__PURE__ */ new Date(), this.emit("child:add", S, this), S;
    }
    deleteChild(E) {
      E.getNode().isDirectory() && (E.children.delete(".."), this.getNode().nlink--), this.children.delete(E.getName()), this.length--, this.getNode().mtime = /* @__PURE__ */ new Date(), this.emit("child:delete", E, this);
    }
    getChild(E) {
      return this.getNode().mtime = /* @__PURE__ */ new Date(), this.children.get(E);
    }
    getPath() {
      return this.steps.join(t.SEP);
    }
    getName() {
      return this.steps[this.steps.length - 1];
    }
    // del() {
    //     const parent = this.parent;
    //     if(parent) {
    //         parent.deleteChild(link);
    //     }
    //     this.parent = null;
    //     this.vol = null;
    // }
    /**
     * Walk the tree path and return the `Link` at that location, if any.
     * @param steps {string[]} Desired location.
     * @param stop {number} Max steps to go into.
     * @param i {number} Current step in the `steps` array.
     *
     * @return {Link|null}
     */
    walk(E, S = E.length, g = 0) {
      if (g >= E.length)
        return this;
      if (g >= S)
        return this;
      const P = E[g], R = this.getChild(P);
      return R ? R.walk(E, S, g + 1) : null;
    }
    toJSON() {
      return {
        steps: this.steps,
        ino: this.ino,
        children: Array.from(this.children.keys())
      };
    }
    syncSteps() {
      this.steps = this.parent ? this.parent.steps.concat([this.name]) : [this.name];
    }
  }
  t.Link = h;
  class y {
    /**
     * Open a Link-Node pair. `node` is provided separately as that might be a different node
     * rather the one `link` points to, because it might be a symlink.
     * @param link
     * @param node
     * @param flags
     * @param fd
     */
    constructor(E, S, g, P) {
      this.link = E, this.node = S, this.flags = g, this.fd = P, this.position = 0, this.flags & d && (this.position = this.getSize());
    }
    getString(E = "utf8") {
      return this.node.getString();
    }
    setString(E) {
      this.node.setString(E);
    }
    getBuffer() {
      return this.node.getBuffer();
    }
    setBuffer(E) {
      this.node.setBuffer(E);
    }
    getSize() {
      return this.node.getSize();
    }
    truncate(E) {
      this.node.truncate(E);
    }
    seekTo(E) {
      this.position = E;
    }
    stats() {
      return u.default.build(this.node);
    }
    write(E, S = 0, g = E.length, P) {
      typeof P != "number" && (P = this.position);
      const R = this.node.write(E, S, g, P);
      return this.position = P + R, R;
    }
    read(E, S = 0, g = E.byteLength, P) {
      typeof P != "number" && (P = this.position);
      const R = this.node.read(E, S, g, P);
      return this.position = P + R, R;
    }
    chmod(E) {
      this.node.chmod(E);
    }
    chown(E, S) {
      this.node.chown(E, S);
    }
  }
  t.File = y;
})(vw);
var j0 = {};
Object.defineProperty(j0, "__esModule", { value: !0 });
let qm;
typeof setImmediate == "function" ? qm = setImmediate.bind(typeof globalThis < "u" ? globalThis : Bt) : qm = setTimeout.bind(typeof globalThis < "u" ? globalThis : Bt);
j0.default = qm;
var pd = {};
Object.defineProperty(pd, "__esModule", { value: !0 });
pd.default = typeof queueMicrotask == "function" ? queueMicrotask : (t) => Promise.resolve().then(() => t()).catch(() => {
});
var F0 = {};
Object.defineProperty(F0, "__esModule", { value: !0 });
function _3(t, e, n) {
  const a = setTimeout.apply(typeof globalThis < "u" ? globalThis : Bt, arguments);
  return a && typeof a == "object" && typeof a.unref == "function" && a.unref(), a;
}
F0.default = _3;
const S3 = {}, w3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: S3
}, Symbol.toStringTag, { value: "Module" })), xr = /* @__PURE__ */ GS(w3);
var hd = {}, Au = {}, oa = {};
Object.defineProperty(oa, "__esModule", { value: !0 });
oa.FLAGS = oa.ERRSTR = void 0;
const T3 = Es;
oa.ERRSTR = {
  PATH_STR: "path must be a string or Buffer",
  // FD:             'file descriptor must be a unsigned 32-bit integer',
  FD: "fd must be a file descriptor",
  MODE_INT: "mode must be an int",
  CB: "callback must be a function",
  UID: "uid must be an unsigned int",
  GID: "gid must be an unsigned int",
  LEN: "len must be an integer",
  ATIME: "atime must be an integer",
  MTIME: "mtime must be an integer",
  PREFIX: "filename prefix is required",
  BUFFER: "buffer must be an instance of Buffer or StaticBuffer",
  OFFSET: "offset must be an integer",
  LENGTH: "length must be an integer",
  POSITION: "position must be an integer"
};
const { O_RDONLY: fv, O_WRONLY: gc, O_RDWR: lo, O_CREAT: zs, O_EXCL: vc, O_TRUNC: Ec, O_APPEND: _c, O_SYNC: dv } = T3.constants;
var pv;
(function(t) {
  t[t.r = fv] = "r", t[t["r+"] = lo] = "r+", t[t.rs = fv | dv] = "rs", t[t.sr = t.rs] = "sr", t[t["rs+"] = lo | dv] = "rs+", t[t["sr+"] = t["rs+"]] = "sr+", t[t.w = gc | zs | Ec] = "w", t[t.wx = gc | zs | Ec | vc] = "wx", t[t.xw = t.wx] = "xw", t[t["w+"] = lo | zs | Ec] = "w+", t[t["wx+"] = lo | zs | Ec | vc] = "wx+", t[t["xw+"] = t["wx+"]] = "xw+", t[t.a = gc | _c | zs] = "a", t[t.ax = gc | _c | zs | vc] = "ax", t[t.xa = t.ax] = "xa", t[t["a+"] = lo | _c | zs] = "a+", t[t["ax+"] = lo | _c | zs | vc] = "ax+", t[t["xa+"] = t["ax+"]] = "xa+";
})(pv || (oa.FLAGS = pv = {}));
var ds = {}, xf = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
xf.exports;
(function(t, e) {
  (function(n) {
    var a = e && !e.nodeType && e, c = t && !t.nodeType && t, u = typeof Bt == "object" && Bt;
    (u.global === u || u.window === u || u.self === u) && (n = u);
    var r, l = 2147483647, i = 36, f = 1, d = 26, s = 38, o = 700, m = 72, h = 128, y = "-", b = /^xn--/, E = /[^\x20-\x7E]/, S = /[\x2E\u3002\uFF0E\uFF61]/g, g = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, P = i - f, R = Math.floor, N = String.fromCharCode, C;
    function I(M) {
      throw new RangeError(g[M]);
    }
    function D(M, B) {
      for (var k = M.length, K = []; k--; )
        K[k] = B(M[k]);
      return K;
    }
    function j(M, B) {
      var k = M.split("@"), K = "";
      k.length > 1 && (K = k[0] + "@", M = k[1]), M = M.replace(S, ".");
      var te = M.split("."), z = D(te, B).join(".");
      return K + z;
    }
    function F(M) {
      for (var B = [], k = 0, K = M.length, te, z; k < K; )
        te = M.charCodeAt(k++), te >= 55296 && te <= 56319 && k < K ? (z = M.charCodeAt(k++), (z & 64512) == 56320 ? B.push(((te & 1023) << 10) + (z & 1023) + 65536) : (B.push(te), k--)) : B.push(te);
      return B;
    }
    function _(M) {
      return D(M, function(B) {
        var k = "";
        return B > 65535 && (B -= 65536, k += N(B >>> 10 & 1023 | 55296), B = 56320 | B & 1023), k += N(B), k;
      }).join("");
    }
    function T(M) {
      return M - 48 < 10 ? M - 22 : M - 65 < 26 ? M - 65 : M - 97 < 26 ? M - 97 : i;
    }
    function v(M, B) {
      return M + 22 + 75 * (M < 26) - ((B != 0) << 5);
    }
    function w(M, B, k) {
      var K = 0;
      for (M = k ? R(M / o) : M >> 1, M += R(M / B); M > P * d >> 1; K += i)
        M = R(M / P);
      return R(K + (P + 1) * M / (M + s));
    }
    function O(M) {
      var B = [], k = M.length, K, te = 0, z = h, q = m, $, Y, H, Q, X, ne, ye, ve, de;
      for ($ = M.lastIndexOf(y), $ < 0 && ($ = 0), Y = 0; Y < $; ++Y)
        M.charCodeAt(Y) >= 128 && I("not-basic"), B.push(M.charCodeAt(Y));
      for (H = $ > 0 ? $ + 1 : 0; H < k; ) {
        for (Q = te, X = 1, ne = i; H >= k && I("invalid-input"), ye = T(M.charCodeAt(H++)), (ye >= i || ye > R((l - te) / X)) && I("overflow"), te += ye * X, ve = ne <= q ? f : ne >= q + d ? d : ne - q, !(ye < ve); ne += i)
          de = i - ve, X > R(l / de) && I("overflow"), X *= de;
        K = B.length + 1, q = w(te - Q, K, Q == 0), R(te / K) > l - z && I("overflow"), z += R(te / K), te %= K, B.splice(te++, 0, z);
      }
      return _(B);
    }
    function G(M) {
      var B, k, K, te, z, q, $, Y, H, Q, X, ne = [], ye, ve, de, oe;
      for (M = F(M), ye = M.length, B = h, k = 0, z = m, q = 0; q < ye; ++q)
        X = M[q], X < 128 && ne.push(N(X));
      for (K = te = ne.length, te && ne.push(y); K < ye; ) {
        for ($ = l, q = 0; q < ye; ++q)
          X = M[q], X >= B && X < $ && ($ = X);
        for (ve = K + 1, $ - B > R((l - k) / ve) && I("overflow"), k += ($ - B) * ve, B = $, q = 0; q < ye; ++q)
          if (X = M[q], X < B && ++k > l && I("overflow"), X == B) {
            for (Y = k, H = i; Q = H <= z ? f : H >= z + d ? d : H - z, !(Y < Q); H += i)
              oe = Y - Q, de = i - Q, ne.push(
                N(v(Q + oe % de, 0))
              ), Y = R(oe / de);
            ne.push(N(v(Y, 0))), z = w(k, ve, K == te), k = 0, ++K;
          }
        ++k, ++B;
      }
      return ne.join("");
    }
    function W(M) {
      return j(M, function(B) {
        return b.test(B) ? O(B.slice(4).toLowerCase()) : B;
      });
    }
    function U(M) {
      return j(M, function(B) {
        return E.test(B) ? "xn--" + G(B) : B;
      });
    }
    if (r = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "1.4.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: F,
        encode: _
      },
      decode: O,
      encode: G,
      toASCII: U,
      toUnicode: W
    }, a && c)
      if (t.exports == a)
        c.exports = r;
      else
        for (C in r)
          r.hasOwnProperty(C) && (a[C] = r[C]);
    else
      n.punycode = r;
  })(Bt);
})(xf, xf.exports);
var A3 = xf.exports, B0 = typeof Map == "function" && Map.prototype, hh = Object.getOwnPropertyDescriptor && B0 ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, Pf = B0 && hh && typeof hh.get == "function" ? hh.get : null, hv = B0 && Map.prototype.forEach, $0 = typeof Set == "function" && Set.prototype, mh = Object.getOwnPropertyDescriptor && $0 ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, Cf = $0 && mh && typeof mh.get == "function" ? mh.get : null, mv = $0 && Set.prototype.forEach, x3 = typeof WeakMap == "function" && WeakMap.prototype, zl = x3 ? WeakMap.prototype.has : null, P3 = typeof WeakSet == "function" && WeakSet.prototype, Kl = P3 ? WeakSet.prototype.has : null, C3 = typeof WeakRef == "function" && WeakRef.prototype, yv = C3 ? WeakRef.prototype.deref : null, I3 = Boolean.prototype.valueOf, O3 = Object.prototype.toString, k3 = Function.prototype.toString, D3 = String.prototype.match, U0 = String.prototype.slice, Qs = String.prototype.replace, N3 = String.prototype.toUpperCase, bv = String.prototype.toLowerCase, Iw = RegExp.prototype.test, gv = Array.prototype.concat, ns = Array.prototype.join, R3 = Array.prototype.slice, vv = Math.floor, Gm = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, yh = Object.getOwnPropertySymbols, zm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, No = typeof Symbol == "function" && typeof Symbol.iterator == "object", In = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === No || "symbol") ? Symbol.toStringTag : null, Ow = Object.prototype.propertyIsEnumerable, Ev = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(t) {
  return t.__proto__;
} : null);
function _v(t, e) {
  if (t === 1 / 0 || t === -1 / 0 || t !== t || t && t > -1e3 && t < 1e3 || Iw.call(/e/, e))
    return e;
  var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof t == "number") {
    var a = t < 0 ? -vv(-t) : vv(t);
    if (a !== t) {
      var c = String(a), u = U0.call(e, c.length + 1);
      return Qs.call(c, n, "$&_") + "." + Qs.call(Qs.call(u, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return Qs.call(e, n, "$&_");
}
var Km = xr, Sv = Km.custom, wv = Dw(Sv) ? Sv : null, M3 = function t(e, n, a, c) {
  var u = n || {};
  if (Xs(u, "quoteStyle") && u.quoteStyle !== "single" && u.quoteStyle !== "double")
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  if (Xs(u, "maxStringLength") && (typeof u.maxStringLength == "number" ? u.maxStringLength < 0 && u.maxStringLength !== 1 / 0 : u.maxStringLength !== null))
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  var r = Xs(u, "customInspect") ? u.customInspect : !0;
  if (typeof r != "boolean" && r !== "symbol")
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  if (Xs(u, "indent") && u.indent !== null && u.indent !== "	" && !(parseInt(u.indent, 10) === u.indent && u.indent > 0))
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  if (Xs(u, "numericSeparator") && typeof u.numericSeparator != "boolean")
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  var l = u.numericSeparator;
  if (typeof e > "u")
    return "undefined";
  if (e === null)
    return "null";
  if (typeof e == "boolean")
    return e ? "true" : "false";
  if (typeof e == "string")
    return Rw(e, u);
  if (typeof e == "number") {
    if (e === 0)
      return 1 / 0 / e > 0 ? "0" : "-0";
    var i = String(e);
    return l ? _v(e, i) : i;
  }
  if (typeof e == "bigint") {
    var f = String(e) + "n";
    return l ? _v(e, f) : f;
  }
  var d = typeof u.depth > "u" ? 5 : u.depth;
  if (typeof a > "u" && (a = 0), a >= d && d > 0 && typeof e == "object")
    return Ym(e) ? "[Array]" : "[Object]";
  var s = Z3(u, a);
  if (typeof c > "u")
    c = [];
  else if (Nw(c, e) >= 0)
    return "[Circular]";
  function o(T, v, w) {
    if (v && (c = R3.call(c), c.push(v)), w) {
      var O = {
        depth: u.depth
      };
      return Xs(u, "quoteStyle") && (O.quoteStyle = u.quoteStyle), t(T, O, a + 1, c);
    }
    return t(T, u, a + 1, c);
  }
  if (typeof e == "function" && !Tv(e)) {
    var m = H3(e), h = Sc(e, o);
    return "[Function" + (m ? ": " + m : " (anonymous)") + "]" + (h.length > 0 ? " { " + ns.call(h, ", ") + " }" : "");
  }
  if (Dw(e)) {
    var y = No ? Qs.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : zm.call(e);
    return typeof e == "object" && !No ? Tl(y) : y;
  }
  if (X3(e)) {
    for (var b = "<" + bv.call(String(e.nodeName)), E = e.attributes || [], S = 0; S < E.length; S++)
      b += " " + E[S].name + "=" + kw(L3(E[S].value), "double", u);
    return b += ">", e.childNodes && e.childNodes.length && (b += "..."), b += "</" + bv.call(String(e.nodeName)) + ">", b;
  }
  if (Ym(e)) {
    if (e.length === 0)
      return "[]";
    var g = Sc(e, o);
    return s && !Q3(g) ? "[" + Xm(g, s) + "]" : "[ " + ns.call(g, ", ") + " ]";
  }
  if (F3(e)) {
    var P = Sc(e, o);
    return !("cause" in Error.prototype) && "cause" in e && !Ow.call(e, "cause") ? "{ [" + String(e) + "] " + ns.call(gv.call("[cause]: " + o(e.cause), P), ", ") + " }" : P.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + ns.call(P, ", ") + " }";
  }
  if (typeof e == "object" && r) {
    if (wv && typeof e[wv] == "function" && Km)
      return Km(e, { depth: d - a });
    if (r !== "symbol" && typeof e.inspect == "function")
      return e.inspect();
  }
  if (q3(e)) {
    var R = [];
    return hv && hv.call(e, function(T, v) {
      R.push(o(v, e, !0) + " => " + o(T, e));
    }), Av("Map", Pf.call(e), R, s);
  }
  if (K3(e)) {
    var N = [];
    return mv && mv.call(e, function(T) {
      N.push(o(T, e));
    }), Av("Set", Cf.call(e), N, s);
  }
  if (G3(e))
    return bh("WeakMap");
  if (Y3(e))
    return bh("WeakSet");
  if (z3(e))
    return bh("WeakRef");
  if ($3(e))
    return Tl(o(Number(e)));
  if (V3(e))
    return Tl(o(Gm.call(e)));
  if (U3(e))
    return Tl(I3.call(e));
  if (B3(e))
    return Tl(o(String(e)));
  if (!j3(e) && !Tv(e)) {
    var C = Sc(e, o), I = Ev ? Ev(e) === Object.prototype : e instanceof Object || e.constructor === Object, D = e instanceof Object ? "" : "null prototype", j = !I && In && Object(e) === e && In in e ? U0.call(da(e), 8, -1) : D ? "Object" : "", F = I || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "", _ = F + (j || D ? "[" + ns.call(gv.call([], j || [], D || []), ": ") + "] " : "");
    return C.length === 0 ? _ + "{}" : s ? _ + "{" + Xm(C, s) + "}" : _ + "{ " + ns.call(C, ", ") + " }";
  }
  return String(e);
};
function kw(t, e, n) {
  var a = (n.quoteStyle || e) === "double" ? '"' : "'";
  return a + t + a;
}
function L3(t) {
  return Qs.call(String(t), /"/g, "&quot;");
}
function Ym(t) {
  return da(t) === "[object Array]" && (!In || !(typeof t == "object" && In in t));
}
function j3(t) {
  return da(t) === "[object Date]" && (!In || !(typeof t == "object" && In in t));
}
function Tv(t) {
  return da(t) === "[object RegExp]" && (!In || !(typeof t == "object" && In in t));
}
function F3(t) {
  return da(t) === "[object Error]" && (!In || !(typeof t == "object" && In in t));
}
function B3(t) {
  return da(t) === "[object String]" && (!In || !(typeof t == "object" && In in t));
}
function $3(t) {
  return da(t) === "[object Number]" && (!In || !(typeof t == "object" && In in t));
}
function U3(t) {
  return da(t) === "[object Boolean]" && (!In || !(typeof t == "object" && In in t));
}
function Dw(t) {
  if (No)
    return t && typeof t == "object" && t instanceof Symbol;
  if (typeof t == "symbol")
    return !0;
  if (!t || typeof t != "object" || !zm)
    return !1;
  try {
    return zm.call(t), !0;
  } catch {
  }
  return !1;
}
function V3(t) {
  if (!t || typeof t != "object" || !Gm)
    return !1;
  try {
    return Gm.call(t), !0;
  } catch {
  }
  return !1;
}
var W3 = Object.prototype.hasOwnProperty || function(t) {
  return t in this;
};
function Xs(t, e) {
  return W3.call(t, e);
}
function da(t) {
  return O3.call(t);
}
function H3(t) {
  if (t.name)
    return t.name;
  var e = D3.call(k3.call(t), /^function\s*([\w$]+)/);
  return e ? e[1] : null;
}
function Nw(t, e) {
  if (t.indexOf)
    return t.indexOf(e);
  for (var n = 0, a = t.length; n < a; n++)
    if (t[n] === e)
      return n;
  return -1;
}
function q3(t) {
  if (!Pf || !t || typeof t != "object")
    return !1;
  try {
    Pf.call(t);
    try {
      Cf.call(t);
    } catch {
      return !0;
    }
    return t instanceof Map;
  } catch {
  }
  return !1;
}
function G3(t) {
  if (!zl || !t || typeof t != "object")
    return !1;
  try {
    zl.call(t, zl);
    try {
      Kl.call(t, Kl);
    } catch {
      return !0;
    }
    return t instanceof WeakMap;
  } catch {
  }
  return !1;
}
function z3(t) {
  if (!yv || !t || typeof t != "object")
    return !1;
  try {
    return yv.call(t), !0;
  } catch {
  }
  return !1;
}
function K3(t) {
  if (!Cf || !t || typeof t != "object")
    return !1;
  try {
    Cf.call(t);
    try {
      Pf.call(t);
    } catch {
      return !0;
    }
    return t instanceof Set;
  } catch {
  }
  return !1;
}
function Y3(t) {
  if (!Kl || !t || typeof t != "object")
    return !1;
  try {
    Kl.call(t, Kl);
    try {
      zl.call(t, zl);
    } catch {
      return !0;
    }
    return t instanceof WeakSet;
  } catch {
  }
  return !1;
}
function X3(t) {
  return !t || typeof t != "object" ? !1 : typeof HTMLElement < "u" && t instanceof HTMLElement ? !0 : typeof t.nodeName == "string" && typeof t.getAttribute == "function";
}
function Rw(t, e) {
  if (t.length > e.maxStringLength) {
    var n = t.length - e.maxStringLength, a = "... " + n + " more character" + (n > 1 ? "s" : "");
    return Rw(U0.call(t, 0, e.maxStringLength), e) + a;
  }
  var c = Qs.call(Qs.call(t, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, J3);
  return kw(c, "single", e);
}
function J3(t) {
  var e = t.charCodeAt(0), n = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[e];
  return n ? "\\" + n : "\\x" + (e < 16 ? "0" : "") + N3.call(e.toString(16));
}
function Tl(t) {
  return "Object(" + t + ")";
}
function bh(t) {
  return t + " { ? }";
}
function Av(t, e, n, a) {
  var c = a ? Xm(n, a) : ns.call(n, ", ");
  return t + " (" + e + ") {" + c + "}";
}
function Q3(t) {
  for (var e = 0; e < t.length; e++)
    if (Nw(t[e], `
`) >= 0)
      return !1;
  return !0;
}
function Z3(t, e) {
  var n;
  if (t.indent === "	")
    n = "	";
  else if (typeof t.indent == "number" && t.indent > 0)
    n = ns.call(Array(t.indent + 1), " ");
  else
    return null;
  return {
    base: n,
    prev: ns.call(Array(e + 1), n)
  };
}
function Xm(t, e) {
  if (t.length === 0)
    return "";
  var n = `
` + e.prev + e.base;
  return n + ns.call(t, "," + n) + `
` + e.prev;
}
function Sc(t, e) {
  var n = Ym(t), a = [];
  if (n) {
    a.length = t.length;
    for (var c = 0; c < t.length; c++)
      a[c] = Xs(t, c) ? e(t[c], t) : "";
  }
  var u = typeof yh == "function" ? yh(t) : [], r;
  if (No) {
    r = {};
    for (var l = 0; l < u.length; l++)
      r["$" + u[l]] = u[l];
  }
  for (var i in t)
    Xs(t, i) && (n && String(Number(i)) === i && i < t.length || No && r["$" + i] instanceof Symbol || (Iw.call(/[^\w$]/, i) ? a.push(e(i, t) + ": " + e(t[i], t)) : a.push(i + ": " + e(t[i], t))));
  if (typeof yh == "function")
    for (var f = 0; f < u.length; f++)
      Ow.call(t, u[f]) && a.push("[" + e(u[f]) + "]: " + e(t[u[f]], t));
  return a;
}
var V0 = Qo, el = wu, eD = M3, tD = V0("%TypeError%"), wc = V0("%WeakMap%", !0), Tc = V0("%Map%", !0), rD = el("WeakMap.prototype.get", !0), nD = el("WeakMap.prototype.set", !0), iD = el("WeakMap.prototype.has", !0), sD = el("Map.prototype.get", !0), aD = el("Map.prototype.set", !0), oD = el("Map.prototype.has", !0), W0 = function(t, e) {
  for (var n = t, a; (a = n.next) !== null; n = a)
    if (a.key === e)
      return n.next = a.next, a.next = t.next, t.next = a, a;
}, lD = function(t, e) {
  var n = W0(t, e);
  return n && n.value;
}, uD = function(t, e, n) {
  var a = W0(t, e);
  a ? a.value = n : t.next = {
    // eslint-disable-line no-param-reassign
    key: e,
    next: t.next,
    value: n
  };
}, cD = function(t, e) {
  return !!W0(t, e);
}, fD = function() {
  var e, n, a, c = {
    assert: function(u) {
      if (!c.has(u))
        throw new tD("Side channel does not contain " + eD(u));
    },
    get: function(u) {
      if (wc && u && (typeof u == "object" || typeof u == "function")) {
        if (e)
          return rD(e, u);
      } else if (Tc) {
        if (n)
          return sD(n, u);
      } else if (a)
        return lD(a, u);
    },
    has: function(u) {
      if (wc && u && (typeof u == "object" || typeof u == "function")) {
        if (e)
          return iD(e, u);
      } else if (Tc) {
        if (n)
          return oD(n, u);
      } else if (a)
        return cD(a, u);
      return !1;
    },
    set: function(u, r) {
      wc && u && (typeof u == "object" || typeof u == "function") ? (e || (e = new wc()), nD(e, u, r)) : Tc ? (n || (n = new Tc()), aD(n, u, r)) : (a || (a = { key: {}, next: null }), uD(a, u, r));
    }
  };
  return c;
}, dD = String.prototype.replace, pD = /%20/g, gh = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
}, H0 = {
  default: gh.RFC3986,
  formatters: {
    RFC1738: function(t) {
      return dD.call(t, pD, "+");
    },
    RFC3986: function(t) {
      return String(t);
    }
  },
  RFC1738: gh.RFC1738,
  RFC3986: gh.RFC3986
}, hD = H0, vh = Object.prototype.hasOwnProperty, Ca = Array.isArray, Qi = function() {
  for (var t = [], e = 0; e < 256; ++e)
    t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
  return t;
}(), mD = function(e) {
  for (; e.length > 1; ) {
    var n = e.pop(), a = n.obj[n.prop];
    if (Ca(a)) {
      for (var c = [], u = 0; u < a.length; ++u)
        typeof a[u] < "u" && c.push(a[u]);
      n.obj[n.prop] = c;
    }
  }
}, Mw = function(e, n) {
  for (var a = n && n.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, c = 0; c < e.length; ++c)
    typeof e[c] < "u" && (a[c] = e[c]);
  return a;
}, yD = function t(e, n, a) {
  if (!n)
    return e;
  if (typeof n != "object") {
    if (Ca(e))
      e.push(n);
    else if (e && typeof e == "object")
      (a && (a.plainObjects || a.allowPrototypes) || !vh.call(Object.prototype, n)) && (e[n] = !0);
    else
      return [e, n];
    return e;
  }
  if (!e || typeof e != "object")
    return [e].concat(n);
  var c = e;
  return Ca(e) && !Ca(n) && (c = Mw(e, a)), Ca(e) && Ca(n) ? (n.forEach(function(u, r) {
    if (vh.call(e, r)) {
      var l = e[r];
      l && typeof l == "object" && u && typeof u == "object" ? e[r] = t(l, u, a) : e.push(u);
    } else
      e[r] = u;
  }), e) : Object.keys(n).reduce(function(u, r) {
    var l = n[r];
    return vh.call(u, r) ? u[r] = t(u[r], l, a) : u[r] = l, u;
  }, c);
}, bD = function(e, n) {
  return Object.keys(n).reduce(function(a, c) {
    return a[c] = n[c], a;
  }, e);
}, gD = function(t, e, n) {
  var a = t.replace(/\+/g, " ");
  if (n === "iso-8859-1")
    return a.replace(/%[0-9a-f]{2}/gi, unescape);
  try {
    return decodeURIComponent(a);
  } catch {
    return a;
  }
}, vD = function(e, n, a, c, u) {
  if (e.length === 0)
    return e;
  var r = e;
  if (typeof e == "symbol" ? r = Symbol.prototype.toString.call(e) : typeof e != "string" && (r = String(e)), a === "iso-8859-1")
    return escape(r).replace(/%u[0-9a-f]{4}/gi, function(d) {
      return "%26%23" + parseInt(d.slice(2), 16) + "%3B";
    });
  for (var l = "", i = 0; i < r.length; ++i) {
    var f = r.charCodeAt(i);
    if (f === 45 || f === 46 || f === 95 || f === 126 || f >= 48 && f <= 57 || f >= 65 && f <= 90 || f >= 97 && f <= 122 || u === hD.RFC1738 && (f === 40 || f === 41)) {
      l += r.charAt(i);
      continue;
    }
    if (f < 128) {
      l = l + Qi[f];
      continue;
    }
    if (f < 2048) {
      l = l + (Qi[192 | f >> 6] + Qi[128 | f & 63]);
      continue;
    }
    if (f < 55296 || f >= 57344) {
      l = l + (Qi[224 | f >> 12] + Qi[128 | f >> 6 & 63] + Qi[128 | f & 63]);
      continue;
    }
    i += 1, f = 65536 + ((f & 1023) << 10 | r.charCodeAt(i) & 1023), l += Qi[240 | f >> 18] + Qi[128 | f >> 12 & 63] + Qi[128 | f >> 6 & 63] + Qi[128 | f & 63];
  }
  return l;
}, ED = function(e) {
  for (var n = [{ obj: { o: e }, prop: "o" }], a = [], c = 0; c < n.length; ++c)
    for (var u = n[c], r = u.obj[u.prop], l = Object.keys(r), i = 0; i < l.length; ++i) {
      var f = l[i], d = r[f];
      typeof d == "object" && d !== null && a.indexOf(d) === -1 && (n.push({ obj: r, prop: f }), a.push(d));
    }
  return mD(n), e;
}, _D = function(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}, SD = function(e) {
  return !e || typeof e != "object" ? !1 : !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e));
}, wD = function(e, n) {
  return [].concat(e, n);
}, TD = function(e, n) {
  if (Ca(e)) {
    for (var a = [], c = 0; c < e.length; c += 1)
      a.push(n(e[c]));
    return a;
  }
  return n(e);
}, Lw = {
  arrayToObject: Mw,
  assign: bD,
  combine: wD,
  compact: ED,
  decode: gD,
  encode: vD,
  isBuffer: SD,
  isRegExp: _D,
  maybeMap: TD,
  merge: yD
}, jw = fD, nf = Lw, Yl = H0, AD = Object.prototype.hasOwnProperty, xv = {
  brackets: function(e) {
    return e + "[]";
  },
  comma: "comma",
  indices: function(e, n) {
    return e + "[" + n + "]";
  },
  repeat: function(e) {
    return e;
  }
}, Os = Array.isArray, xD = Array.prototype.push, Fw = function(t, e) {
  xD.apply(t, Os(e) ? e : [e]);
}, PD = Date.prototype.toISOString, Pv = Yl.default, An = {
  addQueryPrefix: !1,
  allowDots: !1,
  charset: "utf-8",
  charsetSentinel: !1,
  delimiter: "&",
  encode: !0,
  encoder: nf.encode,
  encodeValuesOnly: !1,
  format: Pv,
  formatter: Yl.formatters[Pv],
  // deprecated
  indices: !1,
  serializeDate: function(e) {
    return PD.call(e);
  },
  skipNulls: !1,
  strictNullHandling: !1
}, CD = function(e) {
  return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "symbol" || typeof e == "bigint";
}, Eh = {}, ID = function t(e, n, a, c, u, r, l, i, f, d, s, o, m, h, y, b) {
  for (var E = e, S = b, g = 0, P = !1; (S = S.get(Eh)) !== void 0 && !P; ) {
    var R = S.get(e);
    if (g += 1, typeof R < "u") {
      if (R === g)
        throw new RangeError("Cyclic object value");
      P = !0;
    }
    typeof S.get(Eh) > "u" && (g = 0);
  }
  if (typeof i == "function" ? E = i(n, E) : E instanceof Date ? E = s(E) : a === "comma" && Os(E) && (E = nf.maybeMap(E, function(O) {
    return O instanceof Date ? s(O) : O;
  })), E === null) {
    if (u)
      return l && !h ? l(n, An.encoder, y, "key", o) : n;
    E = "";
  }
  if (CD(E) || nf.isBuffer(E)) {
    if (l) {
      var N = h ? n : l(n, An.encoder, y, "key", o);
      return [m(N) + "=" + m(l(E, An.encoder, y, "value", o))];
    }
    return [m(n) + "=" + m(String(E))];
  }
  var C = [];
  if (typeof E > "u")
    return C;
  var I;
  if (a === "comma" && Os(E))
    h && l && (E = nf.maybeMap(E, l)), I = [{ value: E.length > 0 ? E.join(",") || null : void 0 }];
  else if (Os(i))
    I = i;
  else {
    var D = Object.keys(E);
    I = f ? D.sort(f) : D;
  }
  for (var j = c && Os(E) && E.length === 1 ? n + "[]" : n, F = 0; F < I.length; ++F) {
    var _ = I[F], T = typeof _ == "object" && typeof _.value < "u" ? _.value : E[_];
    if (!(r && T === null)) {
      var v = Os(E) ? typeof a == "function" ? a(j, _) : j : j + (d ? "." + _ : "[" + _ + "]");
      b.set(e, g);
      var w = jw();
      w.set(Eh, b), Fw(C, t(
        T,
        v,
        a,
        c,
        u,
        r,
        a === "comma" && h && Os(E) ? null : l,
        i,
        f,
        d,
        s,
        o,
        m,
        h,
        y,
        w
      ));
    }
  }
  return C;
}, OD = function(e) {
  if (!e)
    return An;
  if (e.encoder !== null && typeof e.encoder < "u" && typeof e.encoder != "function")
    throw new TypeError("Encoder has to be a function.");
  var n = e.charset || An.charset;
  if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var a = Yl.default;
  if (typeof e.format < "u") {
    if (!AD.call(Yl.formatters, e.format))
      throw new TypeError("Unknown format option provided.");
    a = e.format;
  }
  var c = Yl.formatters[a], u = An.filter;
  return (typeof e.filter == "function" || Os(e.filter)) && (u = e.filter), {
    addQueryPrefix: typeof e.addQueryPrefix == "boolean" ? e.addQueryPrefix : An.addQueryPrefix,
    allowDots: typeof e.allowDots > "u" ? An.allowDots : !!e.allowDots,
    charset: n,
    charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : An.charsetSentinel,
    delimiter: typeof e.delimiter > "u" ? An.delimiter : e.delimiter,
    encode: typeof e.encode == "boolean" ? e.encode : An.encode,
    encoder: typeof e.encoder == "function" ? e.encoder : An.encoder,
    encodeValuesOnly: typeof e.encodeValuesOnly == "boolean" ? e.encodeValuesOnly : An.encodeValuesOnly,
    filter: u,
    format: a,
    formatter: c,
    serializeDate: typeof e.serializeDate == "function" ? e.serializeDate : An.serializeDate,
    skipNulls: typeof e.skipNulls == "boolean" ? e.skipNulls : An.skipNulls,
    sort: typeof e.sort == "function" ? e.sort : null,
    strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : An.strictNullHandling
  };
}, kD = function(t, e) {
  var n = t, a = OD(e), c, u;
  typeof a.filter == "function" ? (u = a.filter, n = u("", n)) : Os(a.filter) && (u = a.filter, c = u);
  var r = [];
  if (typeof n != "object" || n === null)
    return "";
  var l;
  e && e.arrayFormat in xv ? l = e.arrayFormat : e && "indices" in e ? l = e.indices ? "indices" : "repeat" : l = "indices";
  var i = xv[l];
  if (e && "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean")
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  var f = i === "comma" && e && e.commaRoundTrip;
  c || (c = Object.keys(n)), a.sort && c.sort(a.sort);
  for (var d = jw(), s = 0; s < c.length; ++s) {
    var o = c[s];
    a.skipNulls && n[o] === null || Fw(r, ID(
      n[o],
      o,
      i,
      f,
      a.strictNullHandling,
      a.skipNulls,
      a.encode ? a.encoder : null,
      a.filter,
      a.sort,
      a.allowDots,
      a.serializeDate,
      a.format,
      a.formatter,
      a.encodeValuesOnly,
      a.charset,
      d
    ));
  }
  var m = r.join(a.delimiter), h = a.addQueryPrefix === !0 ? "?" : "";
  return a.charsetSentinel && (a.charset === "iso-8859-1" ? h += "utf8=%26%2310003%3B&" : h += "utf8=%E2%9C%93&"), m.length > 0 ? h + m : "";
}, Ro = Lw, Jm = Object.prototype.hasOwnProperty, DD = Array.isArray, an = {
  allowDots: !1,
  allowPrototypes: !1,
  allowSparse: !1,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: !1,
  comma: !1,
  decoder: Ro.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: !1,
  interpretNumericEntities: !1,
  parameterLimit: 1e3,
  parseArrays: !0,
  plainObjects: !1,
  strictNullHandling: !1
}, ND = function(t) {
  return t.replace(/&#(\d+);/g, function(e, n) {
    return String.fromCharCode(parseInt(n, 10));
  });
}, Bw = function(t, e) {
  return t && typeof t == "string" && e.comma && t.indexOf(",") > -1 ? t.split(",") : t;
}, RD = "utf8=%26%2310003%3B", MD = "utf8=%E2%9C%93", LD = function(e, n) {
  var a = { __proto__: null }, c = n.ignoreQueryPrefix ? e.replace(/^\?/, "") : e, u = n.parameterLimit === 1 / 0 ? void 0 : n.parameterLimit, r = c.split(n.delimiter, u), l = -1, i, f = n.charset;
  if (n.charsetSentinel)
    for (i = 0; i < r.length; ++i)
      r[i].indexOf("utf8=") === 0 && (r[i] === MD ? f = "utf-8" : r[i] === RD && (f = "iso-8859-1"), l = i, i = r.length);
  for (i = 0; i < r.length; ++i)
    if (i !== l) {
      var d = r[i], s = d.indexOf("]="), o = s === -1 ? d.indexOf("=") : s + 1, m, h;
      o === -1 ? (m = n.decoder(d, an.decoder, f, "key"), h = n.strictNullHandling ? null : "") : (m = n.decoder(d.slice(0, o), an.decoder, f, "key"), h = Ro.maybeMap(
        Bw(d.slice(o + 1), n),
        function(y) {
          return n.decoder(y, an.decoder, f, "value");
        }
      )), h && n.interpretNumericEntities && f === "iso-8859-1" && (h = ND(h)), d.indexOf("[]=") > -1 && (h = DD(h) ? [h] : h), Jm.call(a, m) ? a[m] = Ro.combine(a[m], h) : a[m] = h;
    }
  return a;
}, jD = function(t, e, n, a) {
  for (var c = a ? e : Bw(e, n), u = t.length - 1; u >= 0; --u) {
    var r, l = t[u];
    if (l === "[]" && n.parseArrays)
      r = [].concat(c);
    else {
      r = n.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var i = l.charAt(0) === "[" && l.charAt(l.length - 1) === "]" ? l.slice(1, -1) : l, f = parseInt(i, 10);
      !n.parseArrays && i === "" ? r = { 0: c } : !isNaN(f) && l !== i && String(f) === i && f >= 0 && n.parseArrays && f <= n.arrayLimit ? (r = [], r[f] = c) : i !== "__proto__" && (r[i] = c);
    }
    c = r;
  }
  return c;
}, FD = function(e, n, a, c) {
  if (e) {
    var u = a.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e, r = /(\[[^[\]]*])/, l = /(\[[^[\]]*])/g, i = a.depth > 0 && r.exec(u), f = i ? u.slice(0, i.index) : u, d = [];
    if (f) {
      if (!a.plainObjects && Jm.call(Object.prototype, f) && !a.allowPrototypes)
        return;
      d.push(f);
    }
    for (var s = 0; a.depth > 0 && (i = l.exec(u)) !== null && s < a.depth; ) {
      if (s += 1, !a.plainObjects && Jm.call(Object.prototype, i[1].slice(1, -1)) && !a.allowPrototypes)
        return;
      d.push(i[1]);
    }
    return i && d.push("[" + u.slice(i.index) + "]"), jD(d, n, a, c);
  }
}, BD = function(e) {
  if (!e)
    return an;
  if (e.decoder !== null && e.decoder !== void 0 && typeof e.decoder != "function")
    throw new TypeError("Decoder has to be a function.");
  if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var n = typeof e.charset > "u" ? an.charset : e.charset;
  return {
    allowDots: typeof e.allowDots > "u" ? an.allowDots : !!e.allowDots,
    allowPrototypes: typeof e.allowPrototypes == "boolean" ? e.allowPrototypes : an.allowPrototypes,
    allowSparse: typeof e.allowSparse == "boolean" ? e.allowSparse : an.allowSparse,
    arrayLimit: typeof e.arrayLimit == "number" ? e.arrayLimit : an.arrayLimit,
    charset: n,
    charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : an.charsetSentinel,
    comma: typeof e.comma == "boolean" ? e.comma : an.comma,
    decoder: typeof e.decoder == "function" ? e.decoder : an.decoder,
    delimiter: typeof e.delimiter == "string" || Ro.isRegExp(e.delimiter) ? e.delimiter : an.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof e.depth == "number" || e.depth === !1 ? +e.depth : an.depth,
    ignoreQueryPrefix: e.ignoreQueryPrefix === !0,
    interpretNumericEntities: typeof e.interpretNumericEntities == "boolean" ? e.interpretNumericEntities : an.interpretNumericEntities,
    parameterLimit: typeof e.parameterLimit == "number" ? e.parameterLimit : an.parameterLimit,
    parseArrays: e.parseArrays !== !1,
    plainObjects: typeof e.plainObjects == "boolean" ? e.plainObjects : an.plainObjects,
    strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : an.strictNullHandling
  };
}, $D = function(t, e) {
  var n = BD(e);
  if (t === "" || t === null || typeof t > "u")
    return n.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var a = typeof t == "string" ? LD(t, n) : t, c = n.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, u = Object.keys(a), r = 0; r < u.length; ++r) {
    var l = u[r], i = FD(l, a[l], n, typeof t == "string");
    c = Ro.merge(c, i, n);
  }
  return n.allowSparse === !0 ? c : Ro.compact(c);
}, UD = kD, VD = $D, WD = H0, HD = {
  formats: WD,
  parse: VD,
  stringify: UD
}, qD = A3;
function pi() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var GD = /^([a-z0-9.+-]+:)/i, zD = /:[0-9]*$/, KD = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, YD = [
  "<",
  ">",
  '"',
  "`",
  " ",
  "\r",
  `
`,
  "	"
], XD = [
  "{",
  "}",
  "|",
  "\\",
  "^",
  "`"
].concat(YD), Qm = ["'"].concat(XD), Cv = [
  "%",
  "/",
  "?",
  ";",
  "#"
].concat(Qm), Iv = [
  "/",
  "?",
  "#"
], JD = 255, Ov = /^[+a-z0-9A-Z_-]{0,63}$/, QD = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, ZD = {
  javascript: !0,
  "javascript:": !0
}, Zm = {
  javascript: !0,
  "javascript:": !0
}, Po = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
}, e1 = HD;
function xu(t, e, n) {
  if (t && typeof t == "object" && t instanceof pi)
    return t;
  var a = new pi();
  return a.parse(t, e, n), a;
}
pi.prototype.parse = function(t, e, n) {
  if (typeof t != "string")
    throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
  var a = t.indexOf("?"), c = a !== -1 && a < t.indexOf("#") ? "?" : "#", u = t.split(c), r = /\\/g;
  u[0] = u[0].replace(r, "/"), t = u.join(c);
  var l = t;
  if (l = l.trim(), !n && t.split("#").length === 1) {
    var i = KD.exec(l);
    if (i)
      return this.path = l, this.href = l, this.pathname = i[1], i[2] ? (this.search = i[2], e ? this.query = e1.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : e && (this.search = "", this.query = {}), this;
  }
  var f = GD.exec(l);
  if (f) {
    f = f[0];
    var d = f.toLowerCase();
    this.protocol = d, l = l.substr(f.length);
  }
  if (n || f || l.match(/^\/\/[^@/]+@[^@/]+/)) {
    var s = l.substr(0, 2) === "//";
    s && !(f && Zm[f]) && (l = l.substr(2), this.slashes = !0);
  }
  if (!Zm[f] && (s || f && !Po[f])) {
    for (var o = -1, m = 0; m < Iv.length; m++) {
      var h = l.indexOf(Iv[m]);
      h !== -1 && (o === -1 || h < o) && (o = h);
    }
    var y, b;
    o === -1 ? b = l.lastIndexOf("@") : b = l.lastIndexOf("@", o), b !== -1 && (y = l.slice(0, b), l = l.slice(b + 1), this.auth = decodeURIComponent(y)), o = -1;
    for (var m = 0; m < Cv.length; m++) {
      var h = l.indexOf(Cv[m]);
      h !== -1 && (o === -1 || h < o) && (o = h);
    }
    o === -1 && (o = l.length), this.host = l.slice(0, o), l = l.slice(o), this.parseHost(), this.hostname = this.hostname || "";
    var E = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!E)
      for (var S = this.hostname.split(/\./), m = 0, g = S.length; m < g; m++) {
        var P = S[m];
        if (P && !P.match(Ov)) {
          for (var R = "", N = 0, C = P.length; N < C; N++)
            P.charCodeAt(N) > 127 ? R += "x" : R += P[N];
          if (!R.match(Ov)) {
            var I = S.slice(0, m), D = S.slice(m + 1), j = P.match(QD);
            j && (I.push(j[1]), D.unshift(j[2])), D.length && (l = "/" + D.join(".") + l), this.hostname = I.join(".");
            break;
          }
        }
      }
    this.hostname.length > JD ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), E || (this.hostname = qD.toASCII(this.hostname));
    var F = this.port ? ":" + this.port : "", _ = this.hostname || "";
    this.host = _ + F, this.href += this.host, E && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), l[0] !== "/" && (l = "/" + l));
  }
  if (!ZD[d])
    for (var m = 0, g = Qm.length; m < g; m++) {
      var T = Qm[m];
      if (l.indexOf(T) !== -1) {
        var v = encodeURIComponent(T);
        v === T && (v = escape(T)), l = l.split(T).join(v);
      }
    }
  var w = l.indexOf("#");
  w !== -1 && (this.hash = l.substr(w), l = l.slice(0, w));
  var O = l.indexOf("?");
  if (O !== -1 ? (this.search = l.substr(O), this.query = l.substr(O + 1), e && (this.query = e1.parse(this.query)), l = l.slice(0, O)) : e && (this.search = "", this.query = {}), l && (this.pathname = l), Po[d] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
    var F = this.pathname || "", G = this.search || "";
    this.path = F + G;
  }
  return this.href = this.format(), this;
};
function e5(t) {
  return typeof t == "string" && (t = xu(t)), t instanceof pi ? t.format() : pi.prototype.format.call(t);
}
pi.prototype.format = function() {
  var t = this.auth || "";
  t && (t = encodeURIComponent(t), t = t.replace(/%3A/i, ":"), t += "@");
  var e = this.protocol || "", n = this.pathname || "", a = this.hash || "", c = !1, u = "";
  this.host ? c = t + this.host : this.hostname && (c = t + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (c += ":" + this.port)), this.query && typeof this.query == "object" && Object.keys(this.query).length && (u = e1.stringify(this.query, {
    arrayFormat: "repeat",
    addQueryPrefix: !1
  }));
  var r = this.search || u && "?" + u || "";
  return e && e.substr(-1) !== ":" && (e += ":"), this.slashes || (!e || Po[e]) && c !== !1 ? (c = "//" + (c || ""), n && n.charAt(0) !== "/" && (n = "/" + n)) : c || (c = ""), a && a.charAt(0) !== "#" && (a = "#" + a), r && r.charAt(0) !== "?" && (r = "?" + r), n = n.replace(/[?#]/g, function(l) {
    return encodeURIComponent(l);
  }), r = r.replace("#", "%23"), e + c + n + r + a;
};
function t5(t, e) {
  return xu(t, !1, !0).resolve(e);
}
pi.prototype.resolve = function(t) {
  return this.resolveObject(xu(t, !1, !0)).format();
};
function r5(t, e) {
  return t ? xu(t, !1, !0).resolveObject(e) : e;
}
pi.prototype.resolveObject = function(t) {
  if (typeof t == "string") {
    var e = new pi();
    e.parse(t, !1, !0), t = e;
  }
  for (var n = new pi(), a = Object.keys(this), c = 0; c < a.length; c++) {
    var u = a[c];
    n[u] = this[u];
  }
  if (n.hash = t.hash, t.href === "")
    return n.href = n.format(), n;
  if (t.slashes && !t.protocol) {
    for (var r = Object.keys(t), l = 0; l < r.length; l++) {
      var i = r[l];
      i !== "protocol" && (n[i] = t[i]);
    }
    return Po[n.protocol] && n.hostname && !n.pathname && (n.pathname = "/", n.path = n.pathname), n.href = n.format(), n;
  }
  if (t.protocol && t.protocol !== n.protocol) {
    if (!Po[t.protocol]) {
      for (var f = Object.keys(t), d = 0; d < f.length; d++) {
        var s = f[d];
        n[s] = t[s];
      }
      return n.href = n.format(), n;
    }
    if (n.protocol = t.protocol, !t.host && !Zm[t.protocol]) {
      for (var g = (t.pathname || "").split("/"); g.length && !(t.host = g.shift()); )
        ;
      t.host || (t.host = ""), t.hostname || (t.hostname = ""), g[0] !== "" && g.unshift(""), g.length < 2 && g.unshift(""), n.pathname = g.join("/");
    } else
      n.pathname = t.pathname;
    if (n.search = t.search, n.query = t.query, n.host = t.host || "", n.auth = t.auth, n.hostname = t.hostname || t.host, n.port = t.port, n.pathname || n.search) {
      var o = n.pathname || "", m = n.search || "";
      n.path = o + m;
    }
    return n.slashes = n.slashes || t.slashes, n.href = n.format(), n;
  }
  var h = n.pathname && n.pathname.charAt(0) === "/", y = t.host || t.pathname && t.pathname.charAt(0) === "/", b = y || h || n.host && t.pathname, E = b, S = n.pathname && n.pathname.split("/") || [], g = t.pathname && t.pathname.split("/") || [], P = n.protocol && !Po[n.protocol];
  if (P && (n.hostname = "", n.port = null, n.host && (S[0] === "" ? S[0] = n.host : S.unshift(n.host)), n.host = "", t.protocol && (t.hostname = null, t.port = null, t.host && (g[0] === "" ? g[0] = t.host : g.unshift(t.host)), t.host = null), b = b && (g[0] === "" || S[0] === "")), y)
    n.host = t.host || t.host === "" ? t.host : n.host, n.hostname = t.hostname || t.hostname === "" ? t.hostname : n.hostname, n.search = t.search, n.query = t.query, S = g;
  else if (g.length)
    S || (S = []), S.pop(), S = S.concat(g), n.search = t.search, n.query = t.query;
  else if (t.search != null) {
    if (P) {
      n.host = S.shift(), n.hostname = n.host;
      var R = n.host && n.host.indexOf("@") > 0 ? n.host.split("@") : !1;
      R && (n.auth = R.shift(), n.hostname = R.shift(), n.host = n.hostname);
    }
    return n.search = t.search, n.query = t.query, (n.pathname !== null || n.search !== null) && (n.path = (n.pathname ? n.pathname : "") + (n.search ? n.search : "")), n.href = n.format(), n;
  }
  if (!S.length)
    return n.pathname = null, n.search ? n.path = "/" + n.search : n.path = null, n.href = n.format(), n;
  for (var N = S.slice(-1)[0], C = (n.host || t.host || S.length > 1) && (N === "." || N === "..") || N === "", I = 0, D = S.length; D >= 0; D--)
    N = S[D], N === "." ? S.splice(D, 1) : N === ".." ? (S.splice(D, 1), I++) : I && (S.splice(D, 1), I--);
  if (!b && !E)
    for (; I--; I)
      S.unshift("..");
  b && S[0] !== "" && (!S[0] || S[0].charAt(0) !== "/") && S.unshift(""), C && S.join("/").substr(-1) !== "/" && S.push("");
  var j = S[0] === "" || S[0] && S[0].charAt(0) === "/";
  if (P) {
    n.hostname = j ? "" : S.length ? S.shift() : "", n.host = n.hostname;
    var R = n.host && n.host.indexOf("@") > 0 ? n.host.split("@") : !1;
    R && (n.auth = R.shift(), n.hostname = R.shift(), n.host = n.hostname);
  }
  return b = b || n.host && S.length, b && !j && S.unshift(""), S.length > 0 ? n.pathname = S.join("/") : (n.pathname = null, n.path = null), (n.pathname !== null || n.search !== null) && (n.path = (n.pathname ? n.pathname : "") + (n.search ? n.search : "")), n.auth = t.auth || n.auth, n.slashes = n.slashes || t.slashes, n.href = n.format(), n;
};
pi.prototype.parseHost = function() {
  var t = this.host, e = zD.exec(t);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t);
};
ds.parse = xu;
ds.resolve = t5;
ds.resolveObject = r5;
ds.format = e5;
ds.Url = pi;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.unixify = t.bufferToEncoding = t.getWriteSyncArgs = t.getWriteArgs = t.bufToUint8 = t.dataToBuffer = t.validateFd = t.isFd = t.flagsToNumber = t.genRndStr6 = t.createError = t.pathToFilename = t.nullCheck = t.modeToNumber = t.validateCallback = t.promisify = t.isWin = void 0;
  const e = oa, n = I0, a = Eu, c = _u, u = pd;
  t.isWin = Ve.process.platform === "win32";
  function r(q, $, Y = (H) => H) {
    return (...H) => new Promise((Q, X) => {
      q[$].bind(q)(...H, (ne, ye) => ne ? X(ne) : Q(Y(ye)));
    });
  }
  t.promisify = r;
  function l(q) {
    if (typeof q != "function")
      throw TypeError(e.ERRSTR.CB);
    return q;
  }
  t.validateCallback = l;
  function i(q, $) {
    if (typeof q == "number")
      return q;
    if (typeof q == "string")
      return parseInt(q, 8);
    if ($)
      return f($);
  }
  function f(q, $) {
    const Y = i(q, $);
    if (typeof Y != "number" || isNaN(Y))
      throw new TypeError(e.ERRSTR.MODE_INT);
    return Y;
  }
  t.modeToNumber = f;
  function d(q, $) {
    if (("" + q).indexOf("\0") !== -1) {
      const Y = new Error("Path must be a string without null bytes");
      if (Y.code = "ENOENT", typeof $ != "function")
        throw Y;
      return (0, u.default)(() => {
        $(Y);
      }), !1;
    }
    return !0;
  }
  t.nullCheck = d;
  function s(q) {
    if (q.hostname !== "")
      throw new n.TypeError("ERR_INVALID_FILE_URL_HOST", Ve.process.platform);
    const $ = q.pathname;
    for (let Y = 0; Y < $.length; Y++)
      if ($[Y] === "%") {
        const H = $.codePointAt(Y + 2) | 32;
        if ($[Y + 1] === "2" && H === 102)
          throw new n.TypeError("ERR_INVALID_FILE_URL_PATH", "must not include encoded / characters");
      }
    return decodeURIComponent($);
  }
  function o(q) {
    if (typeof q != "string" && !Ve.Buffer.isBuffer(q)) {
      try {
        if (!(q instanceof ds.URL))
          throw new TypeError(e.ERRSTR.PATH_STR);
      } catch {
        throw new TypeError(e.ERRSTR.PATH_STR);
      }
      q = s(q);
    }
    const $ = String(q);
    return d($), $;
  }
  t.pathToFilename = o;
  const m = "ENOENT", h = "EBADF", y = "EINVAL", b = "EPERM", E = "EPROTO", S = "EEXIST", g = "ENOTDIR", P = "EMFILE", R = "EACCES", N = "EISDIR", C = "ENOTEMPTY", I = "ENOSYS", D = "ERR_FS_EISDIR", j = "ERR_OUT_OF_RANGE";
  function F(q, $ = "", Y = "", H = "") {
    let Q = "";
    switch (Y && (Q = ` '${Y}'`), H && (Q += ` -> '${H}'`), q) {
      case m:
        return `ENOENT: no such file or directory, ${$}${Q}`;
      case h:
        return `EBADF: bad file descriptor, ${$}${Q}`;
      case y:
        return `EINVAL: invalid argument, ${$}${Q}`;
      case b:
        return `EPERM: operation not permitted, ${$}${Q}`;
      case E:
        return `EPROTO: protocol error, ${$}${Q}`;
      case S:
        return `EEXIST: file already exists, ${$}${Q}`;
      case g:
        return `ENOTDIR: not a directory, ${$}${Q}`;
      case N:
        return `EISDIR: illegal operation on a directory, ${$}${Q}`;
      case R:
        return `EACCES: permission denied, ${$}${Q}`;
      case C:
        return `ENOTEMPTY: directory not empty, ${$}${Q}`;
      case P:
        return `EMFILE: too many open files, ${$}${Q}`;
      case I:
        return `ENOSYS: function not implemented, ${$}${Q}`;
      case D:
        return `[ERR_FS_EISDIR]: Path is a directory: ${$} returned EISDIR (is a directory) ${Y}`;
      case j:
        return `[ERR_OUT_OF_RANGE]: value out of range, ${$}${Q}`;
      default:
        return `${q}: error occurred, ${$}${Q}`;
    }
  }
  function _(q, $ = "", Y = "", H = "", Q = Error) {
    const X = new Q(F(q, $, Y, H));
    return X.code = q, Y && (X.path = Y), X;
  }
  t.createError = _;
  function T() {
    const q = (Math.random() + 1).toString(36).substring(2, 8);
    return q.length === 6 ? q : T();
  }
  t.genRndStr6 = T;
  function v(q) {
    if (typeof q == "number")
      return q;
    if (typeof q == "string") {
      const $ = e.FLAGS[q];
      if (typeof $ < "u")
        return $;
    }
    throw new n.TypeError("ERR_INVALID_OPT_VALUE", "flags", q);
  }
  t.flagsToNumber = v;
  function w(q) {
    return q >>> 0 === q;
  }
  t.isFd = w;
  function O(q) {
    if (!w(q))
      throw TypeError(e.ERRSTR.FD);
  }
  t.validateFd = O;
  function G(q, $ = a.ENCODING_UTF8) {
    return Ve.Buffer.isBuffer(q) ? q : q instanceof Uint8Array ? (0, c.bufferFrom)(q) : (0, c.bufferFrom)(String(q), $);
  }
  t.dataToBuffer = G;
  const W = (q) => new Uint8Array(q.buffer, q.byteOffset, q.byteLength);
  t.bufToUint8 = W;
  const U = (q, $, Y, H, Q, X) => {
    O(q);
    let ne = 0, ye, ve = null, de, oe;
    const re = typeof $, ae = typeof Y, le = typeof H, ue = typeof Q;
    re !== "string" ? ae === "function" ? oe = Y : le === "function" ? (ne = Y | 0, oe = H) : ue === "function" ? (ne = Y | 0, ye = H, oe = Q) : (ne = Y | 0, ye = H, ve = Q, oe = X) : ae === "function" ? oe = Y : le === "function" ? (ve = Y, oe = H) : ue === "function" && (ve = Y, de = H, oe = Q);
    const ie = G($, de);
    re !== "string" ? typeof ye > "u" && (ye = ie.length) : (ne = 0, ye = ie.length);
    const we = l(oe);
    return [q, re === "string", ie, ne, ye, ve, we];
  };
  t.getWriteArgs = U;
  const M = (q, $, Y, H, Q) => {
    O(q);
    let X, ne, ye, ve;
    const de = typeof $ != "string";
    de ? (ne = (Y || 0) | 0, ye = H, ve = Q) : (ve = Y, X = H);
    const oe = G($, X);
    return de ? typeof ye > "u" && (ye = oe.length) : (ne = 0, ye = oe.length), [q, oe, ne || 0, ye, ve];
  };
  t.getWriteSyncArgs = M;
  function B(q, $) {
    return !$ || $ === "buffer" ? q : q.toString($);
  }
  t.bufferToEncoding = B;
  const k = (q, $) => {
    let Y = q[$];
    return $ > 0 && (Y === "/" || t.isWin && Y === "\\");
  }, K = (q) => {
    let $ = q.length - 1;
    if ($ < 2)
      return q;
    for (; k(q, $); )
      $--;
    return q.substr(0, $ + 1);
  }, te = (q, $) => {
    if (typeof q != "string")
      throw new TypeError("expected a string");
    return q = q.replace(/[\\\/]+/g, "/"), $ !== !1 && (q = K(q)), q;
  }, z = (q, $ = !0) => t.isWin ? (q = te(q, $), q.replace(/^([a-zA-Z]+:|\.\/)/, "")) : q;
  t.unixify = z;
})(Au);
Object.defineProperty(hd, "__esModule", { value: !0 });
hd.FileHandle = void 0;
const On = Au;
class n5 {
  constructor(e, n) {
    this.fs = e, this.fd = n;
  }
  appendFile(e, n) {
    return (0, On.promisify)(this.fs, "appendFile")(this.fd, e, n);
  }
  chmod(e) {
    return (0, On.promisify)(this.fs, "fchmod")(this.fd, e);
  }
  chown(e, n) {
    return (0, On.promisify)(this.fs, "fchown")(this.fd, e, n);
  }
  close() {
    return (0, On.promisify)(this.fs, "close")(this.fd);
  }
  datasync() {
    return (0, On.promisify)(this.fs, "fdatasync")(this.fd);
  }
  read(e, n, a, c) {
    return (0, On.promisify)(this.fs, "read", (u) => ({ bytesRead: u, buffer: e }))(this.fd, e, n, a, c);
  }
  readv(e, n) {
    return (0, On.promisify)(this.fs, "readv", (a) => ({ bytesRead: a, buffers: e }))(this.fd, e, n);
  }
  readFile(e) {
    return (0, On.promisify)(this.fs, "readFile")(this.fd, e);
  }
  stat(e) {
    return (0, On.promisify)(this.fs, "fstat")(this.fd, e);
  }
  sync() {
    return (0, On.promisify)(this.fs, "fsync")(this.fd);
  }
  truncate(e) {
    return (0, On.promisify)(this.fs, "ftruncate")(this.fd, e);
  }
  utimes(e, n) {
    return (0, On.promisify)(this.fs, "futimes")(this.fd, e, n);
  }
  write(e, n, a, c) {
    return (0, On.promisify)(this.fs, "write", (u) => ({ bytesWritten: u, buffer: e }))(this.fd, e, n, a, c);
  }
  writev(e, n) {
    return (0, On.promisify)(this.fs, "writev", (a) => ({ bytesWritten: a, buffers: e }))(this.fd, e, n);
  }
  writeFile(e, n) {
    return (0, On.promisify)(this.fs, "writeFile")(this.fd, e, n);
  }
}
hd.FileHandle = n5;
var md = {};
Object.defineProperty(md, "__esModule", { value: !0 });
md.FsPromises = void 0;
const mr = Au, i5 = Es;
class s5 {
  constructor(e, n) {
    this.fs = e, this.FileHandle = n, this.constants = i5.constants, this.cp = (0, mr.promisify)(this.fs, "cp"), this.opendir = (0, mr.promisify)(this.fs, "opendir"), this.statfs = (0, mr.promisify)(this.fs, "statfs"), this.lutimes = (0, mr.promisify)(this.fs, "lutimes"), this.access = (0, mr.promisify)(this.fs, "access"), this.chmod = (0, mr.promisify)(this.fs, "chmod"), this.chown = (0, mr.promisify)(this.fs, "chown"), this.copyFile = (0, mr.promisify)(this.fs, "copyFile"), this.lchmod = (0, mr.promisify)(this.fs, "lchmod"), this.lchown = (0, mr.promisify)(this.fs, "lchown"), this.link = (0, mr.promisify)(this.fs, "link"), this.lstat = (0, mr.promisify)(this.fs, "lstat"), this.mkdir = (0, mr.promisify)(this.fs, "mkdir"), this.mkdtemp = (0, mr.promisify)(this.fs, "mkdtemp"), this.readdir = (0, mr.promisify)(this.fs, "readdir"), this.readlink = (0, mr.promisify)(this.fs, "readlink"), this.realpath = (0, mr.promisify)(this.fs, "realpath"), this.rename = (0, mr.promisify)(this.fs, "rename"), this.rmdir = (0, mr.promisify)(this.fs, "rmdir"), this.rm = (0, mr.promisify)(this.fs, "rm"), this.stat = (0, mr.promisify)(this.fs, "stat"), this.symlink = (0, mr.promisify)(this.fs, "symlink"), this.truncate = (0, mr.promisify)(this.fs, "truncate"), this.unlink = (0, mr.promisify)(this.fs, "unlink"), this.utimes = (0, mr.promisify)(this.fs, "utimes"), this.readFile = (a, c) => (0, mr.promisify)(this.fs, "readFile")(a instanceof this.FileHandle ? a.fd : a, c), this.appendFile = (a, c, u) => (0, mr.promisify)(this.fs, "appendFile")(a instanceof this.FileHandle ? a.fd : a, c, u), this.open = (a, c = "r", u) => (0, mr.promisify)(this.fs, "open", (r) => new this.FileHandle(this.fs, r))(a, c, u), this.writeFile = (a, c, u) => (0, mr.promisify)(this.fs, "writeFile")(a instanceof this.FileHandle ? a.fd : a, c, u), this.watch = () => {
      throw new Error("Not implemented");
    };
  }
}
md.FsPromises = s5;
var $w = {}, yd = {};
Object.defineProperty(yd, "__esModule", { value: !0 });
yd.printTree = void 0;
const a5 = (t = "", e) => {
  e = e.filter(Boolean);
  let n = "";
  for (let a = 0; a < e.length; a++) {
    const c = a >= e.length - 1, u = e[a];
    if (!u)
      continue;
    const r = u(t + `${c ? " " : ""}  `);
    n += `
${t}${r ? c ? "" : "" : " "} ${r}`;
  }
  return n;
};
yd.printTree = a5;
var xn = {};
Object.defineProperty(xn, "__esModule", { value: !0 });
xn.newNotAllowedError = xn.newTypeMismatchError = xn.newNotFoundError = xn.assertCanWrite = xn.assertName = xn.basename = xn.ctx = void 0;
const o5 = (t = {}) => Object.assign({ separator: "/", syncHandleAllowed: !1, mode: "read" }, t);
xn.ctx = o5;
const l5 = (t, e) => {
  t[t.length - 1] === e && (t = t.slice(0, -1));
  const n = t.lastIndexOf(e);
  return n === -1 ? t : t.slice(n + 1);
};
xn.basename = l5;
const u5 = /^(\.{1,2})|(.*(\/|\\).*)$/, c5 = (t, e, n) => {
  if (!t || u5.test(t))
    throw new TypeError(`Failed to execute '${e}' on '${n}': Name is not allowed.`);
};
xn.assertName = c5;
const f5 = (t) => {
  if (t !== "readwrite")
    throw new DOMException("The request is not allowed by the user agent or the platform in the current context.", "NotAllowedError");
};
xn.assertCanWrite = f5;
const d5 = () => new DOMException("A requested file or directory could not be found at the time an operation was processed.", "NotFoundError");
xn.newNotFoundError = d5;
const p5 = () => new DOMException("The path supplied exists, but was not an entry of requested type.", "TypeMismatchError");
xn.newTypeMismatchError = p5;
const h5 = () => new DOMException("Permission not granted.", "NotAllowedError");
xn.newNotAllowedError = h5;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.toTreeSync = void 0;
  const e = yd, n = xn, a = (c, u = {}) => {
    var r;
    const l = u.separator || "/";
    let i = u.dir || l;
    i[i.length - 1] !== l && (i += l);
    const f = u.tab || "", d = (r = u.depth) !== null && r !== void 0 ? r : 10;
    let s = " (...)";
    if (d > 0) {
      const m = c.readdirSync(i, { withFileTypes: !0 });
      s = (0, e.printTree)(f, m.map((h) => (y) => h.isDirectory() ? (0, t.toTreeSync)(c, { dir: i + h.name, depth: d - 1, tab: y }) : h.isSymbolicLink() ? "" + h.name + "  " + c.readlinkSync(i + h.name) : "" + h.name));
    }
    return (0, n.basename)(i, l) + l + s;
  };
  t.toTreeSync = a;
})($w);
var Uw = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.getWriteFileOptions = t.writeFileDefaults = t.getRealpathOptsAndCb = t.getRealpathOptions = t.getStatOptsAndCb = t.getStatOptions = t.getAppendFileOptsAndCb = t.getAppendFileOpts = t.getReaddirOptsAndCb = t.getReaddirOptions = t.getReadFileOptions = t.getRmOptsAndCb = t.getRmdirOptions = t.getDefaultOptsAndCb = t.getDefaultOpts = t.optsDefaults = t.optsAndCbGenerator = t.optsGenerator = t.getOptions = t.getMkdirOptions = void 0;
  const e = oa, n = Eu, a = Au, c = {
    mode: 511,
    recursive: !1
  }, u = (P) => typeof P == "number" ? Object.assign({}, c, { mode: P }) : Object.assign({}, c, P);
  t.getMkdirOptions = u;
  const r = (P) => `Expected options to be either an object or a string, but got ${P} instead`;
  function l(P, R) {
    let N;
    if (R) {
      const C = typeof R;
      switch (C) {
        case "string":
          N = Object.assign({}, P, { encoding: R });
          break;
        case "object":
          N = Object.assign({}, P, R);
          break;
        default:
          throw TypeError(r(C));
      }
    } else
      return P;
    return N.encoding !== "buffer" && (0, n.assertEncoding)(N.encoding), N;
  }
  t.getOptions = l;
  function i(P) {
    return (R) => l(P, R);
  }
  t.optsGenerator = i;
  function f(P) {
    return (R, N) => typeof R == "function" ? [P(), R] : [P(R), (0, a.validateCallback)(N)];
  }
  t.optsAndCbGenerator = f, t.optsDefaults = {
    encoding: "utf8"
  }, t.getDefaultOpts = i(t.optsDefaults), t.getDefaultOptsAndCb = f(t.getDefaultOpts);
  const d = {
    recursive: !1
  }, s = (P) => Object.assign({}, d, P);
  t.getRmdirOptions = s;
  const o = i(t.optsDefaults);
  t.getRmOptsAndCb = f(o);
  const m = {
    flag: "r"
  };
  t.getReadFileOptions = i(m);
  const h = {
    encoding: "utf8",
    withFileTypes: !1
  };
  t.getReaddirOptions = i(h), t.getReaddirOptsAndCb = f(t.getReaddirOptions);
  const y = {
    encoding: "utf8",
    mode: 438,
    flag: e.FLAGS[e.FLAGS.a]
  };
  t.getAppendFileOpts = i(y), t.getAppendFileOptsAndCb = f(t.getAppendFileOpts);
  const b = {
    bigint: !1
  }, E = (P = {}) => Object.assign({}, b, P);
  t.getStatOptions = E;
  const S = (P, R) => typeof P == "function" ? [(0, t.getStatOptions)(), P] : [(0, t.getStatOptions)(P), (0, a.validateCallback)(R)];
  t.getStatOptsAndCb = S;
  const g = t.optsDefaults;
  t.getRealpathOptions = i(g), t.getRealpathOptsAndCb = f(t.getRealpathOptions), t.writeFileDefaults = {
    encoding: "utf8",
    mode: 438,
    flag: e.FLAGS[e.FLAGS.w]
  }, t.getWriteFileOptions = i(t.writeFileDefaults);
})(Uw);
Object.defineProperty(ln, "__esModule", { value: !0 });
ln.FSWatcher = ln.StatWatcher = ln.Volume = ln.toUnixTimestamp = ln.dataToStr = ln.pathToSteps = ln.filenameToSteps = void 0;
const sf = Lr, _h = vw, Sh = Ka, m5 = Jo, la = _u, uo = j0, bd = pd, Vw = Zo, y5 = F0, gd = xr, b5 = Es, Ww = Tu, Zs = Eu, g5 = hd, Hw = mi, v5 = md, E5 = $w, Xl = oa, dr = Uw, Qe = Au, _5 = sf.resolve, { O_RDONLY: kv, O_WRONLY: Dv, O_RDWR: Nv, O_CREAT: Rv, O_EXCL: S5, O_TRUNC: w5, O_APPEND: T5, O_DIRECTORY: A5, O_SYMLINK: Mv, F_OK: Lv, COPYFILE_EXCL: x5, COPYFILE_FICLONE_FORCE: P5 } = b5.constants, { sep: ki, relative: Jl, join: C5, dirname: I5 } = sf.posix ? sf.posix : sf, O5 = 128, k5 = "EPERM", en = "ENOENT", wh = "EBADF", D5 = "EINVAL", Sa = "EEXIST", co = "ENOTDIR", N5 = "EMFILE", R5 = "EACCES", jv = "EISDIR", M5 = "ENOTEMPTY", L5 = "ENOSYS", j5 = "ERR_FS_EISDIR", F5 = "ERR_OUT_OF_RANGE";
let nu = (t, e = Vw.default.cwd()) => _5(e, t);
if (Qe.isWin) {
  const t = nu;
  nu = (e, n) => (0, Qe.unixify)(t(e, n));
}
function Kr(t, e) {
  const a = nu(t, e).substring(1);
  return a ? a.split(ki) : [];
}
ln.filenameToSteps = Kr;
function B5(t) {
  return Kr((0, Qe.pathToFilename)(t));
}
ln.pathToSteps = B5;
function $5(t, e = Zs.ENCODING_UTF8) {
  return la.Buffer.isBuffer(t) ? t.toString(e) : t instanceof Uint8Array ? (0, la.bufferFrom)(t).toString(e) : String(t);
}
ln.dataToStr = $5;
function Is(t) {
  if (typeof t == "string" && +t == t)
    return +t;
  if (t instanceof Date)
    return t.getTime() / 1e3;
  if (isFinite(t))
    return t < 0 ? Date.now() / 1e3 : t;
  throw new Error("Cannot parse time: " + t);
}
ln.toUnixTimestamp = Is;
function fo(t) {
  if (typeof t != "number")
    throw TypeError(Xl.ERRSTR.UID);
}
function po(t) {
  if (typeof t != "number")
    throw TypeError(Xl.ERRSTR.GID);
}
function U5(t) {
  const e = {};
  function n(a, c) {
    for (const u in c) {
      const r = c[u], l = C5(a, u);
      typeof r == "string" || r instanceof la.Buffer ? e[l] = r : typeof r == "object" && r !== null && Object.keys(r).length > 0 ? n(l, r) : e[l] = null;
    }
  }
  return n("", t), e;
}
const Ps = () => {
  throw new Error("Not implemented");
};
class Co {
  static fromJSON(e, n) {
    const a = new Co();
    return a.fromJSON(e, n), a;
  }
  static fromNestedJSON(e, n) {
    const a = new Co();
    return a.fromNestedJSON(e, n), a;
  }
  get promises() {
    if (this.promisesApi === null)
      throw new Error("Promise is not supported in this environment.");
    return this.promisesApi;
  }
  constructor(e = {}) {
    this.ino = 0, this.inodes = {}, this.releasedInos = [], this.fds = {}, this.releasedFds = [], this.maxFiles = 1e4, this.openFiles = 0, this.promisesApi = new v5.FsPromises(this, g5.FileHandle), this.statWatchers = {}, this.cpSync = Ps, this.lutimesSync = Ps, this.statfsSync = Ps, this.opendirSync = Ps, this.cp = Ps, this.lutimes = Ps, this.statfs = Ps, this.openAsBlob = Ps, this.opendir = Ps, this.props = Object.assign({ Node: _h.Node, Link: _h.Link, File: _h.File }, e);
    const n = this.createLink();
    n.setNode(this.createNode(!0));
    const a = this;
    this.StatWatcher = class extends qw {
      constructor() {
        super(a);
      }
    };
    const c = ps;
    this.ReadStream = class extends c {
      constructor(...r) {
        super(a, ...r);
      }
    };
    const u = yi;
    this.WriteStream = class extends u {
      constructor(...r) {
        super(a, ...r);
      }
    }, this.FSWatcher = class extends zw {
      constructor() {
        super(a);
      }
    }, n.setChild(".", n), n.getNode().nlink++, n.setChild("..", n), n.getNode().nlink++, this.root = n;
  }
  createLink(e, n, a = !1, c) {
    if (!e)
      return new this.props.Link(this, null, "");
    if (!n)
      throw new Error("createLink: name cannot be empty");
    return e.createChild(n, this.createNode(a, c));
  }
  deleteLink(e) {
    const n = e.parent;
    return n ? (n.deleteChild(e), !0) : !1;
  }
  newInoNumber() {
    const e = this.releasedInos.pop();
    return e || (this.ino = (this.ino + 1) % 4294967295, this.ino);
  }
  newFdNumber() {
    const e = this.releasedFds.pop();
    return typeof e == "number" ? e : Co.fd--;
  }
  createNode(e = !1, n) {
    const a = new this.props.Node(this.newInoNumber(), n);
    return e && a.setIsDirectory(), this.inodes[a.ino] = a, a;
  }
  deleteNode(e) {
    e.del(), delete this.inodes[e.ino], this.releasedInos.push(e.ino);
  }
  // Returns a `Link` (hard link) referenced by path "split" into steps.
  getLink(e) {
    return this.root.walk(e);
  }
  // Just link `getLink`, but throws a correct user error, if link to found.
  getLinkOrThrow(e, n) {
    const a = Kr(e), c = this.getLink(a);
    if (!c)
      throw (0, Qe.createError)(en, n, e);
    return c;
  }
  // Just like `getLink`, but also dereference/resolves symbolic links.
  getResolvedLink(e) {
    let n = typeof e == "string" ? Kr(e) : e, a = this.root, c = 0;
    for (; c < n.length; ) {
      const u = n[c];
      if (a = a.getChild(u), !a)
        return null;
      const r = a.getNode();
      if (r.isSymlink()) {
        n = r.symlink.concat(n.slice(c + 1)), a = this.root, c = 0;
        continue;
      }
      c++;
    }
    return a;
  }
  // Just like `getLinkOrThrow`, but also dereference/resolves symbolic links.
  getResolvedLinkOrThrow(e, n) {
    const a = this.getResolvedLink(e);
    if (!a)
      throw (0, Qe.createError)(en, n, e);
    return a;
  }
  resolveSymlinks(e) {
    return this.getResolvedLink(e.steps.slice(1));
  }
  // Just like `getLinkOrThrow`, but also verifies that the link is a directory.
  getLinkAsDirOrThrow(e, n) {
    const a = this.getLinkOrThrow(e, n);
    if (!a.getNode().isDirectory())
      throw (0, Qe.createError)(co, n, e);
    return a;
  }
  // Get the immediate parent directory of the link.
  getLinkParent(e) {
    return this.root.walk(e, e.length - 1);
  }
  getLinkParentAsDirOrThrow(e, n) {
    const a = e instanceof Array ? e : Kr(e), c = this.getLinkParent(a);
    if (!c)
      throw (0, Qe.createError)(en, n, ki + a.join(ki));
    if (!c.getNode().isDirectory())
      throw (0, Qe.createError)(co, n, ki + a.join(ki));
    return c;
  }
  getFileByFd(e) {
    return this.fds[String(e)];
  }
  getFileByFdOrThrow(e, n) {
    if (!(0, Qe.isFd)(e))
      throw TypeError(Xl.ERRSTR.FD);
    const a = this.getFileByFd(e);
    if (!a)
      throw (0, Qe.createError)(wh, n);
    return a;
  }
  /**
   * @todo This is not used anymore. Remove.
   */
  /*
    private getNodeByIdOrCreate(id: TFileId, flags: number, perm: number): Node {
      if (typeof id === 'number') {
        const file = this.getFileByFd(id);
        if (!file) throw Error('File nto found');
        return file.node;
      } else {
        const steps = pathToSteps(id as PathLike);
        let link = this.getLink(steps);
        if (link) return link.getNode();
  
        // Try creating a node if not found.
        if (flags & O_CREAT) {
          const dirLink = this.getLinkParent(steps);
          if (dirLink) {
            const name = steps[steps.length - 1];
            link = this.createLink(dirLink, name, false, perm);
            return link.getNode();
          }
        }
  
        throw createError(ENOENT, 'getNodeByIdOrCreate', pathToFilename(id));
      }
    }
    */
  wrapAsync(e, n, a) {
    (0, Qe.validateCallback)(a), (0, uo.default)(() => {
      let c;
      try {
        c = e.apply(this, n);
      } catch (u) {
        a(u);
        return;
      }
      a(null, c);
    });
  }
  _toJSON(e = this.root, n = {}, a, c) {
    let u = !0, r = e.children;
    e.getNode().isFile() && (r = /* @__PURE__ */ new Map([[e.getName(), e.parent.getChild(e.getName())]]), e = e.parent);
    for (const i of r.keys()) {
      if (i === "." || i === "..")
        continue;
      u = !1;
      const f = e.getChild(i);
      if (!f)
        throw new Error("_toJSON: unexpected undefined");
      const d = f.getNode();
      if (d.isFile()) {
        let s = f.getPath();
        a && (s = Jl(a, s)), n[s] = c ? d.getBuffer() : d.getString();
      } else
        d.isDirectory() && this._toJSON(f, n, a);
    }
    let l = e.getPath();
    return a && (l = Jl(a, l)), l && u && (n[l] = null), n;
  }
  toJSON(e, n = {}, a = !1, c = !1) {
    const u = [];
    if (e) {
      Array.isArray(e) || (e = [e]);
      for (const r of e) {
        const l = (0, Qe.pathToFilename)(r), i = this.getResolvedLink(l);
        i && u.push(i);
      }
    } else
      u.push(this.root);
    if (!u.length)
      return n;
    for (const r of u)
      this._toJSON(r, n, a ? r.getPath() : "", c);
    return n;
  }
  // TODO: `cwd` should probably not invoke `process.cwd()`.
  fromJSON(e, n = Vw.default.cwd()) {
    for (let a in e) {
      const c = e[a];
      if (a = nu(a, n), typeof c == "string" || c instanceof la.Buffer) {
        const u = I5(a);
        this.mkdirpBase(
          u,
          511
          /* MODE.DIR */
        ), this.writeFileSync(a, c);
      } else
        this.mkdirpBase(
          a,
          511
          /* MODE.DIR */
        );
    }
  }
  fromNestedJSON(e, n) {
    this.fromJSON(U5(e), n);
  }
  toTree(e = { separator: ki }) {
    return (0, E5.toTreeSync)(this, e);
  }
  reset() {
    this.ino = 0, this.inodes = {}, this.releasedInos = [], this.fds = {}, this.releasedFds = [], this.openFiles = 0, this.root = this.createLink(), this.root.setNode(this.createNode(!0));
  }
  // Legacy interface
  mountSync(e, n) {
    this.fromJSON(n, e);
  }
  openLink(e, n, a = !0) {
    if (this.openFiles >= this.maxFiles)
      throw (0, Qe.createError)(N5, "open", e.getPath());
    let c = e;
    if (a && (c = this.resolveSymlinks(e)), !c)
      throw (0, Qe.createError)(en, "open", e.getPath());
    const u = c.getNode();
    if (u.isDirectory()) {
      if ((n & (kv | Nv | Dv)) !== kv)
        throw (0, Qe.createError)(jv, "open", e.getPath());
    } else if (n & A5)
      throw (0, Qe.createError)(co, "open", e.getPath());
    if (!(n & Dv) && !u.canRead())
      throw (0, Qe.createError)(R5, "open", e.getPath());
    const r = new this.props.File(e, u, n, this.newFdNumber());
    return this.fds[r.fd] = r, this.openFiles++, n & w5 && r.truncate(), r;
  }
  openFile(e, n, a, c = !0) {
    const u = Kr(e);
    let r = c ? this.getResolvedLink(u) : this.getLink(u);
    if (r && n & S5)
      throw (0, Qe.createError)(Sa, "open", e);
    if (!r && n & Rv) {
      const l = this.getResolvedLink(u.slice(0, u.length - 1));
      if (!l)
        throw (0, Qe.createError)(en, "open", ki + u.join(ki));
      n & Rv && typeof a == "number" && (r = this.createLink(l, u[u.length - 1], !1, a));
    }
    if (r)
      return this.openLink(r, n, c);
    throw (0, Qe.createError)(en, "open", e);
  }
  openBase(e, n, a, c = !0) {
    const u = this.openFile(e, n, a, c);
    if (!u)
      throw (0, Qe.createError)(en, "open", e);
    return u.fd;
  }
  openSync(e, n, a = 438) {
    const c = (0, Qe.modeToNumber)(a), u = (0, Qe.pathToFilename)(e), r = (0, Qe.flagsToNumber)(n);
    return this.openBase(u, r, c, !(r & Mv));
  }
  open(e, n, a, c) {
    let u = a, r = c;
    typeof a == "function" && (u = 438, r = a), u = u || 438;
    const l = (0, Qe.modeToNumber)(u), i = (0, Qe.pathToFilename)(e), f = (0, Qe.flagsToNumber)(n);
    this.wrapAsync(this.openBase, [i, f, l, !(f & Mv)], r);
  }
  closeFile(e) {
    this.fds[e.fd] && (this.openFiles--, delete this.fds[e.fd], this.releasedFds.push(e.fd));
  }
  closeSync(e) {
    (0, Qe.validateFd)(e);
    const n = this.getFileByFdOrThrow(e, "close");
    this.closeFile(n);
  }
  close(e, n) {
    (0, Qe.validateFd)(e), this.wrapAsync(this.closeSync, [e], n);
  }
  openFileOrGetById(e, n, a) {
    if (typeof e == "number") {
      const c = this.fds[e];
      if (!c)
        throw (0, Qe.createError)(en);
      return c;
    } else
      return this.openFile((0, Qe.pathToFilename)(e), n, a);
  }
  readBase(e, n, a, c, u) {
    if (n.byteLength < c)
      throw (0, Qe.createError)(F5, "read", void 0, void 0, RangeError);
    const r = this.getFileByFdOrThrow(e);
    if (r.node.isSymlink())
      throw (0, Qe.createError)(k5, "read", r.link.getPath());
    return r.read(n, Number(a), Number(c), u === -1 || typeof u != "number" ? void 0 : u);
  }
  readSync(e, n, a, c, u) {
    return (0, Qe.validateFd)(e), this.readBase(e, n, a, c, u);
  }
  read(e, n, a, c, u, r) {
    if ((0, Qe.validateCallback)(r), c === 0)
      return (0, bd.default)(() => {
        r && r(null, 0, n);
      });
    (0, uo.default)(() => {
      try {
        const l = this.readBase(e, n, a, c, u);
        r(null, l, n);
      } catch (l) {
        r(l);
      }
    });
  }
  readvBase(e, n, a) {
    const c = this.getFileByFdOrThrow(e);
    let u = a ?? void 0;
    u === -1 && (u = void 0);
    let r = 0;
    for (const l of n) {
      const i = c.read(l, 0, l.byteLength, u);
      if (u = void 0, r += i, i < l.byteLength)
        break;
    }
    return r;
  }
  readv(e, n, a, c) {
    let u = a, r = c;
    typeof a == "function" && (u = null, r = a), (0, Qe.validateCallback)(r), (0, uo.default)(() => {
      try {
        const l = this.readvBase(e, n, u);
        r(null, l, n);
      } catch (l) {
        r(l);
      }
    });
  }
  readvSync(e, n, a) {
    return (0, Qe.validateFd)(e), this.readvBase(e, n, a);
  }
  readFileBase(e, n, a) {
    let c;
    const r = typeof e == "number" && (0, Qe.isFd)(e);
    let l;
    if (r)
      l = e;
    else {
      const i = (0, Qe.pathToFilename)(e), f = Kr(i), d = this.getResolvedLink(f);
      if (d && d.getNode().isDirectory())
        throw (0, Qe.createError)(jv, "open", d.getPath());
      l = this.openSync(e, n);
    }
    try {
      c = (0, Qe.bufferToEncoding)(this.getFileByFdOrThrow(l).getBuffer(), a);
    } finally {
      r || this.closeSync(l);
    }
    return c;
  }
  readFileSync(e, n) {
    const a = (0, dr.getReadFileOptions)(n), c = (0, Qe.flagsToNumber)(a.flag);
    return this.readFileBase(e, c, a.encoding);
  }
  readFile(e, n, a) {
    const [c, u] = (0, dr.optsAndCbGenerator)(dr.getReadFileOptions)(n, a), r = (0, Qe.flagsToNumber)(c.flag);
    this.wrapAsync(this.readFileBase, [e, r, c.encoding], u);
  }
  writeBase(e, n, a, c, u) {
    const r = this.getFileByFdOrThrow(e, "write");
    if (r.node.isSymlink())
      throw (0, Qe.createError)(wh, "write", r.link.getPath());
    return r.write(n, a, c, u === -1 || typeof u != "number" ? void 0 : u);
  }
  writeSync(e, n, a, c, u) {
    const [, r, l, i, f] = (0, Qe.getWriteSyncArgs)(e, n, a, c, u);
    return this.writeBase(e, r, l, i, f);
  }
  write(e, n, a, c, u, r) {
    const [, l, i, f, d, s, o] = (0, Qe.getWriteArgs)(e, n, a, c, u, r);
    (0, uo.default)(() => {
      try {
        const m = this.writeBase(e, i, f, d, s);
        l ? o(null, m, n) : o(null, m, i);
      } catch (m) {
        o(m);
      }
    });
  }
  writevBase(e, n, a) {
    const c = this.getFileByFdOrThrow(e);
    let u = a ?? void 0;
    u === -1 && (u = void 0);
    let r = 0;
    for (const l of n) {
      const i = la.Buffer.from(l.buffer, l.byteOffset, l.byteLength), f = c.write(i, 0, i.byteLength, u);
      if (u = void 0, r += f, f < i.byteLength)
        break;
    }
    return r;
  }
  writev(e, n, a, c) {
    let u = a, r = c;
    typeof a == "function" && (u = null, r = a), (0, Qe.validateCallback)(r), (0, uo.default)(() => {
      try {
        const l = this.writevBase(e, n, u);
        r(null, l, n);
      } catch (l) {
        r(l);
      }
    });
  }
  writevSync(e, n, a) {
    return (0, Qe.validateFd)(e), this.writevBase(e, n, a);
  }
  writeFileBase(e, n, a, c) {
    const u = typeof e == "number";
    let r;
    u ? r = e : r = this.openBase((0, Qe.pathToFilename)(e), a, c);
    let l = 0, i = n.length, f = a & T5 ? void 0 : 0;
    try {
      for (; i > 0; ) {
        const d = this.writeSync(r, n, l, i, f);
        l += d, i -= d, f !== void 0 && (f += d);
      }
    } finally {
      u || this.closeSync(r);
    }
  }
  writeFileSync(e, n, a) {
    const c = (0, dr.getWriteFileOptions)(a), u = (0, Qe.flagsToNumber)(c.flag), r = (0, Qe.modeToNumber)(c.mode), l = (0, Qe.dataToBuffer)(n, c.encoding);
    this.writeFileBase(e, l, u, r);
  }
  writeFile(e, n, a, c) {
    let u = a, r = c;
    typeof a == "function" && (u = dr.writeFileDefaults, r = a);
    const l = (0, Qe.validateCallback)(r), i = (0, dr.getWriteFileOptions)(u), f = (0, Qe.flagsToNumber)(i.flag), d = (0, Qe.modeToNumber)(i.mode), s = (0, Qe.dataToBuffer)(n, i.encoding);
    this.wrapAsync(this.writeFileBase, [e, s, f, d], l);
  }
  linkBase(e, n) {
    const a = Kr(e), c = this.getLink(a);
    if (!c)
      throw (0, Qe.createError)(en, "link", e, n);
    const u = Kr(n), r = this.getLinkParent(u);
    if (!r)
      throw (0, Qe.createError)(en, "link", e, n);
    const l = u[u.length - 1];
    if (r.getChild(l))
      throw (0, Qe.createError)(Sa, "link", e, n);
    const i = c.getNode();
    i.nlink++, r.createChild(l, i);
  }
  copyFileBase(e, n, a) {
    const c = this.readFileSync(e);
    if (a & x5 && this.existsSync(n))
      throw (0, Qe.createError)(Sa, "copyFile", e, n);
    if (a & P5)
      throw (0, Qe.createError)(L5, "copyFile", e, n);
    this.writeFileBase(
      n,
      c,
      Xl.FLAGS.w,
      438
      /* MODE.DEFAULT */
    );
  }
  copyFileSync(e, n, a) {
    const c = (0, Qe.pathToFilename)(e), u = (0, Qe.pathToFilename)(n);
    return this.copyFileBase(c, u, (a || 0) | 0);
  }
  copyFile(e, n, a, c) {
    const u = (0, Qe.pathToFilename)(e), r = (0, Qe.pathToFilename)(n);
    let l, i;
    typeof a == "function" ? (l = 0, i = a) : (l = a, i = c), (0, Qe.validateCallback)(i), this.wrapAsync(this.copyFileBase, [u, r, l], i);
  }
  linkSync(e, n) {
    const a = (0, Qe.pathToFilename)(e), c = (0, Qe.pathToFilename)(n);
    this.linkBase(a, c);
  }
  link(e, n, a) {
    const c = (0, Qe.pathToFilename)(e), u = (0, Qe.pathToFilename)(n);
    this.wrapAsync(this.linkBase, [c, u], a);
  }
  unlinkBase(e) {
    const n = Kr(e), a = this.getLink(n);
    if (!a)
      throw (0, Qe.createError)(en, "unlink", e);
    if (a.length)
      throw Error("Dir not empty...");
    this.deleteLink(a);
    const c = a.getNode();
    c.nlink--, c.nlink <= 0 && this.deleteNode(c);
  }
  unlinkSync(e) {
    const n = (0, Qe.pathToFilename)(e);
    this.unlinkBase(n);
  }
  unlink(e, n) {
    const a = (0, Qe.pathToFilename)(e);
    this.wrapAsync(this.unlinkBase, [a], n);
  }
  symlinkBase(e, n) {
    const a = Kr(n), c = this.getLinkParent(a);
    if (!c)
      throw (0, Qe.createError)(en, "symlink", e, n);
    const u = a[a.length - 1];
    if (c.getChild(u))
      throw (0, Qe.createError)(Sa, "symlink", e, n);
    const r = c.createChild(u);
    return r.getNode().makeSymlink(Kr(e)), r;
  }
  // `type` argument works only on Windows.
  symlinkSync(e, n, a) {
    const c = (0, Qe.pathToFilename)(e), u = (0, Qe.pathToFilename)(n);
    this.symlinkBase(c, u);
  }
  symlink(e, n, a, c) {
    const u = (0, Qe.validateCallback)(typeof a == "function" ? a : c), r = (0, Qe.pathToFilename)(e), l = (0, Qe.pathToFilename)(n);
    this.wrapAsync(this.symlinkBase, [r, l], u);
  }
  realpathBase(e, n) {
    const a = Kr(e), c = this.getResolvedLink(a);
    if (!c)
      throw (0, Qe.createError)(en, "realpath", e);
    return (0, Zs.strToEncoding)(c.getPath() || "/", n);
  }
  realpathSync(e, n) {
    return this.realpathBase((0, Qe.pathToFilename)(e), (0, dr.getRealpathOptions)(n).encoding);
  }
  realpath(e, n, a) {
    const [c, u] = (0, dr.getRealpathOptsAndCb)(n, a), r = (0, Qe.pathToFilename)(e);
    this.wrapAsync(this.realpathBase, [r, c.encoding], u);
  }
  lstatBase(e, n = !1, a = !1) {
    const c = this.getLink(Kr(e));
    if (c)
      return Sh.default.build(c.getNode(), n);
    if (a)
      throw (0, Qe.createError)(en, "lstat", e);
  }
  lstatSync(e, n) {
    const { throwIfNoEntry: a = !0, bigint: c = !1 } = (0, dr.getStatOptions)(n);
    return this.lstatBase((0, Qe.pathToFilename)(e), c, a);
  }
  lstat(e, n, a) {
    const [{ throwIfNoEntry: c = !0, bigint: u = !1 }, r] = (0, dr.getStatOptsAndCb)(n, a);
    this.wrapAsync(this.lstatBase, [(0, Qe.pathToFilename)(e), u, c], r);
  }
  statBase(e, n = !1, a = !0) {
    const c = this.getResolvedLink(Kr(e));
    if (c)
      return Sh.default.build(c.getNode(), n);
    if (a)
      throw (0, Qe.createError)(en, "stat", e);
  }
  statSync(e, n) {
    const { bigint: a = !0, throwIfNoEntry: c = !0 } = (0, dr.getStatOptions)(n);
    return this.statBase((0, Qe.pathToFilename)(e), a, c);
  }
  stat(e, n, a) {
    const [{ bigint: c = !1, throwIfNoEntry: u = !0 }, r] = (0, dr.getStatOptsAndCb)(n, a);
    this.wrapAsync(this.statBase, [(0, Qe.pathToFilename)(e), c, u], r);
  }
  fstatBase(e, n = !1) {
    const a = this.getFileByFd(e);
    if (!a)
      throw (0, Qe.createError)(wh, "fstat");
    return Sh.default.build(a.node, n);
  }
  fstatSync(e, n) {
    return this.fstatBase(e, (0, dr.getStatOptions)(n).bigint);
  }
  fstat(e, n, a) {
    const [c, u] = (0, dr.getStatOptsAndCb)(n, a);
    this.wrapAsync(this.fstatBase, [e, c.bigint], u);
  }
  renameBase(e, n) {
    const a = this.getLink(Kr(e));
    if (!a)
      throw (0, Qe.createError)(en, "rename", e, n);
    const c = Kr(n), u = this.getLinkParent(c);
    if (!u)
      throw (0, Qe.createError)(en, "rename", e, n);
    const r = a.parent;
    r && r.deleteChild(a);
    const l = c[c.length - 1];
    a.name = l, a.steps = [...u.steps, l], u.setChild(a.getName(), a);
  }
  renameSync(e, n) {
    const a = (0, Qe.pathToFilename)(e), c = (0, Qe.pathToFilename)(n);
    this.renameBase(a, c);
  }
  rename(e, n, a) {
    const c = (0, Qe.pathToFilename)(e), u = (0, Qe.pathToFilename)(n);
    this.wrapAsync(this.renameBase, [c, u], a);
  }
  existsBase(e) {
    return !!this.statBase(e);
  }
  existsSync(e) {
    try {
      return this.existsBase((0, Qe.pathToFilename)(e));
    } catch {
      return !1;
    }
  }
  exists(e, n) {
    const a = (0, Qe.pathToFilename)(e);
    if (typeof n != "function")
      throw Error(Xl.ERRSTR.CB);
    (0, uo.default)(() => {
      try {
        n(this.existsBase(a));
      } catch {
        n(!1);
      }
    });
  }
  accessBase(e, n) {
    this.getLinkOrThrow(e, "access");
  }
  accessSync(e, n = Lv) {
    const a = (0, Qe.pathToFilename)(e);
    n = n | 0, this.accessBase(a, n);
  }
  access(e, n, a) {
    let c = Lv, u;
    typeof n != "function" ? (c = n | 0, u = (0, Qe.validateCallback)(a)) : u = n;
    const r = (0, Qe.pathToFilename)(e);
    this.wrapAsync(this.accessBase, [r, c], u);
  }
  appendFileSync(e, n, a) {
    const c = (0, dr.getAppendFileOpts)(a);
    (!c.flag || (0, Qe.isFd)(e)) && (c.flag = "a"), this.writeFileSync(e, n, c);
  }
  appendFile(e, n, a, c) {
    const [u, r] = (0, dr.getAppendFileOptsAndCb)(a, c);
    (!u.flag || (0, Qe.isFd)(e)) && (u.flag = "a"), this.writeFile(e, n, u, r);
  }
  readdirBase(e, n) {
    const a = Kr(e), c = this.getResolvedLink(a);
    if (!c)
      throw (0, Qe.createError)(en, "readdir", e);
    if (!c.getNode().isDirectory())
      throw (0, Qe.createError)(co, "scandir", e);
    if (n.withFileTypes) {
      const l = [];
      for (const i of c.children.keys()) {
        const f = c.getChild(i);
        !f || i === "." || i === ".." || l.push(m5.default.build(f, n.encoding));
      }
      return !Qe.isWin && n.encoding !== "buffer" && l.sort((i, f) => i.name < f.name ? -1 : i.name > f.name ? 1 : 0), l;
    }
    const r = [];
    for (const l of c.children.keys())
      l === "." || l === ".." || r.push((0, Zs.strToEncoding)(l, n.encoding));
    return !Qe.isWin && n.encoding !== "buffer" && r.sort(), r;
  }
  readdirSync(e, n) {
    const a = (0, dr.getReaddirOptions)(n), c = (0, Qe.pathToFilename)(e);
    return this.readdirBase(c, a);
  }
  readdir(e, n, a) {
    const [c, u] = (0, dr.getReaddirOptsAndCb)(n, a), r = (0, Qe.pathToFilename)(e);
    this.wrapAsync(this.readdirBase, [r, c], u);
  }
  readlinkBase(e, n) {
    const c = this.getLinkOrThrow(e, "readlink").getNode();
    if (!c.isSymlink())
      throw (0, Qe.createError)(D5, "readlink", e);
    const u = ki + c.symlink.join(ki);
    return (0, Zs.strToEncoding)(u, n);
  }
  readlinkSync(e, n) {
    const a = (0, dr.getDefaultOpts)(n), c = (0, Qe.pathToFilename)(e);
    return this.readlinkBase(c, a.encoding);
  }
  readlink(e, n, a) {
    const [c, u] = (0, dr.getDefaultOptsAndCb)(n, a), r = (0, Qe.pathToFilename)(e);
    this.wrapAsync(this.readlinkBase, [r, c.encoding], u);
  }
  fsyncBase(e) {
    this.getFileByFdOrThrow(e, "fsync");
  }
  fsyncSync(e) {
    this.fsyncBase(e);
  }
  fsync(e, n) {
    this.wrapAsync(this.fsyncBase, [e], n);
  }
  fdatasyncBase(e) {
    this.getFileByFdOrThrow(e, "fdatasync");
  }
  fdatasyncSync(e) {
    this.fdatasyncBase(e);
  }
  fdatasync(e, n) {
    this.wrapAsync(this.fdatasyncBase, [e], n);
  }
  ftruncateBase(e, n) {
    this.getFileByFdOrThrow(e, "ftruncate").truncate(n);
  }
  ftruncateSync(e, n) {
    this.ftruncateBase(e, n);
  }
  ftruncate(e, n, a) {
    const c = typeof n == "number" ? n : 0, u = (0, Qe.validateCallback)(typeof n == "number" ? a : n);
    this.wrapAsync(this.ftruncateBase, [e, c], u);
  }
  truncateBase(e, n) {
    const a = this.openSync(e, "r+");
    try {
      this.ftruncateSync(a, n);
    } finally {
      this.closeSync(a);
    }
  }
  /**
   * `id` should be a file descriptor or a path. `id` as file descriptor will
   * not be supported soon.
   */
  truncateSync(e, n) {
    if ((0, Qe.isFd)(e))
      return this.ftruncateSync(e, n);
    this.truncateBase(e, n);
  }
  truncate(e, n, a) {
    const c = typeof n == "number" ? n : 0, u = (0, Qe.validateCallback)(typeof n == "number" ? a : n);
    if ((0, Qe.isFd)(e))
      return this.ftruncate(e, c, u);
    this.wrapAsync(this.truncateBase, [e, c], u);
  }
  futimesBase(e, n, a) {
    const u = this.getFileByFdOrThrow(e, "futimes").node;
    u.atime = new Date(n * 1e3), u.mtime = new Date(a * 1e3);
  }
  futimesSync(e, n, a) {
    this.futimesBase(e, Is(n), Is(a));
  }
  futimes(e, n, a, c) {
    this.wrapAsync(this.futimesBase, [e, Is(n), Is(a)], c);
  }
  utimesBase(e, n, a) {
    const c = this.openSync(e, "r");
    try {
      this.futimesBase(c, n, a);
    } finally {
      this.closeSync(c);
    }
  }
  utimesSync(e, n, a) {
    this.utimesBase((0, Qe.pathToFilename)(e), Is(n), Is(a));
  }
  utimes(e, n, a, c) {
    this.wrapAsync(this.utimesBase, [(0, Qe.pathToFilename)(e), Is(n), Is(a)], c);
  }
  mkdirBase(e, n) {
    const a = Kr(e);
    if (!a.length)
      throw (0, Qe.createError)(Sa, "mkdir", e);
    const c = this.getLinkParentAsDirOrThrow(e, "mkdir"), u = a[a.length - 1];
    if (c.getChild(u))
      throw (0, Qe.createError)(Sa, "mkdir", e);
    c.createChild(u, this.createNode(!0, n));
  }
  /**
   * Creates directory tree recursively.
   * @param filename
   * @param modeNum
   */
  mkdirpBase(e, n) {
    const a = nu(e), c = a.substring(1), u = c ? c.split(ki) : [];
    let r = this.root, l = !1;
    for (let i = 0; i < u.length; i++) {
      const f = u[i];
      if (!r.getNode().isDirectory())
        throw (0, Qe.createError)(co, "mkdir", r.getPath());
      const d = r.getChild(f);
      if (d)
        if (d.getNode().isDirectory())
          r = d;
        else
          throw (0, Qe.createError)(co, "mkdir", d.getPath());
      else
        r = r.createChild(f, this.createNode(!0, n)), l = !0;
    }
    return l ? a : void 0;
  }
  mkdirSync(e, n) {
    const a = (0, dr.getMkdirOptions)(n), c = (0, Qe.modeToNumber)(a.mode, 511), u = (0, Qe.pathToFilename)(e);
    if (a.recursive)
      return this.mkdirpBase(u, c);
    this.mkdirBase(u, c);
  }
  mkdir(e, n, a) {
    const c = (0, dr.getMkdirOptions)(n), u = (0, Qe.validateCallback)(typeof n == "function" ? n : a), r = (0, Qe.modeToNumber)(c.mode, 511), l = (0, Qe.pathToFilename)(e);
    c.recursive ? this.wrapAsync(this.mkdirpBase, [l, r], u) : this.wrapAsync(this.mkdirBase, [l, r], u);
  }
  mkdtempBase(e, n, a = 5) {
    const c = e + (0, Qe.genRndStr6)();
    try {
      return this.mkdirBase(
        c,
        511
        /* MODE.DIR */
      ), (0, Zs.strToEncoding)(c, n);
    } catch (u) {
      if (u.code === Sa) {
        if (a > 1)
          return this.mkdtempBase(e, n, a - 1);
        throw Error("Could not create temp dir.");
      } else
        throw u;
    }
  }
  mkdtempSync(e, n) {
    const { encoding: a } = (0, dr.getDefaultOpts)(n);
    if (!e || typeof e != "string")
      throw new TypeError("filename prefix is required");
    return (0, Qe.nullCheck)(e), this.mkdtempBase(e, a);
  }
  mkdtemp(e, n, a) {
    const [{ encoding: c }, u] = (0, dr.getDefaultOptsAndCb)(n, a);
    if (!e || typeof e != "string")
      throw new TypeError("filename prefix is required");
    (0, Qe.nullCheck)(e) && this.wrapAsync(this.mkdtempBase, [e, c], u);
  }
  rmdirBase(e, n) {
    const a = (0, dr.getRmdirOptions)(n), c = this.getLinkAsDirOrThrow(e, "rmdir");
    if (c.length && !a.recursive)
      throw (0, Qe.createError)(M5, "rmdir", e);
    this.deleteLink(c);
  }
  rmdirSync(e, n) {
    this.rmdirBase((0, Qe.pathToFilename)(e), n);
  }
  rmdir(e, n, a) {
    const c = (0, dr.getRmdirOptions)(n), u = (0, Qe.validateCallback)(typeof n == "function" ? n : a);
    this.wrapAsync(this.rmdirBase, [(0, Qe.pathToFilename)(e), c], u);
  }
  rmBase(e, n = {}) {
    const a = this.getResolvedLink(e);
    if (!a) {
      if (!n.force)
        throw (0, Qe.createError)(en, "stat", e);
      return;
    }
    if (a.getNode().isDirectory() && !n.recursive)
      throw (0, Qe.createError)(j5, "rm", e);
    this.deleteLink(a);
  }
  rmSync(e, n) {
    this.rmBase((0, Qe.pathToFilename)(e), n);
  }
  rm(e, n, a) {
    const [c, u] = (0, dr.getRmOptsAndCb)(n, a);
    this.wrapAsync(this.rmBase, [(0, Qe.pathToFilename)(e), c], u);
  }
  fchmodBase(e, n) {
    this.getFileByFdOrThrow(e, "fchmod").chmod(n);
  }
  fchmodSync(e, n) {
    this.fchmodBase(e, (0, Qe.modeToNumber)(n));
  }
  fchmod(e, n, a) {
    this.wrapAsync(this.fchmodBase, [e, (0, Qe.modeToNumber)(n)], a);
  }
  chmodBase(e, n) {
    const a = this.openSync(e, "r");
    try {
      this.fchmodBase(a, n);
    } finally {
      this.closeSync(a);
    }
  }
  chmodSync(e, n) {
    const a = (0, Qe.modeToNumber)(n), c = (0, Qe.pathToFilename)(e);
    this.chmodBase(c, a);
  }
  chmod(e, n, a) {
    const c = (0, Qe.modeToNumber)(n), u = (0, Qe.pathToFilename)(e);
    this.wrapAsync(this.chmodBase, [u, c], a);
  }
  lchmodBase(e, n) {
    const a = this.openBase(e, Nv, 0, !1);
    try {
      this.fchmodBase(a, n);
    } finally {
      this.closeSync(a);
    }
  }
  lchmodSync(e, n) {
    const a = (0, Qe.modeToNumber)(n), c = (0, Qe.pathToFilename)(e);
    this.lchmodBase(c, a);
  }
  lchmod(e, n, a) {
    const c = (0, Qe.modeToNumber)(n), u = (0, Qe.pathToFilename)(e);
    this.wrapAsync(this.lchmodBase, [u, c], a);
  }
  fchownBase(e, n, a) {
    this.getFileByFdOrThrow(e, "fchown").chown(n, a);
  }
  fchownSync(e, n, a) {
    fo(n), po(a), this.fchownBase(e, n, a);
  }
  fchown(e, n, a, c) {
    fo(n), po(a), this.wrapAsync(this.fchownBase, [e, n, a], c);
  }
  chownBase(e, n, a) {
    this.getResolvedLinkOrThrow(e, "chown").getNode().chown(n, a);
  }
  chownSync(e, n, a) {
    fo(n), po(a), this.chownBase((0, Qe.pathToFilename)(e), n, a);
  }
  chown(e, n, a, c) {
    fo(n), po(a), this.wrapAsync(this.chownBase, [(0, Qe.pathToFilename)(e), n, a], c);
  }
  lchownBase(e, n, a) {
    this.getLinkOrThrow(e, "lchown").getNode().chown(n, a);
  }
  lchownSync(e, n, a) {
    fo(n), po(a), this.lchownBase((0, Qe.pathToFilename)(e), n, a);
  }
  lchown(e, n, a, c) {
    fo(n), po(a), this.wrapAsync(this.lchownBase, [(0, Qe.pathToFilename)(e), n, a], c);
  }
  watchFile(e, n, a) {
    const c = (0, Qe.pathToFilename)(e);
    let u = n, r = a;
    if (typeof u == "function" && (r = n, u = null), typeof r != "function")
      throw Error('"watchFile()" requires a listener function');
    let l = 5007, i = !0;
    u && typeof u == "object" && (typeof u.interval == "number" && (l = u.interval), typeof u.persistent == "boolean" && (i = u.persistent));
    let f = this.statWatchers[c];
    return f || (f = new this.StatWatcher(), f.start(c, i, l), this.statWatchers[c] = f), f.addListener("change", r), f;
  }
  unwatchFile(e, n) {
    const a = (0, Qe.pathToFilename)(e), c = this.statWatchers[a];
    c && (typeof n == "function" ? c.removeListener("change", n) : c.removeAllListeners("change"), c.listenerCount("change") === 0 && (c.stop(), delete this.statWatchers[a]));
  }
  createReadStream(e, n) {
    return new this.ReadStream(e, n);
  }
  createWriteStream(e, n) {
    return new this.WriteStream(e, n);
  }
  // watch(path: PathLike): FSWatcher;
  // watch(path: PathLike, options?: IWatchOptions | string): FSWatcher;
  watch(e, n, a) {
    const c = (0, Qe.pathToFilename)(e);
    let u = n;
    typeof n == "function" && (a = n, u = null);
    let { persistent: r, recursive: l, encoding: i } = (0, dr.getDefaultOpts)(u);
    r === void 0 && (r = !0), l === void 0 && (l = !1);
    const f = new this.FSWatcher();
    return f.start(c, r, l, i), a && f.addListener("change", a), f;
  }
}
ln.Volume = Co;
Co.fd = 2147483647;
function V5(t) {
  t.emit("stop");
}
class qw extends Ww.EventEmitter {
  constructor(e) {
    super(), this.onInterval = () => {
      try {
        const n = this.vol.statSync(this.filename);
        this.hasChanged(n) && (this.emit("change", n, this.prev), this.prev = n);
      } finally {
        this.loop();
      }
    }, this.vol = e;
  }
  loop() {
    this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
  }
  hasChanged(e) {
    return e.mtimeMs > this.prev.mtimeMs || e.nlink !== this.prev.nlink;
  }
  start(e, n = !0, a = 5007) {
    this.filename = (0, Qe.pathToFilename)(e), this.setTimeout = n ? setTimeout.bind(typeof globalThis < "u" ? globalThis : Bt) : y5.default, this.interval = a, this.prev = this.vol.statSync(this.filename), this.loop();
  }
  stop() {
    clearTimeout(this.timeoutRef), (0, bd.default)(() => {
      V5.call(this, this);
    });
  }
}
ln.StatWatcher = qw;
var si;
function W5(t) {
  si = (0, la.bufferAllocUnsafe)(t), si.used = 0;
}
Hw.inherits(ps, gd.Readable);
ln.ReadStream = ps;
function ps(t, e, n) {
  if (!(this instanceof ps))
    return new ps(t, e, n);
  if (this._vol = t, n = Object.assign({}, (0, dr.getOptions)(n, {})), n.highWaterMark === void 0 && (n.highWaterMark = 64 * 1024), gd.Readable.call(this, n), this.path = (0, Qe.pathToFilename)(e), this.fd = n.fd === void 0 ? null : n.fd, this.flags = n.flags === void 0 ? "r" : n.flags, this.mode = n.mode === void 0 ? 438 : n.mode, this.start = n.start, this.end = n.end, this.autoClose = n.autoClose === void 0 ? !0 : n.autoClose, this.pos = void 0, this.bytesRead = 0, this.start !== void 0) {
    if (typeof this.start != "number")
      throw new TypeError('"start" option must be a Number');
    if (this.end === void 0)
      this.end = 1 / 0;
    else if (typeof this.end != "number")
      throw new TypeError('"end" option must be a Number');
    if (this.start > this.end)
      throw new Error('"start" option must be <= "end" option');
    this.pos = this.start;
  }
  typeof this.fd != "number" && this.open(), this.on("end", function() {
    this.autoClose && this.destroy && this.destroy();
  });
}
ps.prototype.open = function() {
  var t = this;
  this._vol.open(this.path, this.flags, this.mode, (e, n) => {
    if (e) {
      t.autoClose && t.destroy && t.destroy(), t.emit("error", e);
      return;
    }
    t.fd = n, t.emit("open", n), t.read();
  });
};
ps.prototype._read = function(t) {
  if (typeof this.fd != "number")
    return this.once("open", function() {
      this._read(t);
    });
  if (this.destroyed)
    return;
  (!si || si.length - si.used < O5) && W5(this._readableState.highWaterMark);
  var e = si, n = Math.min(si.length - si.used, t), a = si.used;
  if (this.pos !== void 0 && (n = Math.min(this.end - this.pos + 1, n)), n <= 0)
    return this.push(null);
  var c = this;
  this._vol.read(this.fd, si, si.used, n, this.pos, u), this.pos !== void 0 && (this.pos += n), si.used += n;
  function u(r, l) {
    if (r)
      c.autoClose && c.destroy && c.destroy(), c.emit("error", r);
    else {
      var i = null;
      l > 0 && (c.bytesRead += l, i = e.slice(a, a + l)), c.push(i);
    }
  }
};
ps.prototype._destroy = function(t, e) {
  this.close((n) => {
    e(t || n);
  });
};
ps.prototype.close = function(t) {
  var e;
  if (t && this.once("close", t), this.closed || typeof this.fd != "number") {
    if (typeof this.fd != "number") {
      this.once("open", Gw);
      return;
    }
    return (0, bd.default)(() => this.emit("close"));
  }
  typeof ((e = this._readableState) === null || e === void 0 ? void 0 : e.closed) == "boolean" ? this._readableState.closed = !0 : this.closed = !0, this._vol.close(this.fd, (n) => {
    n ? this.emit("error", n) : this.emit("close");
  }), this.fd = null;
};
function Gw(t) {
  this.close();
}
Hw.inherits(yi, gd.Writable);
ln.WriteStream = yi;
function yi(t, e, n) {
  if (!(this instanceof yi))
    return new yi(t, e, n);
  if (this._vol = t, n = Object.assign({}, (0, dr.getOptions)(n, {})), gd.Writable.call(this, n), this.path = (0, Qe.pathToFilename)(e), this.fd = n.fd === void 0 ? null : n.fd, this.flags = n.flags === void 0 ? "w" : n.flags, this.mode = n.mode === void 0 ? 438 : n.mode, this.start = n.start, this.autoClose = n.autoClose === void 0 ? !0 : !!n.autoClose, this.pos = void 0, this.bytesWritten = 0, this.pending = !0, this.start !== void 0) {
    if (typeof this.start != "number")
      throw new TypeError('"start" option must be a Number');
    if (this.start < 0)
      throw new Error('"start" must be >= zero');
    this.pos = this.start;
  }
  n.encoding && this.setDefaultEncoding(n.encoding), typeof this.fd != "number" && this.open(), this.once("finish", function() {
    this.autoClose && this.close();
  });
}
yi.prototype.open = function() {
  this._vol.open(this.path, this.flags, this.mode, (function(t, e) {
    if (t) {
      this.autoClose && this.destroy && this.destroy(), this.emit("error", t);
      return;
    }
    this.fd = e, this.pending = !1, this.emit("open", e);
  }).bind(this));
};
yi.prototype._write = function(t, e, n) {
  if (!(t instanceof la.Buffer || t instanceof Uint8Array))
    return this.emit("error", new Error("Invalid data"));
  if (typeof this.fd != "number")
    return this.once("open", function() {
      this._write(t, e, n);
    });
  var a = this;
  this._vol.write(this.fd, t, 0, t.length, this.pos, (c, u) => {
    if (c)
      return a.autoClose && a.destroy && a.destroy(), n(c);
    a.bytesWritten += u, n();
  }), this.pos !== void 0 && (this.pos += t.length);
};
yi.prototype._writev = function(t, e) {
  if (typeof this.fd != "number")
    return this.once("open", function() {
      this._writev(t, e);
    });
  const n = this, a = t.length, c = new Array(a);
  for (var u = 0, r = 0; r < a; r++) {
    var l = t[r].chunk;
    c[r] = l, u += l.length;
  }
  const i = la.Buffer.concat(c);
  this._vol.write(this.fd, i, 0, i.length, this.pos, (f, d) => {
    if (f)
      return n.destroy && n.destroy(), e(f);
    n.bytesWritten += d, e();
  }), this.pos !== void 0 && (this.pos += u);
};
yi.prototype.close = function(t) {
  var e;
  if (t && this.once("close", t), this.closed || typeof this.fd != "number") {
    if (typeof this.fd != "number") {
      this.once("open", Gw);
      return;
    }
    return (0, bd.default)(() => this.emit("close"));
  }
  typeof ((e = this._writableState) === null || e === void 0 ? void 0 : e.closed) == "boolean" ? this._writableState.closed = !0 : this.closed = !0, this._vol.close(this.fd, (n) => {
    n ? this.emit("error", n) : this.emit("close");
  }), this.fd = null;
};
yi.prototype._destroy = ps.prototype._destroy;
yi.prototype.destroySoon = yi.prototype.end;
class zw extends Ww.EventEmitter {
  constructor(e) {
    super(), this._filename = "", this._filenameEncoded = "", this._recursive = !1, this._encoding = Zs.ENCODING_UTF8, this._listenerRemovers = /* @__PURE__ */ new Map(), this._onParentChild = (n) => {
      n.getName() === this._getName() && this._emit("rename");
    }, this._emit = (n) => {
      this.emit("change", n, this._filenameEncoded);
    }, this._persist = () => {
      this._timer = setTimeout(this._persist, 1e6);
    }, this._vol = e;
  }
  _getName() {
    return this._steps[this._steps.length - 1];
  }
  start(e, n = !0, a = !1, c = Zs.ENCODING_UTF8) {
    this._filename = (0, Qe.pathToFilename)(e), this._steps = Kr(this._filename), this._filenameEncoded = (0, Zs.strToEncoding)(this._filename), this._recursive = a, this._encoding = c;
    try {
      this._link = this._vol.getLinkOrThrow(this._filename, "FSWatcher");
    } catch (i) {
      const f = new Error(`watch ${this._filename} ${i.code}`);
      throw f.code = i.code, f.errno = i.code, f;
    }
    const u = (i) => {
      var f;
      const d = i.getPath(), s = i.getNode(), o = () => {
        let h = Jl(this._filename, d);
        return h || (h = this._getName()), this.emit("change", "change", h);
      };
      s.on("change", o);
      const m = (f = this._listenerRemovers.get(s.ino)) !== null && f !== void 0 ? f : [];
      m.push(() => s.removeListener("change", o)), this._listenerRemovers.set(s.ino, m);
    }, r = (i) => {
      var f;
      const d = i.getNode(), s = (h) => {
        this.emit("change", "rename", Jl(this._filename, h.getPath())), setTimeout(() => {
          u(h), r(h);
        });
      }, o = (h) => {
        const y = (b) => {
          const E = b.getNode().ino, S = this._listenerRemovers.get(E);
          S && (S.forEach((g) => g()), this._listenerRemovers.delete(E));
          for (const [g, P] of b.children.entries())
            P && g !== "." && g !== ".." && y(P);
        };
        y(h), this.emit("change", "rename", Jl(this._filename, h.getPath()));
      };
      for (const [h, y] of i.children.entries())
        y && h !== "." && h !== ".." && u(y);
      if (i.on("child:add", s), i.on("child:delete", o), ((f = this._listenerRemovers.get(d.ino)) !== null && f !== void 0 ? f : []).push(() => {
        i.removeListener("child:add", s), i.removeListener("child:delete", o);
      }), a)
        for (const [h, y] of i.children.entries())
          y && h !== "." && h !== ".." && r(y);
    };
    u(this._link), r(this._link);
    const l = this._link.parent;
    l && (l.setMaxListeners(l.getMaxListeners() + 1), l.on("child:delete", this._onParentChild)), n && this._persist();
  }
  close() {
    clearTimeout(this._timer), this._listenerRemovers.forEach((n) => {
      n.forEach((a) => a());
    }), this._listenerRemovers.clear();
    const e = this._link.parent;
    e && e.removeListener("child:delete", this._onParentChild);
  }
}
ln.FSWatcher = zw;
var vd = {};
Object.defineProperty(vd, "__esModule", { value: !0 });
vd.fsSynchronousApiList = void 0;
vd.fsSynchronousApiList = [
  "accessSync",
  "appendFileSync",
  "chmodSync",
  "chownSync",
  "closeSync",
  "copyFileSync",
  "existsSync",
  "fchmodSync",
  "fchownSync",
  "fdatasyncSync",
  "fstatSync",
  "fsyncSync",
  "ftruncateSync",
  "futimesSync",
  "lchmodSync",
  "lchownSync",
  "linkSync",
  "lstatSync",
  "mkdirSync",
  "mkdtempSync",
  "openSync",
  "readdirSync",
  "readFileSync",
  "readlinkSync",
  "readSync",
  "readvSync",
  "realpathSync",
  "renameSync",
  "rmdirSync",
  "rmSync",
  "statSync",
  "symlinkSync",
  "truncateSync",
  "unlinkSync",
  "utimesSync",
  "writeFileSync",
  "writeSync",
  "writevSync"
  // 'cpSync',
  // 'lutimesSync',
  // 'statfsSync',
];
var Ed = {};
Object.defineProperty(Ed, "__esModule", { value: !0 });
Ed.fsCallbackApiList = void 0;
Ed.fsCallbackApiList = [
  "access",
  "appendFile",
  "chmod",
  "chown",
  "close",
  "copyFile",
  "createReadStream",
  "createWriteStream",
  "exists",
  "fchmod",
  "fchown",
  "fdatasync",
  "fstat",
  "fsync",
  "ftruncate",
  "futimes",
  "lchmod",
  "lchown",
  "link",
  "lstat",
  "mkdir",
  "mkdtemp",
  "open",
  "read",
  "readv",
  "readdir",
  "readFile",
  "readlink",
  "realpath",
  "rename",
  "rm",
  "rmdir",
  "stat",
  "symlink",
  "truncate",
  "unlink",
  "unwatchFile",
  "utimes",
  "watch",
  "watchFile",
  "write",
  "writev",
  "writeFile"
];
(function(t, e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.memfs = e.fs = e.createFsFromVolume = e.vol = e.Volume = void 0;
  const n = Ka, a = Jo, c = ln, u = Es, r = vd, l = Ed, { F_OK: i, R_OK: f, W_OK: d, X_OK: s } = u.constants;
  e.Volume = c.Volume, e.vol = new c.Volume();
  function o(h) {
    const y = { F_OK: i, R_OK: f, W_OK: d, X_OK: s, constants: u.constants, Stats: n.default, Dirent: a.default };
    for (const b of r.fsSynchronousApiList)
      typeof h[b] == "function" && (y[b] = h[b].bind(h));
    for (const b of l.fsCallbackApiList)
      typeof h[b] == "function" && (y[b] = h[b].bind(h));
    return y.StatWatcher = h.StatWatcher, y.FSWatcher = h.FSWatcher, y.WriteStream = h.WriteStream, y.ReadStream = h.ReadStream, y.promises = h.promises, y._toUnixTimestamp = c.toUnixTimestamp, y.__vol = h, y;
  }
  e.createFsFromVolume = o, e.fs = o(e.vol);
  const m = (h = {}, y = "/") => {
    const b = e.Volume.fromNestedJSON(h, y);
    return { fs: o(b), vol: b };
  };
  e.memfs = m, t.exports = Object.assign(Object.assign({}, t.exports), e.fs), t.exports.semantic = !0;
})(Fm, Fm.exports);
var Dn = Fm.exports;
class H5 {
  constructor(e = {}) {
    if (!(e.maxSize && e.maxSize > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    if (typeof e.maxAge == "number" && e.maxAge === 0)
      throw new TypeError("`maxAge` must be a number greater than 0");
    this.maxSize = e.maxSize, this.maxAge = e.maxAge || 1 / 0, this.onEviction = e.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
  }
  _emitEvictions(e) {
    if (typeof this.onEviction == "function")
      for (const [n, a] of e)
        this.onEviction(n, a.value);
  }
  _deleteIfExpired(e, n) {
    return typeof n.expiry == "number" && n.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(e, n.value), this.delete(e)) : !1;
  }
  _getOrDeleteIfExpired(e, n) {
    if (this._deleteIfExpired(e, n) === !1)
      return n.value;
  }
  _getItemValue(e, n) {
    return n.expiry ? this._getOrDeleteIfExpired(e, n) : n.value;
  }
  _peek(e, n) {
    const a = n.get(e);
    return this._getItemValue(e, a);
  }
  _set(e, n) {
    this.cache.set(e, n), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map());
  }
  _moveToRecent(e, n) {
    this.oldCache.delete(e), this._set(e, n);
  }
  *_entriesAscending() {
    for (const e of this.oldCache) {
      const [n, a] = e;
      this.cache.has(n) || this._deleteIfExpired(n, a) === !1 && (yield e);
    }
    for (const e of this.cache) {
      const [n, a] = e;
      this._deleteIfExpired(n, a) === !1 && (yield e);
    }
  }
  get(e) {
    if (this.cache.has(e)) {
      const n = this.cache.get(e);
      return this._getItemValue(e, n);
    }
    if (this.oldCache.has(e)) {
      const n = this.oldCache.get(e);
      if (this._deleteIfExpired(e, n) === !1)
        return this._moveToRecent(e, n), n.value;
    }
  }
  set(e, n, { maxAge: a = this.maxAge === 1 / 0 ? void 0 : Date.now() + this.maxAge } = {}) {
    this.cache.has(e) ? this.cache.set(e, {
      value: n,
      maxAge: a
    }) : this._set(e, { value: n, expiry: a });
  }
  has(e) {
    return this.cache.has(e) ? !this._deleteIfExpired(e, this.cache.get(e)) : this.oldCache.has(e) ? !this._deleteIfExpired(e, this.oldCache.get(e)) : !1;
  }
  peek(e) {
    if (this.cache.has(e))
      return this._peek(e, this.cache);
    if (this.oldCache.has(e))
      return this._peek(e, this.oldCache);
  }
  delete(e) {
    const n = this.cache.delete(e);
    return n && this._size--, this.oldCache.delete(e) || n;
  }
  clear() {
    this.cache.clear(), this.oldCache.clear(), this._size = 0;
  }
  resize(e) {
    if (!(e && e > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    const n = [...this._entriesAscending()], a = n.length - e;
    a < 0 ? (this.cache = new Map(n), this.oldCache = /* @__PURE__ */ new Map(), this._size = n.length) : (a > 0 && this._emitEvictions(n.slice(0, a)), this.oldCache = new Map(n.slice(a)), this.cache = /* @__PURE__ */ new Map(), this._size = 0), this.maxSize = e;
  }
  *keys() {
    for (const [e] of this)
      yield e;
  }
  *values() {
    for (const [, e] of this)
      yield e;
  }
  *[Symbol.iterator]() {
    for (const e of this.cache) {
      const [n, a] = e;
      this._deleteIfExpired(n, a) === !1 && (yield [n, a.value]);
    }
    for (const e of this.oldCache) {
      const [n, a] = e;
      this.cache.has(n) || this._deleteIfExpired(n, a) === !1 && (yield [n, a.value]);
    }
  }
  *entriesDescending() {
    let e = [...this.cache];
    for (let n = e.length - 1; n >= 0; --n) {
      const a = e[n], [c, u] = a;
      this._deleteIfExpired(c, u) === !1 && (yield [c, u.value]);
    }
    e = [...this.oldCache];
    for (let n = e.length - 1; n >= 0; --n) {
      const a = e[n], [c, u] = a;
      this.cache.has(c) || this._deleteIfExpired(c, u) === !1 && (yield [c, u.value]);
    }
  }
  *entriesAscending() {
    for (const [e, n] of this._entriesAscending())
      yield [e, n.value];
  }
  get size() {
    if (!this._size)
      return this.oldCache.size;
    let e = 0;
    for (const n of this.oldCache.keys())
      this.cache.has(n) || e++;
    return Math.min(this._size + e, this.maxSize);
  }
}
var Kw = H5, Yw = {};
function $l(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Xw = { exports: {} };
(function(t, e) {
  (function(n) {
    t.exports = n();
  })(function() {
    return function n(a, c, u) {
      function r(f, d) {
        if (!c[f]) {
          if (!a[f]) {
            var s = typeof $l == "function" && $l;
            if (!d && s)
              return s(f, !0);
            if (l)
              return l(f, !0);
            throw new Error("Cannot find module '" + f + "'");
          }
          d = c[f] = { exports: {} }, a[f][0].call(d.exports, function(o) {
            var m = a[f][1][o];
            return r(m || o);
          }, d, d.exports, n, a, c, u);
        }
        return c[f].exports;
      }
      for (var l = typeof $l == "function" && $l, i = 0; i < u.length; i++)
        r(u[i]);
      return r;
    }({ 1: [function(n, a, c) {
      (function(u, r, l, i, f, d, s, o, m) {
        var h = n("crypto");
        function y(N, C) {
          C = S(N, C);
          var I;
          return (I = C.algorithm !== "passthrough" ? h.createHash(C.algorithm) : new R()).write === void 0 && (I.write = I.update, I.end = I.update), P(C, I).dispatch(N), I.update || I.end(""), I.digest ? I.digest(C.encoding === "buffer" ? void 0 : C.encoding) : (N = I.read(), C.encoding !== "buffer" ? N.toString(C.encoding) : N);
        }
        (c = a.exports = y).sha1 = function(N) {
          return y(N);
        }, c.keys = function(N) {
          return y(N, { excludeValues: !0, algorithm: "sha1", encoding: "hex" });
        }, c.MD5 = function(N) {
          return y(N, { algorithm: "md5", encoding: "hex" });
        }, c.keysMD5 = function(N) {
          return y(N, { algorithm: "md5", encoding: "hex", excludeValues: !0 });
        };
        var b = h.getHashes ? h.getHashes().slice() : ["sha1", "md5"], E = (b.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
        function S(N, C) {
          var I = {};
          if (I.algorithm = (C = C || {}).algorithm || "sha1", I.encoding = C.encoding || "hex", I.excludeValues = !!C.excludeValues, I.algorithm = I.algorithm.toLowerCase(), I.encoding = I.encoding.toLowerCase(), I.ignoreUnknown = C.ignoreUnknown === !0, I.respectType = C.respectType !== !1, I.respectFunctionNames = C.respectFunctionNames !== !1, I.respectFunctionProperties = C.respectFunctionProperties !== !1, I.unorderedArrays = C.unorderedArrays === !0, I.unorderedSets = C.unorderedSets !== !1, I.unorderedObjects = C.unorderedObjects !== !1, I.replacer = C.replacer || void 0, I.excludeKeys = C.excludeKeys || void 0, N === void 0)
            throw new Error("Object argument required.");
          for (var D = 0; D < b.length; ++D)
            b[D].toLowerCase() === I.algorithm.toLowerCase() && (I.algorithm = b[D]);
          if (b.indexOf(I.algorithm) === -1)
            throw new Error('Algorithm "' + I.algorithm + '"  not supported. supported values: ' + b.join(", "));
          if (E.indexOf(I.encoding) === -1 && I.algorithm !== "passthrough")
            throw new Error('Encoding "' + I.encoding + '"  not supported. supported values: ' + E.join(", "));
          return I;
        }
        function g(N) {
          if (typeof N == "function")
            return /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(N)) != null;
        }
        function P(N, C, I) {
          I = I || [];
          function D(j) {
            return C.update ? C.update(j, "utf8") : C.write(j, "utf8");
          }
          return { dispatch: function(j) {
            return this["_" + ((j = N.replacer ? N.replacer(j) : j) === null ? "null" : typeof j)](j);
          }, _object: function(j) {
            var F, _ = Object.prototype.toString.call(j), T = /\[object (.*)\]/i.exec(_);
            if (T = (T = T ? T[1] : "unknown:[" + _ + "]").toLowerCase(), 0 <= (_ = I.indexOf(j)))
              return this.dispatch("[CIRCULAR:" + _ + "]");
            if (I.push(j), l !== void 0 && l.isBuffer && l.isBuffer(j))
              return D("buffer:"), D(j);
            if (T === "object" || T === "function" || T === "asyncfunction")
              return _ = Object.keys(j), N.unorderedObjects && (_ = _.sort()), N.respectType === !1 || g(j) || _.splice(0, 0, "prototype", "__proto__", "constructor"), N.excludeKeys && (_ = _.filter(function(v) {
                return !N.excludeKeys(v);
              })), D("object:" + _.length + ":"), F = this, _.forEach(function(v) {
                F.dispatch(v), D(":"), N.excludeValues || F.dispatch(j[v]), D(",");
              });
            if (!this["_" + T]) {
              if (N.ignoreUnknown)
                return D("[" + T + "]");
              throw new Error('Unknown object type "' + T + '"');
            }
            this["_" + T](j);
          }, _array: function(j, v) {
            v = v !== void 0 ? v : N.unorderedArrays !== !1;
            var _ = this;
            if (D("array:" + j.length + ":"), !v || j.length <= 1)
              return j.forEach(function(w) {
                return _.dispatch(w);
              });
            var T = [], v = j.map(function(w) {
              var O = new R(), G = I.slice();
              return P(N, O, G).dispatch(w), T = T.concat(G.slice(I.length)), O.read().toString();
            });
            return I = I.concat(T), v.sort(), this._array(v, !1);
          }, _date: function(j) {
            return D("date:" + j.toJSON());
          }, _symbol: function(j) {
            return D("symbol:" + j.toString());
          }, _error: function(j) {
            return D("error:" + j.toString());
          }, _boolean: function(j) {
            return D("bool:" + j.toString());
          }, _string: function(j) {
            D("string:" + j.length + ":"), D(j.toString());
          }, _function: function(j) {
            D("fn:"), g(j) ? this.dispatch("[native]") : this.dispatch(j.toString()), N.respectFunctionNames !== !1 && this.dispatch("function-name:" + String(j.name)), N.respectFunctionProperties && this._object(j);
          }, _number: function(j) {
            return D("number:" + j.toString());
          }, _xml: function(j) {
            return D("xml:" + j.toString());
          }, _null: function() {
            return D("Null");
          }, _undefined: function() {
            return D("Undefined");
          }, _regexp: function(j) {
            return D("regex:" + j.toString());
          }, _uint8array: function(j) {
            return D("uint8array:"), this.dispatch(Array.prototype.slice.call(j));
          }, _uint8clampedarray: function(j) {
            return D("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(j));
          }, _int8array: function(j) {
            return D("int8array:"), this.dispatch(Array.prototype.slice.call(j));
          }, _uint16array: function(j) {
            return D("uint16array:"), this.dispatch(Array.prototype.slice.call(j));
          }, _int16array: function(j) {
            return D("int16array:"), this.dispatch(Array.prototype.slice.call(j));
          }, _uint32array: function(j) {
            return D("uint32array:"), this.dispatch(Array.prototype.slice.call(j));
          }, _int32array: function(j) {
            return D("int32array:"), this.dispatch(Array.prototype.slice.call(j));
          }, _float32array: function(j) {
            return D("float32array:"), this.dispatch(Array.prototype.slice.call(j));
          }, _float64array: function(j) {
            return D("float64array:"), this.dispatch(Array.prototype.slice.call(j));
          }, _arraybuffer: function(j) {
            return D("arraybuffer:"), this.dispatch(new Uint8Array(j));
          }, _url: function(j) {
            return D("url:" + j.toString());
          }, _map: function(j) {
            return D("map:"), j = Array.from(j), this._array(j, N.unorderedSets !== !1);
          }, _set: function(j) {
            return D("set:"), j = Array.from(j), this._array(j, N.unorderedSets !== !1);
          }, _file: function(j) {
            return D("file:"), this.dispatch([j.name, j.size, j.type, j.lastModfied]);
          }, _blob: function() {
            if (N.ignoreUnknown)
              return D("[blob]");
            throw Error(`Hashing Blob objects is currently not supported
(see https://github.com/puleos/object-hash/issues/26)
Use "options.replacer" or "options.ignoreUnknown"
`);
          }, _domwindow: function() {
            return D("domwindow");
          }, _bigint: function(j) {
            return D("bigint:" + j.toString());
          }, _process: function() {
            return D("process");
          }, _timer: function() {
            return D("timer");
          }, _pipe: function() {
            return D("pipe");
          }, _tcp: function() {
            return D("tcp");
          }, _udp: function() {
            return D("udp");
          }, _tty: function() {
            return D("tty");
          }, _statwatcher: function() {
            return D("statwatcher");
          }, _securecontext: function() {
            return D("securecontext");
          }, _connection: function() {
            return D("connection");
          }, _zlib: function() {
            return D("zlib");
          }, _context: function() {
            return D("context");
          }, _nodescript: function() {
            return D("nodescript");
          }, _httpparser: function() {
            return D("httpparser");
          }, _dataview: function() {
            return D("dataview");
          }, _signal: function() {
            return D("signal");
          }, _fsevent: function() {
            return D("fsevent");
          }, _tlswrap: function() {
            return D("tlswrap");
          } };
        }
        function R() {
          return { buf: "", write: function(N) {
            this.buf += N;
          }, end: function(N) {
            this.buf += N;
          }, read: function() {
            return this.buf;
          } };
        }
        c.writeToStream = function(N, C, I) {
          return I === void 0 && (I = C, C = {}), P(C = S(N, C), I).dispatch(N);
        };
      }).call(this, n("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, n("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
    }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(n, a, c) {
      (function(u, r, l, i, f, d, s, o, m) {
        (function(h) {
          var y = typeof Uint8Array < "u" ? Uint8Array : Array, b = "+".charCodeAt(0), E = "/".charCodeAt(0), S = "0".charCodeAt(0), g = "a".charCodeAt(0), P = "A".charCodeAt(0), R = "-".charCodeAt(0), N = "_".charCodeAt(0);
          function C(I) {
            return I = I.charCodeAt(0), I === b || I === R ? 62 : I === E || I === N ? 63 : I < S ? -1 : I < S + 10 ? I - S + 26 + 26 : I < P + 26 ? I - P : I < g + 26 ? I - g + 26 : void 0;
          }
          h.toByteArray = function(I) {
            var D, j;
            if (0 < I.length % 4)
              throw new Error("Invalid string. Length must be a multiple of 4");
            var F = I.length, F = I.charAt(F - 2) === "=" ? 2 : I.charAt(F - 1) === "=" ? 1 : 0, _ = new y(3 * I.length / 4 - F), T = 0 < F ? I.length - 4 : I.length, v = 0;
            function w(O) {
              _[v++] = O;
            }
            for (D = 0; D < T; D += 4, 0)
              w((16711680 & (j = C(I.charAt(D)) << 18 | C(I.charAt(D + 1)) << 12 | C(I.charAt(D + 2)) << 6 | C(I.charAt(D + 3)))) >> 16), w((65280 & j) >> 8), w(255 & j);
            return F == 2 ? w(255 & (j = C(I.charAt(D)) << 2 | C(I.charAt(D + 1)) >> 4)) : F == 1 && (w((j = C(I.charAt(D)) << 10 | C(I.charAt(D + 1)) << 4 | C(I.charAt(D + 2)) >> 2) >> 8 & 255), w(255 & j)), _;
          }, h.fromByteArray = function(I) {
            var D, j, F, _, T = I.length % 3, v = "";
            function w(O) {
              return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(O);
            }
            for (D = 0, F = I.length - T; D < F; D += 3)
              j = (I[D] << 16) + (I[D + 1] << 8) + I[D + 2], v += w((_ = j) >> 18 & 63) + w(_ >> 12 & 63) + w(_ >> 6 & 63) + w(63 & _);
            switch (T) {
              case 1:
                v = (v += w((j = I[I.length - 1]) >> 2)) + w(j << 4 & 63) + "==";
                break;
              case 2:
                v = (v = (v += w((j = (I[I.length - 2] << 8) + I[I.length - 1]) >> 10)) + w(j >> 4 & 63)) + w(j << 2 & 63) + "=";
            }
            return v;
          };
        })(c === void 0 ? this.base64js = {} : c);
      }).call(this, n("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, n("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
    }, { buffer: 3, lYpoI2: 11 }], 3: [function(n, a, c) {
      (function(u, r, b, i, f, d, s, o, m) {
        var h = n("base64-js"), y = n("ieee754");
        function b(H, Q, X) {
          if (!(this instanceof b))
            return new b(H, Q, X);
          var ne, ye, ve, de, oe = typeof H;
          if (Q === "base64" && oe == "string")
            for (H = (de = H).trim ? de.trim() : de.replace(/^\s+|\s+$/g, ""); H.length % 4 != 0; )
              H += "=";
          if (oe == "number")
            ne = W(H);
          else if (oe == "string")
            ne = b.byteLength(H, Q);
          else {
            if (oe != "object")
              throw new Error("First argument needs to be a number, array or string.");
            ne = W(H.length);
          }
          if (b._useTypedArrays ? ye = b._augment(new Uint8Array(ne)) : ((ye = this).length = ne, ye._isBuffer = !0), b._useTypedArrays && typeof H.byteLength == "number")
            ye._set(H);
          else if (U(de = H) || b.isBuffer(de) || de && typeof de == "object" && typeof de.length == "number")
            for (ve = 0; ve < ne; ve++)
              b.isBuffer(H) ? ye[ve] = H.readUInt8(ve) : ye[ve] = H[ve];
          else if (oe == "string")
            ye.write(H, 0, Q);
          else if (oe == "number" && !b._useTypedArrays && !X)
            for (ve = 0; ve < ne; ve++)
              ye[ve] = 0;
          return ye;
        }
        function E(H, Q, X, ne) {
          return b._charsWritten = K(function(ye) {
            for (var ve = [], de = 0; de < ye.length; de++)
              ve.push(255 & ye.charCodeAt(de));
            return ve;
          }(Q), H, X, ne);
        }
        function S(H, Q, X, ne) {
          return b._charsWritten = K(function(ye) {
            for (var ve, de, oe = [], re = 0; re < ye.length; re++)
              de = ye.charCodeAt(re), ve = de >> 8, de = de % 256, oe.push(de), oe.push(ve);
            return oe;
          }(Q), H, X, ne);
        }
        function g(H, Q, X) {
          var ne = "";
          X = Math.min(H.length, X);
          for (var ye = Q; ye < X; ye++)
            ne += String.fromCharCode(H[ye]);
          return ne;
        }
        function P(H, Q, X, ve) {
          ve || (Y(typeof X == "boolean", "missing or invalid endian"), Y(Q != null, "missing offset"), Y(Q + 1 < H.length, "Trying to read beyond buffer length"));
          var ye, ve = H.length;
          if (!(ve <= Q))
            return X ? (ye = H[Q], Q + 1 < ve && (ye |= H[Q + 1] << 8)) : (ye = H[Q] << 8, Q + 1 < ve && (ye |= H[Q + 1])), ye;
        }
        function R(H, Q, X, ve) {
          ve || (Y(typeof X == "boolean", "missing or invalid endian"), Y(Q != null, "missing offset"), Y(Q + 3 < H.length, "Trying to read beyond buffer length"));
          var ye, ve = H.length;
          if (!(ve <= Q))
            return X ? (Q + 2 < ve && (ye = H[Q + 2] << 16), Q + 1 < ve && (ye |= H[Q + 1] << 8), ye |= H[Q], Q + 3 < ve && (ye += H[Q + 3] << 24 >>> 0)) : (Q + 1 < ve && (ye = H[Q + 1] << 16), Q + 2 < ve && (ye |= H[Q + 2] << 8), Q + 3 < ve && (ye |= H[Q + 3]), ye += H[Q] << 24 >>> 0), ye;
        }
        function N(H, Q, X, ne) {
          if (ne || (Y(typeof X == "boolean", "missing or invalid endian"), Y(Q != null, "missing offset"), Y(Q + 1 < H.length, "Trying to read beyond buffer length")), !(H.length <= Q))
            return ne = P(H, Q, X, !0), 32768 & ne ? -1 * (65535 - ne + 1) : ne;
        }
        function C(H, Q, X, ne) {
          if (ne || (Y(typeof X == "boolean", "missing or invalid endian"), Y(Q != null, "missing offset"), Y(Q + 3 < H.length, "Trying to read beyond buffer length")), !(H.length <= Q))
            return ne = R(H, Q, X, !0), 2147483648 & ne ? -1 * (4294967295 - ne + 1) : ne;
        }
        function I(H, Q, X, ne) {
          return ne || (Y(typeof X == "boolean", "missing or invalid endian"), Y(Q + 3 < H.length, "Trying to read beyond buffer length")), y.read(H, Q, X, 23, 4);
        }
        function D(H, Q, X, ne) {
          return ne || (Y(typeof X == "boolean", "missing or invalid endian"), Y(Q + 7 < H.length, "Trying to read beyond buffer length")), y.read(H, Q, X, 52, 8);
        }
        function j(H, Q, X, ne, ye) {
          if (ye || (Y(Q != null, "missing value"), Y(typeof ne == "boolean", "missing or invalid endian"), Y(X != null, "missing offset"), Y(X + 1 < H.length, "trying to write beyond buffer length"), z(Q, 65535)), ye = H.length, !(ye <= X))
            for (var ve = 0, de = Math.min(ye - X, 2); ve < de; ve++)
              H[X + ve] = (Q & 255 << 8 * (ne ? ve : 1 - ve)) >>> 8 * (ne ? ve : 1 - ve);
        }
        function F(H, Q, X, ne, ye) {
          if (ye || (Y(Q != null, "missing value"), Y(typeof ne == "boolean", "missing or invalid endian"), Y(X != null, "missing offset"), Y(X + 3 < H.length, "trying to write beyond buffer length"), z(Q, 4294967295)), ye = H.length, !(ye <= X))
            for (var ve = 0, de = Math.min(ye - X, 4); ve < de; ve++)
              H[X + ve] = Q >>> 8 * (ne ? ve : 3 - ve) & 255;
        }
        function _(H, Q, X, ne, ye) {
          ye || (Y(Q != null, "missing value"), Y(typeof ne == "boolean", "missing or invalid endian"), Y(X != null, "missing offset"), Y(X + 1 < H.length, "Trying to write beyond buffer length"), q(Q, 32767, -32768)), H.length <= X || j(H, 0 <= Q ? Q : 65535 + Q + 1, X, ne, ye);
        }
        function T(H, Q, X, ne, ye) {
          ye || (Y(Q != null, "missing value"), Y(typeof ne == "boolean", "missing or invalid endian"), Y(X != null, "missing offset"), Y(X + 3 < H.length, "Trying to write beyond buffer length"), q(Q, 2147483647, -2147483648)), H.length <= X || F(H, 0 <= Q ? Q : 4294967295 + Q + 1, X, ne, ye);
        }
        function v(H, Q, X, ne, ye) {
          ye || (Y(Q != null, "missing value"), Y(typeof ne == "boolean", "missing or invalid endian"), Y(X != null, "missing offset"), Y(X + 3 < H.length, "Trying to write beyond buffer length"), $(Q, 34028234663852886e22, -34028234663852886e22)), H.length <= X || y.write(H, Q, X, ne, 23, 4);
        }
        function w(H, Q, X, ne, ye) {
          ye || (Y(Q != null, "missing value"), Y(typeof ne == "boolean", "missing or invalid endian"), Y(X != null, "missing offset"), Y(X + 7 < H.length, "Trying to write beyond buffer length"), $(Q, 17976931348623157e292, -17976931348623157e292)), H.length <= X || y.write(H, Q, X, ne, 52, 8);
        }
        c.Buffer = b, c.SlowBuffer = b, c.INSPECT_MAX_BYTES = 50, b.poolSize = 8192, b._useTypedArrays = function() {
          try {
            var H = new ArrayBuffer(0), Q = new Uint8Array(H);
            return Q.foo = function() {
              return 42;
            }, Q.foo() === 42 && typeof Q.subarray == "function";
          } catch {
            return !1;
          }
        }(), b.isEncoding = function(H) {
          switch (String(H).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "raw":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1;
          }
        }, b.isBuffer = function(H) {
          return !(H == null || !H._isBuffer);
        }, b.byteLength = function(H, Q) {
          var X;
          switch (H += "", Q || "utf8") {
            case "hex":
              X = H.length / 2;
              break;
            case "utf8":
            case "utf-8":
              X = B(H).length;
              break;
            case "ascii":
            case "binary":
            case "raw":
              X = H.length;
              break;
            case "base64":
              X = k(H).length;
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              X = 2 * H.length;
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return X;
        }, b.concat = function(H, Q) {
          if (Y(U(H), `Usage: Buffer.concat(list, [totalLength])
list should be an Array.`), H.length === 0)
            return new b(0);
          if (H.length === 1)
            return H[0];
          if (typeof Q != "number")
            for (ye = Q = 0; ye < H.length; ye++)
              Q += H[ye].length;
          for (var X = new b(Q), ne = 0, ye = 0; ye < H.length; ye++) {
            var ve = H[ye];
            ve.copy(X, ne), ne += ve.length;
          }
          return X;
        }, b.prototype.write = function(H, Q, X, ne) {
          isFinite(Q) ? isFinite(X) || (ne = X, X = void 0) : (re = ne, ne = Q, Q = X, X = re), Q = Number(Q) || 0;
          var ye, ve, de, oe, re = this.length - Q;
          switch ((!X || re < (X = Number(X))) && (X = re), ne = String(ne || "utf8").toLowerCase()) {
            case "hex":
              ye = function(ae, le, ue, ie) {
                ue = Number(ue) || 0;
                var we = ae.length - ue;
                (!ie || we < (ie = Number(ie))) && (ie = we), Y((we = le.length) % 2 == 0, "Invalid hex string"), we / 2 < ie && (ie = we / 2);
                for (var De = 0; De < ie; De++) {
                  var Ee = parseInt(le.substr(2 * De, 2), 16);
                  Y(!isNaN(Ee), "Invalid hex string"), ae[ue + De] = Ee;
                }
                return b._charsWritten = 2 * De, De;
              }(this, H, Q, X);
              break;
            case "utf8":
            case "utf-8":
              ve = this, de = Q, oe = X, ye = b._charsWritten = K(B(H), ve, de, oe);
              break;
            case "ascii":
            case "binary":
              ye = E(this, H, Q, X);
              break;
            case "base64":
              ve = this, de = Q, oe = X, ye = b._charsWritten = K(k(H), ve, de, oe);
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              ye = S(this, H, Q, X);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return ye;
        }, b.prototype.toString = function(H, Q, X) {
          var ne, ye, ve, de, oe = this;
          if (H = String(H || "utf8").toLowerCase(), Q = Number(Q) || 0, (X = X !== void 0 ? Number(X) : oe.length) === Q)
            return "";
          switch (H) {
            case "hex":
              ne = function(re, ae, le) {
                var ue = re.length;
                (!ae || ae < 0) && (ae = 0), (!le || le < 0 || ue < le) && (le = ue);
                for (var ie = "", we = ae; we < le; we++)
                  ie += M(re[we]);
                return ie;
              }(oe, Q, X);
              break;
            case "utf8":
            case "utf-8":
              ne = function(re, ae, le) {
                var ue = "", ie = "";
                le = Math.min(re.length, le);
                for (var we = ae; we < le; we++)
                  re[we] <= 127 ? (ue += te(ie) + String.fromCharCode(re[we]), ie = "") : ie += "%" + re[we].toString(16);
                return ue + te(ie);
              }(oe, Q, X);
              break;
            case "ascii":
            case "binary":
              ne = g(oe, Q, X);
              break;
            case "base64":
              ye = oe, de = X, ne = (ve = Q) === 0 && de === ye.length ? h.fromByteArray(ye) : h.fromByteArray(ye.slice(ve, de));
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              ne = function(re, ae, le) {
                for (var ue = re.slice(ae, le), ie = "", we = 0; we < ue.length; we += 2)
                  ie += String.fromCharCode(ue[we] + 256 * ue[we + 1]);
                return ie;
              }(oe, Q, X);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return ne;
        }, b.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        }, b.prototype.copy = function(H, Q, X, ne) {
          if (Q = Q || 0, (ne = ne || ne === 0 ? ne : this.length) !== (X = X || 0) && H.length !== 0 && this.length !== 0) {
            Y(X <= ne, "sourceEnd < sourceStart"), Y(0 <= Q && Q < H.length, "targetStart out of bounds"), Y(0 <= X && X < this.length, "sourceStart out of bounds"), Y(0 <= ne && ne <= this.length, "sourceEnd out of bounds"), ne > this.length && (ne = this.length);
            var ye = (ne = H.length - Q < ne - X ? H.length - Q + X : ne) - X;
            if (ye < 100 || !b._useTypedArrays)
              for (var ve = 0; ve < ye; ve++)
                H[ve + Q] = this[ve + X];
            else
              H._set(this.subarray(X, X + ye), Q);
          }
        }, b.prototype.slice = function(H, Q) {
          var X = this.length;
          if (H = G(H, X, 0), Q = G(Q, X, X), b._useTypedArrays)
            return b._augment(this.subarray(H, Q));
          for (var ne = Q - H, ye = new b(ne, void 0, !0), ve = 0; ve < ne; ve++)
            ye[ve] = this[ve + H];
          return ye;
        }, b.prototype.get = function(H) {
          return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(H);
        }, b.prototype.set = function(H, Q) {
          return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(H, Q);
        }, b.prototype.readUInt8 = function(H, Q) {
          if (Q || (Y(H != null, "missing offset"), Y(H < this.length, "Trying to read beyond buffer length")), !(H >= this.length))
            return this[H];
        }, b.prototype.readUInt16LE = function(H, Q) {
          return P(this, H, !0, Q);
        }, b.prototype.readUInt16BE = function(H, Q) {
          return P(this, H, !1, Q);
        }, b.prototype.readUInt32LE = function(H, Q) {
          return R(this, H, !0, Q);
        }, b.prototype.readUInt32BE = function(H, Q) {
          return R(this, H, !1, Q);
        }, b.prototype.readInt8 = function(H, Q) {
          if (Q || (Y(H != null, "missing offset"), Y(H < this.length, "Trying to read beyond buffer length")), !(H >= this.length))
            return 128 & this[H] ? -1 * (255 - this[H] + 1) : this[H];
        }, b.prototype.readInt16LE = function(H, Q) {
          return N(this, H, !0, Q);
        }, b.prototype.readInt16BE = function(H, Q) {
          return N(this, H, !1, Q);
        }, b.prototype.readInt32LE = function(H, Q) {
          return C(this, H, !0, Q);
        }, b.prototype.readInt32BE = function(H, Q) {
          return C(this, H, !1, Q);
        }, b.prototype.readFloatLE = function(H, Q) {
          return I(this, H, !0, Q);
        }, b.prototype.readFloatBE = function(H, Q) {
          return I(this, H, !1, Q);
        }, b.prototype.readDoubleLE = function(H, Q) {
          return D(this, H, !0, Q);
        }, b.prototype.readDoubleBE = function(H, Q) {
          return D(this, H, !1, Q);
        }, b.prototype.writeUInt8 = function(H, Q, X) {
          X || (Y(H != null, "missing value"), Y(Q != null, "missing offset"), Y(Q < this.length, "trying to write beyond buffer length"), z(H, 255)), Q >= this.length || (this[Q] = H);
        }, b.prototype.writeUInt16LE = function(H, Q, X) {
          j(this, H, Q, !0, X);
        }, b.prototype.writeUInt16BE = function(H, Q, X) {
          j(this, H, Q, !1, X);
        }, b.prototype.writeUInt32LE = function(H, Q, X) {
          F(this, H, Q, !0, X);
        }, b.prototype.writeUInt32BE = function(H, Q, X) {
          F(this, H, Q, !1, X);
        }, b.prototype.writeInt8 = function(H, Q, X) {
          X || (Y(H != null, "missing value"), Y(Q != null, "missing offset"), Y(Q < this.length, "Trying to write beyond buffer length"), q(H, 127, -128)), Q >= this.length || (0 <= H ? this.writeUInt8(H, Q, X) : this.writeUInt8(255 + H + 1, Q, X));
        }, b.prototype.writeInt16LE = function(H, Q, X) {
          _(this, H, Q, !0, X);
        }, b.prototype.writeInt16BE = function(H, Q, X) {
          _(this, H, Q, !1, X);
        }, b.prototype.writeInt32LE = function(H, Q, X) {
          T(this, H, Q, !0, X);
        }, b.prototype.writeInt32BE = function(H, Q, X) {
          T(this, H, Q, !1, X);
        }, b.prototype.writeFloatLE = function(H, Q, X) {
          v(this, H, Q, !0, X);
        }, b.prototype.writeFloatBE = function(H, Q, X) {
          v(this, H, Q, !1, X);
        }, b.prototype.writeDoubleLE = function(H, Q, X) {
          w(this, H, Q, !0, X);
        }, b.prototype.writeDoubleBE = function(H, Q, X) {
          w(this, H, Q, !1, X);
        }, b.prototype.fill = function(H, Q, X) {
          if (Q = Q || 0, X = X || this.length, Y(typeof (H = typeof (H = H || 0) == "string" ? H.charCodeAt(0) : H) == "number" && !isNaN(H), "value is not a number"), Y(Q <= X, "end < start"), X !== Q && this.length !== 0) {
            Y(0 <= Q && Q < this.length, "start out of bounds"), Y(0 <= X && X <= this.length, "end out of bounds");
            for (var ne = Q; ne < X; ne++)
              this[ne] = H;
          }
        }, b.prototype.inspect = function() {
          for (var H = [], Q = this.length, X = 0; X < Q; X++)
            if (H[X] = M(this[X]), X === c.INSPECT_MAX_BYTES) {
              H[X + 1] = "...";
              break;
            }
          return "<Buffer " + H.join(" ") + ">";
        }, b.prototype.toArrayBuffer = function() {
          if (typeof Uint8Array > "u")
            throw new Error("Buffer.toArrayBuffer not supported in this browser");
          if (b._useTypedArrays)
            return new b(this).buffer;
          for (var H = new Uint8Array(this.length), Q = 0, X = H.length; Q < X; Q += 1)
            H[Q] = this[Q];
          return H.buffer;
        };
        var O = b.prototype;
        function G(H, Q, X) {
          return typeof H != "number" ? X : Q <= (H = ~~H) ? Q : 0 <= H || 0 <= (H += Q) ? H : 0;
        }
        function W(H) {
          return (H = ~~Math.ceil(+H)) < 0 ? 0 : H;
        }
        function U(H) {
          return (Array.isArray || function(Q) {
            return Object.prototype.toString.call(Q) === "[object Array]";
          })(H);
        }
        function M(H) {
          return H < 16 ? "0" + H.toString(16) : H.toString(16);
        }
        function B(H) {
          for (var Q = [], X = 0; X < H.length; X++) {
            var ne = H.charCodeAt(X);
            if (ne <= 127)
              Q.push(H.charCodeAt(X));
            else
              for (var ye = X, ve = (55296 <= ne && ne <= 57343 && X++, encodeURIComponent(H.slice(ye, X + 1)).substr(1).split("%")), de = 0; de < ve.length; de++)
                Q.push(parseInt(ve[de], 16));
          }
          return Q;
        }
        function k(H) {
          return h.toByteArray(H);
        }
        function K(H, Q, X, ne) {
          for (var ye = 0; ye < ne && !(ye + X >= Q.length || ye >= H.length); ye++)
            Q[ye + X] = H[ye];
          return ye;
        }
        function te(H) {
          try {
            return decodeURIComponent(H);
          } catch {
            return String.fromCharCode(65533);
          }
        }
        function z(H, Q) {
          Y(typeof H == "number", "cannot write a non-number as a number"), Y(0 <= H, "specified a negative value for writing an unsigned value"), Y(H <= Q, "value is larger than maximum value for type"), Y(Math.floor(H) === H, "value has a fractional component");
        }
        function q(H, Q, X) {
          Y(typeof H == "number", "cannot write a non-number as a number"), Y(H <= Q, "value larger than maximum allowed value"), Y(X <= H, "value smaller than minimum allowed value"), Y(Math.floor(H) === H, "value has a fractional component");
        }
        function $(H, Q, X) {
          Y(typeof H == "number", "cannot write a non-number as a number"), Y(H <= Q, "value larger than maximum allowed value"), Y(X <= H, "value smaller than minimum allowed value");
        }
        function Y(H, Q) {
          if (!H)
            throw new Error(Q || "Failed assertion");
        }
        b._augment = function(H) {
          return H._isBuffer = !0, H._get = H.get, H._set = H.set, H.get = O.get, H.set = O.set, H.write = O.write, H.toString = O.toString, H.toLocaleString = O.toString, H.toJSON = O.toJSON, H.copy = O.copy, H.slice = O.slice, H.readUInt8 = O.readUInt8, H.readUInt16LE = O.readUInt16LE, H.readUInt16BE = O.readUInt16BE, H.readUInt32LE = O.readUInt32LE, H.readUInt32BE = O.readUInt32BE, H.readInt8 = O.readInt8, H.readInt16LE = O.readInt16LE, H.readInt16BE = O.readInt16BE, H.readInt32LE = O.readInt32LE, H.readInt32BE = O.readInt32BE, H.readFloatLE = O.readFloatLE, H.readFloatBE = O.readFloatBE, H.readDoubleLE = O.readDoubleLE, H.readDoubleBE = O.readDoubleBE, H.writeUInt8 = O.writeUInt8, H.writeUInt16LE = O.writeUInt16LE, H.writeUInt16BE = O.writeUInt16BE, H.writeUInt32LE = O.writeUInt32LE, H.writeUInt32BE = O.writeUInt32BE, H.writeInt8 = O.writeInt8, H.writeInt16LE = O.writeInt16LE, H.writeInt16BE = O.writeInt16BE, H.writeInt32LE = O.writeInt32LE, H.writeInt32BE = O.writeInt32BE, H.writeFloatLE = O.writeFloatLE, H.writeFloatBE = O.writeFloatBE, H.writeDoubleLE = O.writeDoubleLE, H.writeDoubleBE = O.writeDoubleBE, H.fill = O.fill, H.inspect = O.inspect, H.toArrayBuffer = O.toArrayBuffer, H;
        };
      }).call(this, n("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, n("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
    }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(n, a, c) {
      (function(u, r, h, i, f, d, s, o, m) {
        var h = n("buffer").Buffer, y = 4, b = new h(y);
        b.fill(0), a.exports = { hash: function(E, S, g, P) {
          for (var R = S(function(j, F) {
            j.length % y != 0 && (_ = j.length + (y - j.length % y), j = h.concat([j, b], _));
            for (var _, T = [], v = F ? j.readInt32BE : j.readInt32LE, w = 0; w < j.length; w += y)
              T.push(v.call(j, w));
            return T;
          }(E = h.isBuffer(E) ? E : new h(E), P), 8 * E.length), S = P, N = new h(g), C = S ? N.writeInt32BE : N.writeInt32LE, I = 0; I < R.length; I++)
            C.call(N, R[I], 4 * I, !0);
          return N;
        } };
      }).call(this, n("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, n("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 11 }], 5: [function(n, a, c) {
      (function(u, r, h, i, f, d, s, o, m) {
        var h = n("buffer").Buffer, y = n("./sha"), b = n("./sha256"), E = n("./rng"), S = { sha1: y, sha256: b, md5: n("./md5") }, g = 64, P = new h(g);
        function R(j, F) {
          var _ = S[j = j || "sha1"], T = [];
          return _ || N("algorithm:", j, "is not yet supported"), { update: function(v) {
            return h.isBuffer(v) || (v = new h(v)), T.push(v), v.length, this;
          }, digest: function(v) {
            var w = h.concat(T), w = F ? function(O, G, W) {
              h.isBuffer(G) || (G = new h(G)), h.isBuffer(W) || (W = new h(W)), G.length > g ? G = O(G) : G.length < g && (G = h.concat([G, P], g));
              for (var U = new h(g), M = new h(g), B = 0; B < g; B++)
                U[B] = 54 ^ G[B], M[B] = 92 ^ G[B];
              return W = O(h.concat([U, W])), O(h.concat([M, W]));
            }(_, F, w) : _(w);
            return T = null, v ? w.toString(v) : w;
          } };
        }
        function N() {
          var j = [].slice.call(arguments).join(" ");
          throw new Error([j, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join(`
`));
        }
        P.fill(0), c.createHash = function(j) {
          return R(j);
        }, c.createHmac = R, c.randomBytes = function(j, F) {
          if (!F || !F.call)
            return new h(E(j));
          try {
            F.call(this, void 0, new h(E(j)));
          } catch (_) {
            F(_);
          }
        };
        var C, I = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], D = function(j) {
          c[j] = function() {
            N("sorry,", j, "is not implemented yet");
          };
        };
        for (C in I)
          D(I[C]);
      }).call(this, n("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, n("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(n, a, c) {
      (function(u, r, l, i, f, d, s, o, m) {
        var h = n("./helpers");
        function y(N, C) {
          N[C >> 5] |= 128 << C % 32, N[14 + (C + 64 >>> 9 << 4)] = C;
          for (var I = 1732584193, D = -271733879, j = -1732584194, F = 271733878, _ = 0; _ < N.length; _ += 16) {
            var T = I, v = D, w = j, O = F, I = E(I, D, j, F, N[_ + 0], 7, -680876936), F = E(F, I, D, j, N[_ + 1], 12, -389564586), j = E(j, F, I, D, N[_ + 2], 17, 606105819), D = E(D, j, F, I, N[_ + 3], 22, -1044525330);
            I = E(I, D, j, F, N[_ + 4], 7, -176418897), F = E(F, I, D, j, N[_ + 5], 12, 1200080426), j = E(j, F, I, D, N[_ + 6], 17, -1473231341), D = E(D, j, F, I, N[_ + 7], 22, -45705983), I = E(I, D, j, F, N[_ + 8], 7, 1770035416), F = E(F, I, D, j, N[_ + 9], 12, -1958414417), j = E(j, F, I, D, N[_ + 10], 17, -42063), D = E(D, j, F, I, N[_ + 11], 22, -1990404162), I = E(I, D, j, F, N[_ + 12], 7, 1804603682), F = E(F, I, D, j, N[_ + 13], 12, -40341101), j = E(j, F, I, D, N[_ + 14], 17, -1502002290), I = S(I, D = E(D, j, F, I, N[_ + 15], 22, 1236535329), j, F, N[_ + 1], 5, -165796510), F = S(F, I, D, j, N[_ + 6], 9, -1069501632), j = S(j, F, I, D, N[_ + 11], 14, 643717713), D = S(D, j, F, I, N[_ + 0], 20, -373897302), I = S(I, D, j, F, N[_ + 5], 5, -701558691), F = S(F, I, D, j, N[_ + 10], 9, 38016083), j = S(j, F, I, D, N[_ + 15], 14, -660478335), D = S(D, j, F, I, N[_ + 4], 20, -405537848), I = S(I, D, j, F, N[_ + 9], 5, 568446438), F = S(F, I, D, j, N[_ + 14], 9, -1019803690), j = S(j, F, I, D, N[_ + 3], 14, -187363961), D = S(D, j, F, I, N[_ + 8], 20, 1163531501), I = S(I, D, j, F, N[_ + 13], 5, -1444681467), F = S(F, I, D, j, N[_ + 2], 9, -51403784), j = S(j, F, I, D, N[_ + 7], 14, 1735328473), I = g(I, D = S(D, j, F, I, N[_ + 12], 20, -1926607734), j, F, N[_ + 5], 4, -378558), F = g(F, I, D, j, N[_ + 8], 11, -2022574463), j = g(j, F, I, D, N[_ + 11], 16, 1839030562), D = g(D, j, F, I, N[_ + 14], 23, -35309556), I = g(I, D, j, F, N[_ + 1], 4, -1530992060), F = g(F, I, D, j, N[_ + 4], 11, 1272893353), j = g(j, F, I, D, N[_ + 7], 16, -155497632), D = g(D, j, F, I, N[_ + 10], 23, -1094730640), I = g(I, D, j, F, N[_ + 13], 4, 681279174), F = g(F, I, D, j, N[_ + 0], 11, -358537222), j = g(j, F, I, D, N[_ + 3], 16, -722521979), D = g(D, j, F, I, N[_ + 6], 23, 76029189), I = g(I, D, j, F, N[_ + 9], 4, -640364487), F = g(F, I, D, j, N[_ + 12], 11, -421815835), j = g(j, F, I, D, N[_ + 15], 16, 530742520), I = P(I, D = g(D, j, F, I, N[_ + 2], 23, -995338651), j, F, N[_ + 0], 6, -198630844), F = P(F, I, D, j, N[_ + 7], 10, 1126891415), j = P(j, F, I, D, N[_ + 14], 15, -1416354905), D = P(D, j, F, I, N[_ + 5], 21, -57434055), I = P(I, D, j, F, N[_ + 12], 6, 1700485571), F = P(F, I, D, j, N[_ + 3], 10, -1894986606), j = P(j, F, I, D, N[_ + 10], 15, -1051523), D = P(D, j, F, I, N[_ + 1], 21, -2054922799), I = P(I, D, j, F, N[_ + 8], 6, 1873313359), F = P(F, I, D, j, N[_ + 15], 10, -30611744), j = P(j, F, I, D, N[_ + 6], 15, -1560198380), D = P(D, j, F, I, N[_ + 13], 21, 1309151649), I = P(I, D, j, F, N[_ + 4], 6, -145523070), F = P(F, I, D, j, N[_ + 11], 10, -1120210379), j = P(j, F, I, D, N[_ + 2], 15, 718787259), D = P(D, j, F, I, N[_ + 9], 21, -343485551), I = R(I, T), D = R(D, v), j = R(j, w), F = R(F, O);
          }
          return Array(I, D, j, F);
        }
        function b(N, C, I, D, j, F) {
          return R((C = R(R(C, N), R(D, F))) << j | C >>> 32 - j, I);
        }
        function E(N, C, I, D, j, F, _) {
          return b(C & I | ~C & D, N, C, j, F, _);
        }
        function S(N, C, I, D, j, F, _) {
          return b(C & D | I & ~D, N, C, j, F, _);
        }
        function g(N, C, I, D, j, F, _) {
          return b(C ^ I ^ D, N, C, j, F, _);
        }
        function P(N, C, I, D, j, F, _) {
          return b(I ^ (C | ~D), N, C, j, F, _);
        }
        function R(N, C) {
          var I = (65535 & N) + (65535 & C);
          return (N >> 16) + (C >> 16) + (I >> 16) << 16 | 65535 & I;
        }
        a.exports = function(N) {
          return h.hash(N, y, 16);
        };
      }).call(this, n("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, n("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(n, a, c) {
      (function(u, r, l, i, f, d, s, o, m) {
        a.exports = function(h) {
          for (var y, b = new Array(h), E = 0; E < h; E++)
            !(3 & E) && (y = 4294967296 * Math.random()), b[E] = y >>> ((3 & E) << 3) & 255;
          return b;
        };
      }).call(this, n("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, n("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 11 }], 8: [function(n, a, c) {
      (function(u, r, l, i, f, d, s, o, m) {
        var h = n("./helpers");
        function y(S, g) {
          S[g >> 5] |= 128 << 24 - g % 32, S[15 + (g + 64 >> 9 << 4)] = g;
          for (var P, R, N, C = Array(80), I = 1732584193, D = -271733879, j = -1732584194, F = 271733878, _ = -1009589776, T = 0; T < S.length; T += 16) {
            for (var v = I, w = D, O = j, G = F, W = _, U = 0; U < 80; U++) {
              C[U] = U < 16 ? S[T + U] : E(C[U - 3] ^ C[U - 8] ^ C[U - 14] ^ C[U - 16], 1);
              var M = b(b(E(I, 5), (M = D, R = j, N = F, (P = U) < 20 ? M & R | ~M & N : !(P < 40) && P < 60 ? M & R | M & N | R & N : M ^ R ^ N)), b(b(_, C[U]), (P = U) < 20 ? 1518500249 : P < 40 ? 1859775393 : P < 60 ? -1894007588 : -899497514)), _ = F, F = j, j = E(D, 30), D = I, I = M;
            }
            I = b(I, v), D = b(D, w), j = b(j, O), F = b(F, G), _ = b(_, W);
          }
          return Array(I, D, j, F, _);
        }
        function b(S, g) {
          var P = (65535 & S) + (65535 & g);
          return (S >> 16) + (g >> 16) + (P >> 16) << 16 | 65535 & P;
        }
        function E(S, g) {
          return S << g | S >>> 32 - g;
        }
        a.exports = function(S) {
          return h.hash(S, y, 20, !0);
        };
      }).call(this, n("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, n("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(n, a, c) {
      (function(u, r, l, i, f, d, s, o, m) {
        function h(g, P) {
          var R = (65535 & g) + (65535 & P);
          return (g >> 16) + (P >> 16) + (R >> 16) << 16 | 65535 & R;
        }
        function y(g, P) {
          var R, N = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), C = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), I = new Array(64);
          g[P >> 5] |= 128 << 24 - P % 32, g[15 + (P + 64 >> 9 << 4)] = P;
          for (var D, j, F = 0; F < g.length; F += 16) {
            for (var _ = C[0], T = C[1], v = C[2], w = C[3], O = C[4], G = C[5], W = C[6], U = C[7], M = 0; M < 64; M++)
              I[M] = M < 16 ? g[M + F] : h(h(h((j = I[M - 2], E(j, 17) ^ E(j, 19) ^ S(j, 10)), I[M - 7]), (j = I[M - 15], E(j, 7) ^ E(j, 18) ^ S(j, 3))), I[M - 16]), R = h(h(h(h(U, E(j = O, 6) ^ E(j, 11) ^ E(j, 25)), O & G ^ ~O & W), N[M]), I[M]), D = h(E(D = _, 2) ^ E(D, 13) ^ E(D, 22), _ & T ^ _ & v ^ T & v), U = W, W = G, G = O, O = h(w, R), w = v, v = T, T = _, _ = h(R, D);
            C[0] = h(_, C[0]), C[1] = h(T, C[1]), C[2] = h(v, C[2]), C[3] = h(w, C[3]), C[4] = h(O, C[4]), C[5] = h(G, C[5]), C[6] = h(W, C[6]), C[7] = h(U, C[7]);
          }
          return C;
        }
        var b = n("./helpers"), E = function(g, P) {
          return g >>> P | g << 32 - P;
        }, S = function(g, P) {
          return g >>> P;
        };
        a.exports = function(g) {
          return b.hash(g, y, 32, !0);
        };
      }).call(this, n("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, n("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(n, a, c) {
      (function(u, r, l, i, f, d, s, o, m) {
        c.read = function(h, y, b, E, F) {
          var g, P, R = 8 * F - E - 1, N = (1 << R) - 1, C = N >> 1, I = -7, D = b ? F - 1 : 0, j = b ? -1 : 1, F = h[y + D];
          for (D += j, g = F & (1 << -I) - 1, F >>= -I, I += R; 0 < I; g = 256 * g + h[y + D], D += j, I -= 8)
            ;
          for (P = g & (1 << -I) - 1, g >>= -I, I += E; 0 < I; P = 256 * P + h[y + D], D += j, I -= 8)
            ;
          if (g === 0)
            g = 1 - C;
          else {
            if (g === N)
              return P ? NaN : 1 / 0 * (F ? -1 : 1);
            P += Math.pow(2, E), g -= C;
          }
          return (F ? -1 : 1) * P * Math.pow(2, g - E);
        }, c.write = function(h, y, b, E, S, _) {
          var P, R, N = 8 * _ - S - 1, C = (1 << N) - 1, I = C >> 1, D = S === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, j = E ? 0 : _ - 1, F = E ? 1 : -1, _ = y < 0 || y === 0 && 1 / y < 0 ? 1 : 0;
          for (y = Math.abs(y), isNaN(y) || y === 1 / 0 ? (R = isNaN(y) ? 1 : 0, P = C) : (P = Math.floor(Math.log(y) / Math.LN2), y * (E = Math.pow(2, -P)) < 1 && (P--, E *= 2), 2 <= (y += 1 <= P + I ? D / E : D * Math.pow(2, 1 - I)) * E && (P++, E /= 2), C <= P + I ? (R = 0, P = C) : 1 <= P + I ? (R = (y * E - 1) * Math.pow(2, S), P += I) : (R = y * Math.pow(2, I - 1) * Math.pow(2, S), P = 0)); 8 <= S; h[b + j] = 255 & R, j += F, R /= 256, S -= 8)
            ;
          for (P = P << S | R, N += S; 0 < N; h[b + j] = 255 & P, j += F, P /= 256, N -= 8)
            ;
          h[b + j - F] |= 128 * _;
        };
      }).call(this, n("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, n("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
    }, { buffer: 3, lYpoI2: 11 }], 11: [function(n, a, c) {
      (function(u, r, l, i, f, d, s, o, m) {
        var h, y, b;
        function E() {
        }
        (u = a.exports = {}).nextTick = (y = typeof window < "u" && window.setImmediate, b = typeof window < "u" && window.postMessage && window.addEventListener, y ? function(S) {
          return window.setImmediate(S);
        } : b ? (h = [], window.addEventListener("message", function(S) {
          var g = S.source;
          g !== window && g !== null || S.data !== "process-tick" || (S.stopPropagation(), 0 < h.length && h.shift()());
        }, !0), function(S) {
          h.push(S), window.postMessage("process-tick", "*");
        }) : function(S) {
          setTimeout(S, 0);
        }), u.title = "browser", u.browser = !0, u.env = {}, u.argv = [], u.on = E, u.addListener = E, u.once = E, u.off = E, u.removeListener = E, u.removeAllListeners = E, u.emit = E, u.binding = function(S) {
          throw new Error("process.binding is not supported");
        }, u.cwd = function() {
          return "/";
        }, u.chdir = function(S) {
          throw new Error("process.chdir is not supported");
        };
      }).call(this, n("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, n("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
    }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
  });
})(Xw);
var q5 = Xw.exports;
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return a;
    }
  });
  const e = /* @__PURE__ */ n(q5);
  function n(c) {
    return c && c.__esModule ? c : {
      default: c
    };
  }
  function a(c) {
    return (0, e.default)(c, {
      ignoreUnknown: !0
    });
  }
})(Yw);
var Jw = {}, Qw = {}, _d = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(n) {
    if (n = `${n}`, n === "0")
      return "0";
    if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(n))
      return n.replace(/^[+-]?/, (c) => c === "-" ? "" : "-");
    let a = [
      "var",
      "calc",
      "min",
      "max",
      "clamp"
    ];
    for (const c of a)
      if (n.includes(`${c}(`))
        return `calc(${n} * -1)`;
  }
})(_d);
var Zw = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  const e = [
    "preflight",
    "container",
    "accessibility",
    "pointerEvents",
    "visibility",
    "position",
    "inset",
    "isolation",
    "zIndex",
    "order",
    "gridColumn",
    "gridColumnStart",
    "gridColumnEnd",
    "gridRow",
    "gridRowStart",
    "gridRowEnd",
    "float",
    "clear",
    "margin",
    "boxSizing",
    "lineClamp",
    "display",
    "aspectRatio",
    "height",
    "maxHeight",
    "minHeight",
    "width",
    "minWidth",
    "maxWidth",
    "flex",
    "flexShrink",
    "flexGrow",
    "flexBasis",
    "tableLayout",
    "captionSide",
    "borderCollapse",
    "borderSpacing",
    "transformOrigin",
    "translate",
    "rotate",
    "skew",
    "scale",
    "transform",
    "animation",
    "cursor",
    "touchAction",
    "userSelect",
    "resize",
    "scrollSnapType",
    "scrollSnapAlign",
    "scrollSnapStop",
    "scrollMargin",
    "scrollPadding",
    "listStylePosition",
    "listStyleType",
    "listStyleImage",
    "appearance",
    "columns",
    "breakBefore",
    "breakInside",
    "breakAfter",
    "gridAutoColumns",
    "gridAutoFlow",
    "gridAutoRows",
    "gridTemplateColumns",
    "gridTemplateRows",
    "flexDirection",
    "flexWrap",
    "placeContent",
    "placeItems",
    "alignContent",
    "alignItems",
    "justifyContent",
    "justifyItems",
    "gap",
    "space",
    "divideWidth",
    "divideStyle",
    "divideColor",
    "divideOpacity",
    "placeSelf",
    "alignSelf",
    "justifySelf",
    "overflow",
    "overscrollBehavior",
    "scrollBehavior",
    "textOverflow",
    "hyphens",
    "whitespace",
    "wordBreak",
    "borderRadius",
    "borderWidth",
    "borderStyle",
    "borderColor",
    "borderOpacity",
    "backgroundColor",
    "backgroundOpacity",
    "backgroundImage",
    "gradientColorStops",
    "boxDecorationBreak",
    "backgroundSize",
    "backgroundAttachment",
    "backgroundClip",
    "backgroundPosition",
    "backgroundRepeat",
    "backgroundOrigin",
    "fill",
    "stroke",
    "strokeWidth",
    "objectFit",
    "objectPosition",
    "padding",
    "textAlign",
    "textIndent",
    "verticalAlign",
    "fontFamily",
    "fontSize",
    "fontWeight",
    "textTransform",
    "fontStyle",
    "fontVariantNumeric",
    "lineHeight",
    "letterSpacing",
    "textColor",
    "textOpacity",
    "textDecoration",
    "textDecorationColor",
    "textDecorationStyle",
    "textDecorationThickness",
    "textUnderlineOffset",
    "fontSmoothing",
    "placeholderColor",
    "placeholderOpacity",
    "caretColor",
    "accentColor",
    "opacity",
    "backgroundBlendMode",
    "mixBlendMode",
    "boxShadow",
    "boxShadowColor",
    "outlineStyle",
    "outlineWidth",
    "outlineOffset",
    "outlineColor",
    "ringWidth",
    "ringColor",
    "ringOpacity",
    "ringOffsetWidth",
    "ringOffsetColor",
    "blur",
    "brightness",
    "contrast",
    "dropShadow",
    "grayscale",
    "hueRotate",
    "invert",
    "saturate",
    "sepia",
    "filter",
    "backdropBlur",
    "backdropBrightness",
    "backdropContrast",
    "backdropGrayscale",
    "backdropHueRotate",
    "backdropInvert",
    "backdropOpacity",
    "backdropSaturate",
    "backdropSepia",
    "backdropFilter",
    "transitionProperty",
    "transitionDelay",
    "transitionDuration",
    "transitionTimingFunction",
    "willChange",
    "content"
  ];
})(Zw);
var e2 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(n, a) {
    return n === void 0 ? a : Array.isArray(n) ? n : [
      ...new Set(a.filter((u) => n !== !1 && n[u] !== !1).concat(Object.keys(n).filter((u) => n[u] !== !1)))
    ];
  }
})(e2);
var t2 = {}, Bi = {}, q0 = { exports: {} }, Ar = String, r2 = function() {
  return { isColorSupported: !1, reset: Ar, bold: Ar, dim: Ar, italic: Ar, underline: Ar, inverse: Ar, hidden: Ar, strikethrough: Ar, black: Ar, red: Ar, green: Ar, yellow: Ar, blue: Ar, magenta: Ar, cyan: Ar, white: Ar, gray: Ar, bgBlack: Ar, bgRed: Ar, bgGreen: Ar, bgYellow: Ar, bgBlue: Ar, bgMagenta: Ar, bgCyan: Ar, bgWhite: Ar };
};
q0.exports = r2();
q0.exports.createColors = r2;
var G0 = q0.exports;
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(i, f) {
    for (var d in f)
      Object.defineProperty(i, d, {
        enumerable: !0,
        get: f[d]
      });
  }
  e(t, {
    dim: function() {
      return r;
    },
    default: function() {
      return l;
    }
  });
  const n = /* @__PURE__ */ a(G0);
  function a(i) {
    return i && i.__esModule ? i : {
      default: i
    };
  }
  let c = /* @__PURE__ */ new Set();
  function u(i, f, d) {
    typeof Ve.process < "u" && Ve.process.env.JEST_WORKER_ID || d && c.has(d) || (d && c.add(d), console.warn(""), f.forEach((s) => console.warn(i, "-", s)));
  }
  function r(i) {
    return n.default.dim(i);
  }
  const l = {
    info(i, f) {
      u(n.default.bold(n.default.cyan("info")), ...Array.isArray(i) ? [
        i
      ] : [
        f,
        i
      ]);
    },
    warn(i, f) {
      u(n.default.bold(n.default.yellow("warn")), ...Array.isArray(i) ? [
        i
      ] : [
        f,
        i
      ]);
    },
    risk(i, f) {
      u(n.default.bold(n.default.magenta("risk")), ...Array.isArray(i) ? [
        i
      ] : [
        f,
        i
      ]);
    }
  };
})(Bi);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return c;
    }
  });
  const e = /* @__PURE__ */ n(Bi);
  function n(u) {
    return u && u.__esModule ? u : {
      default: u
    };
  }
  function a({ version: u, from: r, to: l }) {
    e.default.warn(`${r}-color-renamed`, [
      `As of Tailwind CSS ${u}, \`${r}\` has been renamed to \`${l}\`.`,
      "Update your configuration file to silence this warning."
    ]);
  }
  const c = {
    inherit: "inherit",
    current: "currentColor",
    transparent: "transparent",
    black: "#000",
    white: "#fff",
    slate: {
      50: "#f8fafc",
      100: "#f1f5f9",
      200: "#e2e8f0",
      300: "#cbd5e1",
      400: "#94a3b8",
      500: "#64748b",
      600: "#475569",
      700: "#334155",
      800: "#1e293b",
      900: "#0f172a",
      950: "#020617"
    },
    gray: {
      50: "#f9fafb",
      100: "#f3f4f6",
      200: "#e5e7eb",
      300: "#d1d5db",
      400: "#9ca3af",
      500: "#6b7280",
      600: "#4b5563",
      700: "#374151",
      800: "#1f2937",
      900: "#111827",
      950: "#030712"
    },
    zinc: {
      50: "#fafafa",
      100: "#f4f4f5",
      200: "#e4e4e7",
      300: "#d4d4d8",
      400: "#a1a1aa",
      500: "#71717a",
      600: "#52525b",
      700: "#3f3f46",
      800: "#27272a",
      900: "#18181b",
      950: "#09090b"
    },
    neutral: {
      50: "#fafafa",
      100: "#f5f5f5",
      200: "#e5e5e5",
      300: "#d4d4d4",
      400: "#a3a3a3",
      500: "#737373",
      600: "#525252",
      700: "#404040",
      800: "#262626",
      900: "#171717",
      950: "#0a0a0a"
    },
    stone: {
      50: "#fafaf9",
      100: "#f5f5f4",
      200: "#e7e5e4",
      300: "#d6d3d1",
      400: "#a8a29e",
      500: "#78716c",
      600: "#57534e",
      700: "#44403c",
      800: "#292524",
      900: "#1c1917",
      950: "#0c0a09"
    },
    red: {
      50: "#fef2f2",
      100: "#fee2e2",
      200: "#fecaca",
      300: "#fca5a5",
      400: "#f87171",
      500: "#ef4444",
      600: "#dc2626",
      700: "#b91c1c",
      800: "#991b1b",
      900: "#7f1d1d",
      950: "#450a0a"
    },
    orange: {
      50: "#fff7ed",
      100: "#ffedd5",
      200: "#fed7aa",
      300: "#fdba74",
      400: "#fb923c",
      500: "#f97316",
      600: "#ea580c",
      700: "#c2410c",
      800: "#9a3412",
      900: "#7c2d12",
      950: "#431407"
    },
    amber: {
      50: "#fffbeb",
      100: "#fef3c7",
      200: "#fde68a",
      300: "#fcd34d",
      400: "#fbbf24",
      500: "#f59e0b",
      600: "#d97706",
      700: "#b45309",
      800: "#92400e",
      900: "#78350f",
      950: "#451a03"
    },
    yellow: {
      50: "#fefce8",
      100: "#fef9c3",
      200: "#fef08a",
      300: "#fde047",
      400: "#facc15",
      500: "#eab308",
      600: "#ca8a04",
      700: "#a16207",
      800: "#854d0e",
      900: "#713f12",
      950: "#422006"
    },
    lime: {
      50: "#f7fee7",
      100: "#ecfccb",
      200: "#d9f99d",
      300: "#bef264",
      400: "#a3e635",
      500: "#84cc16",
      600: "#65a30d",
      700: "#4d7c0f",
      800: "#3f6212",
      900: "#365314",
      950: "#1a2e05"
    },
    green: {
      50: "#f0fdf4",
      100: "#dcfce7",
      200: "#bbf7d0",
      300: "#86efac",
      400: "#4ade80",
      500: "#22c55e",
      600: "#16a34a",
      700: "#15803d",
      800: "#166534",
      900: "#14532d",
      950: "#052e16"
    },
    emerald: {
      50: "#ecfdf5",
      100: "#d1fae5",
      200: "#a7f3d0",
      300: "#6ee7b7",
      400: "#34d399",
      500: "#10b981",
      600: "#059669",
      700: "#047857",
      800: "#065f46",
      900: "#064e3b",
      950: "#022c22"
    },
    teal: {
      50: "#f0fdfa",
      100: "#ccfbf1",
      200: "#99f6e4",
      300: "#5eead4",
      400: "#2dd4bf",
      500: "#14b8a6",
      600: "#0d9488",
      700: "#0f766e",
      800: "#115e59",
      900: "#134e4a",
      950: "#042f2e"
    },
    cyan: {
      50: "#ecfeff",
      100: "#cffafe",
      200: "#a5f3fc",
      300: "#67e8f9",
      400: "#22d3ee",
      500: "#06b6d4",
      600: "#0891b2",
      700: "#0e7490",
      800: "#155e75",
      900: "#164e63",
      950: "#083344"
    },
    sky: {
      50: "#f0f9ff",
      100: "#e0f2fe",
      200: "#bae6fd",
      300: "#7dd3fc",
      400: "#38bdf8",
      500: "#0ea5e9",
      600: "#0284c7",
      700: "#0369a1",
      800: "#075985",
      900: "#0c4a6e",
      950: "#082f49"
    },
    blue: {
      50: "#eff6ff",
      100: "#dbeafe",
      200: "#bfdbfe",
      300: "#93c5fd",
      400: "#60a5fa",
      500: "#3b82f6",
      600: "#2563eb",
      700: "#1d4ed8",
      800: "#1e40af",
      900: "#1e3a8a",
      950: "#172554"
    },
    indigo: {
      50: "#eef2ff",
      100: "#e0e7ff",
      200: "#c7d2fe",
      300: "#a5b4fc",
      400: "#818cf8",
      500: "#6366f1",
      600: "#4f46e5",
      700: "#4338ca",
      800: "#3730a3",
      900: "#312e81",
      950: "#1e1b4b"
    },
    violet: {
      50: "#f5f3ff",
      100: "#ede9fe",
      200: "#ddd6fe",
      300: "#c4b5fd",
      400: "#a78bfa",
      500: "#8b5cf6",
      600: "#7c3aed",
      700: "#6d28d9",
      800: "#5b21b6",
      900: "#4c1d95",
      950: "#2e1065"
    },
    purple: {
      50: "#faf5ff",
      100: "#f3e8ff",
      200: "#e9d5ff",
      300: "#d8b4fe",
      400: "#c084fc",
      500: "#a855f7",
      600: "#9333ea",
      700: "#7e22ce",
      800: "#6b21a8",
      900: "#581c87",
      950: "#3b0764"
    },
    fuchsia: {
      50: "#fdf4ff",
      100: "#fae8ff",
      200: "#f5d0fe",
      300: "#f0abfc",
      400: "#e879f9",
      500: "#d946ef",
      600: "#c026d3",
      700: "#a21caf",
      800: "#86198f",
      900: "#701a75",
      950: "#4a044e"
    },
    pink: {
      50: "#fdf2f8",
      100: "#fce7f3",
      200: "#fbcfe8",
      300: "#f9a8d4",
      400: "#f472b6",
      500: "#ec4899",
      600: "#db2777",
      700: "#be185d",
      800: "#9d174d",
      900: "#831843",
      950: "#500724"
    },
    rose: {
      50: "#fff1f2",
      100: "#ffe4e6",
      200: "#fecdd3",
      300: "#fda4af",
      400: "#fb7185",
      500: "#f43f5e",
      600: "#e11d48",
      700: "#be123c",
      800: "#9f1239",
      900: "#881337",
      950: "#4c0519"
    },
    get lightBlue() {
      return a({
        version: "v2.2",
        from: "lightBlue",
        to: "sky"
      }), this.sky;
    },
    get warmGray() {
      return a({
        version: "v3.0",
        from: "warmGray",
        to: "stone"
      }), this.stone;
    },
    get trueGray() {
      return a({
        version: "v3.0",
        from: "trueGray",
        to: "neutral"
      }), this.neutral;
    },
    get coolGray() {
      return a({
        version: "v3.0",
        from: "coolGray",
        to: "gray"
      }), this.gray;
    },
    get blueGray() {
      return a({
        version: "v3.0",
        from: "blueGray",
        to: "slate"
      }), this.slate;
    }
  };
})(t2);
var n2 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "defaults", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(n, ...a) {
    for (let r of a) {
      for (let l in r) {
        var c;
        !(n == null || (c = n.hasOwnProperty) === null || c === void 0) && c.call(n, l) || (n[l] = r[l]);
      }
      for (let l of Object.getOwnPropertySymbols(r)) {
        var u;
        !(n == null || (u = n.hasOwnProperty) === null || u === void 0) && u.call(n, l) || (n[l] = r[l]);
      }
    }
    return n;
  }
})(n2);
var Sd = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "toPath", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(n) {
    if (Array.isArray(n))
      return n;
    let a = n.split("[").length - 1, c = n.split("]").length - 1;
    if (a !== c)
      throw new Error(`Path is invalid. Has unbalanced brackets: ${n}`);
    return n.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
  }
})(Sd);
var i2 = {}, _s = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(s, o) {
    for (var m in o)
      Object.defineProperty(s, m, {
        enumerable: !0,
        get: o[m]
      });
  }
  e(t, {
    flagEnabled: function() {
      return l;
    },
    issueFlagNotices: function() {
      return f;
    },
    default: function() {
      return d;
    }
  });
  const n = /* @__PURE__ */ c(G0), a = /* @__PURE__ */ c(Bi);
  function c(s) {
    return s && s.__esModule ? s : {
      default: s
    };
  }
  let u = {
    optimizeUniversalDefaults: !1,
    generalizedModifiers: !0,
    get disableColorOpacityUtilitiesByDefault() {
      return !1;
    },
    get relativeContentPathsByDefault() {
      return !1;
    }
  }, r = {
    future: [
      "hoverOnlyWhenSupported",
      "respectDefaultRingColorOpacity",
      "disableColorOpacityUtilitiesByDefault",
      "relativeContentPathsByDefault"
    ],
    experimental: [
      "optimizeUniversalDefaults",
      "generalizedModifiers"
    ]
  };
  function l(s, o) {
    if (r.future.includes(o)) {
      var m, h, y;
      return s.future === "all" || ((y = (h = s == null || (m = s.future) === null || m === void 0 ? void 0 : m[o]) !== null && h !== void 0 ? h : u[o]) !== null && y !== void 0 ? y : !1);
    }
    if (r.experimental.includes(o)) {
      var b, E, S;
      return s.experimental === "all" || ((S = (E = s == null || (b = s.experimental) === null || b === void 0 ? void 0 : b[o]) !== null && E !== void 0 ? E : u[o]) !== null && S !== void 0 ? S : !1);
    }
    return !1;
  }
  function i(s) {
    if (s.experimental === "all")
      return r.experimental;
    var o;
    return Object.keys((o = s == null ? void 0 : s.experimental) !== null && o !== void 0 ? o : {}).filter((m) => r.experimental.includes(m) && s.experimental[m]);
  }
  function f(s) {
    if (Ve.process.env.JEST_WORKER_ID === void 0 && i(s).length > 0) {
      let o = i(s).map((m) => n.default.yellow(m)).join(", ");
      a.default.warn("experimental-flags-enabled", [
        `You have enabled experimental features: ${o}`,
        "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."
      ]);
    }
  }
  const d = r;
})(_s);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "normalizeConfig", {
    enumerable: !0,
    get: function() {
      return u;
    }
  });
  const e = _s, n = /* @__PURE__ */ c(Bi);
  function a(r) {
    if (typeof WeakMap != "function")
      return null;
    var l = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap();
    return (a = function(f) {
      return f ? i : l;
    })(r);
  }
  function c(r, l) {
    if (!l && r && r.__esModule)
      return r;
    if (r === null || typeof r != "object" && typeof r != "function")
      return {
        default: r
      };
    var i = a(l);
    if (i && i.has(r))
      return i.get(r);
    var f = {}, d = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var s in r)
      if (s !== "default" && Object.prototype.hasOwnProperty.call(r, s)) {
        var o = d ? Object.getOwnPropertyDescriptor(r, s) : null;
        o && (o.get || o.set) ? Object.defineProperty(f, s, o) : f[s] = r[s];
      }
    return f.default = r, i && i.set(r, f), f;
  }
  function u(r) {
    if ((() => {
      if (r.purge || !r.content || !Array.isArray(r.content) && !(typeof r.content == "object" && r.content !== null))
        return !1;
      if (Array.isArray(r.content))
        return r.content.every((f) => typeof f == "string" ? !0 : !(typeof (f == null ? void 0 : f.raw) != "string" || f != null && f.extension && typeof (f == null ? void 0 : f.extension) != "string"));
      if (typeof r.content == "object" && r.content !== null) {
        if (Object.keys(r.content).some((f) => ![
          "files",
          "relative",
          "extract",
          "transform"
        ].includes(f)))
          return !1;
        if (Array.isArray(r.content.files)) {
          if (!r.content.files.every((f) => typeof f == "string" ? !0 : !(typeof (f == null ? void 0 : f.raw) != "string" || f != null && f.extension && typeof (f == null ? void 0 : f.extension) != "string")))
            return !1;
          if (typeof r.content.extract == "object") {
            for (let f of Object.values(r.content.extract))
              if (typeof f != "function")
                return !1;
          } else if (!(r.content.extract === void 0 || typeof r.content.extract == "function"))
            return !1;
          if (typeof r.content.transform == "object") {
            for (let f of Object.values(r.content.transform))
              if (typeof f != "function")
                return !1;
          } else if (!(r.content.transform === void 0 || typeof r.content.transform == "function"))
            return !1;
          if (typeof r.content.relative != "boolean" && typeof r.content.relative < "u")
            return !1;
        }
        return !0;
      }
      return !1;
    })() || n.default.warn("purge-deprecation", [
      "The `purge`/`content` options have changed in Tailwind CSS v3.0.",
      "Update your configuration file to eliminate this warning.",
      "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"
    ]), r.safelist = (() => {
      var f;
      let { content: d, purge: s, safelist: o } = r;
      return Array.isArray(o) ? o : Array.isArray(d == null ? void 0 : d.safelist) ? d.safelist : Array.isArray(s == null ? void 0 : s.safelist) ? s.safelist : Array.isArray(s == null || (f = s.options) === null || f === void 0 ? void 0 : f.safelist) ? s.options.safelist : [];
    })(), r.blocklist = (() => {
      let { blocklist: f } = r;
      if (Array.isArray(f)) {
        if (f.every((d) => typeof d == "string"))
          return f;
        n.default.warn("blocklist-invalid", [
          "The `blocklist` option must be an array of strings.",
          "https://tailwindcss.com/docs/content-configuration#discarding-classes"
        ]);
      }
      return [];
    })(), typeof r.prefix == "function")
      n.default.warn("prefix-function", [
        "As of Tailwind CSS v3.0, `prefix` cannot be a function.",
        "Update `prefix` in your configuration to be a string to eliminate this warning.",
        "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"
      ]), r.prefix = "";
    else {
      var i;
      r.prefix = (i = r.prefix) !== null && i !== void 0 ? i : "";
    }
    r.content = {
      relative: (() => {
        let { content: f } = r;
        return f != null && f.relative ? f.relative : (0, e.flagEnabled)(r, "relativeContentPathsByDefault");
      })(),
      files: (() => {
        let { content: f, purge: d } = r;
        return Array.isArray(d) ? d : Array.isArray(d == null ? void 0 : d.content) ? d.content : Array.isArray(f) ? f : Array.isArray(f == null ? void 0 : f.content) ? f.content : Array.isArray(f == null ? void 0 : f.files) ? f.files : [];
      })(),
      extract: (() => {
        let f = (() => {
          var o, m, h, y, b, E, S, g, P, R;
          return !((o = r.purge) === null || o === void 0) && o.extract ? r.purge.extract : !((m = r.content) === null || m === void 0) && m.extract ? r.content.extract : !((h = r.purge) === null || h === void 0 || (y = h.extract) === null || y === void 0) && y.DEFAULT ? r.purge.extract.DEFAULT : !((b = r.content) === null || b === void 0 || (E = b.extract) === null || E === void 0) && E.DEFAULT ? r.content.extract.DEFAULT : !((S = r.purge) === null || S === void 0 || (g = S.options) === null || g === void 0) && g.extractors ? r.purge.options.extractors : !((P = r.content) === null || P === void 0 || (R = P.options) === null || R === void 0) && R.extractors ? r.content.options.extractors : {};
        })(), d = {}, s = (() => {
          var o, m, h, y;
          if (!((o = r.purge) === null || o === void 0 || (m = o.options) === null || m === void 0) && m.defaultExtractor)
            return r.purge.options.defaultExtractor;
          if (!((h = r.content) === null || h === void 0 || (y = h.options) === null || y === void 0) && y.defaultExtractor)
            return r.content.options.defaultExtractor;
        })();
        if (s !== void 0 && (d.DEFAULT = s), typeof f == "function")
          d.DEFAULT = f;
        else if (Array.isArray(f))
          for (let { extensions: o, extractor: m } of f ?? [])
            for (let h of o)
              d[h] = m;
        else
          typeof f == "object" && f !== null && Object.assign(d, f);
        return d;
      })(),
      transform: (() => {
        let f = (() => {
          var s, o, m, h, y, b;
          return !((s = r.purge) === null || s === void 0) && s.transform ? r.purge.transform : !((o = r.content) === null || o === void 0) && o.transform ? r.content.transform : !((m = r.purge) === null || m === void 0 || (h = m.transform) === null || h === void 0) && h.DEFAULT ? r.purge.transform.DEFAULT : !((y = r.content) === null || y === void 0 || (b = y.transform) === null || b === void 0) && b.DEFAULT ? r.content.transform.DEFAULT : {};
        })(), d = {};
        return typeof f == "function" && (d.DEFAULT = f), typeof f == "object" && f !== null && Object.assign(d, f), d;
      })()
    };
    for (let f of r.content.files)
      if (typeof f == "string" && /{([^,]*?)}/g.test(f)) {
        n.default.warn("invalid-glob-braces", [
          `The glob pattern ${(0, n.dim)(f)} in your Tailwind CSS configuration is invalid.`,
          `Update it to ${(0, n.dim)(f.replace(/{([^,]*?)}/g, "$1"))} to silence this warning.`
        ]);
        break;
      }
    return r;
  }
})(i2);
var tl = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(n) {
    if (Object.prototype.toString.call(n) !== "[object Object]")
      return !1;
    const a = Object.getPrototypeOf(n);
    return a === null || a === Object.prototype;
  }
})(tl);
var s2 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "cloneDeep", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(n) {
    return Array.isArray(n) ? n.map((a) => e(a)) : typeof n == "object" && n !== null ? Object.fromEntries(Object.entries(n).map(([a, c]) => [
      a,
      e(c)
    ])) : n;
  }
})(s2);
var Pu = {}, wd = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(n) {
    return n.replace(/\\,/g, "\\2c ");
  }
})(wd);
var Cu = {}, z0 = {}, a2 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  const e = {
    aliceblue: [
      240,
      248,
      255
    ],
    antiquewhite: [
      250,
      235,
      215
    ],
    aqua: [
      0,
      255,
      255
    ],
    aquamarine: [
      127,
      255,
      212
    ],
    azure: [
      240,
      255,
      255
    ],
    beige: [
      245,
      245,
      220
    ],
    bisque: [
      255,
      228,
      196
    ],
    black: [
      0,
      0,
      0
    ],
    blanchedalmond: [
      255,
      235,
      205
    ],
    blue: [
      0,
      0,
      255
    ],
    blueviolet: [
      138,
      43,
      226
    ],
    brown: [
      165,
      42,
      42
    ],
    burlywood: [
      222,
      184,
      135
    ],
    cadetblue: [
      95,
      158,
      160
    ],
    chartreuse: [
      127,
      255,
      0
    ],
    chocolate: [
      210,
      105,
      30
    ],
    coral: [
      255,
      127,
      80
    ],
    cornflowerblue: [
      100,
      149,
      237
    ],
    cornsilk: [
      255,
      248,
      220
    ],
    crimson: [
      220,
      20,
      60
    ],
    cyan: [
      0,
      255,
      255
    ],
    darkblue: [
      0,
      0,
      139
    ],
    darkcyan: [
      0,
      139,
      139
    ],
    darkgoldenrod: [
      184,
      134,
      11
    ],
    darkgray: [
      169,
      169,
      169
    ],
    darkgreen: [
      0,
      100,
      0
    ],
    darkgrey: [
      169,
      169,
      169
    ],
    darkkhaki: [
      189,
      183,
      107
    ],
    darkmagenta: [
      139,
      0,
      139
    ],
    darkolivegreen: [
      85,
      107,
      47
    ],
    darkorange: [
      255,
      140,
      0
    ],
    darkorchid: [
      153,
      50,
      204
    ],
    darkred: [
      139,
      0,
      0
    ],
    darksalmon: [
      233,
      150,
      122
    ],
    darkseagreen: [
      143,
      188,
      143
    ],
    darkslateblue: [
      72,
      61,
      139
    ],
    darkslategray: [
      47,
      79,
      79
    ],
    darkslategrey: [
      47,
      79,
      79
    ],
    darkturquoise: [
      0,
      206,
      209
    ],
    darkviolet: [
      148,
      0,
      211
    ],
    deeppink: [
      255,
      20,
      147
    ],
    deepskyblue: [
      0,
      191,
      255
    ],
    dimgray: [
      105,
      105,
      105
    ],
    dimgrey: [
      105,
      105,
      105
    ],
    dodgerblue: [
      30,
      144,
      255
    ],
    firebrick: [
      178,
      34,
      34
    ],
    floralwhite: [
      255,
      250,
      240
    ],
    forestgreen: [
      34,
      139,
      34
    ],
    fuchsia: [
      255,
      0,
      255
    ],
    gainsboro: [
      220,
      220,
      220
    ],
    ghostwhite: [
      248,
      248,
      255
    ],
    gold: [
      255,
      215,
      0
    ],
    goldenrod: [
      218,
      165,
      32
    ],
    gray: [
      128,
      128,
      128
    ],
    green: [
      0,
      128,
      0
    ],
    greenyellow: [
      173,
      255,
      47
    ],
    grey: [
      128,
      128,
      128
    ],
    honeydew: [
      240,
      255,
      240
    ],
    hotpink: [
      255,
      105,
      180
    ],
    indianred: [
      205,
      92,
      92
    ],
    indigo: [
      75,
      0,
      130
    ],
    ivory: [
      255,
      255,
      240
    ],
    khaki: [
      240,
      230,
      140
    ],
    lavender: [
      230,
      230,
      250
    ],
    lavenderblush: [
      255,
      240,
      245
    ],
    lawngreen: [
      124,
      252,
      0
    ],
    lemonchiffon: [
      255,
      250,
      205
    ],
    lightblue: [
      173,
      216,
      230
    ],
    lightcoral: [
      240,
      128,
      128
    ],
    lightcyan: [
      224,
      255,
      255
    ],
    lightgoldenrodyellow: [
      250,
      250,
      210
    ],
    lightgray: [
      211,
      211,
      211
    ],
    lightgreen: [
      144,
      238,
      144
    ],
    lightgrey: [
      211,
      211,
      211
    ],
    lightpink: [
      255,
      182,
      193
    ],
    lightsalmon: [
      255,
      160,
      122
    ],
    lightseagreen: [
      32,
      178,
      170
    ],
    lightskyblue: [
      135,
      206,
      250
    ],
    lightslategray: [
      119,
      136,
      153
    ],
    lightslategrey: [
      119,
      136,
      153
    ],
    lightsteelblue: [
      176,
      196,
      222
    ],
    lightyellow: [
      255,
      255,
      224
    ],
    lime: [
      0,
      255,
      0
    ],
    limegreen: [
      50,
      205,
      50
    ],
    linen: [
      250,
      240,
      230
    ],
    magenta: [
      255,
      0,
      255
    ],
    maroon: [
      128,
      0,
      0
    ],
    mediumaquamarine: [
      102,
      205,
      170
    ],
    mediumblue: [
      0,
      0,
      205
    ],
    mediumorchid: [
      186,
      85,
      211
    ],
    mediumpurple: [
      147,
      112,
      219
    ],
    mediumseagreen: [
      60,
      179,
      113
    ],
    mediumslateblue: [
      123,
      104,
      238
    ],
    mediumspringgreen: [
      0,
      250,
      154
    ],
    mediumturquoise: [
      72,
      209,
      204
    ],
    mediumvioletred: [
      199,
      21,
      133
    ],
    midnightblue: [
      25,
      25,
      112
    ],
    mintcream: [
      245,
      255,
      250
    ],
    mistyrose: [
      255,
      228,
      225
    ],
    moccasin: [
      255,
      228,
      181
    ],
    navajowhite: [
      255,
      222,
      173
    ],
    navy: [
      0,
      0,
      128
    ],
    oldlace: [
      253,
      245,
      230
    ],
    olive: [
      128,
      128,
      0
    ],
    olivedrab: [
      107,
      142,
      35
    ],
    orange: [
      255,
      165,
      0
    ],
    orangered: [
      255,
      69,
      0
    ],
    orchid: [
      218,
      112,
      214
    ],
    palegoldenrod: [
      238,
      232,
      170
    ],
    palegreen: [
      152,
      251,
      152
    ],
    paleturquoise: [
      175,
      238,
      238
    ],
    palevioletred: [
      219,
      112,
      147
    ],
    papayawhip: [
      255,
      239,
      213
    ],
    peachpuff: [
      255,
      218,
      185
    ],
    peru: [
      205,
      133,
      63
    ],
    pink: [
      255,
      192,
      203
    ],
    plum: [
      221,
      160,
      221
    ],
    powderblue: [
      176,
      224,
      230
    ],
    purple: [
      128,
      0,
      128
    ],
    rebeccapurple: [
      102,
      51,
      153
    ],
    red: [
      255,
      0,
      0
    ],
    rosybrown: [
      188,
      143,
      143
    ],
    royalblue: [
      65,
      105,
      225
    ],
    saddlebrown: [
      139,
      69,
      19
    ],
    salmon: [
      250,
      128,
      114
    ],
    sandybrown: [
      244,
      164,
      96
    ],
    seagreen: [
      46,
      139,
      87
    ],
    seashell: [
      255,
      245,
      238
    ],
    sienna: [
      160,
      82,
      45
    ],
    silver: [
      192,
      192,
      192
    ],
    skyblue: [
      135,
      206,
      235
    ],
    slateblue: [
      106,
      90,
      205
    ],
    slategray: [
      112,
      128,
      144
    ],
    slategrey: [
      112,
      128,
      144
    ],
    snow: [
      255,
      250,
      250
    ],
    springgreen: [
      0,
      255,
      127
    ],
    steelblue: [
      70,
      130,
      180
    ],
    tan: [
      210,
      180,
      140
    ],
    teal: [
      0,
      128,
      128
    ],
    thistle: [
      216,
      191,
      216
    ],
    tomato: [
      255,
      99,
      71
    ],
    turquoise: [
      64,
      224,
      208
    ],
    violet: [
      238,
      130,
      238
    ],
    wheat: [
      245,
      222,
      179
    ],
    white: [
      255,
      255,
      255
    ],
    whitesmoke: [
      245,
      245,
      245
    ],
    yellow: [
      255,
      255,
      0
    ],
    yellowgreen: [
      154,
      205,
      50
    ]
  };
})(a2);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(h, y) {
    for (var b in y)
      Object.defineProperty(h, b, {
        enumerable: !0,
        get: y[b]
      });
  }
  e(t, {
    parseColor: function() {
      return o;
    },
    formatColor: function() {
      return m;
    }
  });
  const n = /* @__PURE__ */ a(a2);
  function a(h) {
    return h && h.__esModule ? h : {
      default: h
    };
  }
  let c = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i, u = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, r = /(?:\d+|\d*\.\d+)%?/, l = /(?:\s*,\s*|\s+)/, i = /\s*[,/]\s*/, f = /var\(--(?:[^ )]*?)\)/, d = new RegExp(`^(rgba?)\\(\\s*(${r.source}|${f.source})(?:${l.source}(${r.source}|${f.source}))?(?:${l.source}(${r.source}|${f.source}))?(?:${i.source}(${r.source}|${f.source}))?\\s*\\)$`), s = new RegExp(`^(hsla?)\\(\\s*((?:${r.source})(?:deg|rad|grad|turn)?|${f.source})(?:${l.source}(${r.source}|${f.source}))?(?:${l.source}(${r.source}|${f.source}))?(?:${i.source}(${r.source}|${f.source}))?\\s*\\)$`);
  function o(h, { loose: y = !1 } = {}) {
    var b, E;
    if (typeof h != "string")
      return null;
    if (h = h.trim(), h === "transparent")
      return {
        mode: "rgb",
        color: [
          "0",
          "0",
          "0"
        ],
        alpha: "0"
      };
    if (h in n.default)
      return {
        mode: "rgb",
        color: n.default[h].map((N) => N.toString())
      };
    let S = h.replace(u, (N, C, I, D, j) => [
      "#",
      C,
      C,
      I,
      I,
      D,
      D,
      j ? j + j : ""
    ].join("")).match(c);
    if (S !== null)
      return {
        mode: "rgb",
        color: [
          parseInt(S[1], 16),
          parseInt(S[2], 16),
          parseInt(S[3], 16)
        ].map((N) => N.toString()),
        alpha: S[4] ? (parseInt(S[4], 16) / 255).toString() : void 0
      };
    var g;
    let P = (g = h.match(d)) !== null && g !== void 0 ? g : h.match(s);
    if (P === null)
      return null;
    let R = [
      P[2],
      P[3],
      P[4]
    ].filter(Boolean).map((N) => N.toString());
    return R.length === 2 && R[0].startsWith("var(") ? {
      mode: P[1],
      color: [
        R[0]
      ],
      alpha: R[1]
    } : !y && R.length !== 3 || R.length < 3 && !R.some((N) => /^var\(.*?\)$/.test(N)) ? null : {
      mode: P[1],
      color: R,
      alpha: (b = P[5]) === null || b === void 0 || (E = b.toString) === null || E === void 0 ? void 0 : E.call(b)
    };
  }
  function m({ mode: h, color: y, alpha: b }) {
    let E = b !== void 0;
    return h === "rgba" || h === "hsla" ? `${h}(${y.join(", ")}${E ? `, ${b}` : ""})` : `${h}(${y.join(" ")}${E ? ` / ${b}` : ""})`;
  }
})(z0);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(u, r) {
    for (var l in r)
      Object.defineProperty(u, l, {
        enumerable: !0,
        get: r[l]
      });
  }
  e(t, {
    withAlphaValue: function() {
      return a;
    },
    default: function() {
      return c;
    }
  });
  const n = z0;
  function a(u, r, l) {
    if (typeof u == "function")
      return u({
        opacityValue: r
      });
    let i = (0, n.parseColor)(u, {
      loose: !0
    });
    return i === null ? l : (0, n.formatColor)({
      ...i,
      alpha: r
    });
  }
  function c({ color: u, property: r, variable: l }) {
    let i = [].concat(r);
    if (typeof u == "function")
      return {
        [l]: "1",
        ...Object.fromEntries(i.map((d) => [
          d,
          u({
            opacityVariable: l,
            opacityValue: `var(${l})`
          })
        ]))
      };
    const f = (0, n.parseColor)(u);
    return f === null ? Object.fromEntries(i.map((d) => [
      d,
      u
    ])) : f.alpha !== void 0 ? Object.fromEntries(i.map((d) => [
      d,
      u
    ])) : {
      [l]: "1",
      ...Object.fromEntries(i.map((d) => [
        d,
        (0, n.formatColor)({
          ...f,
          alpha: `var(${l})`
        })
      ]))
    };
  }
})(Cu);
var Iu = {}, K0 = {}, Ou = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "splitAtTopLevelOnly", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(n, a) {
    let c = [], u = [], r = 0, l = !1;
    for (let i = 0; i < n.length; i++) {
      let f = n[i];
      c.length === 0 && f === a[0] && !l && (a.length === 1 || n.slice(i, i + a.length) === a) && (u.push(n.slice(r, i)), r = i + a.length), l ? l = !1 : f === "\\" && (l = !0), f === "(" || f === "[" || f === "{" ? c.push(f) : (f === ")" && c[c.length - 1] === "(" || f === "]" && c[c.length - 1] === "[" || f === "}" && c[c.length - 1] === "{") && c.pop();
    }
    return u.push(n.slice(r)), u;
  }
})(Ou);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(i, f) {
    for (var d in f)
      Object.defineProperty(i, d, {
        enumerable: !0,
        get: f[d]
      });
  }
  e(t, {
    parseBoxShadowValue: function() {
      return r;
    },
    formatBoxShadowValue: function() {
      return l;
    }
  });
  const n = Ou;
  let a = /* @__PURE__ */ new Set([
    "inset",
    "inherit",
    "initial",
    "revert",
    "unset"
  ]), c = /\ +(?![^(]*\))/g, u = /^-?(\d+|\.\d+)(.*?)$/g;
  function r(i) {
    return (0, n.splitAtTopLevelOnly)(i, ",").map((d) => {
      let s = d.trim(), o = {
        raw: s
      }, m = s.split(c), h = /* @__PURE__ */ new Set();
      for (let y of m)
        u.lastIndex = 0, !h.has("KEYWORD") && a.has(y) ? (o.keyword = y, h.add("KEYWORD")) : u.test(y) ? h.has("X") ? h.has("Y") ? h.has("BLUR") ? h.has("SPREAD") || (o.spread = y, h.add("SPREAD")) : (o.blur = y, h.add("BLUR")) : (o.y = y, h.add("Y")) : (o.x = y, h.add("X")) : o.color ? (o.unknown || (o.unknown = []), o.unknown.push(y)) : o.color = y;
      return o.valid = o.x !== void 0 && o.y !== void 0, o;
    });
  }
  function l(i) {
    return i.map((f) => f.valid ? [
      f.keyword,
      f.x,
      f.y,
      f.blur,
      f.spread,
      f.color
    ].filter(Boolean).join(" ") : f.raw).join(", ");
  }
})(K0);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(O, G) {
    for (var W in G)
      Object.defineProperty(O, W, {
        enumerable: !0,
        get: G[W]
      });
  }
  e(t, {
    normalize: function() {
      return f;
    },
    url: function() {
      return d;
    },
    number: function() {
      return s;
    },
    percentage: function() {
      return o;
    },
    length: function() {
      return y;
    },
    lineWidth: function() {
      return E;
    },
    shadow: function() {
      return S;
    },
    color: function() {
      return g;
    },
    image: function() {
      return P;
    },
    gradient: function() {
      return N;
    },
    position: function() {
      return I;
    },
    familyName: function() {
      return D;
    },
    genericName: function() {
      return F;
    },
    absoluteSize: function() {
      return T;
    },
    relativeSize: function() {
      return w;
    }
  });
  const n = z0, a = K0, c = Ou;
  let u = [
    "min",
    "max",
    "clamp",
    "calc"
  ];
  function r(O) {
    return u.some((G) => new RegExp(`^${G}\\(.*\\)`).test(O));
  }
  const l = "--tw-placeholder", i = new RegExp(l, "g");
  function f(O, G = !0) {
    return O.startsWith("--") ? `var(${O})` : O.includes("url(") ? O.split(/(url\(.*?\))/g).filter(Boolean).map((W) => /^url\(.*?\)$/.test(W) ? W : f(W, !1)).join("") : (O = O.replace(/([^\\])_+/g, (W, U) => U + " ".repeat(W.length - 1)).replace(/^_/g, " ").replace(/\\_/g, "_"), G && (O = O.trim()), O = O.replace(/(calc|min|max|clamp)\(.+\)/g, (W) => {
      let U = [];
      return W.replace(/var\((--.+?)[,)]/g, (M, B) => (U.push(B), M.replace(B, l))).replace(/(-?\d*\.?\d(?!\b-\d.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ").replace(i, () => U.shift());
    }), O);
  }
  function d(O) {
    return O.startsWith("url(");
  }
  function s(O) {
    return !isNaN(Number(O)) || r(O);
  }
  function o(O) {
    return O.endsWith("%") && s(O.slice(0, -1)) || r(O);
  }
  let h = `(?:${[
    "cm",
    "mm",
    "Q",
    "in",
    "pc",
    "pt",
    "px",
    "em",
    "ex",
    "ch",
    "rem",
    "lh",
    "rlh",
    "vw",
    "vh",
    "vmin",
    "vmax",
    "vb",
    "vi",
    "svw",
    "svh",
    "lvw",
    "lvh",
    "dvw",
    "dvh",
    "cqw",
    "cqh",
    "cqi",
    "cqb",
    "cqmin",
    "cqmax"
  ].join("|")})`;
  function y(O) {
    return O === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${h}$`).test(O) || r(O);
  }
  let b = /* @__PURE__ */ new Set([
    "thin",
    "medium",
    "thick"
  ]);
  function E(O) {
    return b.has(O);
  }
  function S(O) {
    let G = (0, a.parseBoxShadowValue)(f(O));
    for (let W of G)
      if (!W.valid)
        return !1;
    return !0;
  }
  function g(O) {
    let G = 0;
    return (0, c.splitAtTopLevelOnly)(O, "_").every((U) => (U = f(U), U.startsWith("var(") ? !0 : (0, n.parseColor)(U, {
      loose: !0
    }) !== null ? (G++, !0) : !1)) ? G > 0 : !1;
  }
  function P(O) {
    let G = 0;
    return (0, c.splitAtTopLevelOnly)(O, ",").every((U) => (U = f(U), U.startsWith("var(") ? !0 : d(U) || N(U) || [
      "element(",
      "image(",
      "cross-fade(",
      "image-set("
    ].some((M) => U.startsWith(M)) ? (G++, !0) : !1)) ? G > 0 : !1;
  }
  let R = /* @__PURE__ */ new Set([
    "linear-gradient",
    "radial-gradient",
    "repeating-linear-gradient",
    "repeating-radial-gradient",
    "conic-gradient"
  ]);
  function N(O) {
    O = f(O);
    for (let G of R)
      if (O.startsWith(`${G}(`))
        return !0;
    return !1;
  }
  let C = /* @__PURE__ */ new Set([
    "center",
    "top",
    "right",
    "bottom",
    "left"
  ]);
  function I(O) {
    let G = 0;
    return (0, c.splitAtTopLevelOnly)(O, "_").every((U) => (U = f(U), U.startsWith("var(") ? !0 : C.has(U) || y(U) || o(U) ? (G++, !0) : !1)) ? G > 0 : !1;
  }
  function D(O) {
    let G = 0;
    return (0, c.splitAtTopLevelOnly)(O, ",").every((U) => (U = f(U), U.startsWith("var(") ? !0 : U.includes(" ") && !/(['"])([^"']+)\1/g.test(U) || /^\d/g.test(U) ? !1 : (G++, !0))) ? G > 0 : !1;
  }
  let j = /* @__PURE__ */ new Set([
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui",
    "ui-serif",
    "ui-sans-serif",
    "ui-monospace",
    "ui-rounded",
    "math",
    "emoji",
    "fangsong"
  ]);
  function F(O) {
    return j.has(O);
  }
  let _ = /* @__PURE__ */ new Set([
    "xx-small",
    "x-small",
    "small",
    "medium",
    "large",
    "x-large",
    "x-large",
    "xxx-large"
  ]);
  function T(O) {
    return _.has(O);
  }
  let v = /* @__PURE__ */ new Set([
    "larger",
    "smaller"
  ]);
  function w(O) {
    return v.has(O);
  }
})(Iu);
var o2 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "backgroundSize", {
    enumerable: !0,
    get: function() {
      return a;
    }
  });
  const e = Iu, n = Ou;
  function a(c) {
    let u = [
      "cover",
      "contain"
    ];
    return (0, n.splitAtTopLevelOnly)(c, ",").every((r) => {
      let l = (0, n.splitAtTopLevelOnly)(r, "_").filter(Boolean);
      return l.length === 1 && u.includes(l[0]) ? !0 : l.length !== 1 && l.length !== 2 ? !1 : l.every((i) => (0, e.length)(i) || (0, e.percentage)(i) || i === "auto");
    });
  }
})(o2);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(D, j) {
    for (var F in j)
      Object.defineProperty(D, F, {
        enumerable: !0,
        get: j[F]
      });
  }
  e(t, {
    updateAllClasses: function() {
      return f;
    },
    asValue: function() {
      return o;
    },
    parseColorFormat: function() {
      return y;
    },
    asColor: function() {
      return E;
    },
    asLookupValue: function() {
      return S;
    },
    typeMap: function() {
      return P;
    },
    coerceValue: function() {
      return C;
    },
    getMatchingTypes: function() {
      return I;
    }
  });
  const n = /* @__PURE__ */ i(wd), a = Cu, c = Iu, u = /* @__PURE__ */ i(_d), r = o2, l = _s;
  function i(D) {
    return D && D.__esModule ? D : {
      default: D
    };
  }
  function f(D, j) {
    D.walkClasses((F) => {
      F.value = j(F.value), F.raws && F.raws.value && (F.raws.value = (0, n.default)(F.raws.value));
    });
  }
  function d(D, j) {
    if (!m(D))
      return;
    let F = D.slice(1, -1);
    if (j(F))
      return (0, c.normalize)(F);
  }
  function s(D, j = {}, F) {
    let _ = j[D];
    if (_ !== void 0)
      return (0, u.default)(_);
    if (m(D)) {
      let T = d(D, F);
      return T === void 0 ? void 0 : (0, u.default)(T);
    }
  }
  function o(D, j = {}, { validate: F = () => !0 } = {}) {
    var _;
    let T = (_ = j.values) === null || _ === void 0 ? void 0 : _[D];
    return T !== void 0 ? T : j.supportsNegativeValues && D.startsWith("-") ? s(D.slice(1), j.values, F) : d(D, F);
  }
  function m(D) {
    return D.startsWith("[") && D.endsWith("]");
  }
  function h(D) {
    let j = D.lastIndexOf("/");
    return j === -1 || j === D.length - 1 ? [
      D,
      void 0
    ] : m(D) && !D.includes("]/[") ? [
      D,
      void 0
    ] : [
      D.slice(0, j),
      D.slice(j + 1)
    ];
  }
  function y(D) {
    if (typeof D == "string" && D.includes("<alpha-value>")) {
      let j = D;
      return ({ opacityValue: F = 1 }) => j.replace("<alpha-value>", F);
    }
    return D;
  }
  function b(D) {
    return (0, c.normalize)(D.slice(1, -1));
  }
  function E(D, j = {}, { tailwindConfig: F = {} } = {}) {
    var _;
    if (((_ = j.values) === null || _ === void 0 ? void 0 : _[D]) !== void 0) {
      var T;
      return y((T = j.values) === null || T === void 0 ? void 0 : T[D]);
    }
    let [v, w] = h(D);
    if (w !== void 0) {
      var O, G, W, U;
      let M = (U = (O = j.values) === null || O === void 0 ? void 0 : O[v]) !== null && U !== void 0 ? U : m(v) ? v.slice(1, -1) : void 0;
      return M === void 0 ? void 0 : (M = y(M), m(w) ? (0, a.withAlphaValue)(M, b(w)) : ((G = F.theme) === null || G === void 0 || (W = G.opacity) === null || W === void 0 ? void 0 : W[w]) === void 0 ? void 0 : (0, a.withAlphaValue)(M, F.theme.opacity[w]));
    }
    return o(D, j, {
      validate: c.color
    });
  }
  function S(D, j = {}) {
    var F;
    return (F = j.values) === null || F === void 0 ? void 0 : F[D];
  }
  function g(D) {
    return (j, F) => o(j, F, {
      validate: D
    });
  }
  let P = {
    any: o,
    color: E,
    url: g(c.url),
    image: g(c.image),
    length: g(c.length),
    percentage: g(c.percentage),
    position: g(c.position),
    lookup: S,
    "generic-name": g(c.genericName),
    "family-name": g(c.familyName),
    number: g(c.number),
    "line-width": g(c.lineWidth),
    "absolute-size": g(c.absoluteSize),
    "relative-size": g(c.relativeSize),
    shadow: g(c.shadow),
    size: g(r.backgroundSize)
  }, R = Object.keys(P);
  function N(D, j) {
    let F = D.indexOf(j);
    return F === -1 ? [
      void 0,
      D
    ] : [
      D.slice(0, F),
      D.slice(F + 1)
    ];
  }
  function C(D, j, F, _) {
    if (F.values && j in F.values)
      for (let { type: v } of D ?? []) {
        let w = P[v](j, F, {
          tailwindConfig: _
        });
        if (w !== void 0)
          return [
            w,
            v,
            null
          ];
      }
    if (m(j)) {
      let v = j.slice(1, -1), [w, O] = N(v, ":");
      if (!/^[\w-_]+$/g.test(w))
        O = v;
      else if (w !== void 0 && !R.includes(w))
        return [];
      if (O.length > 0 && R.includes(w))
        return [
          o(`[${O}]`, F),
          w,
          null
        ];
    }
    let T = I(D, j, F, _);
    for (let v of T)
      return v;
    return [];
  }
  function* I(D, j, F, _) {
    let T = (0, l.flagEnabled)(_, "generalizedModifiers"), [v, w] = h(j);
    if (T && F.modifiers != null && (F.modifiers === "any" || typeof F.modifiers == "object" && (w && m(w) || w in F.modifiers)) || (v = j, w = void 0), w !== void 0 && v === "" && (v = "DEFAULT"), w !== void 0 && typeof F.modifiers == "object") {
      var G, W;
      let U = (W = (G = F.modifiers) === null || G === void 0 ? void 0 : G[w]) !== null && W !== void 0 ? W : null;
      U !== null ? w = U : m(w) && (w = b(w));
    }
    for (let { type: U } of D ?? []) {
      let M = P[U](v, F, {
        tailwindConfig: _
      });
      M !== void 0 && (yield [
        M,
        U,
        w ?? null
      ]);
    }
  }
})(Pu);
var Y0 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(n) {
    return typeof n == "function" ? n({}) : n;
  }
})(Y0);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return F;
    }
  });
  const e = /* @__PURE__ */ m(_d), n = /* @__PURE__ */ m(Zw), a = /* @__PURE__ */ m(e2), c = /* @__PURE__ */ m(t2), u = n2, r = Sd, l = i2, i = /* @__PURE__ */ m(tl), f = s2, d = Pu, s = Cu, o = /* @__PURE__ */ m(Y0);
  function m(_) {
    return _ && _.__esModule ? _ : {
      default: _
    };
  }
  function h(_) {
    return typeof _ == "function";
  }
  function y(_, ...T) {
    let v = T.pop();
    for (let w of T)
      for (let O in w) {
        let G = v(_[O], w[O]);
        G === void 0 ? (0, i.default)(_[O]) && (0, i.default)(w[O]) ? _[O] = y({}, _[O], w[O], v) : _[O] = w[O] : _[O] = G;
      }
    return _;
  }
  const b = {
    colors: c.default,
    negative(_) {
      return Object.keys(_).filter((T) => _[T] !== "0").reduce((T, v) => {
        let w = (0, e.default)(_[v]);
        return w !== void 0 && (T[`-${v}`] = w), T;
      }, {});
    },
    breakpoints(_) {
      return Object.keys(_).filter((T) => typeof _[T] == "string").reduce((T, v) => ({
        ...T,
        [`screen-${v}`]: _[v]
      }), {});
    }
  };
  function E(_, ...T) {
    return h(_) ? _(...T) : _;
  }
  function S(_) {
    return _.reduce((T, { extend: v }) => y(T, v, (w, O) => w === void 0 ? [
      O
    ] : Array.isArray(w) ? [
      O,
      ...w
    ] : [
      O,
      w
    ]), {});
  }
  function g(_) {
    return {
      ..._.reduce((T, v) => (0, u.defaults)(T, v), {}),
      // In order to resolve n config objects, we combine all of their `extend` properties
      // into arrays instead of objects so they aren't overridden.
      extend: S(_)
    };
  }
  function P(_, T) {
    if (Array.isArray(_) && (0, i.default)(_[0]))
      return _.concat(T);
    if (Array.isArray(T) && (0, i.default)(T[0]) && (0, i.default)(_))
      return [
        _,
        ...T
      ];
    if (Array.isArray(T))
      return T;
  }
  function R({ extend: _, ...T }) {
    return y(T, _, (v, w) => !h(v) && !w.some(h) ? y({}, v, ...w, P) : (O, G) => y({}, ...[
      v,
      ...w
    ].map((W) => E(W, O, G)), P));
  }
  function* N(_) {
    let T = (0, r.toPath)(_);
    if (T.length === 0 || (yield T, Array.isArray(_)))
      return;
    let v = /^(.*?)\s*\/\s*([^/]+)$/, w = _.match(v);
    if (w !== null) {
      let [, O, G] = w, W = (0, r.toPath)(O);
      W.alpha = G, yield W;
    }
  }
  function C(_) {
    const T = (v, w) => {
      for (const O of N(v)) {
        let G = 0, W = _;
        for (; W != null && G < O.length; )
          W = W[O[G++]], W = h(W) && (O.alpha === void 0 || G <= O.length - 1) ? W(T, b) : W;
        if (W !== void 0) {
          if (O.alpha !== void 0) {
            let U = (0, d.parseColorFormat)(W);
            return (0, s.withAlphaValue)(U, O.alpha, (0, o.default)(U));
          }
          return (0, i.default)(W) ? (0, f.cloneDeep)(W) : W;
        }
      }
      return w;
    };
    return Object.assign(T, {
      theme: T,
      ...b
    }), Object.keys(_).reduce((v, w) => (v[w] = h(_[w]) ? _[w](T, b) : _[w], v), {});
  }
  function I(_) {
    let T = [];
    return _.forEach((v) => {
      T = [
        ...T,
        v
      ];
      var w;
      const O = (w = v == null ? void 0 : v.plugins) !== null && w !== void 0 ? w : [];
      O.length !== 0 && O.forEach((G) => {
        G.__isOptionsFunction && (G = G());
        var W;
        T = [
          ...T,
          ...I([
            (W = G == null ? void 0 : G.config) !== null && W !== void 0 ? W : {}
          ])
        ];
      });
    }), T;
  }
  function D(_) {
    return [
      ..._
    ].reduceRight((v, w) => h(w) ? w({
      corePlugins: v
    }) : (0, a.default)(w, v), n.default);
  }
  function j(_) {
    return [
      ..._
    ].reduceRight((v, w) => [
      ...v,
      ...w
    ], []);
  }
  function F(_) {
    let T = [
      ...I(_),
      {
        prefix: "",
        important: !1,
        separator: ":"
      }
    ];
    var v, w;
    return (0, l.normalizeConfig)((0, u.defaults)({
      theme: C(R(g(T.map((O) => (v = O == null ? void 0 : O.theme) !== null && v !== void 0 ? v : {})))),
      corePlugins: D(T.map((O) => O.corePlugins)),
      plugins: j(_.map((O) => (w = O == null ? void 0 : O.plugins) !== null && w !== void 0 ? w : []))
    }, ...T));
  }
})(Qw);
var l2 = {}, G5 = {
  content: [],
  presets: [],
  darkMode: "media",
  // or 'class'
  theme: {
    accentColor: ({ theme: t }) => ({
      ...t("colors"),
      auto: "auto"
    }),
    animation: {
      none: "none",
      spin: "spin 1s linear infinite",
      ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
      pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
      bounce: "bounce 1s infinite"
    },
    aria: {
      checked: 'checked="true"',
      disabled: 'disabled="true"',
      expanded: 'expanded="true"',
      hidden: 'hidden="true"',
      pressed: 'pressed="true"',
      readonly: 'readonly="true"',
      required: 'required="true"',
      selected: 'selected="true"'
    },
    aspectRatio: {
      auto: "auto",
      square: "1 / 1",
      video: "16 / 9"
    },
    backdropBlur: ({ theme: t }) => t("blur"),
    backdropBrightness: ({ theme: t }) => t("brightness"),
    backdropContrast: ({ theme: t }) => t("contrast"),
    backdropGrayscale: ({ theme: t }) => t("grayscale"),
    backdropHueRotate: ({ theme: t }) => t("hueRotate"),
    backdropInvert: ({ theme: t }) => t("invert"),
    backdropOpacity: ({ theme: t }) => t("opacity"),
    backdropSaturate: ({ theme: t }) => t("saturate"),
    backdropSepia: ({ theme: t }) => t("sepia"),
    backgroundColor: ({ theme: t }) => t("colors"),
    backgroundImage: {
      none: "none",
      "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
      "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
      "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
      "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
      "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
      "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
      "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
      "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
    },
    backgroundOpacity: ({ theme: t }) => t("opacity"),
    backgroundPosition: {
      bottom: "bottom",
      center: "center",
      left: "left",
      "left-bottom": "left bottom",
      "left-top": "left top",
      right: "right",
      "right-bottom": "right bottom",
      "right-top": "right top",
      top: "top"
    },
    backgroundSize: {
      auto: "auto",
      cover: "cover",
      contain: "contain"
    },
    blur: {
      0: "0",
      none: "0",
      sm: "4px",
      DEFAULT: "8px",
      md: "12px",
      lg: "16px",
      xl: "24px",
      "2xl": "40px",
      "3xl": "64px"
    },
    borderColor: ({ theme: t }) => ({
      ...t("colors"),
      DEFAULT: t("colors.gray.200", "currentColor")
    }),
    borderOpacity: ({ theme: t }) => t("opacity"),
    borderRadius: {
      none: "0px",
      sm: "0.125rem",
      DEFAULT: "0.25rem",
      md: "0.375rem",
      lg: "0.5rem",
      xl: "0.75rem",
      "2xl": "1rem",
      "3xl": "1.5rem",
      full: "9999px"
    },
    borderSpacing: ({ theme: t }) => ({
      ...t("spacing")
    }),
    borderWidth: {
      DEFAULT: "1px",
      0: "0px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    boxShadow: {
      sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
      DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
      md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
      lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
      xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
      "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
      inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
      none: "none"
    },
    boxShadowColor: ({ theme: t }) => t("colors"),
    brightness: {
      0: "0",
      50: ".5",
      75: ".75",
      90: ".9",
      95: ".95",
      100: "1",
      105: "1.05",
      110: "1.1",
      125: "1.25",
      150: "1.5",
      200: "2"
    },
    caretColor: ({ theme: t }) => t("colors"),
    colors: ({ colors: t }) => ({
      inherit: t.inherit,
      current: t.current,
      transparent: t.transparent,
      black: t.black,
      white: t.white,
      slate: t.slate,
      gray: t.gray,
      zinc: t.zinc,
      neutral: t.neutral,
      stone: t.stone,
      red: t.red,
      orange: t.orange,
      amber: t.amber,
      yellow: t.yellow,
      lime: t.lime,
      green: t.green,
      emerald: t.emerald,
      teal: t.teal,
      cyan: t.cyan,
      sky: t.sky,
      blue: t.blue,
      indigo: t.indigo,
      violet: t.violet,
      purple: t.purple,
      fuchsia: t.fuchsia,
      pink: t.pink,
      rose: t.rose
    }),
    columns: {
      auto: "auto",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12",
      "3xs": "16rem",
      "2xs": "18rem",
      xs: "20rem",
      sm: "24rem",
      md: "28rem",
      lg: "32rem",
      xl: "36rem",
      "2xl": "42rem",
      "3xl": "48rem",
      "4xl": "56rem",
      "5xl": "64rem",
      "6xl": "72rem",
      "7xl": "80rem"
    },
    container: {},
    content: {
      none: "none"
    },
    contrast: {
      0: "0",
      50: ".5",
      75: ".75",
      100: "1",
      125: "1.25",
      150: "1.5",
      200: "2"
    },
    cursor: {
      auto: "auto",
      default: "default",
      pointer: "pointer",
      wait: "wait",
      text: "text",
      move: "move",
      help: "help",
      "not-allowed": "not-allowed",
      none: "none",
      "context-menu": "context-menu",
      progress: "progress",
      cell: "cell",
      crosshair: "crosshair",
      "vertical-text": "vertical-text",
      alias: "alias",
      copy: "copy",
      "no-drop": "no-drop",
      grab: "grab",
      grabbing: "grabbing",
      "all-scroll": "all-scroll",
      "col-resize": "col-resize",
      "row-resize": "row-resize",
      "n-resize": "n-resize",
      "e-resize": "e-resize",
      "s-resize": "s-resize",
      "w-resize": "w-resize",
      "ne-resize": "ne-resize",
      "nw-resize": "nw-resize",
      "se-resize": "se-resize",
      "sw-resize": "sw-resize",
      "ew-resize": "ew-resize",
      "ns-resize": "ns-resize",
      "nesw-resize": "nesw-resize",
      "nwse-resize": "nwse-resize",
      "zoom-in": "zoom-in",
      "zoom-out": "zoom-out"
    },
    divideColor: ({ theme: t }) => t("borderColor"),
    divideOpacity: ({ theme: t }) => t("borderOpacity"),
    divideWidth: ({ theme: t }) => t("borderWidth"),
    dropShadow: {
      sm: "0 1px 1px rgb(0 0 0 / 0.05)",
      DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
      md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
      lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
      xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
      "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
      none: "0 0 #0000"
    },
    fill: ({ theme: t }) => ({
      none: "none",
      ...t("colors")
    }),
    flex: {
      1: "1 1 0%",
      auto: "1 1 auto",
      initial: "0 1 auto",
      none: "none"
    },
    flexBasis: ({ theme: t }) => ({
      auto: "auto",
      ...t("spacing"),
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      "1/5": "20%",
      "2/5": "40%",
      "3/5": "60%",
      "4/5": "80%",
      "1/6": "16.666667%",
      "2/6": "33.333333%",
      "3/6": "50%",
      "4/6": "66.666667%",
      "5/6": "83.333333%",
      "1/12": "8.333333%",
      "2/12": "16.666667%",
      "3/12": "25%",
      "4/12": "33.333333%",
      "5/12": "41.666667%",
      "6/12": "50%",
      "7/12": "58.333333%",
      "8/12": "66.666667%",
      "9/12": "75%",
      "10/12": "83.333333%",
      "11/12": "91.666667%",
      full: "100%"
    }),
    flexGrow: {
      0: "0",
      DEFAULT: "1"
    },
    flexShrink: {
      0: "0",
      DEFAULT: "1"
    },
    fontFamily: {
      sans: [
        "ui-sans-serif",
        "system-ui",
        "-apple-system",
        "BlinkMacSystemFont",
        '"Segoe UI"',
        "Roboto",
        '"Helvetica Neue"',
        "Arial",
        '"Noto Sans"',
        "sans-serif",
        '"Apple Color Emoji"',
        '"Segoe UI Emoji"',
        '"Segoe UI Symbol"',
        '"Noto Color Emoji"'
      ],
      serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"],
      mono: [
        "ui-monospace",
        "SFMono-Regular",
        "Menlo",
        "Monaco",
        "Consolas",
        '"Liberation Mono"',
        '"Courier New"',
        "monospace"
      ]
    },
    fontSize: {
      xs: ["0.75rem", { lineHeight: "1rem" }],
      sm: ["0.875rem", { lineHeight: "1.25rem" }],
      base: ["1rem", { lineHeight: "1.5rem" }],
      lg: ["1.125rem", { lineHeight: "1.75rem" }],
      xl: ["1.25rem", { lineHeight: "1.75rem" }],
      "2xl": ["1.5rem", { lineHeight: "2rem" }],
      "3xl": ["1.875rem", { lineHeight: "2.25rem" }],
      "4xl": ["2.25rem", { lineHeight: "2.5rem" }],
      "5xl": ["3rem", { lineHeight: "1" }],
      "6xl": ["3.75rem", { lineHeight: "1" }],
      "7xl": ["4.5rem", { lineHeight: "1" }],
      "8xl": ["6rem", { lineHeight: "1" }],
      "9xl": ["8rem", { lineHeight: "1" }]
    },
    fontWeight: {
      thin: "100",
      extralight: "200",
      light: "300",
      normal: "400",
      medium: "500",
      semibold: "600",
      bold: "700",
      extrabold: "800",
      black: "900"
    },
    gap: ({ theme: t }) => t("spacing"),
    gradientColorStops: ({ theme: t }) => t("colors"),
    gradientColorStopPositions: {
      "0%": "0%",
      "5%": "5%",
      "10%": "10%",
      "15%": "15%",
      "20%": "20%",
      "25%": "25%",
      "30%": "30%",
      "35%": "35%",
      "40%": "40%",
      "45%": "45%",
      "50%": "50%",
      "55%": "55%",
      "60%": "60%",
      "65%": "65%",
      "70%": "70%",
      "75%": "75%",
      "80%": "80%",
      "85%": "85%",
      "90%": "90%",
      "95%": "95%",
      "100%": "100%"
    },
    grayscale: {
      0: "0",
      DEFAULT: "100%"
    },
    gridAutoColumns: {
      auto: "auto",
      min: "min-content",
      max: "max-content",
      fr: "minmax(0, 1fr)"
    },
    gridAutoRows: {
      auto: "auto",
      min: "min-content",
      max: "max-content",
      fr: "minmax(0, 1fr)"
    },
    gridColumn: {
      auto: "auto",
      "span-1": "span 1 / span 1",
      "span-2": "span 2 / span 2",
      "span-3": "span 3 / span 3",
      "span-4": "span 4 / span 4",
      "span-5": "span 5 / span 5",
      "span-6": "span 6 / span 6",
      "span-7": "span 7 / span 7",
      "span-8": "span 8 / span 8",
      "span-9": "span 9 / span 9",
      "span-10": "span 10 / span 10",
      "span-11": "span 11 / span 11",
      "span-12": "span 12 / span 12",
      "span-full": "1 / -1"
    },
    gridColumnEnd: {
      auto: "auto",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12",
      13: "13"
    },
    gridColumnStart: {
      auto: "auto",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12",
      13: "13"
    },
    gridRow: {
      auto: "auto",
      "span-1": "span 1 / span 1",
      "span-2": "span 2 / span 2",
      "span-3": "span 3 / span 3",
      "span-4": "span 4 / span 4",
      "span-5": "span 5 / span 5",
      "span-6": "span 6 / span 6",
      "span-full": "1 / -1"
    },
    gridRowEnd: {
      auto: "auto",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7"
    },
    gridRowStart: {
      auto: "auto",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7"
    },
    gridTemplateColumns: {
      none: "none",
      1: "repeat(1, minmax(0, 1fr))",
      2: "repeat(2, minmax(0, 1fr))",
      3: "repeat(3, minmax(0, 1fr))",
      4: "repeat(4, minmax(0, 1fr))",
      5: "repeat(5, minmax(0, 1fr))",
      6: "repeat(6, minmax(0, 1fr))",
      7: "repeat(7, minmax(0, 1fr))",
      8: "repeat(8, minmax(0, 1fr))",
      9: "repeat(9, minmax(0, 1fr))",
      10: "repeat(10, minmax(0, 1fr))",
      11: "repeat(11, minmax(0, 1fr))",
      12: "repeat(12, minmax(0, 1fr))"
    },
    gridTemplateRows: {
      none: "none",
      1: "repeat(1, minmax(0, 1fr))",
      2: "repeat(2, minmax(0, 1fr))",
      3: "repeat(3, minmax(0, 1fr))",
      4: "repeat(4, minmax(0, 1fr))",
      5: "repeat(5, minmax(0, 1fr))",
      6: "repeat(6, minmax(0, 1fr))"
    },
    height: ({ theme: t }) => ({
      auto: "auto",
      ...t("spacing"),
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      "1/5": "20%",
      "2/5": "40%",
      "3/5": "60%",
      "4/5": "80%",
      "1/6": "16.666667%",
      "2/6": "33.333333%",
      "3/6": "50%",
      "4/6": "66.666667%",
      "5/6": "83.333333%",
      full: "100%",
      screen: "100vh",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    }),
    hueRotate: {
      0: "0deg",
      15: "15deg",
      30: "30deg",
      60: "60deg",
      90: "90deg",
      180: "180deg"
    },
    inset: ({ theme: t }) => ({
      auto: "auto",
      ...t("spacing"),
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      full: "100%"
    }),
    invert: {
      0: "0",
      DEFAULT: "100%"
    },
    keyframes: {
      spin: {
        to: {
          transform: "rotate(360deg)"
        }
      },
      ping: {
        "75%, 100%": {
          transform: "scale(2)",
          opacity: "0"
        }
      },
      pulse: {
        "50%": {
          opacity: ".5"
        }
      },
      bounce: {
        "0%, 100%": {
          transform: "translateY(-25%)",
          animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
        },
        "50%": {
          transform: "none",
          animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
        }
      }
    },
    letterSpacing: {
      tighter: "-0.05em",
      tight: "-0.025em",
      normal: "0em",
      wide: "0.025em",
      wider: "0.05em",
      widest: "0.1em"
    },
    lineHeight: {
      none: "1",
      tight: "1.25",
      snug: "1.375",
      normal: "1.5",
      relaxed: "1.625",
      loose: "2",
      3: ".75rem",
      4: "1rem",
      5: "1.25rem",
      6: "1.5rem",
      7: "1.75rem",
      8: "2rem",
      9: "2.25rem",
      10: "2.5rem"
    },
    listStyleType: {
      none: "none",
      disc: "disc",
      decimal: "decimal"
    },
    listStyleImage: {
      none: "none"
    },
    margin: ({ theme: t }) => ({
      auto: "auto",
      ...t("spacing")
    }),
    lineClamp: {
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6"
    },
    maxHeight: ({ theme: t }) => ({
      ...t("spacing"),
      none: "none",
      full: "100%",
      screen: "100vh",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    }),
    maxWidth: ({ theme: t, breakpoints: e }) => ({
      none: "none",
      0: "0rem",
      xs: "20rem",
      sm: "24rem",
      md: "28rem",
      lg: "32rem",
      xl: "36rem",
      "2xl": "42rem",
      "3xl": "48rem",
      "4xl": "56rem",
      "5xl": "64rem",
      "6xl": "72rem",
      "7xl": "80rem",
      full: "100%",
      min: "min-content",
      max: "max-content",
      fit: "fit-content",
      prose: "65ch",
      ...e(t("screens"))
    }),
    minHeight: {
      0: "0px",
      full: "100%",
      screen: "100vh",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    },
    minWidth: {
      0: "0px",
      full: "100%",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    },
    objectPosition: {
      bottom: "bottom",
      center: "center",
      left: "left",
      "left-bottom": "left bottom",
      "left-top": "left top",
      right: "right",
      "right-bottom": "right bottom",
      "right-top": "right top",
      top: "top"
    },
    opacity: {
      0: "0",
      5: "0.05",
      10: "0.1",
      20: "0.2",
      25: "0.25",
      30: "0.3",
      40: "0.4",
      50: "0.5",
      60: "0.6",
      70: "0.7",
      75: "0.75",
      80: "0.8",
      90: "0.9",
      95: "0.95",
      100: "1"
    },
    order: {
      first: "-9999",
      last: "9999",
      none: "0",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12"
    },
    outlineColor: ({ theme: t }) => t("colors"),
    outlineOffset: {
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    outlineWidth: {
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    padding: ({ theme: t }) => t("spacing"),
    placeholderColor: ({ theme: t }) => t("colors"),
    placeholderOpacity: ({ theme: t }) => t("opacity"),
    ringColor: ({ theme: t }) => ({
      DEFAULT: t("colors.blue.500", "#3b82f6"),
      ...t("colors")
    }),
    ringOffsetColor: ({ theme: t }) => t("colors"),
    ringOffsetWidth: {
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    ringOpacity: ({ theme: t }) => ({
      DEFAULT: "0.5",
      ...t("opacity")
    }),
    ringWidth: {
      DEFAULT: "3px",
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    rotate: {
      0: "0deg",
      1: "1deg",
      2: "2deg",
      3: "3deg",
      6: "6deg",
      12: "12deg",
      45: "45deg",
      90: "90deg",
      180: "180deg"
    },
    saturate: {
      0: "0",
      50: ".5",
      100: "1",
      150: "1.5",
      200: "2"
    },
    scale: {
      0: "0",
      50: ".5",
      75: ".75",
      90: ".9",
      95: ".95",
      100: "1",
      105: "1.05",
      110: "1.1",
      125: "1.25",
      150: "1.5"
    },
    screens: {
      sm: "640px",
      md: "768px",
      lg: "1024px",
      xl: "1280px",
      "2xl": "1536px"
    },
    scrollMargin: ({ theme: t }) => ({
      ...t("spacing")
    }),
    scrollPadding: ({ theme: t }) => t("spacing"),
    sepia: {
      0: "0",
      DEFAULT: "100%"
    },
    skew: {
      0: "0deg",
      1: "1deg",
      2: "2deg",
      3: "3deg",
      6: "6deg",
      12: "12deg"
    },
    space: ({ theme: t }) => ({
      ...t("spacing")
    }),
    spacing: {
      px: "1px",
      0: "0px",
      0.5: "0.125rem",
      1: "0.25rem",
      1.5: "0.375rem",
      2: "0.5rem",
      2.5: "0.625rem",
      3: "0.75rem",
      3.5: "0.875rem",
      4: "1rem",
      5: "1.25rem",
      6: "1.5rem",
      7: "1.75rem",
      8: "2rem",
      9: "2.25rem",
      10: "2.5rem",
      11: "2.75rem",
      12: "3rem",
      14: "3.5rem",
      16: "4rem",
      20: "5rem",
      24: "6rem",
      28: "7rem",
      32: "8rem",
      36: "9rem",
      40: "10rem",
      44: "11rem",
      48: "12rem",
      52: "13rem",
      56: "14rem",
      60: "15rem",
      64: "16rem",
      72: "18rem",
      80: "20rem",
      96: "24rem"
    },
    stroke: ({ theme: t }) => ({
      none: "none",
      ...t("colors")
    }),
    strokeWidth: {
      0: "0",
      1: "1",
      2: "2"
    },
    supports: {},
    data: {},
    textColor: ({ theme: t }) => t("colors"),
    textDecorationColor: ({ theme: t }) => t("colors"),
    textDecorationThickness: {
      auto: "auto",
      "from-font": "from-font",
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    textIndent: ({ theme: t }) => ({
      ...t("spacing")
    }),
    textOpacity: ({ theme: t }) => t("opacity"),
    textUnderlineOffset: {
      auto: "auto",
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    transformOrigin: {
      center: "center",
      top: "top",
      "top-right": "top right",
      right: "right",
      "bottom-right": "bottom right",
      bottom: "bottom",
      "bottom-left": "bottom left",
      left: "left",
      "top-left": "top left"
    },
    transitionDelay: {
      0: "0s",
      75: "75ms",
      100: "100ms",
      150: "150ms",
      200: "200ms",
      300: "300ms",
      500: "500ms",
      700: "700ms",
      1e3: "1000ms"
    },
    transitionDuration: {
      DEFAULT: "150ms",
      0: "0s",
      75: "75ms",
      100: "100ms",
      150: "150ms",
      200: "200ms",
      300: "300ms",
      500: "500ms",
      700: "700ms",
      1e3: "1000ms"
    },
    transitionProperty: {
      none: "none",
      all: "all",
      DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
      colors: "color, background-color, border-color, text-decoration-color, fill, stroke",
      opacity: "opacity",
      shadow: "box-shadow",
      transform: "transform"
    },
    transitionTimingFunction: {
      DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
      linear: "linear",
      in: "cubic-bezier(0.4, 0, 1, 1)",
      out: "cubic-bezier(0, 0, 0.2, 1)",
      "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
    },
    translate: ({ theme: t }) => ({
      ...t("spacing"),
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      full: "100%"
    }),
    width: ({ theme: t }) => ({
      auto: "auto",
      ...t("spacing"),
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      "1/5": "20%",
      "2/5": "40%",
      "3/5": "60%",
      "4/5": "80%",
      "1/6": "16.666667%",
      "2/6": "33.333333%",
      "3/6": "50%",
      "4/6": "66.666667%",
      "5/6": "83.333333%",
      "1/12": "8.333333%",
      "2/12": "16.666667%",
      "3/12": "25%",
      "4/12": "33.333333%",
      "5/12": "41.666667%",
      "6/12": "50%",
      "7/12": "58.333333%",
      "8/12": "66.666667%",
      "9/12": "75%",
      "10/12": "83.333333%",
      "11/12": "91.666667%",
      full: "100%",
      screen: "100vw",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    }),
    willChange: {
      auto: "auto",
      scroll: "scroll-position",
      contents: "contents",
      transform: "transform"
    },
    zIndex: {
      auto: "auto",
      0: "0",
      10: "10",
      20: "20",
      30: "30",
      40: "40",
      50: "50"
    }
  },
  plugins: []
};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return c;
    }
  });
  const e = /* @__PURE__ */ a(G5), n = _s;
  function a(u) {
    return u && u.__esModule ? u : {
      default: u
    };
  }
  function c(u) {
    var r;
    const l = ((r = u == null ? void 0 : u.presets) !== null && r !== void 0 ? r : [
      e.default
    ]).slice().reverse().flatMap((d) => c(d instanceof Function ? d() : d)), i = {
      // Add experimental configs here...
      respectDefaultRingColorOpacity: {
        theme: {
          ringColor: ({ theme: d }) => ({
            DEFAULT: "#3b82f67f",
            ...d("colors")
          })
        }
      },
      disableColorOpacityUtilitiesByDefault: {
        corePlugins: {
          backgroundOpacity: !1,
          borderOpacity: !1,
          divideOpacity: !1,
          placeholderOpacity: !1,
          ringOpacity: !1,
          textOpacity: !1
        }
      }
    }, f = Object.keys(i).filter((d) => (0, n.flagEnabled)(u, d)).map((d) => i[d]);
    return [
      u,
      ...f,
      ...l
    ];
  }
})(l2);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return c;
    }
  });
  const e = /* @__PURE__ */ a(Qw), n = /* @__PURE__ */ a(l2);
  function a(u) {
    return u && u.__esModule ? u : {
      default: u
    };
  }
  function c(...u) {
    let [, ...r] = (0, n.default)(u[0]);
    return (0, e.default)([
      ...u,
      ...r
    ]);
  }
})(Jw);
var u2 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(s, o) {
    for (var m in o)
      Object.defineProperty(s, m, {
        enumerable: !0,
        get: o[m]
      });
  }
  e(t, {
    default: function() {
      return f;
    },
    resolveDefaultConfigPath: function() {
      return d;
    }
  });
  const n = /* @__PURE__ */ c(Dn), a = /* @__PURE__ */ c(Lr);
  function c(s) {
    return s && s.__esModule ? s : {
      default: s
    };
  }
  const u = [
    "./tailwind.config.js",
    "./tailwind.config.cjs",
    "./tailwind.config.mjs",
    "./tailwind.config.ts"
  ];
  function r(s) {
    return typeof s == "object" && s !== null;
  }
  function l(s) {
    return Object.keys(s).length === 0;
  }
  function i(s) {
    return typeof s == "string" || s instanceof String;
  }
  function f(s) {
    return r(s) && s.config === void 0 && !l(s) ? null : r(s) && s.config !== void 0 && i(s.config) ? a.default.resolve(s.config) : r(s) && s.config !== void 0 && r(s.config) ? null : i(s) ? a.default.resolve(s) : d();
  }
  function d() {
    for (const s of u)
      try {
        const o = a.default.resolve(s);
        return n.default.accessSync(o), o;
      } catch {
      }
    return null;
  }
})(u2);
var Th = {};
let Fv = G0, Bv = xr, t1 = class c2 extends Error {
  constructor(e, n, a, c, u, r) {
    super(e), this.name = "CssSyntaxError", this.reason = e, u && (this.file = u), c && (this.source = c), r && (this.plugin = r), typeof n < "u" && typeof a < "u" && (typeof n == "number" ? (this.line = n, this.column = a) : (this.line = n.line, this.column = n.column, this.endLine = a.line, this.endColumn = a.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, c2);
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
  }
  showSourceCode(e) {
    if (!this.source)
      return "";
    let n = this.source;
    e == null && (e = Fv.isColorSupported), Bv && e && (n = Bv(n));
    let a = n.split(/\r?\n/), c = Math.max(this.line - 3, 0), u = Math.min(this.line + 2, a.length), r = String(u).length, l, i;
    if (e) {
      let { bold: f, gray: d, red: s } = Fv.createColors(!0);
      l = (o) => f(s(o)), i = (o) => d(o);
    } else
      l = i = (f) => f;
    return a.slice(c, u).map((f, d) => {
      let s = c + 1 + d, o = " " + (" " + s).slice(-r) + " | ";
      if (s === this.line) {
        let m = i(o.replace(/\d/g, " ")) + f.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return l(">") + i(o) + f + `
 ` + m + l("^");
      }
      return " " + i(o) + f;
    }).join(`
`);
  }
  toString() {
    let e = this.showSourceCode();
    return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
  }
};
var X0 = t1;
t1.default = t1;
var ku = {};
ku.isClean = Symbol("isClean");
ku.my = Symbol("my");
const $v = {
  after: `
`,
  beforeClose: `
`,
  beforeComment: `
`,
  beforeDecl: `
`,
  beforeOpen: " ",
  beforeRule: `
`,
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: !1
};
function z5(t) {
  return t[0].toUpperCase() + t.slice(1);
}
let r1 = class {
  constructor(e) {
    this.builder = e;
  }
  atrule(e, n) {
    let a = "@" + e.name, c = e.params ? this.rawValue(e, "params") : "";
    if (typeof e.raws.afterName < "u" ? a += e.raws.afterName : c && (a += " "), e.nodes)
      this.block(e, a + c);
    else {
      let u = (e.raws.between || "") + (n ? ";" : "");
      this.builder(a + c + u, e);
    }
  }
  beforeAfter(e, n) {
    let a;
    e.type === "decl" ? a = this.raw(e, null, "beforeDecl") : e.type === "comment" ? a = this.raw(e, null, "beforeComment") : n === "before" ? a = this.raw(e, null, "beforeRule") : a = this.raw(e, null, "beforeClose");
    let c = e.parent, u = 0;
    for (; c && c.type !== "root"; )
      u += 1, c = c.parent;
    if (a.includes(`
`)) {
      let r = this.raw(e, null, "indent");
      if (r.length)
        for (let l = 0; l < u; l++)
          a += r;
    }
    return a;
  }
  block(e, n) {
    let a = this.raw(e, "between", "beforeOpen");
    this.builder(n + a + "{", e, "start");
    let c;
    e.nodes && e.nodes.length ? (this.body(e), c = this.raw(e, "after")) : c = this.raw(e, "after", "emptyBody"), c && this.builder(c), this.builder("}", e, "end");
  }
  body(e) {
    let n = e.nodes.length - 1;
    for (; n > 0 && e.nodes[n].type === "comment"; )
      n -= 1;
    let a = this.raw(e, "semicolon");
    for (let c = 0; c < e.nodes.length; c++) {
      let u = e.nodes[c], r = this.raw(u, "before");
      r && this.builder(r), this.stringify(u, n !== c || a);
    }
  }
  comment(e) {
    let n = this.raw(e, "left", "commentLeft"), a = this.raw(e, "right", "commentRight");
    this.builder("/*" + n + e.text + a + "*/", e);
  }
  decl(e, n) {
    let a = this.raw(e, "between", "colon"), c = e.prop + a + this.rawValue(e, "value");
    e.important && (c += e.raws.important || " !important"), n && (c += ";"), this.builder(c, e);
  }
  document(e) {
    this.body(e);
  }
  raw(e, n, a) {
    let c;
    if (a || (a = n), n && (c = e.raws[n], typeof c < "u"))
      return c;
    let u = e.parent;
    if (a === "before" && (!u || u.type === "root" && u.first === e || u && u.type === "document"))
      return "";
    if (!u)
      return $v[a];
    let r = e.root();
    if (r.rawCache || (r.rawCache = {}), typeof r.rawCache[a] < "u")
      return r.rawCache[a];
    if (a === "before" || a === "after")
      return this.beforeAfter(e, a);
    {
      let l = "raw" + z5(a);
      this[l] ? c = this[l](r, e) : r.walk((i) => {
        if (c = i.raws[n], typeof c < "u")
          return !1;
      });
    }
    return typeof c > "u" && (c = $v[a]), r.rawCache[a] = c, c;
  }
  rawBeforeClose(e) {
    let n;
    return e.walk((a) => {
      if (a.nodes && a.nodes.length > 0 && typeof a.raws.after < "u")
        return n = a.raws.after, n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")), !1;
    }), n && (n = n.replace(/\S/g, "")), n;
  }
  rawBeforeComment(e, n) {
    let a;
    return e.walkComments((c) => {
      if (typeof c.raws.before < "u")
        return a = c.raws.before, a.includes(`
`) && (a = a.replace(/[^\n]+$/, "")), !1;
    }), typeof a > "u" ? a = this.raw(n, null, "beforeDecl") : a && (a = a.replace(/\S/g, "")), a;
  }
  rawBeforeDecl(e, n) {
    let a;
    return e.walkDecls((c) => {
      if (typeof c.raws.before < "u")
        return a = c.raws.before, a.includes(`
`) && (a = a.replace(/[^\n]+$/, "")), !1;
    }), typeof a > "u" ? a = this.raw(n, null, "beforeRule") : a && (a = a.replace(/\S/g, "")), a;
  }
  rawBeforeOpen(e) {
    let n;
    return e.walk((a) => {
      if (a.type !== "decl" && (n = a.raws.between, typeof n < "u"))
        return !1;
    }), n;
  }
  rawBeforeRule(e) {
    let n;
    return e.walk((a) => {
      if (a.nodes && (a.parent !== e || e.first !== a) && typeof a.raws.before < "u")
        return n = a.raws.before, n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")), !1;
    }), n && (n = n.replace(/\S/g, "")), n;
  }
  rawColon(e) {
    let n;
    return e.walkDecls((a) => {
      if (typeof a.raws.between < "u")
        return n = a.raws.between.replace(/[^\s:]/g, ""), !1;
    }), n;
  }
  rawEmptyBody(e) {
    let n;
    return e.walk((a) => {
      if (a.nodes && a.nodes.length === 0 && (n = a.raws.after, typeof n < "u"))
        return !1;
    }), n;
  }
  rawIndent(e) {
    if (e.raws.indent)
      return e.raws.indent;
    let n;
    return e.walk((a) => {
      let c = a.parent;
      if (c && c !== e && c.parent && c.parent === e && typeof a.raws.before < "u") {
        let u = a.raws.before.split(`
`);
        return n = u[u.length - 1], n = n.replace(/\S/g, ""), !1;
      }
    }), n;
  }
  rawSemicolon(e) {
    let n;
    return e.walk((a) => {
      if (a.nodes && a.nodes.length && a.last.type === "decl" && (n = a.raws.semicolon, typeof n < "u"))
        return !1;
    }), n;
  }
  rawValue(e, n) {
    let a = e[n], c = e.raws[n];
    return c && c.value === a ? c.raw : a;
  }
  root(e) {
    this.body(e), e.raws.after && this.builder(e.raws.after);
  }
  rule(e) {
    this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
  }
  stringify(e, n) {
    if (!this[e.type])
      throw new Error(
        "Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier."
      );
    this[e.type](e, n);
  }
};
var f2 = r1;
r1.default = r1;
let K5 = f2;
function n1(t, e) {
  new K5(e).stringify(t);
}
var Td = n1;
n1.default = n1;
let { isClean: Ac, my: Y5 } = ku, X5 = X0, J5 = f2, Q5 = Td;
function i1(t, e) {
  let n = new t.constructor();
  for (let a in t) {
    if (!Object.prototype.hasOwnProperty.call(t, a) || a === "proxyCache")
      continue;
    let c = t[a], u = typeof c;
    a === "parent" && u === "object" ? e && (n[a] = e) : a === "source" ? n[a] = c : Array.isArray(c) ? n[a] = c.map((r) => i1(r, n)) : (u === "object" && c !== null && (c = i1(c)), n[a] = c);
  }
  return n;
}
let s1 = class {
  constructor(e = {}) {
    this.raws = {}, this[Ac] = !1, this[Y5] = !0;
    for (let n in e)
      if (n === "nodes") {
        this.nodes = [];
        for (let a of e[n])
          typeof a.clone == "function" ? this.append(a.clone()) : this.append(a);
      } else
        this[n] = e[n];
  }
  addToError(e) {
    if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
      let n = this.source;
      e.stack = e.stack.replace(
        /\n\s{4}at /,
        `$&${n.input.from}:${n.start.line}:${n.start.column}$&`
      );
    }
    return e;
  }
  after(e) {
    return this.parent.insertAfter(this, e), this;
  }
  assign(e = {}) {
    for (let n in e)
      this[n] = e[n];
    return this;
  }
  before(e) {
    return this.parent.insertBefore(this, e), this;
  }
  cleanRaws(e) {
    delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
  }
  clone(e = {}) {
    let n = i1(this);
    for (let a in e)
      n[a] = e[a];
    return n;
  }
  cloneAfter(e = {}) {
    let n = this.clone(e);
    return this.parent.insertAfter(this, n), n;
  }
  cloneBefore(e = {}) {
    let n = this.clone(e);
    return this.parent.insertBefore(this, n), n;
  }
  error(e, n = {}) {
    if (this.source) {
      let { end: a, start: c } = this.rangeBy(n);
      return this.source.input.error(
        e,
        { column: c.column, line: c.line },
        { column: a.column, line: a.line },
        n
      );
    }
    return new X5(e);
  }
  getProxyProcessor() {
    return {
      get(e, n) {
        return n === "proxyOf" ? e : n === "root" ? () => e.root().toProxy() : e[n];
      },
      set(e, n, a) {
        return e[n] === a || (e[n] = a, (n === "prop" || n === "value" || n === "name" || n === "params" || n === "important" || /* c8 ignore next */
        n === "text") && e.markDirty()), !0;
      }
    };
  }
  markDirty() {
    if (this[Ac]) {
      this[Ac] = !1;
      let e = this;
      for (; e = e.parent; )
        e[Ac] = !1;
    }
  }
  next() {
    if (!this.parent)
      return;
    let e = this.parent.index(this);
    return this.parent.nodes[e + 1];
  }
  positionBy(e, n) {
    let a = this.source.start;
    if (e.index)
      a = this.positionInside(e.index, n);
    else if (e.word) {
      n = this.toString();
      let c = n.indexOf(e.word);
      c !== -1 && (a = this.positionInside(c, n));
    }
    return a;
  }
  positionInside(e, n) {
    let a = n || this.toString(), c = this.source.start.column, u = this.source.start.line;
    for (let r = 0; r < e; r++)
      a[r] === `
` ? (c = 1, u += 1) : c += 1;
    return { column: c, line: u };
  }
  prev() {
    if (!this.parent)
      return;
    let e = this.parent.index(this);
    return this.parent.nodes[e - 1];
  }
  rangeBy(e) {
    let n = {
      column: this.source.start.column,
      line: this.source.start.line
    }, a = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line
    } : {
      column: n.column + 1,
      line: n.line
    };
    if (e.word) {
      let c = this.toString(), u = c.indexOf(e.word);
      u !== -1 && (n = this.positionInside(u, c), a = this.positionInside(u + e.word.length, c));
    } else
      e.start ? n = {
        column: e.start.column,
        line: e.start.line
      } : e.index && (n = this.positionInside(e.index)), e.end ? a = {
        column: e.end.column,
        line: e.end.line
      } : e.endIndex ? a = this.positionInside(e.endIndex) : e.index && (a = this.positionInside(e.index + 1));
    return (a.line < n.line || a.line === n.line && a.column <= n.column) && (a = { column: n.column + 1, line: n.line }), { end: a, start: n };
  }
  raw(e, n) {
    return new J5().raw(this, e, n);
  }
  remove() {
    return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
  }
  replaceWith(...e) {
    if (this.parent) {
      let n = this, a = !1;
      for (let c of e)
        c === this ? a = !0 : a ? (this.parent.insertAfter(n, c), n = c) : this.parent.insertBefore(n, c);
      a || this.remove();
    }
    return this;
  }
  root() {
    let e = this;
    for (; e.parent && e.parent.type !== "document"; )
      e = e.parent;
    return e;
  }
  toJSON(e, n) {
    let a = {}, c = n == null;
    n = n || /* @__PURE__ */ new Map();
    let u = 0;
    for (let r in this) {
      if (!Object.prototype.hasOwnProperty.call(this, r) || r === "parent" || r === "proxyCache")
        continue;
      let l = this[r];
      if (Array.isArray(l))
        a[r] = l.map((i) => typeof i == "object" && i.toJSON ? i.toJSON(null, n) : i);
      else if (typeof l == "object" && l.toJSON)
        a[r] = l.toJSON(null, n);
      else if (r === "source") {
        let i = n.get(l.input);
        i == null && (i = u, n.set(l.input, u), u++), a[r] = {
          end: l.end,
          inputId: i,
          start: l.start
        };
      } else
        a[r] = l;
    }
    return c && (a.inputs = [...n.keys()].map((r) => r.toJSON())), a;
  }
  toProxy() {
    return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
  }
  toString(e = Q5) {
    e.stringify && (e = e.stringify);
    let n = "";
    return e(this, (a) => {
      n += a;
    }), n;
  }
  warn(e, n, a) {
    let c = { node: this };
    for (let u in a)
      c[u] = a[u];
    return e.warn(n, c);
  }
  get proxyOf() {
    return this;
  }
};
var Ad = s1;
s1.default = s1;
let Z5 = Ad, a1 = class extends Z5 {
  constructor(e) {
    e && typeof e.value < "u" && typeof e.value != "string" && (e = { ...e, value: String(e.value) }), super(e), this.type = "decl";
  }
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
};
var xd = a1;
a1.default = a1;
let eN = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", tN = (t, e = 21) => (n = e) => {
  let a = "", c = n;
  for (; c--; )
    a += t[Math.random() * t.length | 0];
  return a;
}, rN = (t = 21) => {
  let e = "", n = t;
  for (; n--; )
    e += eN[Math.random() * 64 | 0];
  return e;
};
var nN = { nanoid: rN, customAlphabet: tN };
let { SourceMapConsumer: Uv, SourceMapGenerator: Vv } = xr, { existsSync: iN, readFileSync: sN } = Dn, { dirname: Ah, join: aN } = Lr;
function oN(t) {
  return Ve.Buffer ? Ve.Buffer.from(t, "base64").toString() : window.atob(t);
}
let o1 = class {
  constructor(e, n) {
    if (n.map === !1)
      return;
    this.loadAnnotation(e), this.inline = this.startWith(this.annotation, "data:");
    let a = n.map ? n.map.prev : void 0, c = this.loadMap(n.from, a);
    !this.mapFile && n.from && (this.mapFile = n.from), this.mapFile && (this.root = Ah(this.mapFile)), c && (this.text = c);
  }
  consumer() {
    return this.consumerCache || (this.consumerCache = new Uv(this.text)), this.consumerCache;
  }
  decodeInline(e) {
    let n = /^data:application\/json;charset=utf-?8;base64,/, a = /^data:application\/json;base64,/, c = /^data:application\/json;charset=utf-?8,/, u = /^data:application\/json,/;
    if (c.test(e) || u.test(e))
      return decodeURIComponent(e.substr(RegExp.lastMatch.length));
    if (n.test(e) || a.test(e))
      return oN(e.substr(RegExp.lastMatch.length));
    let r = e.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + r);
  }
  getAnnotationURL(e) {
    return e.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(e) {
    return typeof e != "object" ? !1 : typeof e.mappings == "string" || typeof e._mappings == "string" || Array.isArray(e.sections);
  }
  loadAnnotation(e) {
    let n = e.match(/\/\*\s*# sourceMappingURL=/gm);
    if (!n)
      return;
    let a = e.lastIndexOf(n.pop()), c = e.indexOf("*/", a);
    a > -1 && c > -1 && (this.annotation = this.getAnnotationURL(e.substring(a, c)));
  }
  loadFile(e) {
    if (this.root = Ah(e), iN(e))
      return this.mapFile = e, sN(e, "utf-8").toString().trim();
  }
  loadMap(e, n) {
    if (n === !1)
      return !1;
    if (n) {
      if (typeof n == "string")
        return n;
      if (typeof n == "function") {
        let a = n(e);
        if (a) {
          let c = this.loadFile(a);
          if (!c)
            throw new Error(
              "Unable to load previous source map: " + a.toString()
            );
          return c;
        }
      } else {
        if (n instanceof Uv)
          return Vv.fromSourceMap(n).toString();
        if (n instanceof Vv)
          return n.toString();
        if (this.isMap(n))
          return JSON.stringify(n);
        throw new Error(
          "Unsupported previous source map format: " + n.toString()
        );
      }
    } else {
      if (this.inline)
        return this.decodeInline(this.annotation);
      if (this.annotation) {
        let a = this.annotation;
        return e && (a = aN(Ah(e), a)), this.loadFile(a);
      }
    }
  }
  startWith(e, n) {
    return e ? e.substr(0, n.length) === n : !1;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var d2 = o1;
o1.default = o1;
let { SourceMapConsumer: lN, SourceMapGenerator: uN } = xr, { fileURLToPath: Wv, pathToFileURL: xc } = xr, { isAbsolute: l1, resolve: u1 } = Lr, { nanoid: cN } = nN, xh = xr, Hv = X0, fN = d2, Ph = Symbol("fromOffsetCache"), dN = !!(lN && uN), qv = !!(u1 && l1), If = class {
  constructor(e, n = {}) {
    if (e === null || typeof e > "u" || typeof e == "object" && !e.toString)
      throw new Error(`PostCSS received ${e} instead of CSS string`);
    if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, n.from && (!qv || /^\w+:\/\//.test(n.from) || l1(n.from) ? this.file = n.from : this.file = u1(n.from)), qv && dN) {
      let a = new fN(this.css, n);
      if (a.text) {
        this.map = a;
        let c = a.consumer().file;
        !this.file && c && (this.file = this.mapResolve(c));
      }
    }
    this.file || (this.id = "<input css " + cN(6) + ">"), this.map && (this.map.file = this.from);
  }
  error(e, n, a, c = {}) {
    let u, r, l;
    if (n && typeof n == "object") {
      let f = n, d = a;
      if (typeof f.offset == "number") {
        let s = this.fromOffset(f.offset);
        n = s.line, a = s.col;
      } else
        n = f.line, a = f.column;
      if (typeof d.offset == "number") {
        let s = this.fromOffset(d.offset);
        r = s.line, l = s.col;
      } else
        r = d.line, l = d.column;
    } else if (!a) {
      let f = this.fromOffset(n);
      n = f.line, a = f.col;
    }
    let i = this.origin(n, a, r, l);
    return i ? u = new Hv(
      e,
      i.endLine === void 0 ? i.line : { column: i.column, line: i.line },
      i.endLine === void 0 ? i.column : { column: i.endColumn, line: i.endLine },
      i.source,
      i.file,
      c.plugin
    ) : u = new Hv(
      e,
      r === void 0 ? n : { column: a, line: n },
      r === void 0 ? a : { column: l, line: r },
      this.css,
      this.file,
      c.plugin
    ), u.input = { column: a, endColumn: l, endLine: r, line: n, source: this.css }, this.file && (xc && (u.input.url = xc(this.file).toString()), u.input.file = this.file), u;
  }
  fromOffset(e) {
    let n, a;
    if (this[Ph])
      a = this[Ph];
    else {
      let u = this.css.split(`
`);
      a = new Array(u.length);
      let r = 0;
      for (let l = 0, i = u.length; l < i; l++)
        a[l] = r, r += u[l].length + 1;
      this[Ph] = a;
    }
    n = a[a.length - 1];
    let c = 0;
    if (e >= n)
      c = a.length - 1;
    else {
      let u = a.length - 2, r;
      for (; c < u; )
        if (r = c + (u - c >> 1), e < a[r])
          u = r - 1;
        else if (e >= a[r + 1])
          c = r + 1;
        else {
          c = r;
          break;
        }
    }
    return {
      col: e - a[c] + 1,
      line: c + 1
    };
  }
  mapResolve(e) {
    return /^\w+:\/\//.test(e) ? e : u1(this.map.consumer().sourceRoot || this.map.root || ".", e);
  }
  origin(e, n, a, c) {
    if (!this.map)
      return !1;
    let u = this.map.consumer(), r = u.originalPositionFor({ column: n, line: e });
    if (!r.source)
      return !1;
    let l;
    typeof a == "number" && (l = u.originalPositionFor({ column: c, line: a }));
    let i;
    l1(r.source) ? i = xc(r.source) : i = new URL(
      r.source,
      this.map.consumer().sourceRoot || xc(this.map.mapFile)
    );
    let f = {
      column: r.column,
      endColumn: l && l.column,
      endLine: l && l.line,
      line: r.line,
      url: i.toString()
    };
    if (i.protocol === "file:")
      if (Wv)
        f.file = Wv(i);
      else
        throw new Error("file: protocol is not available in this PostCSS build");
    let d = u.sourceContentFor(r.source);
    return d && (f.source = d), f;
  }
  toJSON() {
    let e = {};
    for (let n of ["hasBOM", "css", "file", "id"])
      this[n] != null && (e[n] = this[n]);
    return this.map && (e.map = { ...this.map }, e.map.consumerCache && (e.map.consumerCache = void 0)), e;
  }
  get from() {
    return this.file || this.id;
  }
};
var Pd = If;
If.default = If;
xh && xh.registerInput && xh.registerInput(If);
let { SourceMapConsumer: p2, SourceMapGenerator: af } = xr, { dirname: of, relative: h2, resolve: m2, sep: y2 } = Lr, { pathToFileURL: Gv } = xr, pN = Pd, hN = !!(p2 && af), mN = !!(of && m2 && h2 && y2), yN = class {
  constructor(e, n, a, c) {
    this.stringify = e, this.mapOpts = a.map || {}, this.root = n, this.opts = a, this.css = c, this.originalCSS = c, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let e;
    this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
    let n = `
`;
    this.css.includes(`\r
`) && (n = `\r
`), this.css += n + "/*# sourceMappingURL=" + e + " */";
  }
  applyPrevMaps() {
    for (let e of this.previous()) {
      let n = this.toUrl(this.path(e.file)), a = e.root || of(e.file), c;
      this.mapOpts.sourcesContent === !1 ? (c = new p2(e.text), c.sourcesContent && (c.sourcesContent = null)) : c = e.consumer(), this.map.applySourceMap(c, n, this.toUrl(this.path(a)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation !== !1)
      if (this.root) {
        let e;
        for (let n = this.root.nodes.length - 1; n >= 0; n--)
          e = this.root.nodes[n], e.type === "comment" && e.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(n);
      } else
        this.css && (this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, ""));
  }
  generate() {
    if (this.clearAnnotation(), mN && hN && this.isMap())
      return this.generateMap();
    {
      let e = "";
      return this.stringify(this.root, (n) => {
        e += n;
      }), [e];
    }
  }
  generateMap() {
    if (this.root)
      this.generateString();
    else if (this.previous().length === 1) {
      let e = this.previous()[0].consumer();
      e.file = this.outputFile(), this.map = af.fromSourceMap(e);
    } else
      this.map = new af({ file: this.outputFile() }), this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
  }
  generateString() {
    this.css = "", this.map = new af({ file: this.outputFile() });
    let e = 1, n = 1, a = "<no source>", c = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    }, u, r;
    this.stringify(this.root, (l, i, f) => {
      if (this.css += l, i && f !== "end" && (c.generated.line = e, c.generated.column = n - 1, i.source && i.source.start ? (c.source = this.sourcePath(i), c.original.line = i.source.start.line, c.original.column = i.source.start.column - 1, this.map.addMapping(c)) : (c.source = a, c.original.line = 1, c.original.column = 0, this.map.addMapping(c))), u = l.match(/\n/g), u ? (e += u.length, r = l.lastIndexOf(`
`), n = l.length - r) : n += l.length, i && f !== "start") {
        let d = i.parent || { raws: {} };
        (!(i.type === "decl" || i.type === "atrule" && !i.nodes) || i !== d.last || d.raws.semicolon) && (i.source && i.source.end ? (c.source = this.sourcePath(i), c.original.line = i.source.end.line, c.original.column = i.source.end.column - 1, c.generated.line = e, c.generated.column = n - 2, this.map.addMapping(c)) : (c.source = a, c.original.line = 1, c.original.column = 0, c.generated.line = e, c.generated.column = n - 1, this.map.addMapping(c)));
      }
    });
  }
  isAnnotation() {
    return this.isInline() ? !0 : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e) => e.annotation) : !0;
  }
  isInline() {
    if (typeof this.mapOpts.inline < "u")
      return this.mapOpts.inline;
    let e = this.mapOpts.annotation;
    return typeof e < "u" && e !== !0 ? !1 : this.previous().length ? this.previous().some((n) => n.inline) : !0;
  }
  isMap() {
    return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
  }
  isSourcesContent() {
    return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e) => e.withContent()) : !0;
  }
  outputFile() {
    return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
  }
  path(e) {
    if (this.mapOpts.absolute || e.charCodeAt(0) === 60 || /^\w+:\/\//.test(e))
      return e;
    let n = this.memoizedPaths.get(e);
    if (n)
      return n;
    let a = this.opts.to ? of(this.opts.to) : ".";
    typeof this.mapOpts.annotation == "string" && (a = of(m2(a, this.mapOpts.annotation)));
    let c = h2(a, e);
    return this.memoizedPaths.set(e, c), c;
  }
  previous() {
    if (!this.previousMaps)
      if (this.previousMaps = [], this.root)
        this.root.walk((e) => {
          if (e.source && e.source.input.map) {
            let n = e.source.input.map;
            this.previousMaps.includes(n) || this.previousMaps.push(n);
          }
        });
      else {
        let e = new pN(this.originalCSS, this.opts);
        e.map && this.previousMaps.push(e.map);
      }
    return this.previousMaps;
  }
  setSourcesContent() {
    let e = {};
    if (this.root)
      this.root.walk((n) => {
        if (n.source) {
          let a = n.source.input.from;
          if (a && !e[a]) {
            e[a] = !0;
            let c = this.usesFileUrls ? this.toFileUrl(a) : this.toUrl(this.path(a));
            this.map.setSourceContent(c, n.source.input.css);
          }
        }
      });
    else if (this.css) {
      let n = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(n, this.css);
    }
  }
  sourcePath(e) {
    return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
  }
  toBase64(e) {
    return Ve.Buffer ? Ve.Buffer.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
  }
  toFileUrl(e) {
    let n = this.memoizedFileURLs.get(e);
    if (n)
      return n;
    if (Gv) {
      let a = Gv(e).toString();
      return this.memoizedFileURLs.set(e, a), a;
    } else
      throw new Error(
        "`map.absolute` option is not available in this PostCSS build"
      );
  }
  toUrl(e) {
    let n = this.memoizedURLs.get(e);
    if (n)
      return n;
    y2 === "\\" && (e = e.replace(/\\/g, "/"));
    let a = encodeURI(e).replace(/[#?]/g, encodeURIComponent);
    return this.memoizedURLs.set(e, a), a;
  }
};
var b2 = yN;
let bN = Ad, c1 = class extends bN {
  constructor(e) {
    super(e), this.type = "comment";
  }
};
var Cd = c1;
c1.default = c1;
let { isClean: g2, my: v2 } = ku, E2 = xd, _2 = Cd, gN = Ad, S2, J0, Q0, w2;
function T2(t) {
  return t.map((e) => (e.nodes && (e.nodes = T2(e.nodes)), delete e.source, e));
}
function A2(t) {
  if (t[g2] = !1, t.proxyOf.nodes)
    for (let e of t.proxyOf.nodes)
      A2(e);
}
let Ls = class x2 extends gN {
  append(...e) {
    for (let n of e) {
      let a = this.normalize(n, this.last);
      for (let c of a)
        this.proxyOf.nodes.push(c);
    }
    return this.markDirty(), this;
  }
  cleanRaws(e) {
    if (super.cleanRaws(e), this.nodes)
      for (let n of this.nodes)
        n.cleanRaws(e);
  }
  each(e) {
    if (!this.proxyOf.nodes)
      return;
    let n = this.getIterator(), a, c;
    for (; this.indexes[n] < this.proxyOf.nodes.length && (a = this.indexes[n], c = e(this.proxyOf.nodes[a], a), c !== !1); )
      this.indexes[n] += 1;
    return delete this.indexes[n], c;
  }
  every(e) {
    return this.nodes.every(e);
  }
  getIterator() {
    this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
    let e = this.lastEach;
    return this.indexes[e] = 0, e;
  }
  getProxyProcessor() {
    return {
      get(e, n) {
        return n === "proxyOf" ? e : e[n] ? n === "each" || typeof n == "string" && n.startsWith("walk") ? (...a) => e[n](
          ...a.map((c) => typeof c == "function" ? (u, r) => c(u.toProxy(), r) : c)
        ) : n === "every" || n === "some" ? (a) => e[n](
          (c, ...u) => a(c.toProxy(), ...u)
        ) : n === "root" ? () => e.root().toProxy() : n === "nodes" ? e.nodes.map((a) => a.toProxy()) : n === "first" || n === "last" ? e[n].toProxy() : e[n] : e[n];
      },
      set(e, n, a) {
        return e[n] === a || (e[n] = a, (n === "name" || n === "params" || n === "selector") && e.markDirty()), !0;
      }
    };
  }
  index(e) {
    return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
  }
  insertAfter(e, n) {
    let a = this.index(e), c = this.normalize(n, this.proxyOf.nodes[a]).reverse();
    a = this.index(e);
    for (let r of c)
      this.proxyOf.nodes.splice(a + 1, 0, r);
    let u;
    for (let r in this.indexes)
      u = this.indexes[r], a < u && (this.indexes[r] = u + c.length);
    return this.markDirty(), this;
  }
  insertBefore(e, n) {
    let a = this.index(e), c = a === 0 ? "prepend" : !1, u = this.normalize(n, this.proxyOf.nodes[a], c).reverse();
    a = this.index(e);
    for (let l of u)
      this.proxyOf.nodes.splice(a, 0, l);
    let r;
    for (let l in this.indexes)
      r = this.indexes[l], a <= r && (this.indexes[l] = r + u.length);
    return this.markDirty(), this;
  }
  normalize(e, n) {
    if (typeof e == "string")
      e = T2(S2(e).nodes);
    else if (typeof e > "u")
      e = [];
    else if (Array.isArray(e)) {
      e = e.slice(0);
      for (let c of e)
        c.parent && c.parent.removeChild(c, "ignore");
    } else if (e.type === "root" && this.type !== "document") {
      e = e.nodes.slice(0);
      for (let c of e)
        c.parent && c.parent.removeChild(c, "ignore");
    } else if (e.type)
      e = [e];
    else if (e.prop) {
      if (typeof e.value > "u")
        throw new Error("Value field is missed in node creation");
      typeof e.value != "string" && (e.value = String(e.value)), e = [new E2(e)];
    } else if (e.selector)
      e = [new J0(e)];
    else if (e.name)
      e = [new Q0(e)];
    else if (e.text)
      e = [new _2(e)];
    else
      throw new Error("Unknown node type in node creation");
    return e.map((c) => (c[v2] || x2.rebuild(c), c = c.proxyOf, c.parent && c.parent.removeChild(c), c[g2] && A2(c), typeof c.raws.before > "u" && n && typeof n.raws.before < "u" && (c.raws.before = n.raws.before.replace(/\S/g, "")), c.parent = this.proxyOf, c));
  }
  prepend(...e) {
    e = e.reverse();
    for (let n of e) {
      let a = this.normalize(n, this.first, "prepend").reverse();
      for (let c of a)
        this.proxyOf.nodes.unshift(c);
      for (let c in this.indexes)
        this.indexes[c] = this.indexes[c] + a.length;
    }
    return this.markDirty(), this;
  }
  push(e) {
    return e.parent = this, this.proxyOf.nodes.push(e), this;
  }
  removeAll() {
    for (let e of this.proxyOf.nodes)
      e.parent = void 0;
    return this.proxyOf.nodes = [], this.markDirty(), this;
  }
  removeChild(e) {
    e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1);
    let n;
    for (let a in this.indexes)
      n = this.indexes[a], n >= e && (this.indexes[a] = n - 1);
    return this.markDirty(), this;
  }
  replaceValues(e, n, a) {
    return a || (a = n, n = {}), this.walkDecls((c) => {
      n.props && !n.props.includes(c.prop) || n.fast && !c.value.includes(n.fast) || (c.value = c.value.replace(e, a));
    }), this.markDirty(), this;
  }
  some(e) {
    return this.nodes.some(e);
  }
  walk(e) {
    return this.each((n, a) => {
      let c;
      try {
        c = e(n, a);
      } catch (u) {
        throw n.addToError(u);
      }
      return c !== !1 && n.walk && (c = n.walk(e)), c;
    });
  }
  walkAtRules(e, n) {
    return n ? e instanceof RegExp ? this.walk((a, c) => {
      if (a.type === "atrule" && e.test(a.name))
        return n(a, c);
    }) : this.walk((a, c) => {
      if (a.type === "atrule" && a.name === e)
        return n(a, c);
    }) : (n = e, this.walk((a, c) => {
      if (a.type === "atrule")
        return n(a, c);
    }));
  }
  walkComments(e) {
    return this.walk((n, a) => {
      if (n.type === "comment")
        return e(n, a);
    });
  }
  walkDecls(e, n) {
    return n ? e instanceof RegExp ? this.walk((a, c) => {
      if (a.type === "decl" && e.test(a.prop))
        return n(a, c);
    }) : this.walk((a, c) => {
      if (a.type === "decl" && a.prop === e)
        return n(a, c);
    }) : (n = e, this.walk((a, c) => {
      if (a.type === "decl")
        return n(a, c);
    }));
  }
  walkRules(e, n) {
    return n ? e instanceof RegExp ? this.walk((a, c) => {
      if (a.type === "rule" && e.test(a.selector))
        return n(a, c);
    }) : this.walk((a, c) => {
      if (a.type === "rule" && a.selector === e)
        return n(a, c);
    }) : (n = e, this.walk((a, c) => {
      if (a.type === "rule")
        return n(a, c);
    }));
  }
  get first() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[0];
  }
  get last() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
};
Ls.registerParse = (t) => {
  S2 = t;
};
Ls.registerRule = (t) => {
  J0 = t;
};
Ls.registerAtRule = (t) => {
  Q0 = t;
};
Ls.registerRoot = (t) => {
  w2 = t;
};
var Ya = Ls;
Ls.default = Ls;
Ls.rebuild = (t) => {
  t.type === "atrule" ? Object.setPrototypeOf(t, Q0.prototype) : t.type === "rule" ? Object.setPrototypeOf(t, J0.prototype) : t.type === "decl" ? Object.setPrototypeOf(t, E2.prototype) : t.type === "comment" ? Object.setPrototypeOf(t, _2.prototype) : t.type === "root" && Object.setPrototypeOf(t, w2.prototype), t[v2] = !0, t.nodes && t.nodes.forEach((e) => {
    Ls.rebuild(e);
  });
};
let vN = Ya, P2, C2, iu = class extends vN {
  constructor(e) {
    super({ type: "document", ...e }), this.nodes || (this.nodes = []);
  }
  toResult(e = {}) {
    return new P2(new C2(), this, e).stringify();
  }
};
iu.registerLazyResult = (t) => {
  P2 = t;
};
iu.registerProcessor = (t) => {
  C2 = t;
};
var Z0 = iu;
iu.default = iu;
let zv = {};
var I2 = function(e) {
  zv[e] || (zv[e] = !0, typeof console < "u" && console.warn && console.warn(e));
};
let f1 = class {
  constructor(e, n = {}) {
    if (this.type = "warning", this.text = e, n.node && n.node.source) {
      let a = n.node.rangeBy(n);
      this.line = a.start.line, this.column = a.start.column, this.endLine = a.end.line, this.endColumn = a.end.column;
    }
    for (let a in n)
      this[a] = n[a];
  }
  toString() {
    return this.node ? this.node.error(this.text, {
      index: this.index,
      plugin: this.plugin,
      word: this.word
    }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
  }
};
var O2 = f1;
f1.default = f1;
let EN = O2, d1 = class {
  constructor(e, n, a) {
    this.processor = e, this.messages = [], this.root = n, this.opts = a, this.css = void 0, this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(e, n = {}) {
    n.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (n.plugin = this.lastPlugin.postcssPlugin);
    let a = new EN(e, n);
    return this.messages.push(a), a;
  }
  warnings() {
    return this.messages.filter((e) => e.type === "warning");
  }
  get content() {
    return this.css;
  }
};
var ey = d1;
d1.default = d1;
const Ch = "'".charCodeAt(0), Kv = '"'.charCodeAt(0), Pc = "\\".charCodeAt(0), Yv = "/".charCodeAt(0), Cc = `
`.charCodeAt(0), Al = " ".charCodeAt(0), Ic = "\f".charCodeAt(0), Oc = "	".charCodeAt(0), kc = "\r".charCodeAt(0), _N = "[".charCodeAt(0), SN = "]".charCodeAt(0), wN = "(".charCodeAt(0), TN = ")".charCodeAt(0), AN = "{".charCodeAt(0), xN = "}".charCodeAt(0), PN = ";".charCodeAt(0), CN = "*".charCodeAt(0), IN = ":".charCodeAt(0), ON = "@".charCodeAt(0), Dc = /[\t\n\f\r "#'()/;[\\\]{}]/g, Nc = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, kN = /.[\r\n"'(/\\]/, Xv = /[\da-f]/i;
var DN = function(e, n = {}) {
  let a = e.css.valueOf(), c = n.ignoreErrors, u, r, l, i, f, d, s, o, m, h, y = a.length, b = 0, E = [], S = [];
  function g() {
    return b;
  }
  function P(I) {
    throw e.error("Unclosed " + I, b);
  }
  function R() {
    return S.length === 0 && b >= y;
  }
  function N(I) {
    if (S.length)
      return S.pop();
    if (b >= y)
      return;
    let D = I ? I.ignoreUnclosed : !1;
    switch (u = a.charCodeAt(b), u) {
      case Cc:
      case Al:
      case Oc:
      case kc:
      case Ic: {
        r = b;
        do
          r += 1, u = a.charCodeAt(r);
        while (u === Al || u === Cc || u === Oc || u === kc || u === Ic);
        h = ["space", a.slice(b, r)], b = r - 1;
        break;
      }
      case _N:
      case SN:
      case AN:
      case xN:
      case IN:
      case PN:
      case TN: {
        let j = String.fromCharCode(u);
        h = [j, j, b];
        break;
      }
      case wN: {
        if (o = E.length ? E.pop()[1] : "", m = a.charCodeAt(b + 1), o === "url" && m !== Ch && m !== Kv && m !== Al && m !== Cc && m !== Oc && m !== Ic && m !== kc) {
          r = b;
          do {
            if (d = !1, r = a.indexOf(")", r + 1), r === -1)
              if (c || D) {
                r = b;
                break;
              } else
                P("bracket");
            for (s = r; a.charCodeAt(s - 1) === Pc; )
              s -= 1, d = !d;
          } while (d);
          h = ["brackets", a.slice(b, r + 1), b, r], b = r;
        } else
          r = a.indexOf(")", b + 1), i = a.slice(b, r + 1), r === -1 || kN.test(i) ? h = ["(", "(", b] : (h = ["brackets", i, b, r], b = r);
        break;
      }
      case Ch:
      case Kv: {
        l = u === Ch ? "'" : '"', r = b;
        do {
          if (d = !1, r = a.indexOf(l, r + 1), r === -1)
            if (c || D) {
              r = b + 1;
              break;
            } else
              P("string");
          for (s = r; a.charCodeAt(s - 1) === Pc; )
            s -= 1, d = !d;
        } while (d);
        h = ["string", a.slice(b, r + 1), b, r], b = r;
        break;
      }
      case ON: {
        Dc.lastIndex = b + 1, Dc.test(a), Dc.lastIndex === 0 ? r = a.length - 1 : r = Dc.lastIndex - 2, h = ["at-word", a.slice(b, r + 1), b, r], b = r;
        break;
      }
      case Pc: {
        for (r = b, f = !0; a.charCodeAt(r + 1) === Pc; )
          r += 1, f = !f;
        if (u = a.charCodeAt(r + 1), f && u !== Yv && u !== Al && u !== Cc && u !== Oc && u !== kc && u !== Ic && (r += 1, Xv.test(a.charAt(r)))) {
          for (; Xv.test(a.charAt(r + 1)); )
            r += 1;
          a.charCodeAt(r + 1) === Al && (r += 1);
        }
        h = ["word", a.slice(b, r + 1), b, r], b = r;
        break;
      }
      default: {
        u === Yv && a.charCodeAt(b + 1) === CN ? (r = a.indexOf("*/", b + 2) + 1, r === 0 && (c || D ? r = a.length : P("comment")), h = ["comment", a.slice(b, r + 1), b, r], b = r) : (Nc.lastIndex = b + 1, Nc.test(a), Nc.lastIndex === 0 ? r = a.length - 1 : r = Nc.lastIndex - 2, h = ["word", a.slice(b, r + 1), b, r], E.push(h), b = r);
        break;
      }
    }
    return b++, h;
  }
  function C(I) {
    S.push(I);
  }
  return {
    back: C,
    endOfFile: R,
    nextToken: N,
    position: g
  };
};
let k2 = Ya, Of = class extends k2 {
  constructor(e) {
    super(e), this.type = "atrule";
  }
  append(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
  }
  prepend(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
  }
};
var ty = Of;
Of.default = Of;
k2.registerAtRule(Of);
let D2 = Ya, N2, R2, Mo = class extends D2 {
  constructor(e) {
    super(e), this.type = "root", this.nodes || (this.nodes = []);
  }
  normalize(e, n, a) {
    let c = super.normalize(e);
    if (n) {
      if (a === "prepend")
        this.nodes.length > 1 ? n.raws.before = this.nodes[1].raws.before : delete n.raws.before;
      else if (this.first !== n)
        for (let u of c)
          u.raws.before = n.raws.before;
    }
    return c;
  }
  removeChild(e, n) {
    let a = this.index(e);
    return !n && a === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[a].raws.before), super.removeChild(e);
  }
  toResult(e = {}) {
    return new N2(new R2(), this, e).stringify();
  }
};
Mo.registerLazyResult = (t) => {
  N2 = t;
};
Mo.registerProcessor = (t) => {
  R2 = t;
};
var Du = Mo;
Mo.default = Mo;
D2.registerRoot(Mo);
let su = {
  comma(t) {
    return su.split(t, [","], !0);
  },
  space(t) {
    let e = [" ", `
`, "	"];
    return su.split(t, e);
  },
  split(t, e, n) {
    let a = [], c = "", u = !1, r = 0, l = !1, i = "", f = !1;
    for (let d of t)
      f ? f = !1 : d === "\\" ? f = !0 : l ? d === i && (l = !1) : d === '"' || d === "'" ? (l = !0, i = d) : d === "(" ? r += 1 : d === ")" ? r > 0 && (r -= 1) : r === 0 && e.includes(d) && (u = !0), u ? (c !== "" && a.push(c.trim()), c = "", u = !1) : c += d;
    return (n || c !== "") && a.push(c.trim()), a;
  }
};
var M2 = su;
su.default = su;
let L2 = Ya, NN = M2, kf = class extends L2 {
  constructor(e) {
    super(e), this.type = "rule", this.nodes || (this.nodes = []);
  }
  get selectors() {
    return NN.comma(this.selector);
  }
  set selectors(e) {
    let n = this.selector ? this.selector.match(/,\s*/) : null, a = n ? n[0] : "," + this.raw("between", "beforeOpen");
    this.selector = e.join(a);
  }
};
var ry = kf;
kf.default = kf;
L2.registerRule(kf);
let RN = xd, MN = DN, LN = Cd, jN = ty, FN = Du, Jv = ry;
const Qv = {
  empty: !0,
  space: !0
};
function BN(t) {
  for (let e = t.length - 1; e >= 0; e--) {
    let n = t[e], a = n[3] || n[2];
    if (a)
      return a;
  }
}
let $N = class {
  constructor(e) {
    this.input = e, this.root = new FN(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.createTokenizer(), this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(e) {
    let n = new jN();
    n.name = e[1].slice(1), n.name === "" && this.unnamedAtrule(n, e), this.init(n, e[2]);
    let a, c, u, r = !1, l = !1, i = [], f = [];
    for (; !this.tokenizer.endOfFile(); ) {
      if (e = this.tokenizer.nextToken(), a = e[0], a === "(" || a === "[" ? f.push(a === "(" ? ")" : "]") : a === "{" && f.length > 0 ? f.push("}") : a === f[f.length - 1] && f.pop(), f.length === 0)
        if (a === ";") {
          n.source.end = this.getPosition(e[2]), n.source.end.offset++, this.semicolon = !0;
          break;
        } else if (a === "{") {
          l = !0;
          break;
        } else if (a === "}") {
          if (i.length > 0) {
            for (u = i.length - 1, c = i[u]; c && c[0] === "space"; )
              c = i[--u];
            c && (n.source.end = this.getPosition(c[3] || c[2]), n.source.end.offset++);
          }
          this.end(e);
          break;
        } else
          i.push(e);
      else
        i.push(e);
      if (this.tokenizer.endOfFile()) {
        r = !0;
        break;
      }
    }
    n.raws.between = this.spacesAndCommentsFromEnd(i), i.length ? (n.raws.afterName = this.spacesAndCommentsFromStart(i), this.raw(n, "params", i), r && (e = i[i.length - 1], n.source.end = this.getPosition(e[3] || e[2]), n.source.end.offset++, this.spaces = n.raws.between, n.raws.between = "")) : (n.raws.afterName = "", n.params = ""), l && (n.nodes = [], this.current = n);
  }
  checkMissedSemicolon(e) {
    let n = this.colon(e);
    if (n === !1)
      return;
    let a = 0, c;
    for (let u = n - 1; u >= 0 && (c = e[u], !(c[0] !== "space" && (a += 1, a === 2))); u--)
      ;
    throw this.input.error(
      "Missed semicolon",
      c[0] === "word" ? c[3] + 1 : c[2]
    );
  }
  colon(e) {
    let n = 0, a, c, u;
    for (let [r, l] of e.entries()) {
      if (a = l, c = a[0], c === "(" && (n += 1), c === ")" && (n -= 1), n === 0 && c === ":")
        if (!u)
          this.doubleColon(a);
        else {
          if (u[0] === "word" && u[1] === "progid")
            continue;
          return r;
        }
      u = a;
    }
    return !1;
  }
  comment(e) {
    let n = new LN();
    this.init(n, e[2]), n.source.end = this.getPosition(e[3] || e[2]), n.source.end.offset++;
    let a = e[1].slice(2, -2);
    if (/^\s*$/.test(a))
      n.text = "", n.raws.left = a, n.raws.right = "";
    else {
      let c = a.match(/^(\s*)([^]*\S)(\s*)$/);
      n.text = c[2], n.raws.left = c[1], n.raws.right = c[3];
    }
  }
  createTokenizer() {
    this.tokenizer = MN(this.input);
  }
  decl(e, n) {
    let a = new RN();
    this.init(a, e[0][2]);
    let c = e[e.length - 1];
    for (c[0] === ";" && (this.semicolon = !0, e.pop()), a.source.end = this.getPosition(
      c[3] || c[2] || BN(e)
    ), a.source.end.offset++; e[0][0] !== "word"; )
      e.length === 1 && this.unknownWord(e), a.raws.before += e.shift()[1];
    for (a.source.start = this.getPosition(e[0][2]), a.prop = ""; e.length; ) {
      let f = e[0][0];
      if (f === ":" || f === "space" || f === "comment")
        break;
      a.prop += e.shift()[1];
    }
    a.raws.between = "";
    let u;
    for (; e.length; )
      if (u = e.shift(), u[0] === ":") {
        a.raws.between += u[1];
        break;
      } else
        u[0] === "word" && /\w/.test(u[1]) && this.unknownWord([u]), a.raws.between += u[1];
    (a.prop[0] === "_" || a.prop[0] === "*") && (a.raws.before += a.prop[0], a.prop = a.prop.slice(1));
    let r = [], l;
    for (; e.length && (l = e[0][0], !(l !== "space" && l !== "comment")); )
      r.push(e.shift());
    this.precheckMissedSemicolon(e);
    for (let f = e.length - 1; f >= 0; f--) {
      if (u = e[f], u[1].toLowerCase() === "!important") {
        a.important = !0;
        let d = this.stringFrom(e, f);
        d = this.spacesFromEnd(e) + d, d !== " !important" && (a.raws.important = d);
        break;
      } else if (u[1].toLowerCase() === "important") {
        let d = e.slice(0), s = "";
        for (let o = f; o > 0; o--) {
          let m = d[o][0];
          if (s.trim().indexOf("!") === 0 && m !== "space")
            break;
          s = d.pop()[1] + s;
        }
        s.trim().indexOf("!") === 0 && (a.important = !0, a.raws.important = s, e = d);
      }
      if (u[0] !== "space" && u[0] !== "comment")
        break;
    }
    e.some((f) => f[0] !== "space" && f[0] !== "comment") && (a.raws.between += r.map((f) => f[1]).join(""), r = []), this.raw(a, "value", r.concat(e), n), a.value.includes(":") && !n && this.checkMissedSemicolon(e);
  }
  doubleColon(e) {
    throw this.input.error(
      "Double colon",
      { offset: e[2] },
      { offset: e[2] + e[1].length }
    );
  }
  emptyRule(e) {
    let n = new Jv();
    this.init(n, e[2]), n.selector = "", n.raws.between = "", this.current = n;
  }
  end(e) {
    this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e);
  }
  endFile() {
    this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(e) {
    if (this.spaces += e[1], this.current.nodes) {
      let n = this.current.nodes[this.current.nodes.length - 1];
      n && n.type === "rule" && !n.raws.ownSemicolon && (n.raws.ownSemicolon = this.spaces, this.spaces = "");
    }
  }
  // Helpers
  getPosition(e) {
    let n = this.input.fromOffset(e);
    return {
      column: n.col,
      line: n.line,
      offset: e
    };
  }
  init(e, n) {
    this.current.push(e), e.source = {
      input: this.input,
      start: this.getPosition(n)
    }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = !1);
  }
  other(e) {
    let n = !1, a = null, c = !1, u = null, r = [], l = e[1].startsWith("--"), i = [], f = e;
    for (; f; ) {
      if (a = f[0], i.push(f), a === "(" || a === "[")
        u || (u = f), r.push(a === "(" ? ")" : "]");
      else if (l && c && a === "{")
        u || (u = f), r.push("}");
      else if (r.length === 0)
        if (a === ";")
          if (c) {
            this.decl(i, l);
            return;
          } else
            break;
        else if (a === "{") {
          this.rule(i);
          return;
        } else if (a === "}") {
          this.tokenizer.back(i.pop()), n = !0;
          break;
        } else
          a === ":" && (c = !0);
      else
        a === r[r.length - 1] && (r.pop(), r.length === 0 && (u = null));
      f = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile() && (n = !0), r.length > 0 && this.unclosedBracket(u), n && c) {
      if (!l)
        for (; i.length && (f = i[i.length - 1][0], !(f !== "space" && f !== "comment")); )
          this.tokenizer.back(i.pop());
      this.decl(i, l);
    } else
      this.unknownWord(i);
  }
  parse() {
    let e;
    for (; !this.tokenizer.endOfFile(); )
      switch (e = this.tokenizer.nextToken(), e[0]) {
        case "space":
          this.spaces += e[1];
          break;
        case ";":
          this.freeSemicolon(e);
          break;
        case "}":
          this.end(e);
          break;
        case "comment":
          this.comment(e);
          break;
        case "at-word":
          this.atrule(e);
          break;
        case "{":
          this.emptyRule(e);
          break;
        default:
          this.other(e);
          break;
      }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(e, n, a, c) {
    let u, r, l = a.length, i = "", f = !0, d, s;
    for (let o = 0; o < l; o += 1)
      u = a[o], r = u[0], r === "space" && o === l - 1 && !c ? f = !1 : r === "comment" ? (s = a[o - 1] ? a[o - 1][0] : "empty", d = a[o + 1] ? a[o + 1][0] : "empty", !Qv[s] && !Qv[d] ? i.slice(-1) === "," ? f = !1 : i += u[1] : f = !1) : i += u[1];
    if (!f) {
      let o = a.reduce((m, h) => m + h[1], "");
      e.raws[n] = { raw: o, value: i };
    }
    e[n] = i;
  }
  rule(e) {
    e.pop();
    let n = new Jv();
    this.init(n, e[0][2]), n.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(n, "selector", e), this.current = n;
  }
  spacesAndCommentsFromEnd(e) {
    let n, a = "";
    for (; e.length && (n = e[e.length - 1][0], !(n !== "space" && n !== "comment")); )
      a = e.pop()[1] + a;
    return a;
  }
  // Errors
  spacesAndCommentsFromStart(e) {
    let n, a = "";
    for (; e.length && (n = e[0][0], !(n !== "space" && n !== "comment")); )
      a += e.shift()[1];
    return a;
  }
  spacesFromEnd(e) {
    let n, a = "";
    for (; e.length && (n = e[e.length - 1][0], n === "space"); )
      a = e.pop()[1] + a;
    return a;
  }
  stringFrom(e, n) {
    let a = "";
    for (let c = n; c < e.length; c++)
      a += e[c][1];
    return e.splice(n, e.length - n), a;
  }
  unclosedBlock() {
    let e = this.current.source.start;
    throw this.input.error("Unclosed block", e.line, e.column);
  }
  unclosedBracket(e) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unexpectedClose(e) {
    throw this.input.error(
      "Unexpected }",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unknownWord(e) {
    throw this.input.error(
      "Unknown word",
      { offset: e[0][2] },
      { offset: e[0][2] + e[0][1].length }
    );
  }
  unnamedAtrule(e, n) {
    throw this.input.error(
      "At-rule without name",
      { offset: n[2] },
      { offset: n[2] + n[1].length }
    );
  }
};
var UN = $N;
let VN = Ya, WN = UN, HN = Pd;
function Df(t, e) {
  let n = new HN(t, e), a = new WN(n);
  try {
    a.parse();
  } catch (c) {
    throw Ve.process.env.NODE_ENV !== "production" && c.name === "CssSyntaxError" && e && e.from && (/\.scss$/i.test(e.from) ? c.message += `
You tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser` : /\.sass/i.test(e.from) ? c.message += `
You tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser` : /\.less$/i.test(e.from) && (c.message += `
You tried to parse Less with the standard CSS parser; try again with the postcss-less parser`)), c;
  }
  return a.root;
}
var ny = Df;
Df.default = Df;
VN.registerParse(Df);
let { isClean: Zi, my: qN } = ku, GN = b2, zN = Td, KN = Ya, YN = Z0, XN = I2, Zv = ey, JN = ny, QN = Du;
const ZN = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
}, e4 = {
  AtRule: !0,
  AtRuleExit: !0,
  Comment: !0,
  CommentExit: !0,
  Declaration: !0,
  DeclarationExit: !0,
  Document: !0,
  DocumentExit: !0,
  Once: !0,
  OnceExit: !0,
  postcssPlugin: !0,
  prepare: !0,
  Root: !0,
  RootExit: !0,
  Rule: !0,
  RuleExit: !0
}, t4 = {
  Once: !0,
  postcssPlugin: !0,
  prepare: !0
}, Lo = 0;
function xl(t) {
  return typeof t == "object" && typeof t.then == "function";
}
function j2(t) {
  let e = !1, n = ZN[t.type];
  return t.type === "decl" ? e = t.prop.toLowerCase() : t.type === "atrule" && (e = t.name.toLowerCase()), e && t.append ? [
    n,
    n + "-" + e,
    Lo,
    n + "Exit",
    n + "Exit-" + e
  ] : e ? [n, n + "-" + e, n + "Exit", n + "Exit-" + e] : t.append ? [n, Lo, n + "Exit"] : [n, n + "Exit"];
}
function eE(t) {
  let e;
  return t.type === "document" ? e = ["Document", Lo, "DocumentExit"] : t.type === "root" ? e = ["Root", Lo, "RootExit"] : e = j2(t), {
    eventIndex: 0,
    events: e,
    iterator: 0,
    node: t,
    visitorIndex: 0,
    visitors: []
  };
}
function p1(t) {
  return t[Zi] = !1, t.nodes && t.nodes.forEach((e) => p1(e)), t;
}
let h1 = {}, jo = class F2 {
  constructor(e, n, a) {
    this.stringified = !1, this.processed = !1;
    let c;
    if (typeof n == "object" && n !== null && (n.type === "root" || n.type === "document"))
      c = p1(n);
    else if (n instanceof F2 || n instanceof Zv)
      c = p1(n.root), n.map && (typeof a.map > "u" && (a.map = {}), a.map.inline || (a.map.inline = !1), a.map.prev = n.map);
    else {
      let u = JN;
      a.syntax && (u = a.syntax.parse), a.parser && (u = a.parser), u.parse && (u = u.parse);
      try {
        c = u(n, a);
      } catch (r) {
        this.processed = !0, this.error = r;
      }
      c && !c[qN] && KN.rebuild(c);
    }
    this.result = new Zv(e, c, a), this.helpers = { ...h1, postcss: h1, result: this.result }, this.plugins = this.processor.plugins.map((u) => typeof u == "object" && u.prepare ? { ...u, ...u.prepare(this.result) } : u);
  }
  async() {
    return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(e, n) {
    let a = this.result.lastPlugin;
    try {
      if (n && n.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin)
        e.plugin = a.postcssPlugin, e.setMessage();
      else if (a.postcssVersion && Ve.process.env.NODE_ENV !== "production") {
        let c = a.postcssPlugin, u = a.postcssVersion, r = this.result.processor.version, l = u.split("."), i = r.split(".");
        (l[0] !== i[0] || parseInt(l[1]) > parseInt(i[1])) && console.error(
          "Unknown error from PostCSS plugin. Your current PostCSS version is " + r + ", but " + c + " uses " + u + ". Perhaps this is the source of the error below."
        );
      }
    } catch (c) {
      console && console.error && console.error(c);
    }
    return e;
  }
  prepareVisitors() {
    this.listeners = {};
    let e = (n, a, c) => {
      this.listeners[a] || (this.listeners[a] = []), this.listeners[a].push([n, c]);
    };
    for (let n of this.plugins)
      if (typeof n == "object")
        for (let a in n) {
          if (!e4[a] && /^[A-Z]/.test(a))
            throw new Error(
              `Unknown event ${a} in ${n.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          if (!t4[a])
            if (typeof n[a] == "object")
              for (let c in n[a])
                c === "*" ? e(n, a, n[a][c]) : e(
                  n,
                  a + "-" + c.toLowerCase(),
                  n[a][c]
                );
            else
              typeof n[a] == "function" && e(n, a, n[a]);
        }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  async runAsync() {
    this.plugin = 0;
    for (let e = 0; e < this.plugins.length; e++) {
      let n = this.plugins[e], a = this.runOnRoot(n);
      if (xl(a))
        try {
          await a;
        } catch (c) {
          throw this.handleError(c);
        }
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[Zi]; ) {
        e[Zi] = !0;
        let n = [eE(e)];
        for (; n.length > 0; ) {
          let a = this.visitTick(n);
          if (xl(a))
            try {
              await a;
            } catch (c) {
              let u = n[n.length - 1].node;
              throw this.handleError(c, u);
            }
        }
      }
      if (this.listeners.OnceExit)
        for (let [n, a] of this.listeners.OnceExit) {
          this.result.lastPlugin = n;
          try {
            if (e.type === "document") {
              let c = e.nodes.map(
                (u) => a(u, this.helpers)
              );
              await Promise.all(c);
            } else
              await a(e, this.helpers);
          } catch (c) {
            throw this.handleError(c);
          }
        }
    }
    return this.processed = !0, this.stringify();
  }
  runOnRoot(e) {
    this.result.lastPlugin = e;
    try {
      if (typeof e == "object" && e.Once) {
        if (this.result.root.type === "document") {
          let n = this.result.root.nodes.map(
            (a) => e.Once(a, this.helpers)
          );
          return xl(n[0]) ? Promise.all(n) : n;
        }
        return e.Once(this.result.root, this.helpers);
      } else if (typeof e == "function")
        return e(this.result.root, this.result);
    } catch (n) {
      throw this.handleError(n);
    }
  }
  stringify() {
    if (this.error)
      throw this.error;
    if (this.stringified)
      return this.result;
    this.stringified = !0, this.sync();
    let e = this.result.opts, n = zN;
    e.syntax && (n = e.syntax.stringify), e.stringifier && (n = e.stringifier), n.stringify && (n = n.stringify);
    let c = new GN(n, this.result.root, this.result.opts).generate();
    return this.result.css = c[0], this.result.map = c[1], this.result;
  }
  sync() {
    if (this.error)
      throw this.error;
    if (this.processed)
      return this.result;
    if (this.processed = !0, this.processing)
      throw this.getAsyncError();
    for (let e of this.plugins) {
      let n = this.runOnRoot(e);
      if (xl(n))
        throw this.getAsyncError();
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[Zi]; )
        e[Zi] = !0, this.walkSync(e);
      if (this.listeners.OnceExit)
        if (e.type === "document")
          for (let n of e.nodes)
            this.visitSync(this.listeners.OnceExit, n);
        else
          this.visitSync(this.listeners.OnceExit, e);
    }
    return this.result;
  }
  then(e, n) {
    return Ve.process.env.NODE_ENV !== "production" && ("from" in this.opts || XN(
      "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
    )), this.async().then(e, n);
  }
  toString() {
    return this.css;
  }
  visitSync(e, n) {
    for (let [a, c] of e) {
      this.result.lastPlugin = a;
      let u;
      try {
        u = c(n, this.helpers);
      } catch (r) {
        throw this.handleError(r, n.proxyOf);
      }
      if (n.type !== "root" && n.type !== "document" && !n.parent)
        return !0;
      if (xl(u))
        throw this.getAsyncError();
    }
  }
  visitTick(e) {
    let n = e[e.length - 1], { node: a, visitors: c } = n;
    if (a.type !== "root" && a.type !== "document" && !a.parent) {
      e.pop();
      return;
    }
    if (c.length > 0 && n.visitorIndex < c.length) {
      let [r, l] = c[n.visitorIndex];
      n.visitorIndex += 1, n.visitorIndex === c.length && (n.visitors = [], n.visitorIndex = 0), this.result.lastPlugin = r;
      try {
        return l(a.toProxy(), this.helpers);
      } catch (i) {
        throw this.handleError(i, a);
      }
    }
    if (n.iterator !== 0) {
      let r = n.iterator, l;
      for (; l = a.nodes[a.indexes[r]]; )
        if (a.indexes[r] += 1, !l[Zi]) {
          l[Zi] = !0, e.push(eE(l));
          return;
        }
      n.iterator = 0, delete a.indexes[r];
    }
    let u = n.events;
    for (; n.eventIndex < u.length; ) {
      let r = u[n.eventIndex];
      if (n.eventIndex += 1, r === Lo) {
        a.nodes && a.nodes.length && (a[Zi] = !0, n.iterator = a.getIterator());
        return;
      } else if (this.listeners[r]) {
        n.visitors = this.listeners[r];
        return;
      }
    }
    e.pop();
  }
  walkSync(e) {
    e[Zi] = !0;
    let n = j2(e);
    for (let a of n)
      if (a === Lo)
        e.nodes && e.each((c) => {
          c[Zi] || this.walkSync(c);
        });
      else {
        let c = this.listeners[a];
        if (c && this.visitSync(c, e.toProxy()))
          return;
      }
  }
  warnings() {
    return this.sync().warnings();
  }
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
};
jo.registerPostcss = (t) => {
  h1 = t;
};
var B2 = jo;
jo.default = jo;
QN.registerLazyResult(jo);
YN.registerLazyResult(jo);
let r4 = b2, n4 = Td, i4 = I2, s4 = ny;
const a4 = ey;
let m1 = class {
  constructor(e, n, a) {
    n = n.toString(), this.stringified = !1, this._processor = e, this._css = n, this._opts = a, this._map = void 0;
    let c, u = n4;
    this.result = new a4(this._processor, c, this._opts), this.result.css = n;
    let r = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return r.root;
      }
    });
    let l = new r4(u, c, this._opts, n);
    if (l.isMap()) {
      let [i, f] = l.generate();
      i && (this.result.css = i), f && (this.result.map = f);
    } else
      l.clearAnnotation(), this.result.css = l.css;
  }
  async() {
    return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  sync() {
    if (this.error)
      throw this.error;
    return this.result;
  }
  then(e, n) {
    return Ve.process.env.NODE_ENV !== "production" && ("from" in this._opts || i4(
      "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
    )), this.async().then(e, n);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root)
      return this._root;
    let e, n = s4;
    try {
      e = n(this._css, this._opts);
    } catch (a) {
      this.error = a;
    }
    if (this.error)
      throw this.error;
    return this._root = e, e;
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
};
var o4 = m1;
m1.default = m1;
let l4 = o4, u4 = B2, c4 = Z0, f4 = Du, au = class {
  constructor(e = []) {
    this.version = "8.4.35", this.plugins = this.normalize(e);
  }
  normalize(e) {
    let n = [];
    for (let a of e)
      if (a.postcss === !0 ? a = a() : a.postcss && (a = a.postcss), typeof a == "object" && Array.isArray(a.plugins))
        n = n.concat(a.plugins);
      else if (typeof a == "object" && a.postcssPlugin)
        n.push(a);
      else if (typeof a == "function")
        n.push(a);
      else if (typeof a == "object" && (a.parse || a.stringify)) {
        if (Ve.process.env.NODE_ENV !== "production")
          throw new Error(
            "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
          );
      } else
        throw new Error(a + " is not a PostCSS plugin");
    return n;
  }
  process(e, n = {}) {
    return !this.plugins.length && !n.parser && !n.stringifier && !n.syntax ? new l4(this, e, n) : new u4(this, e, n);
  }
  use(e) {
    return this.plugins = this.plugins.concat(this.normalize([e])), this;
  }
};
var d4 = au;
au.default = au;
f4.registerProcessor(au);
c4.registerProcessor(au);
let p4 = xd, h4 = d2, m4 = Cd, y4 = ty, b4 = Pd, g4 = Du, v4 = ry;
function ou(t, e) {
  if (Array.isArray(t))
    return t.map((c) => ou(c));
  let { inputs: n, ...a } = t;
  if (n) {
    e = [];
    for (let c of n) {
      let u = { ...c, __proto__: b4.prototype };
      u.map && (u.map = {
        ...u.map,
        __proto__: h4.prototype
      }), e.push(u);
    }
  }
  if (a.nodes && (a.nodes = t.nodes.map((c) => ou(c, e))), a.source) {
    let { inputId: c, ...u } = a.source;
    a.source = u, c != null && (a.source.input = e[c]);
  }
  if (a.type === "root")
    return new g4(a);
  if (a.type === "decl")
    return new p4(a);
  if (a.type === "rule")
    return new v4(a);
  if (a.type === "comment")
    return new m4(a);
  if (a.type === "atrule")
    return new y4(a);
  throw new Error("Unknown node type: " + t.type);
}
var E4 = ou;
ou.default = ou;
let _4 = X0, $2 = xd, S4 = B2, w4 = Ya, iy = d4, T4 = Td, A4 = E4, U2 = Z0, x4 = O2, V2 = Cd, W2 = ty, P4 = ey, C4 = Pd, I4 = ny, O4 = M2, H2 = ry, q2 = Du, k4 = Ad;
function br(...t) {
  return t.length === 1 && Array.isArray(t[0]) && (t = t[0]), new iy(t);
}
br.plugin = function(e, n) {
  let a = !1;
  function c(...r) {
    console && console.warn && !a && (a = !0, console.warn(
      e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
    ), Ve.process.env.LANG && Ve.process.env.LANG.startsWith("cn") && console.warn(
      e + `:  postcss.plugin . :
https://www.w3ctech.com/topic/2226`
    ));
    let l = n(...r);
    return l.postcssPlugin = e, l.postcssVersion = new iy().version, l;
  }
  let u;
  return Object.defineProperty(c, "postcss", {
    get() {
      return u || (u = c()), u;
    }
  }), c.process = function(r, l, i) {
    return br([c(i)]).process(r, l);
  }, c;
};
br.stringify = T4;
br.parse = I4;
br.fromJSON = A4;
br.list = O4;
br.comment = (t) => new V2(t);
br.atRule = (t) => new W2(t);
br.decl = (t) => new $2(t);
br.rule = (t) => new H2(t);
br.root = (t) => new q2(t);
br.document = (t) => new U2(t);
br.CssSyntaxError = _4;
br.Declaration = $2;
br.Container = w4;
br.Processor = iy;
br.Document = U2;
br.Comment = V2;
br.Warning = x4;
br.AtRule = W2;
br.Result = P4;
br.Input = C4;
br.Rule = H2;
br.Root = q2;
br.Node = k4;
S4.registerPostcss(br);
var vi = br;
br.default = br;
const Pr = /* @__PURE__ */ nd(vi);
var G2 = { exports: {} };
(function(t, e) {
  (function(n, a) {
    t.exports = function(c, u, r, l, i) {
      for (u = u.split ? u.split(".") : u, l = 0; l < u.length; l++)
        c = c ? c[u[l]] : i;
      return c === i ? r : c;
    };
  })();
})(G2);
var z2 = G2.exports, y1 = { exports: {} }, b1 = { exports: {} }, g1 = { exports: {} }, v1 = { exports: {} }, E1 = { exports: {} }, _1 = { exports: {} }, Kn = {}, S1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = c;
  function n(u) {
    for (var r = u.toLowerCase(), l = "", i = !1, f = 0; f < 6 && r[f] !== void 0; f++) {
      var d = r.charCodeAt(f), s = d >= 97 && d <= 102 || d >= 48 && d <= 57;
      if (i = d === 32, !s)
        break;
      l += r[f];
    }
    if (l.length !== 0) {
      var o = parseInt(l, 16), m = o >= 55296 && o <= 57343;
      return m || o === 0 || o > 1114111 ? ["", l.length + (i ? 1 : 0)] : [String.fromCodePoint(o), l.length + (i ? 1 : 0)];
    }
  }
  var a = /\\/;
  function c(u) {
    var r = a.test(u);
    if (!r)
      return u;
    for (var l = "", i = 0; i < u.length; i++) {
      if (u[i] === "\\") {
        var f = n(u.slice(i + 1, i + 7));
        if (f !== void 0) {
          l += f[0], i += f[1];
          continue;
        }
        if (u[i + 1] === "\\") {
          l += "\\", i++;
          continue;
        }
        u.length === i + 1 && (l += u[i]);
        continue;
      }
      l += u[i];
    }
    return l;
  }
  t.exports = e.default;
})(S1, S1.exports);
var sy = S1.exports, w1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = n;
  function n(a) {
    for (var c = arguments.length, u = new Array(c > 1 ? c - 1 : 0), r = 1; r < c; r++)
      u[r - 1] = arguments[r];
    for (; u.length > 0; ) {
      var l = u.shift();
      if (!a[l])
        return;
      a = a[l];
    }
    return a;
  }
  t.exports = e.default;
})(w1, w1.exports);
var D4 = w1.exports, T1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = n;
  function n(a) {
    for (var c = arguments.length, u = new Array(c > 1 ? c - 1 : 0), r = 1; r < c; r++)
      u[r - 1] = arguments[r];
    for (; u.length > 0; ) {
      var l = u.shift();
      a[l] || (a[l] = {}), a = a[l];
    }
  }
  t.exports = e.default;
})(T1, T1.exports);
var N4 = T1.exports, A1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = n;
  function n(a) {
    for (var c = "", u = a.indexOf("/*"), r = 0; u >= 0; ) {
      c = c + a.slice(r, u);
      var l = a.indexOf("*/", u + 2);
      if (l < 0)
        return c;
      r = l + 2, u = a.indexOf("/*", r);
    }
    return c = c + a.slice(r), c;
  }
  t.exports = e.default;
})(A1, A1.exports);
var R4 = A1.exports;
Kn.__esModule = !0;
Kn.unesc = Kn.stripComments = Kn.getProp = Kn.ensureObject = void 0;
var M4 = Id(sy);
Kn.unesc = M4.default;
var L4 = Id(D4);
Kn.getProp = L4.default;
var j4 = Id(N4);
Kn.ensureObject = j4.default;
var F4 = Id(R4);
Kn.stripComments = F4.default;
function Id(t) {
  return t && t.__esModule ? t : { default: t };
}
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var n = Kn;
  function a(l, i) {
    for (var f = 0; f < i.length; f++) {
      var d = i[f];
      d.enumerable = d.enumerable || !1, d.configurable = !0, "value" in d && (d.writable = !0), Object.defineProperty(l, d.key, d);
    }
  }
  function c(l, i, f) {
    return i && a(l.prototype, i), f && a(l, f), Object.defineProperty(l, "prototype", { writable: !1 }), l;
  }
  var u = function l(i, f) {
    if (typeof i != "object" || i === null)
      return i;
    var d = new i.constructor();
    for (var s in i)
      if (i.hasOwnProperty(s)) {
        var o = i[s], m = typeof o;
        s === "parent" && m === "object" ? f && (d[s] = f) : o instanceof Array ? d[s] = o.map(function(h) {
          return l(h, d);
        }) : d[s] = l(o, d);
      }
    return d;
  }, r = /* @__PURE__ */ function() {
    function l(f) {
      f === void 0 && (f = {}), Object.assign(this, f), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
    }
    var i = l.prototype;
    return i.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }, i.replaceWith = function() {
      if (this.parent) {
        for (var d in arguments)
          this.parent.insertBefore(this, arguments[d]);
        this.remove();
      }
      return this;
    }, i.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, i.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, i.clone = function(d) {
      d === void 0 && (d = {});
      var s = u(this);
      for (var o in d)
        s[o] = d[o];
      return s;
    }, i.appendToPropertyAndEscape = function(d, s, o) {
      this.raws || (this.raws = {});
      var m = this[d], h = this.raws[d];
      this[d] = m + s, h || o !== s ? this.raws[d] = (h || m) + o : delete this.raws[d];
    }, i.setPropertyAndEscape = function(d, s, o) {
      this.raws || (this.raws = {}), this[d] = s, this.raws[d] = o;
    }, i.setPropertyWithoutEscape = function(d, s) {
      this[d] = s, this.raws && delete this.raws[d];
    }, i.isAtPosition = function(d, s) {
      if (this.source && this.source.start && this.source.end)
        return !(this.source.start.line > d || this.source.end.line < d || this.source.start.line === d && this.source.start.column > s || this.source.end.line === d && this.source.end.column < s);
    }, i.stringifyProperty = function(d) {
      return this.raws && this.raws[d] || this[d];
    }, i.valueToString = function() {
      return String(this.stringifyProperty("value"));
    }, i.toString = function() {
      return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
    }, c(l, [{
      key: "rawSpaceBefore",
      get: function() {
        var d = this.raws && this.raws.spaces && this.raws.spaces.before;
        return d === void 0 && (d = this.spaces && this.spaces.before), d || "";
      },
      set: function(d) {
        (0, n.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = d;
      }
    }, {
      key: "rawSpaceAfter",
      get: function() {
        var d = this.raws && this.raws.spaces && this.raws.spaces.after;
        return d === void 0 && (d = this.spaces.after), d || "";
      },
      set: function(d) {
        (0, n.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = d;
      }
    }]), l;
  }();
  e.default = r, t.exports = e.default;
})(_1, _1.exports);
var pa = _1.exports, Xt = {};
Xt.__esModule = !0;
Xt.UNIVERSAL = Xt.TAG = Xt.STRING = Xt.SELECTOR = Xt.ROOT = Xt.PSEUDO = Xt.NESTING = Xt.ID = Xt.COMMENT = Xt.COMBINATOR = Xt.CLASS = Xt.ATTRIBUTE = void 0;
var B4 = "tag";
Xt.TAG = B4;
var $4 = "string";
Xt.STRING = $4;
var U4 = "selector";
Xt.SELECTOR = U4;
var V4 = "root";
Xt.ROOT = V4;
var W4 = "pseudo";
Xt.PSEUDO = W4;
var H4 = "nesting";
Xt.NESTING = H4;
var q4 = "id";
Xt.ID = q4;
var G4 = "comment";
Xt.COMMENT = G4;
var z4 = "combinator";
Xt.COMBINATOR = z4;
var K4 = "class";
Xt.CLASS = K4;
var Y4 = "attribute";
Xt.ATTRIBUTE = Y4;
var X4 = "universal";
Xt.UNIVERSAL = X4;
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var n = r(pa), a = u(Xt);
  function c(y) {
    if (typeof WeakMap != "function")
      return null;
    var b = /* @__PURE__ */ new WeakMap(), E = /* @__PURE__ */ new WeakMap();
    return (c = function(g) {
      return g ? E : b;
    })(y);
  }
  function u(y, b) {
    if (!b && y && y.__esModule)
      return y;
    if (y === null || typeof y != "object" && typeof y != "function")
      return { default: y };
    var E = c(b);
    if (E && E.has(y))
      return E.get(y);
    var S = {}, g = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var P in y)
      if (P !== "default" && Object.prototype.hasOwnProperty.call(y, P)) {
        var R = g ? Object.getOwnPropertyDescriptor(y, P) : null;
        R && (R.get || R.set) ? Object.defineProperty(S, P, R) : S[P] = y[P];
      }
    return S.default = y, E && E.set(y, S), S;
  }
  function r(y) {
    return y && y.__esModule ? y : { default: y };
  }
  function l(y, b) {
    var E = typeof Symbol < "u" && y[Symbol.iterator] || y["@@iterator"];
    if (E)
      return (E = E.call(y)).next.bind(E);
    if (Array.isArray(y) || (E = i(y)) || b && y && typeof y.length == "number") {
      E && (y = E);
      var S = 0;
      return function() {
        return S >= y.length ? { done: !0 } : { done: !1, value: y[S++] };
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function i(y, b) {
    if (y) {
      if (typeof y == "string")
        return f(y, b);
      var E = Object.prototype.toString.call(y).slice(8, -1);
      if (E === "Object" && y.constructor && (E = y.constructor.name), E === "Map" || E === "Set")
        return Array.from(y);
      if (E === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(E))
        return f(y, b);
    }
  }
  function f(y, b) {
    (b == null || b > y.length) && (b = y.length);
    for (var E = 0, S = new Array(b); E < b; E++)
      S[E] = y[E];
    return S;
  }
  function d(y, b) {
    for (var E = 0; E < b.length; E++) {
      var S = b[E];
      S.enumerable = S.enumerable || !1, S.configurable = !0, "value" in S && (S.writable = !0), Object.defineProperty(y, S.key, S);
    }
  }
  function s(y, b, E) {
    return b && d(y.prototype, b), E && d(y, E), Object.defineProperty(y, "prototype", { writable: !1 }), y;
  }
  function o(y, b) {
    y.prototype = Object.create(b.prototype), y.prototype.constructor = y, m(y, b);
  }
  function m(y, b) {
    return m = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(S, g) {
      return S.__proto__ = g, S;
    }, m(y, b);
  }
  var h = /* @__PURE__ */ function(y) {
    o(b, y);
    function b(S) {
      var g;
      return g = y.call(this, S) || this, g.nodes || (g.nodes = []), g;
    }
    var E = b.prototype;
    return E.append = function(g) {
      return g.parent = this, this.nodes.push(g), this;
    }, E.prepend = function(g) {
      return g.parent = this, this.nodes.unshift(g), this;
    }, E.at = function(g) {
      return this.nodes[g];
    }, E.index = function(g) {
      return typeof g == "number" ? g : this.nodes.indexOf(g);
    }, E.removeChild = function(g) {
      g = this.index(g), this.at(g).parent = void 0, this.nodes.splice(g, 1);
      var P;
      for (var R in this.indexes)
        P = this.indexes[R], P >= g && (this.indexes[R] = P - 1);
      return this;
    }, E.removeAll = function() {
      for (var g = l(this.nodes), P; !(P = g()).done; ) {
        var R = P.value;
        R.parent = void 0;
      }
      return this.nodes = [], this;
    }, E.empty = function() {
      return this.removeAll();
    }, E.insertAfter = function(g, P) {
      P.parent = this;
      var R = this.index(g);
      this.nodes.splice(R + 1, 0, P), P.parent = this;
      var N;
      for (var C in this.indexes)
        N = this.indexes[C], R <= N && (this.indexes[C] = N + 1);
      return this;
    }, E.insertBefore = function(g, P) {
      P.parent = this;
      var R = this.index(g);
      this.nodes.splice(R, 0, P), P.parent = this;
      var N;
      for (var C in this.indexes)
        N = this.indexes[C], N <= R && (this.indexes[C] = N + 1);
      return this;
    }, E._findChildAtPosition = function(g, P) {
      var R = void 0;
      return this.each(function(N) {
        if (N.atPosition) {
          var C = N.atPosition(g, P);
          if (C)
            return R = C, !1;
        } else if (N.isAtPosition(g, P))
          return R = N, !1;
      }), R;
    }, E.atPosition = function(g, P) {
      if (this.isAtPosition(g, P))
        return this._findChildAtPosition(g, P) || this;
    }, E._inferEndPosition = function() {
      this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
    }, E.each = function(g) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var P = this.lastEach;
      if (this.indexes[P] = 0, !!this.length) {
        for (var R, N; this.indexes[P] < this.length && (R = this.indexes[P], N = g(this.at(R), R), N !== !1); )
          this.indexes[P] += 1;
        if (delete this.indexes[P], N === !1)
          return !1;
      }
    }, E.walk = function(g) {
      return this.each(function(P, R) {
        var N = g(P, R);
        if (N !== !1 && P.length && (N = P.walk(g)), N === !1)
          return !1;
      });
    }, E.walkAttributes = function(g) {
      var P = this;
      return this.walk(function(R) {
        if (R.type === a.ATTRIBUTE)
          return g.call(P, R);
      });
    }, E.walkClasses = function(g) {
      var P = this;
      return this.walk(function(R) {
        if (R.type === a.CLASS)
          return g.call(P, R);
      });
    }, E.walkCombinators = function(g) {
      var P = this;
      return this.walk(function(R) {
        if (R.type === a.COMBINATOR)
          return g.call(P, R);
      });
    }, E.walkComments = function(g) {
      var P = this;
      return this.walk(function(R) {
        if (R.type === a.COMMENT)
          return g.call(P, R);
      });
    }, E.walkIds = function(g) {
      var P = this;
      return this.walk(function(R) {
        if (R.type === a.ID)
          return g.call(P, R);
      });
    }, E.walkNesting = function(g) {
      var P = this;
      return this.walk(function(R) {
        if (R.type === a.NESTING)
          return g.call(P, R);
      });
    }, E.walkPseudos = function(g) {
      var P = this;
      return this.walk(function(R) {
        if (R.type === a.PSEUDO)
          return g.call(P, R);
      });
    }, E.walkTags = function(g) {
      var P = this;
      return this.walk(function(R) {
        if (R.type === a.TAG)
          return g.call(P, R);
      });
    }, E.walkUniversals = function(g) {
      var P = this;
      return this.walk(function(R) {
        if (R.type === a.UNIVERSAL)
          return g.call(P, R);
      });
    }, E.split = function(g) {
      var P = this, R = [];
      return this.reduce(function(N, C, I) {
        var D = g.call(P, C);
        return R.push(C), D ? (N.push(R), R = []) : I === P.length - 1 && N.push(R), N;
      }, []);
    }, E.map = function(g) {
      return this.nodes.map(g);
    }, E.reduce = function(g, P) {
      return this.nodes.reduce(g, P);
    }, E.every = function(g) {
      return this.nodes.every(g);
    }, E.some = function(g) {
      return this.nodes.some(g);
    }, E.filter = function(g) {
      return this.nodes.filter(g);
    }, E.sort = function(g) {
      return this.nodes.sort(g);
    }, E.toString = function() {
      return this.map(String).join("");
    }, s(b, [{
      key: "first",
      get: function() {
        return this.at(0);
      }
    }, {
      key: "last",
      get: function() {
        return this.at(this.length - 1);
      }
    }, {
      key: "length",
      get: function() {
        return this.nodes.length;
      }
    }]), b;
  }(n.default);
  e.default = h, t.exports = e.default;
})(E1, E1.exports);
var ay = E1.exports;
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var n = c(ay), a = Xt;
  function c(d) {
    return d && d.__esModule ? d : { default: d };
  }
  function u(d, s) {
    for (var o = 0; o < s.length; o++) {
      var m = s[o];
      m.enumerable = m.enumerable || !1, m.configurable = !0, "value" in m && (m.writable = !0), Object.defineProperty(d, m.key, m);
    }
  }
  function r(d, s, o) {
    return s && u(d.prototype, s), o && u(d, o), Object.defineProperty(d, "prototype", { writable: !1 }), d;
  }
  function l(d, s) {
    d.prototype = Object.create(s.prototype), d.prototype.constructor = d, i(d, s);
  }
  function i(d, s) {
    return i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, h) {
      return m.__proto__ = h, m;
    }, i(d, s);
  }
  var f = /* @__PURE__ */ function(d) {
    l(s, d);
    function s(m) {
      var h;
      return h = d.call(this, m) || this, h.type = a.ROOT, h;
    }
    var o = s.prototype;
    return o.toString = function() {
      var h = this.reduce(function(y, b) {
        return y.push(String(b)), y;
      }, []).join(",");
      return this.trailingComma ? h + "," : h;
    }, o.error = function(h, y) {
      return this._error ? this._error(h, y) : new Error(h);
    }, r(s, [{
      key: "errorGenerator",
      set: function(h) {
        this._error = h;
      }
    }]), s;
  }(n.default);
  e.default = f, t.exports = e.default;
})(v1, v1.exports);
var K2 = v1.exports, x1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var n = c(ay), a = Xt;
  function c(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function u(i, f) {
    i.prototype = Object.create(f.prototype), i.prototype.constructor = i, r(i, f);
  }
  function r(i, f) {
    return r = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(s, o) {
      return s.__proto__ = o, s;
    }, r(i, f);
  }
  var l = /* @__PURE__ */ function(i) {
    u(f, i);
    function f(d) {
      var s;
      return s = i.call(this, d) || this, s.type = a.SELECTOR, s;
    }
    return f;
  }(n.default);
  e.default = l, t.exports = e.default;
})(x1, x1.exports);
var Y2 = x1.exports, P1 = { exports: {} };
/*! https://mths.be/cssesc v3.0.0 by @mathias */
var J4 = {}, Q4 = J4.hasOwnProperty, Z4 = function(e, n) {
  if (!e)
    return n;
  var a = {};
  for (var c in n)
    a[c] = Q4.call(e, c) ? e[c] : n[c];
  return a;
}, e6 = /[ -,\.\/:-@\[-\^`\{-~]/, t6 = /[ -,\.\/:-@\[\]\^`\{-~]/, r6 = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, oy = function t(e, n) {
  n = Z4(n, t.options), n.quotes != "single" && n.quotes != "double" && (n.quotes = "single");
  for (var a = n.quotes == "double" ? '"' : "'", c = n.isIdentifier, u = e.charAt(0), r = "", l = 0, i = e.length; l < i; ) {
    var f = e.charAt(l++), d = f.charCodeAt(), s = void 0;
    if (d < 32 || d > 126) {
      if (d >= 55296 && d <= 56319 && l < i) {
        var o = e.charCodeAt(l++);
        (o & 64512) == 56320 ? d = ((d & 1023) << 10) + (o & 1023) + 65536 : l--;
      }
      s = "\\" + d.toString(16).toUpperCase() + " ";
    } else
      n.escapeEverything ? e6.test(f) ? s = "\\" + f : s = "\\" + d.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(f) ? s = "\\" + d.toString(16).toUpperCase() + " " : f == "\\" || !c && (f == '"' && a == f || f == "'" && a == f) || c && t6.test(f) ? s = "\\" + f : s = f;
    r += s;
  }
  return c && (/^-[-\d]/.test(r) ? r = "\\-" + r.slice(1) : /\d/.test(u) && (r = "\\3" + u + " " + r.slice(1))), r = r.replace(r6, function(m, h, y) {
    return h && h.length % 2 ? m : (h || "") + y;
  }), !c && n.wrap ? a + r + a : r;
};
oy.options = {
  escapeEverything: !1,
  isIdentifier: !1,
  quotes: "single",
  wrap: !1
};
oy.version = "3.0.0";
var ly = oy;
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var n = r(ly), a = Kn, c = r(pa), u = Xt;
  function r(o) {
    return o && o.__esModule ? o : { default: o };
  }
  function l(o, m) {
    for (var h = 0; h < m.length; h++) {
      var y = m[h];
      y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(o, y.key, y);
    }
  }
  function i(o, m, h) {
    return m && l(o.prototype, m), h && l(o, h), Object.defineProperty(o, "prototype", { writable: !1 }), o;
  }
  function f(o, m) {
    o.prototype = Object.create(m.prototype), o.prototype.constructor = o, d(o, m);
  }
  function d(o, m) {
    return d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(y, b) {
      return y.__proto__ = b, y;
    }, d(o, m);
  }
  var s = /* @__PURE__ */ function(o) {
    f(m, o);
    function m(y) {
      var b;
      return b = o.call(this, y) || this, b.type = u.CLASS, b._constructed = !0, b;
    }
    var h = m.prototype;
    return h.valueToString = function() {
      return "." + o.prototype.valueToString.call(this);
    }, i(m, [{
      key: "value",
      get: function() {
        return this._value;
      },
      set: function(b) {
        if (this._constructed) {
          var E = (0, n.default)(b, {
            isIdentifier: !0
          });
          E !== b ? ((0, a.ensureObject)(this, "raws"), this.raws.value = E) : this.raws && delete this.raws.value;
        }
        this._value = b;
      }
    }]), m;
  }(c.default);
  e.default = s, t.exports = e.default;
})(P1, P1.exports);
var X2 = P1.exports, C1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var n = c(pa), a = Xt;
  function c(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function u(i, f) {
    i.prototype = Object.create(f.prototype), i.prototype.constructor = i, r(i, f);
  }
  function r(i, f) {
    return r = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(s, o) {
      return s.__proto__ = o, s;
    }, r(i, f);
  }
  var l = /* @__PURE__ */ function(i) {
    u(f, i);
    function f(d) {
      var s;
      return s = i.call(this, d) || this, s.type = a.COMMENT, s;
    }
    return f;
  }(n.default);
  e.default = l, t.exports = e.default;
})(C1, C1.exports);
var J2 = C1.exports, I1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var n = c(pa), a = Xt;
  function c(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function u(i, f) {
    i.prototype = Object.create(f.prototype), i.prototype.constructor = i, r(i, f);
  }
  function r(i, f) {
    return r = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(s, o) {
      return s.__proto__ = o, s;
    }, r(i, f);
  }
  var l = /* @__PURE__ */ function(i) {
    u(f, i);
    function f(s) {
      var o;
      return o = i.call(this, s) || this, o.type = a.ID, o;
    }
    var d = f.prototype;
    return d.valueToString = function() {
      return "#" + i.prototype.valueToString.call(this);
    }, f;
  }(n.default);
  e.default = l, t.exports = e.default;
})(I1, I1.exports);
var Q2 = I1.exports, O1 = { exports: {} }, k1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var n = u(ly), a = Kn, c = u(pa);
  function u(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function r(s, o) {
    for (var m = 0; m < o.length; m++) {
      var h = o[m];
      h.enumerable = h.enumerable || !1, h.configurable = !0, "value" in h && (h.writable = !0), Object.defineProperty(s, h.key, h);
    }
  }
  function l(s, o, m) {
    return o && r(s.prototype, o), m && r(s, m), Object.defineProperty(s, "prototype", { writable: !1 }), s;
  }
  function i(s, o) {
    s.prototype = Object.create(o.prototype), s.prototype.constructor = s, f(s, o);
  }
  function f(s, o) {
    return f = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(h, y) {
      return h.__proto__ = y, h;
    }, f(s, o);
  }
  var d = /* @__PURE__ */ function(s) {
    i(o, s);
    function o() {
      return s.apply(this, arguments) || this;
    }
    var m = o.prototype;
    return m.qualifiedName = function(y) {
      return this.namespace ? this.namespaceString + "|" + y : y;
    }, m.valueToString = function() {
      return this.qualifiedName(s.prototype.valueToString.call(this));
    }, l(o, [{
      key: "namespace",
      get: function() {
        return this._namespace;
      },
      set: function(y) {
        if (y === !0 || y === "*" || y === "&") {
          this._namespace = y, this.raws && delete this.raws.namespace;
          return;
        }
        var b = (0, n.default)(y, {
          isIdentifier: !0
        });
        this._namespace = y, b !== y ? ((0, a.ensureObject)(this, "raws"), this.raws.namespace = b) : this.raws && delete this.raws.namespace;
      }
    }, {
      key: "ns",
      get: function() {
        return this._namespace;
      },
      set: function(y) {
        this.namespace = y;
      }
    }, {
      key: "namespaceString",
      get: function() {
        if (this.namespace) {
          var y = this.stringifyProperty("namespace");
          return y === !0 ? "" : y;
        } else
          return "";
      }
    }]), o;
  }(c.default);
  e.default = d, t.exports = e.default;
})(k1, k1.exports);
var uy = k1.exports;
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var n = c(uy), a = Xt;
  function c(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function u(i, f) {
    i.prototype = Object.create(f.prototype), i.prototype.constructor = i, r(i, f);
  }
  function r(i, f) {
    return r = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(s, o) {
      return s.__proto__ = o, s;
    }, r(i, f);
  }
  var l = /* @__PURE__ */ function(i) {
    u(f, i);
    function f(d) {
      var s;
      return s = i.call(this, d) || this, s.type = a.TAG, s;
    }
    return f;
  }(n.default);
  e.default = l, t.exports = e.default;
})(O1, O1.exports);
var Z2 = O1.exports, D1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var n = c(pa), a = Xt;
  function c(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function u(i, f) {
    i.prototype = Object.create(f.prototype), i.prototype.constructor = i, r(i, f);
  }
  function r(i, f) {
    return r = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(s, o) {
      return s.__proto__ = o, s;
    }, r(i, f);
  }
  var l = /* @__PURE__ */ function(i) {
    u(f, i);
    function f(d) {
      var s;
      return s = i.call(this, d) || this, s.type = a.STRING, s;
    }
    return f;
  }(n.default);
  e.default = l, t.exports = e.default;
})(D1, D1.exports);
var eT = D1.exports, N1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var n = c(ay), a = Xt;
  function c(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function u(i, f) {
    i.prototype = Object.create(f.prototype), i.prototype.constructor = i, r(i, f);
  }
  function r(i, f) {
    return r = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(s, o) {
      return s.__proto__ = o, s;
    }, r(i, f);
  }
  var l = /* @__PURE__ */ function(i) {
    u(f, i);
    function f(s) {
      var o;
      return o = i.call(this, s) || this, o.type = a.PSEUDO, o;
    }
    var d = f.prototype;
    return d.toString = function() {
      var o = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.rawSpaceBefore, this.stringifyProperty("value"), o, this.rawSpaceAfter].join("");
    }, f;
  }(n.default);
  e.default = l, t.exports = e.default;
})(N1, N1.exports);
var tT = N1.exports, cy = {}, rT = n6;
function n6(t, e) {
  if (Ih("noDeprecation"))
    return t;
  var n = !1;
  function a() {
    if (!n) {
      if (Ih("throwDeprecation"))
        throw new Error(e);
      Ih("traceDeprecation") ? console.trace(e) : console.warn(e), n = !0;
    }
    return t.apply(this, arguments);
  }
  return a;
}
function Ih(t) {
  try {
    if (!Bt.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var e = Bt.localStorage[t];
  return e == null ? !1 : String(e).toLowerCase() === "true";
}
(function(t) {
  t.__esModule = !0, t.default = void 0, t.unescapeValue = b;
  var e = r(ly), n = r(sy), a = r(uy), c = Xt, u;
  function r(R) {
    return R && R.__esModule ? R : { default: R };
  }
  function l(R, N) {
    for (var C = 0; C < N.length; C++) {
      var I = N[C];
      I.enumerable = I.enumerable || !1, I.configurable = !0, "value" in I && (I.writable = !0), Object.defineProperty(R, I.key, I);
    }
  }
  function i(R, N, C) {
    return N && l(R.prototype, N), C && l(R, C), Object.defineProperty(R, "prototype", { writable: !1 }), R;
  }
  function f(R, N) {
    R.prototype = Object.create(N.prototype), R.prototype.constructor = R, d(R, N);
  }
  function d(R, N) {
    return d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(I, D) {
      return I.__proto__ = D, I;
    }, d(R, N);
  }
  var s = rT, o = /^('|")([^]*)\1$/, m = s(function() {
  }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), h = s(function() {
  }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), y = s(function() {
  }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
  function b(R) {
    var N = !1, C = null, I = R, D = I.match(o);
    return D && (C = D[1], I = D[2]), I = (0, n.default)(I), I !== R && (N = !0), {
      deprecatedUsage: N,
      unescaped: I,
      quoteMark: C
    };
  }
  function E(R) {
    if (R.quoteMark !== void 0 || R.value === void 0)
      return R;
    y();
    var N = b(R.value), C = N.quoteMark, I = N.unescaped;
    return R.raws || (R.raws = {}), R.raws.value === void 0 && (R.raws.value = R.value), R.value = I, R.quoteMark = C, R;
  }
  var S = /* @__PURE__ */ function(R) {
    f(N, R);
    function N(I) {
      var D;
      return I === void 0 && (I = {}), D = R.call(this, E(I)) || this, D.type = c.ATTRIBUTE, D.raws = D.raws || {}, Object.defineProperty(D.raws, "unquoted", {
        get: s(function() {
          return D.value;
        }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
        set: s(function() {
          return D.value;
        }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
      }), D._constructed = !0, D;
    }
    var C = N.prototype;
    return C.getQuotedValue = function(D) {
      D === void 0 && (D = {});
      var j = this._determineQuoteMark(D), F = g[j], _ = (0, e.default)(this._value, F);
      return _;
    }, C._determineQuoteMark = function(D) {
      return D.smart ? this.smartQuoteMark(D) : this.preferredQuoteMark(D);
    }, C.setValue = function(D, j) {
      j === void 0 && (j = {}), this._value = D, this._quoteMark = this._determineQuoteMark(j), this._syncRawValue();
    }, C.smartQuoteMark = function(D) {
      var j = this.value, F = j.replace(/[^']/g, "").length, _ = j.replace(/[^"]/g, "").length;
      if (F + _ === 0) {
        var T = (0, e.default)(j, {
          isIdentifier: !0
        });
        if (T === j)
          return N.NO_QUOTE;
        var v = this.preferredQuoteMark(D);
        if (v === N.NO_QUOTE) {
          var w = this.quoteMark || D.quoteMark || N.DOUBLE_QUOTE, O = g[w], G = (0, e.default)(j, O);
          if (G.length < T.length)
            return w;
        }
        return v;
      } else
        return _ === F ? this.preferredQuoteMark(D) : _ < F ? N.DOUBLE_QUOTE : N.SINGLE_QUOTE;
    }, C.preferredQuoteMark = function(D) {
      var j = D.preferCurrentQuoteMark ? this.quoteMark : D.quoteMark;
      return j === void 0 && (j = D.preferCurrentQuoteMark ? D.quoteMark : this.quoteMark), j === void 0 && (j = N.DOUBLE_QUOTE), j;
    }, C._syncRawValue = function() {
      var D = (0, e.default)(this._value, g[this.quoteMark]);
      D === this._value ? this.raws && delete this.raws.value : this.raws.value = D;
    }, C._handleEscapes = function(D, j) {
      if (this._constructed) {
        var F = (0, e.default)(j, {
          isIdentifier: !0
        });
        F !== j ? this.raws[D] = F : delete this.raws[D];
      }
    }, C._spacesFor = function(D) {
      var j = {
        before: "",
        after: ""
      }, F = this.spaces[D] || {}, _ = this.raws.spaces && this.raws.spaces[D] || {};
      return Object.assign(j, F, _);
    }, C._stringFor = function(D, j, F) {
      j === void 0 && (j = D), F === void 0 && (F = P);
      var _ = this._spacesFor(j);
      return F(this.stringifyProperty(D), _);
    }, C.offsetOf = function(D) {
      var j = 1, F = this._spacesFor("attribute");
      if (j += F.before.length, D === "namespace" || D === "ns")
        return this.namespace ? j : -1;
      if (D === "attributeNS" || (j += this.namespaceString.length, this.namespace && (j += 1), D === "attribute"))
        return j;
      j += this.stringifyProperty("attribute").length, j += F.after.length;
      var _ = this._spacesFor("operator");
      j += _.before.length;
      var T = this.stringifyProperty("operator");
      if (D === "operator")
        return T ? j : -1;
      j += T.length, j += _.after.length;
      var v = this._spacesFor("value");
      j += v.before.length;
      var w = this.stringifyProperty("value");
      if (D === "value")
        return w ? j : -1;
      j += w.length, j += v.after.length;
      var O = this._spacesFor("insensitive");
      return j += O.before.length, D === "insensitive" && this.insensitive ? j : -1;
    }, C.toString = function() {
      var D = this, j = [this.rawSpaceBefore, "["];
      return j.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (j.push(this._stringFor("operator")), j.push(this._stringFor("value")), j.push(this._stringFor("insensitiveFlag", "insensitive", function(F, _) {
        return F.length > 0 && !D.quoted && _.before.length === 0 && !(D.spaces.value && D.spaces.value.after) && (_.before = " "), P(F, _);
      }))), j.push("]"), j.push(this.rawSpaceAfter), j.join("");
    }, i(N, [{
      key: "quoted",
      get: function() {
        var D = this.quoteMark;
        return D === "'" || D === '"';
      },
      set: function(D) {
        h();
      }
      /**
       * returns a single (`'`) or double (`"`) quote character if the value is quoted.
       * returns `null` if the value is not quoted.
       * returns `undefined` if the quotation state is unknown (this can happen when
       * the attribute is constructed without specifying a quote mark.)
       */
    }, {
      key: "quoteMark",
      get: function() {
        return this._quoteMark;
      },
      set: function(D) {
        if (!this._constructed) {
          this._quoteMark = D;
          return;
        }
        this._quoteMark !== D && (this._quoteMark = D, this._syncRawValue());
      }
    }, {
      key: "qualifiedAttribute",
      get: function() {
        return this.qualifiedName(this.raws.attribute || this.attribute);
      }
    }, {
      key: "insensitiveFlag",
      get: function() {
        return this.insensitive ? "i" : "";
      }
    }, {
      key: "value",
      get: function() {
        return this._value;
      },
      set: (
        /**
         * Before 3.0, the value had to be set to an escaped value including any wrapped
         * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
         * is unescaped during parsing and any quote marks are removed.
         *
         * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
         * a deprecation warning is raised when the new value contains any characters that would
         * require escaping (including if it contains wrapped quotes).
         *
         * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
         * how the new value is quoted.
         */
        function(D) {
          if (this._constructed) {
            var j = b(D), F = j.deprecatedUsage, _ = j.unescaped, T = j.quoteMark;
            if (F && m(), _ === this._value && T === this._quoteMark)
              return;
            this._value = _, this._quoteMark = T, this._syncRawValue();
          } else
            this._value = D;
        }
      )
    }, {
      key: "insensitive",
      get: function() {
        return this._insensitive;
      },
      set: function(D) {
        D || (this._insensitive = !1, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = void 0)), this._insensitive = D;
      }
    }, {
      key: "attribute",
      get: function() {
        return this._attribute;
      },
      set: function(D) {
        this._handleEscapes("attribute", D), this._attribute = D;
      }
    }]), N;
  }(a.default);
  t.default = S, S.NO_QUOTE = null, S.SINGLE_QUOTE = "'", S.DOUBLE_QUOTE = '"';
  var g = (u = {
    "'": {
      quotes: "single",
      wrap: !0
    },
    '"': {
      quotes: "double",
      wrap: !0
    }
  }, u[null] = {
    isIdentifier: !0
  }, u);
  function P(R, N) {
    return "" + N.before + R + N.after;
  }
})(cy);
var R1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var n = c(uy), a = Xt;
  function c(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function u(i, f) {
    i.prototype = Object.create(f.prototype), i.prototype.constructor = i, r(i, f);
  }
  function r(i, f) {
    return r = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(s, o) {
      return s.__proto__ = o, s;
    }, r(i, f);
  }
  var l = /* @__PURE__ */ function(i) {
    u(f, i);
    function f(d) {
      var s;
      return s = i.call(this, d) || this, s.type = a.UNIVERSAL, s.value = "*", s;
    }
    return f;
  }(n.default);
  e.default = l, t.exports = e.default;
})(R1, R1.exports);
var nT = R1.exports, M1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var n = c(pa), a = Xt;
  function c(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function u(i, f) {
    i.prototype = Object.create(f.prototype), i.prototype.constructor = i, r(i, f);
  }
  function r(i, f) {
    return r = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(s, o) {
      return s.__proto__ = o, s;
    }, r(i, f);
  }
  var l = /* @__PURE__ */ function(i) {
    u(f, i);
    function f(d) {
      var s;
      return s = i.call(this, d) || this, s.type = a.COMBINATOR, s;
    }
    return f;
  }(n.default);
  e.default = l, t.exports = e.default;
})(M1, M1.exports);
var iT = M1.exports, L1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var n = c(pa), a = Xt;
  function c(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function u(i, f) {
    i.prototype = Object.create(f.prototype), i.prototype.constructor = i, r(i, f);
  }
  function r(i, f) {
    return r = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(s, o) {
      return s.__proto__ = o, s;
    }, r(i, f);
  }
  var l = /* @__PURE__ */ function(i) {
    u(f, i);
    function f(d) {
      var s;
      return s = i.call(this, d) || this, s.type = a.NESTING, s.value = "&", s;
    }
    return f;
  }(n.default);
  e.default = l, t.exports = e.default;
})(L1, L1.exports);
var sT = L1.exports, j1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = n;
  function n(a) {
    return a.sort(function(c, u) {
      return c - u;
    });
  }
  t.exports = e.default;
})(j1, j1.exports);
var i6 = j1.exports, aT = {}, Ct = {};
Ct.__esModule = !0;
Ct.word = Ct.tilde = Ct.tab = Ct.str = Ct.space = Ct.slash = Ct.singleQuote = Ct.semicolon = Ct.plus = Ct.pipe = Ct.openSquare = Ct.openParenthesis = Ct.newline = Ct.greaterThan = Ct.feed = Ct.equals = Ct.doubleQuote = Ct.dollar = Ct.cr = Ct.comment = Ct.comma = Ct.combinator = Ct.colon = Ct.closeSquare = Ct.closeParenthesis = Ct.caret = Ct.bang = Ct.backslash = Ct.at = Ct.asterisk = Ct.ampersand = void 0;
var s6 = 38;
Ct.ampersand = s6;
var a6 = 42;
Ct.asterisk = a6;
var o6 = 64;
Ct.at = o6;
var l6 = 44;
Ct.comma = l6;
var u6 = 58;
Ct.colon = u6;
var c6 = 59;
Ct.semicolon = c6;
var f6 = 40;
Ct.openParenthesis = f6;
var d6 = 41;
Ct.closeParenthesis = d6;
var p6 = 91;
Ct.openSquare = p6;
var h6 = 93;
Ct.closeSquare = h6;
var m6 = 36;
Ct.dollar = m6;
var y6 = 126;
Ct.tilde = y6;
var b6 = 94;
Ct.caret = b6;
var g6 = 43;
Ct.plus = g6;
var v6 = 61;
Ct.equals = v6;
var E6 = 124;
Ct.pipe = E6;
var _6 = 62;
Ct.greaterThan = _6;
var S6 = 32;
Ct.space = S6;
var oT = 39;
Ct.singleQuote = oT;
var w6 = 34;
Ct.doubleQuote = w6;
var T6 = 47;
Ct.slash = T6;
var A6 = 33;
Ct.bang = A6;
var x6 = 92;
Ct.backslash = x6;
var P6 = 13;
Ct.cr = P6;
var C6 = 12;
Ct.feed = C6;
var I6 = 10;
Ct.newline = I6;
var O6 = 9;
Ct.tab = O6;
var k6 = oT;
Ct.str = k6;
var D6 = -1;
Ct.comment = D6;
var N6 = -2;
Ct.word = N6;
var R6 = -3;
Ct.combinator = R6;
(function(t) {
  t.__esModule = !0, t.FIELDS = void 0, t.default = h;
  var e = u(Ct), n, a;
  function c(y) {
    if (typeof WeakMap != "function")
      return null;
    var b = /* @__PURE__ */ new WeakMap(), E = /* @__PURE__ */ new WeakMap();
    return (c = function(g) {
      return g ? E : b;
    })(y);
  }
  function u(y, b) {
    if (!b && y && y.__esModule)
      return y;
    if (y === null || typeof y != "object" && typeof y != "function")
      return { default: y };
    var E = c(b);
    if (E && E.has(y))
      return E.get(y);
    var S = {}, g = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var P in y)
      if (P !== "default" && Object.prototype.hasOwnProperty.call(y, P)) {
        var R = g ? Object.getOwnPropertyDescriptor(y, P) : null;
        R && (R.get || R.set) ? Object.defineProperty(S, P, R) : S[P] = y[P];
      }
    return S.default = y, E && E.set(y, S), S;
  }
  for (var r = (n = {}, n[e.tab] = !0, n[e.newline] = !0, n[e.cr] = !0, n[e.feed] = !0, n), l = (a = {}, a[e.space] = !0, a[e.tab] = !0, a[e.newline] = !0, a[e.cr] = !0, a[e.feed] = !0, a[e.ampersand] = !0, a[e.asterisk] = !0, a[e.bang] = !0, a[e.comma] = !0, a[e.colon] = !0, a[e.semicolon] = !0, a[e.openParenthesis] = !0, a[e.closeParenthesis] = !0, a[e.openSquare] = !0, a[e.closeSquare] = !0, a[e.singleQuote] = !0, a[e.doubleQuote] = !0, a[e.plus] = !0, a[e.pipe] = !0, a[e.tilde] = !0, a[e.greaterThan] = !0, a[e.equals] = !0, a[e.dollar] = !0, a[e.caret] = !0, a[e.slash] = !0, a), i = {}, f = "0123456789abcdefABCDEF", d = 0; d < f.length; d++)
    i[f.charCodeAt(d)] = !0;
  function s(y, b) {
    var E = b, S;
    do {
      if (S = y.charCodeAt(E), l[S])
        return E - 1;
      S === e.backslash ? E = o(y, E) + 1 : E++;
    } while (E < y.length);
    return E - 1;
  }
  function o(y, b) {
    var E = b, S = y.charCodeAt(E + 1);
    if (!r[S])
      if (i[S]) {
        var g = 0;
        do
          E++, g++, S = y.charCodeAt(E + 1);
        while (i[S] && g < 6);
        g < 6 && S === e.space && E++;
      } else
        E++;
    return E;
  }
  var m = {
    TYPE: 0,
    START_LINE: 1,
    START_COL: 2,
    END_LINE: 3,
    END_COL: 4,
    START_POS: 5,
    END_POS: 6
  };
  t.FIELDS = m;
  function h(y) {
    var b = [], E = y.css.valueOf(), S = E, g = S.length, P = -1, R = 1, N = 0, C = 0, I, D, j, F, _, T, v, w, O, G, W, U, M;
    function B(k, K) {
      if (y.safe)
        E += K, O = E.length - 1;
      else
        throw y.error("Unclosed " + k, R, N - P, N);
    }
    for (; N < g; ) {
      switch (I = E.charCodeAt(N), I === e.newline && (P = N, R += 1), I) {
        case e.space:
        case e.tab:
        case e.newline:
        case e.cr:
        case e.feed:
          O = N;
          do
            O += 1, I = E.charCodeAt(O), I === e.newline && (P = O, R += 1);
          while (I === e.space || I === e.newline || I === e.tab || I === e.cr || I === e.feed);
          M = e.space, F = R, j = O - P - 1, C = O;
          break;
        case e.plus:
        case e.greaterThan:
        case e.tilde:
        case e.pipe:
          O = N;
          do
            O += 1, I = E.charCodeAt(O);
          while (I === e.plus || I === e.greaterThan || I === e.tilde || I === e.pipe);
          M = e.combinator, F = R, j = N - P, C = O;
          break;
        case e.asterisk:
        case e.ampersand:
        case e.bang:
        case e.comma:
        case e.equals:
        case e.dollar:
        case e.caret:
        case e.openSquare:
        case e.closeSquare:
        case e.colon:
        case e.semicolon:
        case e.openParenthesis:
        case e.closeParenthesis:
          O = N, M = I, F = R, j = N - P, C = O + 1;
          break;
        case e.singleQuote:
        case e.doubleQuote:
          U = I === e.singleQuote ? "'" : '"', O = N;
          do
            for (_ = !1, O = E.indexOf(U, O + 1), O === -1 && B("quote", U), T = O; E.charCodeAt(T - 1) === e.backslash; )
              T -= 1, _ = !_;
          while (_);
          M = e.str, F = R, j = N - P, C = O + 1;
          break;
        default:
          I === e.slash && E.charCodeAt(N + 1) === e.asterisk ? (O = E.indexOf("*/", N + 2) + 1, O === 0 && B("comment", "*/"), D = E.slice(N, O + 1), w = D.split(`
`), v = w.length - 1, v > 0 ? (G = R + v, W = O - w[v].length) : (G = R, W = P), M = e.comment, R = G, F = G, j = O - W) : I === e.slash ? (O = N, M = I, F = R, j = N - P, C = O + 1) : (O = s(E, N), M = e.word, F = R, j = O - P), C = O + 1;
          break;
      }
      b.push([
        M,
        // [0] Token type
        R,
        // [1] Starting line
        N - P,
        // [2] Starting column
        F,
        // [3] Ending line
        j,
        // [4] Ending column
        N,
        // [5] Start position / Source index
        C
        // [6] End position
      ]), W && (P = W, W = null), N = C;
    }
    return b;
  }
})(aT);
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var n = C(K2), a = C(Y2), c = C(X2), u = C(J2), r = C(Q2), l = C(Z2), i = C(eT), f = C(tT), d = N(cy), s = C(nT), o = C(iT), m = C(sT), h = C(i6), y = N(aT), b = N(Ct), E = N(Xt), S = Kn, g, P;
  function R(B) {
    if (typeof WeakMap != "function")
      return null;
    var k = /* @__PURE__ */ new WeakMap(), K = /* @__PURE__ */ new WeakMap();
    return (R = function(z) {
      return z ? K : k;
    })(B);
  }
  function N(B, k) {
    if (!k && B && B.__esModule)
      return B;
    if (B === null || typeof B != "object" && typeof B != "function")
      return { default: B };
    var K = R(k);
    if (K && K.has(B))
      return K.get(B);
    var te = {}, z = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var q in B)
      if (q !== "default" && Object.prototype.hasOwnProperty.call(B, q)) {
        var $ = z ? Object.getOwnPropertyDescriptor(B, q) : null;
        $ && ($.get || $.set) ? Object.defineProperty(te, q, $) : te[q] = B[q];
      }
    return te.default = B, K && K.set(B, te), te;
  }
  function C(B) {
    return B && B.__esModule ? B : { default: B };
  }
  function I(B, k) {
    for (var K = 0; K < k.length; K++) {
      var te = k[K];
      te.enumerable = te.enumerable || !1, te.configurable = !0, "value" in te && (te.writable = !0), Object.defineProperty(B, te.key, te);
    }
  }
  function D(B, k, K) {
    return k && I(B.prototype, k), K && I(B, K), Object.defineProperty(B, "prototype", { writable: !1 }), B;
  }
  var j = (g = {}, g[b.space] = !0, g[b.cr] = !0, g[b.feed] = !0, g[b.newline] = !0, g[b.tab] = !0, g), F = Object.assign({}, j, (P = {}, P[b.comment] = !0, P));
  function _(B) {
    return {
      line: B[y.FIELDS.START_LINE],
      column: B[y.FIELDS.START_COL]
    };
  }
  function T(B) {
    return {
      line: B[y.FIELDS.END_LINE],
      column: B[y.FIELDS.END_COL]
    };
  }
  function v(B, k, K, te) {
    return {
      start: {
        line: B,
        column: k
      },
      end: {
        line: K,
        column: te
      }
    };
  }
  function w(B) {
    return v(B[y.FIELDS.START_LINE], B[y.FIELDS.START_COL], B[y.FIELDS.END_LINE], B[y.FIELDS.END_COL]);
  }
  function O(B, k) {
    if (B)
      return v(B[y.FIELDS.START_LINE], B[y.FIELDS.START_COL], k[y.FIELDS.END_LINE], k[y.FIELDS.END_COL]);
  }
  function G(B, k) {
    var K = B[k];
    if (typeof K == "string")
      return K.indexOf("\\") !== -1 && ((0, S.ensureObject)(B, "raws"), B[k] = (0, S.unesc)(K), B.raws[k] === void 0 && (B.raws[k] = K)), B;
  }
  function W(B, k) {
    for (var K = -1, te = []; (K = B.indexOf(k, K + 1)) !== -1; )
      te.push(K);
    return te;
  }
  function U() {
    var B = Array.prototype.concat.apply([], arguments);
    return B.filter(function(k, K) {
      return K === B.indexOf(k);
    });
  }
  var M = /* @__PURE__ */ function() {
    function B(K, te) {
      te === void 0 && (te = {}), this.rule = K, this.options = Object.assign({
        lossy: !1,
        safe: !1
      }, te), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, y.default)({
        css: this.css,
        error: this._errorGenerator(),
        safe: this.options.safe
      });
      var z = O(this.tokens[0], this.tokens[this.tokens.length - 1]);
      this.root = new n.default({
        source: z
      }), this.root.errorGenerator = this._errorGenerator();
      var q = new a.default({
        source: {
          start: {
            line: 1,
            column: 1
          }
        }
      });
      this.root.append(q), this.current = q, this.loop();
    }
    var k = B.prototype;
    return k._errorGenerator = function() {
      var te = this;
      return function(z, q) {
        return typeof te.rule == "string" ? new Error(z) : te.rule.error(z, q);
      };
    }, k.attribute = function() {
      var te = [], z = this.currToken;
      for (this.position++; this.position < this.tokens.length && this.currToken[y.FIELDS.TYPE] !== b.closeSquare; )
        te.push(this.currToken), this.position++;
      if (this.currToken[y.FIELDS.TYPE] !== b.closeSquare)
        return this.expected("closing square bracket", this.currToken[y.FIELDS.START_POS]);
      var q = te.length, $ = {
        source: v(z[1], z[2], this.currToken[3], this.currToken[4]),
        sourceIndex: z[y.FIELDS.START_POS]
      };
      if (q === 1 && !~[b.word].indexOf(te[0][y.FIELDS.TYPE]))
        return this.expected("attribute", te[0][y.FIELDS.START_POS]);
      for (var Y = 0, H = "", Q = "", X = null, ne = !1; Y < q; ) {
        var ye = te[Y], ve = this.content(ye), de = te[Y + 1];
        switch (ye[y.FIELDS.TYPE]) {
          case b.space:
            if (ne = !0, this.options.lossy)
              break;
            if (X) {
              (0, S.ensureObject)($, "spaces", X);
              var oe = $.spaces[X].after || "";
              $.spaces[X].after = oe + ve;
              var re = (0, S.getProp)($, "raws", "spaces", X, "after") || null;
              re && ($.raws.spaces[X].after = re + ve);
            } else
              H = H + ve, Q = Q + ve;
            break;
          case b.asterisk:
            if (de[y.FIELDS.TYPE] === b.equals)
              $.operator = ve, X = "operator";
            else if ((!$.namespace || X === "namespace" && !ne) && de) {
              H && ((0, S.ensureObject)($, "spaces", "attribute"), $.spaces.attribute.before = H, H = ""), Q && ((0, S.ensureObject)($, "raws", "spaces", "attribute"), $.raws.spaces.attribute.before = H, Q = ""), $.namespace = ($.namespace || "") + ve;
              var ae = (0, S.getProp)($, "raws", "namespace") || null;
              ae && ($.raws.namespace += ve), X = "namespace";
            }
            ne = !1;
            break;
          case b.dollar:
            if (X === "value") {
              var le = (0, S.getProp)($, "raws", "value");
              $.value += "$", le && ($.raws.value = le + "$");
              break;
            }
          case b.caret:
            de[y.FIELDS.TYPE] === b.equals && ($.operator = ve, X = "operator"), ne = !1;
            break;
          case b.combinator:
            if (ve === "~" && de[y.FIELDS.TYPE] === b.equals && ($.operator = ve, X = "operator"), ve !== "|") {
              ne = !1;
              break;
            }
            de[y.FIELDS.TYPE] === b.equals ? ($.operator = ve, X = "operator") : !$.namespace && !$.attribute && ($.namespace = !0), ne = !1;
            break;
          case b.word:
            if (de && this.content(de) === "|" && te[Y + 2] && te[Y + 2][y.FIELDS.TYPE] !== b.equals && // this look-ahead probably fails with comment nodes involved.
            !$.operator && !$.namespace)
              $.namespace = ve, X = "namespace";
            else if (!$.attribute || X === "attribute" && !ne) {
              H && ((0, S.ensureObject)($, "spaces", "attribute"), $.spaces.attribute.before = H, H = ""), Q && ((0, S.ensureObject)($, "raws", "spaces", "attribute"), $.raws.spaces.attribute.before = Q, Q = ""), $.attribute = ($.attribute || "") + ve;
              var ue = (0, S.getProp)($, "raws", "attribute") || null;
              ue && ($.raws.attribute += ve), X = "attribute";
            } else if (!$.value && $.value !== "" || X === "value" && !(ne || $.quoteMark)) {
              var ie = (0, S.unesc)(ve), we = (0, S.getProp)($, "raws", "value") || "", De = $.value || "";
              $.value = De + ie, $.quoteMark = null, (ie !== ve || we) && ((0, S.ensureObject)($, "raws"), $.raws.value = (we || De) + ve), X = "value";
            } else {
              var Ee = ve === "i" || ve === "I";
              ($.value || $.value === "") && ($.quoteMark || ne) ? ($.insensitive = Ee, (!Ee || ve === "I") && ((0, S.ensureObject)($, "raws"), $.raws.insensitiveFlag = ve), X = "insensitive", H && ((0, S.ensureObject)($, "spaces", "insensitive"), $.spaces.insensitive.before = H, H = ""), Q && ((0, S.ensureObject)($, "raws", "spaces", "insensitive"), $.raws.spaces.insensitive.before = Q, Q = "")) : ($.value || $.value === "") && (X = "value", $.value += ve, $.raws.value && ($.raws.value += ve));
            }
            ne = !1;
            break;
          case b.str:
            if (!$.attribute || !$.operator)
              return this.error("Expected an attribute followed by an operator preceding the string.", {
                index: ye[y.FIELDS.START_POS]
              });
            var Ae = (0, d.unescapeValue)(ve), Me = Ae.unescaped, me = Ae.quoteMark;
            $.value = Me, $.quoteMark = me, X = "value", (0, S.ensureObject)($, "raws"), $.raws.value = ve, ne = !1;
            break;
          case b.equals:
            if (!$.attribute)
              return this.expected("attribute", ye[y.FIELDS.START_POS], ve);
            if ($.value)
              return this.error('Unexpected "=" found; an operator was already defined.', {
                index: ye[y.FIELDS.START_POS]
              });
            $.operator = $.operator ? $.operator + ve : ve, X = "operator", ne = !1;
            break;
          case b.comment:
            if (X)
              if (ne || de && de[y.FIELDS.TYPE] === b.space || X === "insensitive") {
                var se = (0, S.getProp)($, "spaces", X, "after") || "", Z = (0, S.getProp)($, "raws", "spaces", X, "after") || se;
                (0, S.ensureObject)($, "raws", "spaces", X), $.raws.spaces[X].after = Z + ve;
              } else {
                var pe = $[X] || "", be = (0, S.getProp)($, "raws", X) || pe;
                (0, S.ensureObject)($, "raws"), $.raws[X] = be + ve;
              }
            else
              Q = Q + ve;
            break;
          default:
            return this.error('Unexpected "' + ve + '" found.', {
              index: ye[y.FIELDS.START_POS]
            });
        }
        Y++;
      }
      G($, "attribute"), G($, "namespace"), this.newNode(new d.default($)), this.position++;
    }, k.parseWhitespaceEquivalentTokens = function(te) {
      te < 0 && (te = this.tokens.length);
      var z = this.position, q = [], $ = "", Y = void 0;
      do
        if (j[this.currToken[y.FIELDS.TYPE]])
          this.options.lossy || ($ += this.content());
        else if (this.currToken[y.FIELDS.TYPE] === b.comment) {
          var H = {};
          $ && (H.before = $, $ = ""), Y = new u.default({
            value: this.content(),
            source: w(this.currToken),
            sourceIndex: this.currToken[y.FIELDS.START_POS],
            spaces: H
          }), q.push(Y);
        }
      while (++this.position < te);
      if ($) {
        if (Y)
          Y.spaces.after = $;
        else if (!this.options.lossy) {
          var Q = this.tokens[z], X = this.tokens[this.position - 1];
          q.push(new i.default({
            value: "",
            source: v(Q[y.FIELDS.START_LINE], Q[y.FIELDS.START_COL], X[y.FIELDS.END_LINE], X[y.FIELDS.END_COL]),
            sourceIndex: Q[y.FIELDS.START_POS],
            spaces: {
              before: $,
              after: ""
            }
          }));
        }
      }
      return q;
    }, k.convertWhitespaceNodesToSpace = function(te, z) {
      var q = this;
      z === void 0 && (z = !1);
      var $ = "", Y = "";
      te.forEach(function(Q) {
        var X = q.lossySpace(Q.spaces.before, z), ne = q.lossySpace(Q.rawSpaceBefore, z);
        $ += X + q.lossySpace(Q.spaces.after, z && X.length === 0), Y += X + Q.value + q.lossySpace(Q.rawSpaceAfter, z && ne.length === 0);
      }), Y === $ && (Y = void 0);
      var H = {
        space: $,
        rawSpace: Y
      };
      return H;
    }, k.isNamedCombinator = function(te) {
      return te === void 0 && (te = this.position), this.tokens[te + 0] && this.tokens[te + 0][y.FIELDS.TYPE] === b.slash && this.tokens[te + 1] && this.tokens[te + 1][y.FIELDS.TYPE] === b.word && this.tokens[te + 2] && this.tokens[te + 2][y.FIELDS.TYPE] === b.slash;
    }, k.namedCombinator = function() {
      if (this.isNamedCombinator()) {
        var te = this.content(this.tokens[this.position + 1]), z = (0, S.unesc)(te).toLowerCase(), q = {};
        z !== te && (q.value = "/" + te + "/");
        var $ = new o.default({
          value: "/" + z + "/",
          source: v(this.currToken[y.FIELDS.START_LINE], this.currToken[y.FIELDS.START_COL], this.tokens[this.position + 2][y.FIELDS.END_LINE], this.tokens[this.position + 2][y.FIELDS.END_COL]),
          sourceIndex: this.currToken[y.FIELDS.START_POS],
          raws: q
        });
        return this.position = this.position + 3, $;
      } else
        this.unexpected();
    }, k.combinator = function() {
      var te = this;
      if (this.content() === "|")
        return this.namespace();
      var z = this.locateNextMeaningfulToken(this.position);
      if (z < 0 || this.tokens[z][y.FIELDS.TYPE] === b.comma) {
        var q = this.parseWhitespaceEquivalentTokens(z);
        if (q.length > 0) {
          var $ = this.current.last;
          if ($) {
            var Y = this.convertWhitespaceNodesToSpace(q), H = Y.space, Q = Y.rawSpace;
            Q !== void 0 && ($.rawSpaceAfter += Q), $.spaces.after += H;
          } else
            q.forEach(function(we) {
              return te.newNode(we);
            });
        }
        return;
      }
      var X = this.currToken, ne = void 0;
      z > this.position && (ne = this.parseWhitespaceEquivalentTokens(z));
      var ye;
      if (this.isNamedCombinator() ? ye = this.namedCombinator() : this.currToken[y.FIELDS.TYPE] === b.combinator ? (ye = new o.default({
        value: this.content(),
        source: w(this.currToken),
        sourceIndex: this.currToken[y.FIELDS.START_POS]
      }), this.position++) : j[this.currToken[y.FIELDS.TYPE]] || ne || this.unexpected(), ye) {
        if (ne) {
          var ve = this.convertWhitespaceNodesToSpace(ne), de = ve.space, oe = ve.rawSpace;
          ye.spaces.before = de, ye.rawSpaceBefore = oe;
        }
      } else {
        var re = this.convertWhitespaceNodesToSpace(ne, !0), ae = re.space, le = re.rawSpace;
        le || (le = ae);
        var ue = {}, ie = {
          spaces: {}
        };
        ae.endsWith(" ") && le.endsWith(" ") ? (ue.before = ae.slice(0, ae.length - 1), ie.spaces.before = le.slice(0, le.length - 1)) : ae.startsWith(" ") && le.startsWith(" ") ? (ue.after = ae.slice(1), ie.spaces.after = le.slice(1)) : ie.value = le, ye = new o.default({
          value: " ",
          source: O(X, this.tokens[this.position - 1]),
          sourceIndex: X[y.FIELDS.START_POS],
          spaces: ue,
          raws: ie
        });
      }
      return this.currToken && this.currToken[y.FIELDS.TYPE] === b.space && (ye.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(ye);
    }, k.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = !0, this.position++;
        return;
      }
      this.current._inferEndPosition();
      var te = new a.default({
        source: {
          start: _(this.tokens[this.position + 1])
        }
      });
      this.current.parent.append(te), this.current = te, this.position++;
    }, k.comment = function() {
      var te = this.currToken;
      this.newNode(new u.default({
        value: this.content(),
        source: w(te),
        sourceIndex: te[y.FIELDS.START_POS]
      })), this.position++;
    }, k.error = function(te, z) {
      throw this.root.error(te, z);
    }, k.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.", {
        index: this.currToken[y.FIELDS.START_POS]
      });
    }, k.missingParenthesis = function() {
      return this.expected("opening parenthesis", this.currToken[y.FIELDS.START_POS]);
    }, k.missingSquareBracket = function() {
      return this.expected("opening square bracket", this.currToken[y.FIELDS.START_POS]);
    }, k.unexpected = function() {
      return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[y.FIELDS.START_POS]);
    }, k.unexpectedPipe = function() {
      return this.error("Unexpected '|'.", this.currToken[y.FIELDS.START_POS]);
    }, k.namespace = function() {
      var te = this.prevToken && this.content(this.prevToken) || !0;
      if (this.nextToken[y.FIELDS.TYPE] === b.word)
        return this.position++, this.word(te);
      if (this.nextToken[y.FIELDS.TYPE] === b.asterisk)
        return this.position++, this.universal(te);
      this.unexpectedPipe();
    }, k.nesting = function() {
      if (this.nextToken) {
        var te = this.content(this.nextToken);
        if (te === "|") {
          this.position++;
          return;
        }
      }
      var z = this.currToken;
      this.newNode(new m.default({
        value: this.content(),
        source: w(z),
        sourceIndex: z[y.FIELDS.START_POS]
      })), this.position++;
    }, k.parentheses = function() {
      var te = this.current.last, z = 1;
      if (this.position++, te && te.type === E.PSEUDO) {
        var q = new a.default({
          source: {
            start: _(this.tokens[this.position - 1])
          }
        }), $ = this.current;
        for (te.append(q), this.current = q; this.position < this.tokens.length && z; )
          this.currToken[y.FIELDS.TYPE] === b.openParenthesis && z++, this.currToken[y.FIELDS.TYPE] === b.closeParenthesis && z--, z ? this.parse() : (this.current.source.end = T(this.currToken), this.current.parent.source.end = T(this.currToken), this.position++);
        this.current = $;
      } else {
        for (var Y = this.currToken, H = "(", Q; this.position < this.tokens.length && z; )
          this.currToken[y.FIELDS.TYPE] === b.openParenthesis && z++, this.currToken[y.FIELDS.TYPE] === b.closeParenthesis && z--, Q = this.currToken, H += this.parseParenthesisToken(this.currToken), this.position++;
        te ? te.appendToPropertyAndEscape("value", H, H) : this.newNode(new i.default({
          value: H,
          source: v(Y[y.FIELDS.START_LINE], Y[y.FIELDS.START_COL], Q[y.FIELDS.END_LINE], Q[y.FIELDS.END_COL]),
          sourceIndex: Y[y.FIELDS.START_POS]
        }));
      }
      if (z)
        return this.expected("closing parenthesis", this.currToken[y.FIELDS.START_POS]);
    }, k.pseudo = function() {
      for (var te = this, z = "", q = this.currToken; this.currToken && this.currToken[y.FIELDS.TYPE] === b.colon; )
        z += this.content(), this.position++;
      if (!this.currToken)
        return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
      if (this.currToken[y.FIELDS.TYPE] === b.word)
        this.splitWord(!1, function($, Y) {
          z += $, te.newNode(new f.default({
            value: z,
            source: O(q, te.currToken),
            sourceIndex: q[y.FIELDS.START_POS]
          })), Y > 1 && te.nextToken && te.nextToken[y.FIELDS.TYPE] === b.openParenthesis && te.error("Misplaced parenthesis.", {
            index: te.nextToken[y.FIELDS.START_POS]
          });
        });
      else
        return this.expected(["pseudo-class", "pseudo-element"], this.currToken[y.FIELDS.START_POS]);
    }, k.space = function() {
      var te = this.content();
      this.position === 0 || this.prevToken[y.FIELDS.TYPE] === b.comma || this.prevToken[y.FIELDS.TYPE] === b.openParenthesis || this.current.nodes.every(function(z) {
        return z.type === "comment";
      }) ? (this.spaces = this.optionalSpace(te), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[y.FIELDS.TYPE] === b.comma || this.nextToken[y.FIELDS.TYPE] === b.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(te), this.position++) : this.combinator();
    }, k.string = function() {
      var te = this.currToken;
      this.newNode(new i.default({
        value: this.content(),
        source: w(te),
        sourceIndex: te[y.FIELDS.START_POS]
      })), this.position++;
    }, k.universal = function(te) {
      var z = this.nextToken;
      if (z && this.content(z) === "|")
        return this.position++, this.namespace();
      var q = this.currToken;
      this.newNode(new s.default({
        value: this.content(),
        source: w(q),
        sourceIndex: q[y.FIELDS.START_POS]
      }), te), this.position++;
    }, k.splitWord = function(te, z) {
      for (var q = this, $ = this.nextToken, Y = this.content(); $ && ~[b.dollar, b.caret, b.equals, b.word].indexOf($[y.FIELDS.TYPE]); ) {
        this.position++;
        var H = this.content();
        if (Y += H, H.lastIndexOf("\\") === H.length - 1) {
          var Q = this.nextToken;
          Q && Q[y.FIELDS.TYPE] === b.space && (Y += this.requiredSpace(this.content(Q)), this.position++);
        }
        $ = this.nextToken;
      }
      var X = W(Y, ".").filter(function(de) {
        var oe = Y[de - 1] === "\\", re = /^\d+\.\d+%$/.test(Y);
        return !oe && !re;
      }), ne = W(Y, "#").filter(function(de) {
        return Y[de - 1] !== "\\";
      }), ye = W(Y, "#{");
      ye.length && (ne = ne.filter(function(de) {
        return !~ye.indexOf(de);
      }));
      var ve = (0, h.default)(U([0].concat(X, ne)));
      ve.forEach(function(de, oe) {
        var re = ve[oe + 1] || Y.length, ae = Y.slice(de, re);
        if (oe === 0 && z)
          return z.call(q, ae, ve.length);
        var le, ue = q.currToken, ie = ue[y.FIELDS.START_POS] + ve[oe], we = v(ue[1], ue[2] + de, ue[3], ue[2] + (re - 1));
        if (~X.indexOf(de)) {
          var De = {
            value: ae.slice(1),
            source: we,
            sourceIndex: ie
          };
          le = new c.default(G(De, "value"));
        } else if (~ne.indexOf(de)) {
          var Ee = {
            value: ae.slice(1),
            source: we,
            sourceIndex: ie
          };
          le = new r.default(G(Ee, "value"));
        } else {
          var Ae = {
            value: ae,
            source: we,
            sourceIndex: ie
          };
          G(Ae, "value"), le = new l.default(Ae);
        }
        q.newNode(le, te), te = null;
      }), this.position++;
    }, k.word = function(te) {
      var z = this.nextToken;
      return z && this.content(z) === "|" ? (this.position++, this.namespace()) : this.splitWord(te);
    }, k.loop = function() {
      for (; this.position < this.tokens.length; )
        this.parse(!0);
      return this.current._inferEndPosition(), this.root;
    }, k.parse = function(te) {
      switch (this.currToken[y.FIELDS.TYPE]) {
        case b.space:
          this.space();
          break;
        case b.comment:
          this.comment();
          break;
        case b.openParenthesis:
          this.parentheses();
          break;
        case b.closeParenthesis:
          te && this.missingParenthesis();
          break;
        case b.openSquare:
          this.attribute();
          break;
        case b.dollar:
        case b.caret:
        case b.equals:
        case b.word:
          this.word();
          break;
        case b.colon:
          this.pseudo();
          break;
        case b.comma:
          this.comma();
          break;
        case b.asterisk:
          this.universal();
          break;
        case b.ampersand:
          this.nesting();
          break;
        case b.slash:
        case b.combinator:
          this.combinator();
          break;
        case b.str:
          this.string();
          break;
        case b.closeSquare:
          this.missingSquareBracket();
        case b.semicolon:
          this.missingBackslash();
        default:
          this.unexpected();
      }
    }, k.expected = function(te, z, q) {
      if (Array.isArray(te)) {
        var $ = te.pop();
        te = te.join(", ") + " or " + $;
      }
      var Y = /^[aeiou]/.test(te[0]) ? "an" : "a";
      return q ? this.error("Expected " + Y + " " + te + ', found "' + q + '" instead.', {
        index: z
      }) : this.error("Expected " + Y + " " + te + ".", {
        index: z
      });
    }, k.requiredSpace = function(te) {
      return this.options.lossy ? " " : te;
    }, k.optionalSpace = function(te) {
      return this.options.lossy ? "" : te;
    }, k.lossySpace = function(te, z) {
      return this.options.lossy ? z ? " " : "" : te;
    }, k.parseParenthesisToken = function(te) {
      var z = this.content(te);
      return te[y.FIELDS.TYPE] === b.space ? this.requiredSpace(z) : z;
    }, k.newNode = function(te, z) {
      return z && (/^ +$/.test(z) && (this.options.lossy || (this.spaces = (this.spaces || "") + z), z = !0), te.namespace = z, G(te, "namespace")), this.spaces && (te.spaces.before = this.spaces, this.spaces = ""), this.current.append(te);
    }, k.content = function(te) {
      return te === void 0 && (te = this.currToken), this.css.slice(te[y.FIELDS.START_POS], te[y.FIELDS.END_POS]);
    }, k.locateNextMeaningfulToken = function(te) {
      te === void 0 && (te = this.position + 1);
      for (var z = te; z < this.tokens.length; )
        if (F[this.tokens[z][y.FIELDS.TYPE]]) {
          z++;
          continue;
        } else
          return z;
      return -1;
    }, D(B, [{
      key: "currToken",
      get: function() {
        return this.tokens[this.position];
      }
    }, {
      key: "nextToken",
      get: function() {
        return this.tokens[this.position + 1];
      }
    }, {
      key: "prevToken",
      get: function() {
        return this.tokens[this.position - 1];
      }
    }]), B;
  }();
  e.default = M, t.exports = e.default;
})(g1, g1.exports);
var M6 = g1.exports;
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var n = a(M6);
  function a(u) {
    return u && u.__esModule ? u : { default: u };
  }
  var c = /* @__PURE__ */ function() {
    function u(l, i) {
      this.func = l || function() {
      }, this.funcRes = null, this.options = i;
    }
    var r = u.prototype;
    return r._shouldUpdateSelector = function(i, f) {
      f === void 0 && (f = {});
      var d = Object.assign({}, this.options, f);
      return d.updateSelector === !1 ? !1 : typeof i != "string";
    }, r._isLossy = function(i) {
      i === void 0 && (i = {});
      var f = Object.assign({}, this.options, i);
      return f.lossless === !1;
    }, r._root = function(i, f) {
      f === void 0 && (f = {});
      var d = new n.default(i, this._parseOptions(f));
      return d.root;
    }, r._parseOptions = function(i) {
      return {
        lossy: this._isLossy(i)
      };
    }, r._run = function(i, f) {
      var d = this;
      return f === void 0 && (f = {}), new Promise(function(s, o) {
        try {
          var m = d._root(i, f);
          Promise.resolve(d.func(m)).then(function(h) {
            var y = void 0;
            return d._shouldUpdateSelector(i, f) && (y = m.toString(), i.selector = y), {
              transform: h,
              root: m,
              string: y
            };
          }).then(s, o);
        } catch (h) {
          o(h);
          return;
        }
      });
    }, r._runSync = function(i, f) {
      f === void 0 && (f = {});
      var d = this._root(i, f), s = this.func(d);
      if (s && typeof s.then == "function")
        throw new Error("Selector processor returned a promise to a synchronous call.");
      var o = void 0;
      return f.updateSelector && typeof i != "string" && (o = d.toString(), i.selector = o), {
        transform: s,
        root: d,
        string: o
      };
    }, r.ast = function(i, f) {
      return this._run(i, f).then(function(d) {
        return d.root;
      });
    }, r.astSync = function(i, f) {
      return this._runSync(i, f).root;
    }, r.transform = function(i, f) {
      return this._run(i, f).then(function(d) {
        return d.transform;
      });
    }, r.transformSync = function(i, f) {
      return this._runSync(i, f).transform;
    }, r.process = function(i, f) {
      return this._run(i, f).then(function(d) {
        return d.string || d.root.toString();
      });
    }, r.processSync = function(i, f) {
      var d = this._runSync(i, f);
      return d.string || d.root.toString();
    }, u;
  }();
  e.default = c, t.exports = e.default;
})(b1, b1.exports);
var L6 = b1.exports, lT = {}, Sr = {};
Sr.__esModule = !0;
Sr.universal = Sr.tag = Sr.string = Sr.selector = Sr.root = Sr.pseudo = Sr.nesting = Sr.id = Sr.comment = Sr.combinator = Sr.className = Sr.attribute = void 0;
var j6 = Ei(cy), F6 = Ei(X2), B6 = Ei(iT), $6 = Ei(J2), U6 = Ei(Q2), V6 = Ei(sT), W6 = Ei(tT), H6 = Ei(K2), q6 = Ei(Y2), G6 = Ei(eT), z6 = Ei(Z2), K6 = Ei(nT);
function Ei(t) {
  return t && t.__esModule ? t : { default: t };
}
var Y6 = function(e) {
  return new j6.default(e);
};
Sr.attribute = Y6;
var X6 = function(e) {
  return new F6.default(e);
};
Sr.className = X6;
var J6 = function(e) {
  return new B6.default(e);
};
Sr.combinator = J6;
var Q6 = function(e) {
  return new $6.default(e);
};
Sr.comment = Q6;
var Z6 = function(e) {
  return new U6.default(e);
};
Sr.id = Z6;
var eR = function(e) {
  return new V6.default(e);
};
Sr.nesting = eR;
var tR = function(e) {
  return new W6.default(e);
};
Sr.pseudo = tR;
var rR = function(e) {
  return new H6.default(e);
};
Sr.root = rR;
var nR = function(e) {
  return new q6.default(e);
};
Sr.selector = nR;
var iR = function(e) {
  return new G6.default(e);
};
Sr.string = iR;
var sR = function(e) {
  return new z6.default(e);
};
Sr.tag = sR;
var aR = function(e) {
  return new K6.default(e);
};
Sr.universal = aR;
var fr = {};
fr.__esModule = !0;
fr.isComment = fr.isCombinator = fr.isClassName = fr.isAttribute = void 0;
fr.isContainer = gR;
fr.isIdentifier = void 0;
fr.isNamespace = vR;
fr.isNesting = void 0;
fr.isNode = fy;
fr.isPseudo = void 0;
fr.isPseudoClass = bR;
fr.isPseudoElement = fT;
fr.isUniversal = fr.isTag = fr.isString = fr.isSelector = fr.isRoot = void 0;
var Ir = Xt, Bn, oR = (Bn = {}, Bn[Ir.ATTRIBUTE] = !0, Bn[Ir.CLASS] = !0, Bn[Ir.COMBINATOR] = !0, Bn[Ir.COMMENT] = !0, Bn[Ir.ID] = !0, Bn[Ir.NESTING] = !0, Bn[Ir.PSEUDO] = !0, Bn[Ir.ROOT] = !0, Bn[Ir.SELECTOR] = !0, Bn[Ir.STRING] = !0, Bn[Ir.TAG] = !0, Bn[Ir.UNIVERSAL] = !0, Bn);
function fy(t) {
  return typeof t == "object" && oR[t.type];
}
function _i(t, e) {
  return fy(e) && e.type === t;
}
var uT = _i.bind(null, Ir.ATTRIBUTE);
fr.isAttribute = uT;
var lR = _i.bind(null, Ir.CLASS);
fr.isClassName = lR;
var uR = _i.bind(null, Ir.COMBINATOR);
fr.isCombinator = uR;
var cR = _i.bind(null, Ir.COMMENT);
fr.isComment = cR;
var fR = _i.bind(null, Ir.ID);
fr.isIdentifier = fR;
var dR = _i.bind(null, Ir.NESTING);
fr.isNesting = dR;
var dy = _i.bind(null, Ir.PSEUDO);
fr.isPseudo = dy;
var pR = _i.bind(null, Ir.ROOT);
fr.isRoot = pR;
var hR = _i.bind(null, Ir.SELECTOR);
fr.isSelector = hR;
var mR = _i.bind(null, Ir.STRING);
fr.isString = mR;
var cT = _i.bind(null, Ir.TAG);
fr.isTag = cT;
var yR = _i.bind(null, Ir.UNIVERSAL);
fr.isUniversal = yR;
function fT(t) {
  return dy(t) && t.value && (t.value.startsWith("::") || t.value.toLowerCase() === ":before" || t.value.toLowerCase() === ":after" || t.value.toLowerCase() === ":first-letter" || t.value.toLowerCase() === ":first-line");
}
function bR(t) {
  return dy(t) && !fT(t);
}
function gR(t) {
  return !!(fy(t) && t.walk);
}
function vR(t) {
  return uT(t) || cT(t);
}
(function(t) {
  t.__esModule = !0;
  var e = Xt;
  Object.keys(e).forEach(function(c) {
    c === "default" || c === "__esModule" || c in t && t[c] === e[c] || (t[c] = e[c]);
  });
  var n = Sr;
  Object.keys(n).forEach(function(c) {
    c === "default" || c === "__esModule" || c in t && t[c] === n[c] || (t[c] = n[c]);
  });
  var a = fr;
  Object.keys(a).forEach(function(c) {
    c === "default" || c === "__esModule" || c in t && t[c] === a[c] || (t[c] = a[c]);
  });
})(lT);
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var n = r(L6), a = u(lT);
  function c(f) {
    if (typeof WeakMap != "function")
      return null;
    var d = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakMap();
    return (c = function(m) {
      return m ? s : d;
    })(f);
  }
  function u(f, d) {
    if (!d && f && f.__esModule)
      return f;
    if (f === null || typeof f != "object" && typeof f != "function")
      return { default: f };
    var s = c(d);
    if (s && s.has(f))
      return s.get(f);
    var o = {}, m = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var h in f)
      if (h !== "default" && Object.prototype.hasOwnProperty.call(f, h)) {
        var y = m ? Object.getOwnPropertyDescriptor(f, h) : null;
        y && (y.get || y.set) ? Object.defineProperty(o, h, y) : o[h] = f[h];
      }
    return o.default = f, s && s.set(f, o), o;
  }
  function r(f) {
    return f && f.__esModule ? f : { default: f };
  }
  var l = function(d) {
    return new n.default(d);
  };
  Object.assign(l, a), delete l.__esModule;
  var i = l;
  e.default = i, t.exports = e.default;
})(y1, y1.exports);
var Ws = y1.exports, Nu = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return c;
    }
  });
  const e = /* @__PURE__ */ a(vi), n = /* @__PURE__ */ a(tl);
  function a(u) {
    return u && u.__esModule ? u : {
      default: u
    };
  }
  function c(u) {
    return [
      "fontSize",
      "outline"
    ].includes(u) ? (r) => (typeof r == "function" && (r = r({})), Array.isArray(r) && (r = r[0]), r) : u === "fontFamily" ? (r) => {
      typeof r == "function" && (r = r({}));
      let l = Array.isArray(r) && (0, n.default)(r[1]) ? r[0] : r;
      return Array.isArray(l) ? l.join(", ") : l;
    } : [
      "boxShadow",
      "transitionProperty",
      "transitionDuration",
      "transitionDelay",
      "transitionTimingFunction",
      "backgroundImage",
      "backgroundSize",
      "backgroundColor",
      "cursor",
      "animation"
    ].includes(u) ? (r) => (typeof r == "function" && (r = r({})), Array.isArray(r) && (r = r.join(", ")), r) : [
      "gridTemplateColumns",
      "gridTemplateRows",
      "objectPosition"
    ].includes(u) ? (r) => (typeof r == "function" && (r = r({})), typeof r == "string" && (r = e.default.list.comma(r).join(" ")), r) : (r, l = {}) => (typeof r == "function" && (r = r(l)), r);
  }
})(Nu);
var py = {}, hy = { exports: {} };
const { Rule: dT, AtRule: ER } = vi;
let pT = Ws;
function F1(t, e) {
  let n;
  try {
    pT((a) => {
      n = a;
    }).processSync(t);
  } catch (a) {
    throw t.includes(":") ? e ? e.error("Missed semicolon") : a : e ? e.error(a.message) : a;
  }
  return n.at(0);
}
function hT(t, e) {
  let n = !1;
  return t.each((a) => {
    if (a.type === "nesting") {
      let c = e.clone({});
      a.value !== "&" ? a.replaceWith(
        F1(a.value.replace("&", c.toString()))
      ) : a.replaceWith(c), n = !0;
    } else
      "nodes" in a && a.nodes && hT(a, e) && (n = !0);
  }), n;
}
function mT(t, e) {
  let n = [];
  return t.selectors.forEach((a) => {
    let c = F1(a, t);
    e.selectors.forEach((u) => {
      if (!u)
        return;
      let r = F1(u, e);
      hT(r, c) || (r.prepend(pT.combinator({ value: " " })), r.prepend(c.clone({}))), n.push(r.toString());
    });
  }), n;
}
function Rc(t, e) {
  let n = t.prev();
  for (e.after(t); n && n.type === "comment"; ) {
    let a = n.prev();
    e.after(n), n = a;
  }
  return t;
}
function _R(t) {
  return function e(n, a, c, u = c) {
    let r = [];
    if (a.each((l) => {
      l.type === "rule" && c ? u && (l.selectors = mT(n, l)) : l.type === "atrule" && l.nodes ? t[l.name] ? e(n, l, u) : a[my] !== !1 && r.push(l) : r.push(l);
    }), c && r.length) {
      let l = n.clone({ nodes: [] });
      for (let i of r)
        l.append(i);
      a.prepend(l);
    }
  };
}
function Oh(t, e, n) {
  let a = new dT({
    selector: t,
    nodes: []
  });
  return a.append(e), n.after(a), a;
}
function tE(t, e) {
  let n = {};
  for (let a of t)
    n[a] = !0;
  if (e)
    for (let a of e)
      n[a.replace(/^@/, "")] = !0;
  return n;
}
function SR(t) {
  t = t.trim();
  let e = t.match(/^\((.*)\)$/);
  if (!e)
    return { type: "basic", selector: t };
  let n = e[1].match(/^(with(?:out)?):(.+)$/);
  if (n) {
    let a = n[1] === "with", c = Object.fromEntries(
      n[2].trim().split(/\s+/).map((r) => [r, !0])
    );
    if (a && c.all)
      return { type: "noop" };
    let u = (r) => !!c[r];
    return c.all ? u = () => !0 : a && (u = (r) => r === "all" ? !1 : !c[r]), {
      type: "withrules",
      escapes: u
    };
  }
  return { type: "unknown" };
}
function wR(t) {
  let e = [], n = t.parent;
  for (; n && n instanceof ER; )
    e.push(n), n = n.parent;
  return e;
}
function TR(t) {
  let e = t[yT];
  if (!e)
    t.after(t.nodes);
  else {
    let n = t.nodes, a, c = -1, u, r, l, i = wR(t);
    if (i.forEach((f, d) => {
      if (e(f.name))
        a = f, c = d, r = l;
      else {
        let s = l;
        l = f.clone({ nodes: [] }), s && l.append(s), u = u || l;
      }
    }), a ? r ? (u.append(n), a.after(r)) : a.after(n) : t.after(n), t.next() && a) {
      let f;
      i.slice(0, c + 1).forEach((d, s, o) => {
        let m = f;
        f = d.clone({ nodes: [] }), m && f.append(m);
        let h = [], b = (o[s - 1] || t).next();
        for (; b; )
          h.push(b), b = b.next();
        f.append(h);
      }), f && (r || n[n.length - 1]).after(f);
    }
  }
  t.remove();
}
const my = Symbol("rootRuleMergeSel"), yT = Symbol("rootRuleEscapes");
function AR(t) {
  let { params: e } = t, { type: n, selector: a, escapes: c } = SR(e);
  if (n === "unknown")
    throw t.error(
      `Unknown @${t.name} parameter ${JSON.stringify(e)}`
    );
  if (n === "basic" && a) {
    let u = new dT({ selector: a, nodes: t.nodes });
    t.removeAll(), t.append(u);
  }
  t[yT] = c, t[my] = c ? !c("all") : n === "noop";
}
const kh = Symbol("hasRootRule");
hy.exports = (t = {}) => {
  let e = tE(
    ["media", "supports", "layer", "container"],
    t.bubble
  ), n = _R(e), a = tE(
    [
      "document",
      "font-face",
      "keyframes",
      "-webkit-keyframes",
      "-moz-keyframes"
    ],
    t.unwrap
  ), c = (t.rootRuleName || "at-root").replace(/^@/, ""), u = t.preserveEmpty;
  return {
    postcssPlugin: "postcss-nested",
    Once(r) {
      r.walkAtRules(c, (l) => {
        AR(l), r[kh] = !0;
      });
    },
    Rule(r) {
      let l = !1, i = r, f = !1, d = [];
      r.each((s) => {
        s.type === "rule" ? (d.length && (i = Oh(r.selector, d, i), d = []), f = !0, l = !0, s.selectors = mT(r, s), i = Rc(s, i)) : s.type === "atrule" ? (d.length && (i = Oh(r.selector, d, i), d = []), s.name === c ? (l = !0, n(r, s, !0, s[my]), i = Rc(s, i)) : e[s.name] ? (f = !0, l = !0, n(r, s, !0), i = Rc(s, i)) : a[s.name] ? (f = !0, l = !0, n(r, s, !1), i = Rc(s, i)) : f && d.push(s)) : s.type === "decl" && f && d.push(s);
      }), d.length && (i = Oh(r.selector, d, i)), l && u !== !0 && (r.raws.semicolon = !0, r.nodes.length === 0 && r.remove());
    },
    RootExit(r) {
      r[kh] && (r.walkAtRules(c, TR), r[kh] = !1);
    }
  };
};
hy.exports.postcss = !0;
var xR = hy.exports, rE = /-(\w|$)/g, nE = function(e, n) {
  return n.toUpperCase();
}, PR = function(e) {
  return e = e.toLowerCase(), e === "float" ? "cssFloat" : e.charCodeAt(0) === 45 && e.charCodeAt(1) === 109 && e.charCodeAt(2) === 115 && e.charCodeAt(3) === 45 ? e.substr(1).replace(rE, nE) : e.replace(rE, nE);
}, CR = PR;
let IR = CR, OR = {
  boxFlex: !0,
  boxFlexGroup: !0,
  columnCount: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  strokeDashoffset: !0,
  strokeOpacity: !0,
  strokeWidth: !0
};
function Dh(t) {
  return typeof t.nodes > "u" ? !0 : yy(t);
}
function yy(t) {
  let e, n = {};
  return t.each((a) => {
    if (a.type === "atrule")
      e = "@" + a.name, a.params && (e += " " + a.params), typeof n[e] > "u" ? n[e] = Dh(a) : Array.isArray(n[e]) ? n[e].push(Dh(a)) : n[e] = [n[e], Dh(a)];
    else if (a.type === "rule") {
      let c = yy(a);
      if (n[a.selector])
        for (let u in c)
          n[a.selector][u] = c[u];
      else
        n[a.selector] = c;
    } else if (a.type === "decl") {
      a.prop[0] === "-" && a.prop[1] === "-" || a.parent && a.parent.selector === ":export" ? e = a.prop : e = IR(a.prop);
      let c = a.value;
      !isNaN(a.value) && OR[e] && (c = parseFloat(a.value)), a.important && (c += " !important"), typeof n[e] > "u" ? n[e] = c : Array.isArray(n[e]) ? n[e].push(c) : n[e] = [n[e], c];
    }
  }), n;
}
var bT = yy;
let lu = vi, iE = /\s*!important\s*$/i, kR = {
  "box-flex": !0,
  "box-flex-group": !0,
  "column-count": !0,
  flex: !0,
  "flex-grow": !0,
  "flex-positive": !0,
  "flex-shrink": !0,
  "flex-negative": !0,
  "font-weight": !0,
  "line-clamp": !0,
  "line-height": !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  "tab-size": !0,
  widows: !0,
  "z-index": !0,
  zoom: !0,
  "fill-opacity": !0,
  "stroke-dashoffset": !0,
  "stroke-opacity": !0,
  "stroke-width": !0
};
function DR(t) {
  return t.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
}
function sE(t, e, n) {
  n === !1 || n === null || (e.startsWith("--") || (e = DR(e)), typeof n == "number" && (n === 0 || kR[e] ? n = n.toString() : n += "px"), e === "css-float" && (e = "float"), iE.test(n) ? (n = n.replace(iE, ""), t.push(lu.decl({ prop: e, value: n, important: !0 }))) : t.push(lu.decl({ prop: e, value: n })));
}
function aE(t, e, n) {
  let a = lu.atRule({ name: e[1], params: e[3] || "" });
  typeof n == "object" && (a.nodes = [], by(n, a)), t.push(a);
}
function by(t, e) {
  let n, a, c;
  for (n in t)
    if (a = t[n], !(a === null || typeof a > "u"))
      if (n[0] === "@") {
        let u = n.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
        if (Array.isArray(a))
          for (let r of a)
            aE(e, u, r);
        else
          aE(e, u, a);
      } else if (Array.isArray(a))
        for (let u of a)
          sE(e, n, u);
      else
        typeof a == "object" ? (c = lu.rule({ selector: n }), by(a, c), e.push(c)) : sE(e, n, a);
}
var gy = function(t) {
  let e = lu.root();
  return by(t, e), e;
};
let NR = bT;
var gT = function(e) {
  return console && console.warn && e.warnings().forEach((n) => {
    let a = n.plugin || "PostCSS";
    console.warn(a + ": " + n.text);
  }), NR(e.root);
};
let RR = vi, MR = gT, LR = gy;
var jR = function(e) {
  let n = RR(e);
  return async (a) => {
    let c = await n.process(a, {
      parser: LR,
      from: void 0
    });
    return MR(c);
  };
};
let FR = vi, BR = gT, $R = gy;
var UR = function(t) {
  let e = FR(t);
  return (n) => {
    let a = e.process(n, { parser: $R, from: void 0 });
    return BR(a);
  };
};
let VR = bT, WR = gy, HR = jR, qR = UR;
var GR = {
  objectify: VR,
  parse: WR,
  async: HR,
  sync: qR
};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return u;
    }
  });
  const e = /* @__PURE__ */ c(vi), n = /* @__PURE__ */ c(xR), a = /* @__PURE__ */ c(GR);
  function c(r) {
    return r && r.__esModule ? r : {
      default: r
    };
  }
  function u(r) {
    return Array.isArray(r) ? r.flatMap((l) => (0, e.default)([
      (0, n.default)({
        bubble: [
          "screen"
        ]
      })
    ]).process(l, {
      parser: a.default
    }).root.nodes) : u([
      r
    ]);
  }
})(py);
var Od = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(
    t,
    /**
    * @template {string | import('postcss-selector-parser').Root} T
    *
    * Prefix all classes in the selector with the given prefix
    *
    * It can take either a string or a selector AST and will return the same type
    *
    * @param {string} prefix
    * @param {T} selector
    * @param {boolean} prependNegative
    * @returns {T}
    */
    "default",
    {
      enumerable: !0,
      get: function() {
        return a;
      }
    }
  );
  const e = /* @__PURE__ */ n(Ws);
  function n(c) {
    return c && c.__esModule ? c : {
      default: c
    };
  }
  function a(c, u, r = !1) {
    if (c === "")
      return u;
    let l = typeof u == "string" ? (0, e.default)().astSync(u) : u;
    return l.walkClasses((i) => {
      let f = i.value, d = r && f.startsWith("-");
      i.value = d ? `-${c}${f.slice(1)}` : `${c}${f}`;
    }), typeof u == "string" ? l.toString() : l;
  }
})(Od);
var rl = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return c;
    }
  });
  const e = /* @__PURE__ */ a(Ws), n = /* @__PURE__ */ a(wd);
  function a(u) {
    return u && u.__esModule ? u : {
      default: u
    };
  }
  function c(u) {
    var r;
    let l = e.default.className();
    l.value = u;
    var i;
    return (0, n.default)((i = l == null || (r = l.raws) === null || r === void 0 ? void 0 : r.value) !== null && i !== void 0 ? i : l.value);
  }
})(rl);
var vy = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(i, f) {
    for (var d in f)
      Object.defineProperty(i, d, {
        enumerable: !0,
        get: f[d]
      });
  }
  e(t, {
    asClass: function() {
      return u;
    },
    default: function() {
      return r;
    },
    formatClass: function() {
      return l;
    }
  });
  const n = /* @__PURE__ */ c(rl), a = /* @__PURE__ */ c(wd);
  function c(i) {
    return i && i.__esModule ? i : {
      default: i
    };
  }
  function u(i) {
    return (0, a.default)(`.${(0, n.default)(i)}`);
  }
  function r(i, f) {
    return u(l(i, f));
  }
  function l(i, f) {
    return f === "DEFAULT" ? i : f === "-" || f === "-DEFAULT" ? `-${i}` : f.startsWith("-") ? `-${i}${f}` : f.startsWith("/") ? `${i}${f}` : `${i}-${f}`;
  }
})(vy);
var vT = {}, ET = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return a;
    }
  });
  const e = /* @__PURE__ */ n(Nu);
  function n(c) {
    return c && c.__esModule ? c : {
      default: c
    };
  }
  function a(c, u = [
    [
      c,
      [
        c
      ]
    ]
  ], { filterDefault: r = !1, ...l } = {}) {
    let i = (0, e.default)(c);
    return function({ matchUtilities: f, theme: d }) {
      for (let o of u) {
        let m = Array.isArray(o[0]) ? o : [
          o
        ];
        var s;
        f(m.reduce((h, [y, b]) => Object.assign(h, {
          [y]: (E) => b.reduce((S, g) => Array.isArray(g) ? Object.assign(S, {
            [g[0]]: g[1]
          }) : Object.assign(S, {
            [g]: i(E)
          }), {})
        }), {}), {
          ...l,
          values: r ? Object.fromEntries(Object.entries((s = d(c)) !== null && s !== void 0 ? s : {}).filter(([h]) => h !== "DEFAULT")) : d(c)
        });
      }
    };
  }
})(ET);
var kd = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(n) {
    return n = Array.isArray(n) ? n : [
      n
    ], n.map((a) => {
      let c = a.values.map((u) => u.raw !== void 0 ? u.raw : [
        u.min && `(min-width: ${u.min})`,
        u.max && `(max-width: ${u.max})`
      ].filter(Boolean).join(" and "));
      return a.not ? `not all and ${c}` : c;
    }).join(", ");
  }
})(kd);
var _T = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return s;
    }
  });
  const e = /* @__PURE__ */ new Set([
    "normal",
    "reverse",
    "alternate",
    "alternate-reverse"
  ]), n = /* @__PURE__ */ new Set([
    "running",
    "paused"
  ]), a = /* @__PURE__ */ new Set([
    "none",
    "forwards",
    "backwards",
    "both"
  ]), c = /* @__PURE__ */ new Set([
    "infinite"
  ]), u = /* @__PURE__ */ new Set([
    "linear",
    "ease",
    "ease-in",
    "ease-out",
    "ease-in-out",
    "step-start",
    "step-end"
  ]), r = [
    "cubic-bezier",
    "steps"
  ], l = /\,(?![^(]*\))/g, i = /\ +(?![^(]*\))/g, f = /^(-?[\d.]+m?s)$/, d = /^(\d+)$/;
  function s(o) {
    return o.split(l).map((h) => {
      let y = h.trim(), b = {
        value: y
      }, E = y.split(i), S = /* @__PURE__ */ new Set();
      for (let g of E)
        !S.has("DIRECTIONS") && e.has(g) ? (b.direction = g, S.add("DIRECTIONS")) : !S.has("PLAY_STATES") && n.has(g) ? (b.playState = g, S.add("PLAY_STATES")) : !S.has("FILL_MODES") && a.has(g) ? (b.fillMode = g, S.add("FILL_MODES")) : !S.has("ITERATION_COUNTS") && (c.has(g) || d.test(g)) ? (b.iterationCount = g, S.add("ITERATION_COUNTS")) : !S.has("TIMING_FUNCTION") && u.has(g) || !S.has("TIMING_FUNCTION") && r.some((P) => g.startsWith(`${P}(`)) ? (b.timingFunction = g, S.add("TIMING_FUNCTION")) : !S.has("DURATION") && f.test(g) ? (b.duration = g, S.add("DURATION")) : !S.has("DELAY") && f.test(g) ? (b.delay = g, S.add("DELAY")) : S.has("NAME") ? (b.unknown || (b.unknown = []), b.unknown.push(g)) : (b.name = g, S.add("NAME"));
      return b;
    });
  }
})(_T);
var ST = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return n;
    }
  });
  const e = (a) => Object.assign({}, ...Object.entries(a ?? {}).flatMap(([c, u]) => typeof u == "object" ? Object.entries(e(u)).map(([r, l]) => ({
    [c + (r === "DEFAULT" ? "" : `-${r}`)]: l
  })) : [
    {
      [`${c}`]: u
    }
  ])), n = e;
})(ST);
const zR = "tailwindcss", KR = "3.3.2", YR = "A utility-first CSS framework for rapidly building custom user interfaces.", XR = "MIT", JR = "lib/index.js", QR = "types/index.d.ts", ZR = "https://github.com/tailwindlabs/tailwindcss.git", e7 = "https://github.com/tailwindlabs/tailwindcss/issues", t7 = "https://tailwindcss.com", r7 = {
  tailwind: "lib/cli.js",
  tailwindcss: "lib/cli.js"
}, n7 = {
  engine: "stable"
}, i7 = {
  prebuild: "npm run generate && rimraf lib",
  build: `swc src --out-dir lib --copy-files --config jsc.transform.optimizer.globals.vars.__OXIDE__='"false"'`,
  postbuild: "esbuild lib/cli-peer-dependencies.js --bundle --platform=node --outfile=peers/index.js --define:process.env.CSS_TRANSFORMER_WASM=false",
  "rebuild-fixtures": "npm run build && node -r @swc/register scripts/rebuildFixtures.js",
  style: "eslint .",
  pretest: "npm run generate",
  test: "jest",
  "test:integrations": "npm run test --prefix ./integrations",
  "install:integrations": "node scripts/install-integrations.js",
  "generate:plugin-list": "node -r @swc/register scripts/create-plugin-list.js",
  "generate:types": "node -r @swc/register scripts/generate-types.js",
  generate: "npm run generate:plugin-list && npm run generate:types",
  "release-channel": "node ./scripts/release-channel.js",
  "release-notes": "node ./scripts/release-notes.js",
  prepublishOnly: "npm install --force && npm run build"
}, s7 = [
  "src/*",
  "cli/*",
  "lib/*",
  "peers/*",
  "scripts/*.js",
  "stubs/*",
  "nesting/*",
  "types/**/*",
  "*.d.ts",
  "*.css",
  "*.js"
], a7 = {
  "@swc/cli": "^0.1.62",
  "@swc/core": "^1.3.55",
  "@swc/jest": "^0.2.26",
  "@swc/register": "^0.1.10",
  autoprefixer: "^10.4.14",
  browserslist: "^4.21.5",
  concurrently: "^8.0.1",
  cssnano: "^6.0.0",
  esbuild: "^0.17.18",
  eslint: "^8.39.0",
  "eslint-config-prettier": "^8.8.0",
  "eslint-plugin-prettier": "^4.2.1",
  jest: "^29.5.0",
  "jest-diff": "^29.5.0",
  lightningcss: "1.18.0",
  prettier: "^2.8.8",
  rimraf: "^5.0.0",
  "source-map-js": "^1.0.2",
  turbo: "^1.9.3"
}, o7 = {
  "@alloc/quick-lru": "^5.2.0",
  arg: "^5.0.2",
  chokidar: "^3.5.3",
  didyoumean: "^1.2.2",
  dlv: "^1.1.3",
  "fast-glob": "^3.2.12",
  "glob-parent": "^6.0.2",
  "is-glob": "^4.0.3",
  jiti: "^1.18.2",
  lilconfig: "^2.1.0",
  micromatch: "^4.0.5",
  "normalize-path": "^3.0.0",
  "object-hash": "^3.0.0",
  picocolors: "^1.0.0",
  postcss: "^8.4.23",
  "postcss-import": "^15.1.0",
  "postcss-js": "^4.0.1",
  "postcss-load-config": "^4.0.1",
  "postcss-nested": "^6.0.1",
  "postcss-selector-parser": "^6.0.11",
  "postcss-value-parser": "^4.2.0",
  resolve: "^1.22.2",
  sucrase: "^3.32.0"
}, l7 = [
  "> 1%",
  "not edge <= 18",
  "not ie 11",
  "not op_mini all"
], u7 = {
  testTimeout: 3e4,
  setupFilesAfterEnv: [
    "<rootDir>/jest/customMatchers.js"
  ],
  testPathIgnorePatterns: [
    "/node_modules/",
    "/integrations/",
    "/standalone-cli/",
    "\\.test\\.skip\\.js$"
  ],
  transformIgnorePatterns: [
    "node_modules/(?!lightningcss)"
  ],
  transform: {
    "\\.js$": "@swc/jest",
    "\\.ts$": "@swc/jest"
  }
}, c7 = {
  node: ">=14.0.0"
}, wT = {
  name: zR,
  version: KR,
  description: YR,
  license: XR,
  main: JR,
  types: QR,
  repository: ZR,
  bugs: e7,
  homepage: t7,
  bin: r7,
  tailwindcss: n7,
  scripts: i7,
  files: s7,
  devDependencies: a7,
  dependencies: o7,
  browserslist: l7,
  jest: u7,
  engines: c7
};
var Dd = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(l, i) {
    for (var f in i)
      Object.defineProperty(l, f, {
        enumerable: !0,
        get: i[f]
      });
  }
  e(t, {
    normalizeScreens: function() {
      return n;
    },
    isScreenSortable: function() {
      return a;
    },
    compareScreens: function() {
      return c;
    },
    toScreen: function() {
      return u;
    }
  });
  function n(l, i = !0) {
    return Array.isArray(l) ? l.map((f) => {
      if (i && Array.isArray(f))
        throw new Error("The tuple syntax is not supported for `screens`.");
      if (typeof f == "string")
        return {
          name: f.toString(),
          not: !1,
          values: [
            {
              min: f,
              max: void 0
            }
          ]
        };
      let [d, s] = f;
      return d = d.toString(), typeof s == "string" ? {
        name: d,
        not: !1,
        values: [
          {
            min: s,
            max: void 0
          }
        ]
      } : Array.isArray(s) ? {
        name: d,
        not: !1,
        values: s.map((o) => r(o))
      } : {
        name: d,
        not: !1,
        values: [
          r(s)
        ]
      };
    }) : n(Object.entries(l ?? {}), !1);
  }
  function a(l) {
    return l.values.length !== 1 ? {
      result: !1,
      reason: "multiple-values"
    } : l.values[0].raw !== void 0 ? {
      result: !1,
      reason: "raw-values"
    } : l.values[0].min !== void 0 && l.values[0].max !== void 0 ? {
      result: !1,
      reason: "min-and-max"
    } : {
      result: !0,
      reason: null
    };
  }
  function c(l, i, f) {
    let d = u(i, l), s = u(f, l), o = a(d), m = a(s);
    if (o.reason === "multiple-values" || m.reason === "multiple-values")
      throw new Error("Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.");
    if (o.reason === "raw-values" || m.reason === "raw-values")
      throw new Error("Attempted to sort a screen with raw values. This should never happen. Please open a bug report.");
    if (o.reason === "min-and-max" || m.reason === "min-and-max")
      throw new Error("Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.");
    let { min: h, max: y } = d.values[0], { min: b, max: E } = s.values[0];
    i.not && ([h, y] = [
      y,
      h
    ]), f.not && ([b, E] = [
      E,
      b
    ]), h = h === void 0 ? h : parseFloat(h), y = y === void 0 ? y : parseFloat(y), b = b === void 0 ? b : parseFloat(b), E = E === void 0 ? E : parseFloat(E);
    let [S, g] = l === "min" ? [
      h,
      b
    ] : [
      E,
      y
    ];
    return S - g;
  }
  function u(l, i) {
    return typeof l == "object" ? l : {
      name: "arbitrary-screen",
      values: [
        {
          [i]: l
        }
      ]
    };
  }
  function r({ "min-width": l, min: i = l, max: f, raw: d } = {}) {
    return {
      min: i,
      max: f,
      raw: d
    };
  }
})(Dd);
var TT = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "removeAlphaVariables", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(n, a) {
    n.walkDecls((c) => {
      if (a.includes(c.prop)) {
        c.remove();
        return;
      }
      for (let u of a)
        c.value.includes(`/ var(${u})`) && (c.value = c.value.replace(`/ var(${u})`, ""));
    });
  }
})(TT);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(T, v) {
    for (var w in v)
      Object.defineProperty(T, w, {
        enumerable: !0,
        get: v[w]
      });
  }
  e(t, {
    variantPlugins: function() {
      return I;
    },
    corePlugins: function() {
      return _;
    }
  });
  const n = /* @__PURE__ */ R(Dn), a = /* @__PURE__ */ C(Lr), c = /* @__PURE__ */ R(vi), u = /* @__PURE__ */ R(ET), r = /* @__PURE__ */ R(kd), l = /* @__PURE__ */ R(rl), i = /* @__PURE__ */ R(_T), f = /* @__PURE__ */ R(ST), d = /* @__PURE__ */ C(Cu), s = /* @__PURE__ */ R(Y0), o = /* @__PURE__ */ R(tl), m = /* @__PURE__ */ R(Nu), h = wT, y = /* @__PURE__ */ R(Bi), b = Dd, E = K0, S = TT, g = _s, P = Iu;
  function R(T) {
    return T && T.__esModule ? T : {
      default: T
    };
  }
  function N(T) {
    if (typeof WeakMap != "function")
      return null;
    var v = /* @__PURE__ */ new WeakMap(), w = /* @__PURE__ */ new WeakMap();
    return (N = function(O) {
      return O ? w : v;
    })(T);
  }
  function C(T, v) {
    if (!v && T && T.__esModule)
      return T;
    if (T === null || typeof T != "object" && typeof T != "function")
      return {
        default: T
      };
    var w = N(v);
    if (w && w.has(T))
      return w.get(T);
    var O = {}, G = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var W in T)
      if (W !== "default" && Object.prototype.hasOwnProperty.call(T, W)) {
        var U = G ? Object.getOwnPropertyDescriptor(T, W) : null;
        U && (U.get || U.set) ? Object.defineProperty(O, W, U) : O[W] = T[W];
      }
    return O.default = T, w && w.set(T, O), O;
  }
  let I = {
    pseudoElementVariants: ({ addVariant: T }) => {
      T("first-letter", "&::first-letter"), T("first-line", "&::first-line"), T("marker", [
        ({ container: v }) => ((0, S.removeAlphaVariables)(v, [
          "--tw-text-opacity"
        ]), "& *::marker"),
        ({ container: v }) => ((0, S.removeAlphaVariables)(v, [
          "--tw-text-opacity"
        ]), "&::marker")
      ]), T("selection", [
        "& *::selection",
        "&::selection"
      ]), T("file", "&::file-selector-button"), T("placeholder", "&::placeholder"), T("backdrop", "&::backdrop"), T("before", ({ container: v }) => (v.walkRules((w) => {
        let O = !1;
        w.walkDecls("content", () => {
          O = !0;
        }), O || w.prepend(c.default.decl({
          prop: "content",
          value: "var(--tw-content)"
        }));
      }), "&::before")), T("after", ({ container: v }) => (v.walkRules((w) => {
        let O = !1;
        w.walkDecls("content", () => {
          O = !0;
        }), O || w.prepend(c.default.decl({
          prop: "content",
          value: "var(--tw-content)"
        }));
      }), "&::after"));
    },
    pseudoClassVariants: ({ addVariant: T, matchVariant: v, config: w }) => {
      let O = [
        // Positional
        [
          "first",
          "&:first-child"
        ],
        [
          "last",
          "&:last-child"
        ],
        [
          "only",
          "&:only-child"
        ],
        [
          "odd",
          "&:nth-child(odd)"
        ],
        [
          "even",
          "&:nth-child(even)"
        ],
        "first-of-type",
        "last-of-type",
        "only-of-type",
        // State
        [
          "visited",
          ({ container: W }) => ((0, S.removeAlphaVariables)(W, [
            "--tw-text-opacity",
            "--tw-border-opacity",
            "--tw-bg-opacity"
          ]), "&:visited")
        ],
        "target",
        [
          "open",
          "&[open]"
        ],
        // Forms
        "default",
        "checked",
        "indeterminate",
        "placeholder-shown",
        "autofill",
        "optional",
        "required",
        "valid",
        "invalid",
        "in-range",
        "out-of-range",
        "read-only",
        // Content
        "empty",
        // Interactive
        "focus-within",
        [
          "hover",
          (0, g.flagEnabled)(w(), "hoverOnlyWhenSupported") ? "@media (hover: hover) and (pointer: fine) { &:hover }" : "&:hover"
        ],
        "focus",
        "focus-visible",
        "active",
        "enabled",
        "disabled"
      ].map((W) => Array.isArray(W) ? W : [
        W,
        `&:${W}`
      ]);
      for (let [W, U] of O)
        T(W, (M) => typeof U == "function" ? U(M) : U);
      let G = {
        group: (W, { modifier: U }) => U ? [
          `:merge(.group\\/${(0, l.default)(U)})`,
          " &"
        ] : [
          ":merge(.group)",
          " &"
        ],
        peer: (W, { modifier: U }) => U ? [
          `:merge(.peer\\/${(0, l.default)(U)})`,
          " ~ &"
        ] : [
          ":merge(.peer)",
          " ~ &"
        ]
      };
      for (let [W, U] of Object.entries(G))
        v(W, (M = "", B) => {
          let k = (0, P.normalize)(typeof M == "function" ? M(B) : M);
          k.includes("&") || (k = "&" + k);
          let [K, te] = U("", B), z = null, q = null, $ = 0;
          for (let Y = 0; Y < k.length; ++Y) {
            let H = k[Y];
            H === "&" ? z = Y : H === "'" || H === '"' ? $ += 1 : z !== null && H === " " && !$ && (q = Y);
          }
          return z !== null && q === null && (q = k.length), k.slice(0, z) + K + k.slice(z + 1, q) + te + k.slice(q);
        }, {
          values: Object.fromEntries(O)
        });
    },
    directionVariants: ({ addVariant: T }) => {
      T("ltr", ':is([dir="ltr"] &)'), T("rtl", ':is([dir="rtl"] &)');
    },
    reducedMotionVariants: ({ addVariant: T }) => {
      T("motion-safe", "@media (prefers-reduced-motion: no-preference)"), T("motion-reduce", "@media (prefers-reduced-motion: reduce)");
    },
    darkVariants: ({ config: T, addVariant: v }) => {
      let [w, O = ".dark"] = [].concat(T("darkMode", "media"));
      w === !1 && (w = "media", y.default.warn("darkmode-false", [
        "The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.",
        "Change `darkMode` to `media` or remove it entirely.",
        "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"
      ])), w === "class" ? v("dark", `:is(${O} &)`) : w === "media" && v("dark", "@media (prefers-color-scheme: dark)");
    },
    printVariant: ({ addVariant: T }) => {
      T("print", "@media print");
    },
    screenVariants: ({ theme: T, addVariant: v, matchVariant: w }) => {
      var O;
      let G = (O = T("screens")) !== null && O !== void 0 ? O : {}, W = Object.values(G).every((X) => typeof X == "string"), U = (0, b.normalizeScreens)(T("screens")), M = /* @__PURE__ */ new Set([]);
      function B(X) {
        var ne, ye;
        return (ye = (ne = X.match(/(\D+)$/)) === null || ne === void 0 ? void 0 : ne[1]) !== null && ye !== void 0 ? ye : "(none)";
      }
      function k(X) {
        X !== void 0 && M.add(B(X));
      }
      function K(X) {
        return k(X), M.size === 1;
      }
      for (const X of U)
        for (const ne of X.values)
          k(ne.min), k(ne.max);
      let te = M.size <= 1;
      function z(X) {
        return Object.fromEntries(U.filter((ne) => (0, b.isScreenSortable)(ne).result).map((ne) => {
          let { min: ye, max: ve } = ne.values[0];
          if (X === "min" && ye !== void 0)
            return ne;
          if (X === "min" && ve !== void 0)
            return {
              ...ne,
              not: !ne.not
            };
          if (X === "max" && ve !== void 0)
            return ne;
          if (X === "max" && ye !== void 0)
            return {
              ...ne,
              not: !ne.not
            };
        }).map((ne) => [
          ne.name,
          ne
        ]));
      }
      function q(X) {
        return (ne, ye) => (0, b.compareScreens)(X, ne.value, ye.value);
      }
      let $ = q("max"), Y = q("min");
      function H(X) {
        return (ne) => {
          if (W)
            if (te) {
              if (typeof ne == "string" && !K(ne))
                return y.default.warn("minmax-have-mixed-units", [
                  "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
                ]), [];
            } else
              return y.default.warn("mixed-screen-units", [
                "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
              ]), [];
          else
            return y.default.warn("complex-screen-config", [
              "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."
            ]), [];
          return [
            `@media ${(0, r.default)((0, b.toScreen)(ne, X))}`
          ];
        };
      }
      w("max", H("max"), {
        sort: $,
        values: W ? z("max") : {}
      });
      let Q = "min-screens";
      for (let X of U)
        v(X.name, `@media ${(0, r.default)(X)}`, {
          id: Q,
          sort: W && te ? Y : void 0,
          value: X
        });
      w("min", H("min"), {
        id: Q,
        sort: Y
      });
    },
    supportsVariants: ({ matchVariant: T, theme: v }) => {
      var w;
      T("supports", (O = "") => {
        let G = (0, P.normalize)(O), W = /^\w*\s*\(/.test(G);
        return G = W ? G.replace(/\b(and|or|not)\b/g, " $1 ") : G, W ? `@supports ${G}` : (G.includes(":") || (G = `${G}: var(--tw)`), G.startsWith("(") && G.endsWith(")") || (G = `(${G})`), `@supports ${G}`);
      }, {
        values: (w = v("supports")) !== null && w !== void 0 ? w : {}
      });
    },
    ariaVariants: ({ matchVariant: T, theme: v }) => {
      var w;
      T("aria", (W) => `&[aria-${(0, P.normalize)(W)}]`, {
        values: (w = v("aria")) !== null && w !== void 0 ? w : {}
      });
      var O;
      T("group-aria", (W, { modifier: U }) => U ? `:merge(.group\\/${U})[aria-${(0, P.normalize)(W)}] &` : `:merge(.group)[aria-${(0, P.normalize)(W)}] &`, {
        values: (O = v("aria")) !== null && O !== void 0 ? O : {}
      });
      var G;
      T("peer-aria", (W, { modifier: U }) => U ? `:merge(.peer\\/${U})[aria-${(0, P.normalize)(W)}] ~ &` : `:merge(.peer)[aria-${(0, P.normalize)(W)}] ~ &`, {
        values: (G = v("aria")) !== null && G !== void 0 ? G : {}
      });
    },
    dataVariants: ({ matchVariant: T, theme: v }) => {
      var w;
      T("data", (W) => `&[data-${(0, P.normalize)(W)}]`, {
        values: (w = v("data")) !== null && w !== void 0 ? w : {}
      });
      var O;
      T("group-data", (W, { modifier: U }) => U ? `:merge(.group\\/${U})[data-${(0, P.normalize)(W)}] &` : `:merge(.group)[data-${(0, P.normalize)(W)}] &`, {
        values: (O = v("data")) !== null && O !== void 0 ? O : {}
      });
      var G;
      T("peer-data", (W, { modifier: U }) => U ? `:merge(.peer\\/${U})[data-${(0, P.normalize)(W)}] ~ &` : `:merge(.peer)[data-${(0, P.normalize)(W)}] ~ &`, {
        values: (G = v("data")) !== null && G !== void 0 ? G : {}
      });
    },
    orientationVariants: ({ addVariant: T }) => {
      T("portrait", "@media (orientation: portrait)"), T("landscape", "@media (orientation: landscape)");
    },
    prefersContrastVariants: ({ addVariant: T }) => {
      T("contrast-more", "@media (prefers-contrast: more)"), T("contrast-less", "@media (prefers-contrast: less)");
    }
  }, D = [
    "translate(var(--tw-translate-x), var(--tw-translate-y))",
    "rotate(var(--tw-rotate))",
    "skewX(var(--tw-skew-x))",
    "skewY(var(--tw-skew-y))",
    "scaleX(var(--tw-scale-x))",
    "scaleY(var(--tw-scale-y))"
  ].join(" "), j = [
    "var(--tw-blur)",
    "var(--tw-brightness)",
    "var(--tw-contrast)",
    "var(--tw-grayscale)",
    "var(--tw-hue-rotate)",
    "var(--tw-invert)",
    "var(--tw-saturate)",
    "var(--tw-sepia)",
    "var(--tw-drop-shadow)"
  ].join(" "), F = [
    "var(--tw-backdrop-blur)",
    "var(--tw-backdrop-brightness)",
    "var(--tw-backdrop-contrast)",
    "var(--tw-backdrop-grayscale)",
    "var(--tw-backdrop-hue-rotate)",
    "var(--tw-backdrop-invert)",
    "var(--tw-backdrop-opacity)",
    "var(--tw-backdrop-saturate)",
    "var(--tw-backdrop-sepia)"
  ].join(" "), _ = {
    preflight: ({ addBase: T }) => {
      let v = c.default.parse(n.default.readFileSync(a.join(__dirname, "./css/preflight.css"), "utf8"));
      T([
        c.default.comment({
          text: `! tailwindcss v${h.version} | MIT License | https://tailwindcss.com`
        }),
        ...v.nodes
      ]);
    },
    container: (() => {
      function T(w = []) {
        return w.flatMap((O) => O.values.map((G) => G.min)).filter((O) => O !== void 0);
      }
      function v(w, O, G) {
        if (typeof G > "u")
          return [];
        if (!(typeof G == "object" && G !== null))
          return [
            {
              screen: "DEFAULT",
              minWidth: 0,
              padding: G
            }
          ];
        let W = [];
        G.DEFAULT && W.push({
          screen: "DEFAULT",
          minWidth: 0,
          padding: G.DEFAULT
        });
        for (let U of w)
          for (let M of O)
            for (let { min: B } of M.values)
              B === U && W.push({
                minWidth: U,
                padding: G[M.name]
              });
        return W;
      }
      return function({ addComponents: w, theme: O }) {
        let G = (0, b.normalizeScreens)(O("container.screens", O("screens"))), W = T(G), U = v(W, G, O("container.padding")), M = (k) => {
          let K = U.find((te) => te.minWidth === k);
          return K ? {
            paddingRight: K.padding,
            paddingLeft: K.padding
          } : {};
        }, B = Array.from(new Set(W.slice().sort((k, K) => parseInt(k) - parseInt(K)))).map((k) => ({
          [`@media (min-width: ${k})`]: {
            ".container": {
              "max-width": k,
              ...M(k)
            }
          }
        }));
        w([
          {
            ".container": Object.assign({
              width: "100%"
            }, O("container.center", !1) ? {
              marginRight: "auto",
              marginLeft: "auto"
            } : {}, M(0))
          },
          ...B
        ]);
      };
    })(),
    accessibility: ({ addUtilities: T }) => {
      T({
        ".sr-only": {
          position: "absolute",
          width: "1px",
          height: "1px",
          padding: "0",
          margin: "-1px",
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          borderWidth: "0"
        },
        ".not-sr-only": {
          position: "static",
          width: "auto",
          height: "auto",
          padding: "0",
          margin: "0",
          overflow: "visible",
          clip: "auto",
          whiteSpace: "normal"
        }
      });
    },
    pointerEvents: ({ addUtilities: T }) => {
      T({
        ".pointer-events-none": {
          "pointer-events": "none"
        },
        ".pointer-events-auto": {
          "pointer-events": "auto"
        }
      });
    },
    visibility: ({ addUtilities: T }) => {
      T({
        ".visible": {
          visibility: "visible"
        },
        ".invisible": {
          visibility: "hidden"
        },
        ".collapse": {
          visibility: "collapse"
        }
      });
    },
    position: ({ addUtilities: T }) => {
      T({
        ".static": {
          position: "static"
        },
        ".fixed": {
          position: "fixed"
        },
        ".absolute": {
          position: "absolute"
        },
        ".relative": {
          position: "relative"
        },
        ".sticky": {
          position: "sticky"
        }
      });
    },
    inset: (0, u.default)("inset", [
      [
        "inset",
        [
          "inset"
        ]
      ],
      [
        [
          "inset-x",
          [
            "left",
            "right"
          ]
        ],
        [
          "inset-y",
          [
            "top",
            "bottom"
          ]
        ]
      ],
      [
        [
          "start",
          [
            "inset-inline-start"
          ]
        ],
        [
          "end",
          [
            "inset-inline-end"
          ]
        ],
        [
          "top",
          [
            "top"
          ]
        ],
        [
          "right",
          [
            "right"
          ]
        ],
        [
          "bottom",
          [
            "bottom"
          ]
        ],
        [
          "left",
          [
            "left"
          ]
        ]
      ]
    ], {
      supportsNegativeValues: !0
    }),
    isolation: ({ addUtilities: T }) => {
      T({
        ".isolate": {
          isolation: "isolate"
        },
        ".isolation-auto": {
          isolation: "auto"
        }
      });
    },
    zIndex: (0, u.default)("zIndex", [
      [
        "z",
        [
          "zIndex"
        ]
      ]
    ], {
      supportsNegativeValues: !0
    }),
    order: (0, u.default)("order", void 0, {
      supportsNegativeValues: !0
    }),
    gridColumn: (0, u.default)("gridColumn", [
      [
        "col",
        [
          "gridColumn"
        ]
      ]
    ]),
    gridColumnStart: (0, u.default)("gridColumnStart", [
      [
        "col-start",
        [
          "gridColumnStart"
        ]
      ]
    ]),
    gridColumnEnd: (0, u.default)("gridColumnEnd", [
      [
        "col-end",
        [
          "gridColumnEnd"
        ]
      ]
    ]),
    gridRow: (0, u.default)("gridRow", [
      [
        "row",
        [
          "gridRow"
        ]
      ]
    ]),
    gridRowStart: (0, u.default)("gridRowStart", [
      [
        "row-start",
        [
          "gridRowStart"
        ]
      ]
    ]),
    gridRowEnd: (0, u.default)("gridRowEnd", [
      [
        "row-end",
        [
          "gridRowEnd"
        ]
      ]
    ]),
    float: ({ addUtilities: T }) => {
      T({
        ".float-right": {
          float: "right"
        },
        ".float-left": {
          float: "left"
        },
        ".float-none": {
          float: "none"
        }
      });
    },
    clear: ({ addUtilities: T }) => {
      T({
        ".clear-left": {
          clear: "left"
        },
        ".clear-right": {
          clear: "right"
        },
        ".clear-both": {
          clear: "both"
        },
        ".clear-none": {
          clear: "none"
        }
      });
    },
    margin: (0, u.default)("margin", [
      [
        "m",
        [
          "margin"
        ]
      ],
      [
        [
          "mx",
          [
            "margin-left",
            "margin-right"
          ]
        ],
        [
          "my",
          [
            "margin-top",
            "margin-bottom"
          ]
        ]
      ],
      [
        [
          "ms",
          [
            "margin-inline-start"
          ]
        ],
        [
          "me",
          [
            "margin-inline-end"
          ]
        ],
        [
          "mt",
          [
            "margin-top"
          ]
        ],
        [
          "mr",
          [
            "margin-right"
          ]
        ],
        [
          "mb",
          [
            "margin-bottom"
          ]
        ],
        [
          "ml",
          [
            "margin-left"
          ]
        ]
      ]
    ], {
      supportsNegativeValues: !0
    }),
    boxSizing: ({ addUtilities: T }) => {
      T({
        ".box-border": {
          "box-sizing": "border-box"
        },
        ".box-content": {
          "box-sizing": "content-box"
        }
      });
    },
    lineClamp: ({ matchUtilities: T, addUtilities: v, theme: w }) => {
      T({
        "line-clamp": (O) => ({
          overflow: "hidden",
          display: "-webkit-box",
          "-webkit-box-orient": "vertical",
          "-webkit-line-clamp": `${O}`
        })
      }, {
        values: w("lineClamp")
      }), v({
        ".line-clamp-none": {
          overflow: "visible",
          display: "block",
          "-webkit-box-orient": "horizontal",
          "-webkit-line-clamp": "none"
        }
      });
    },
    display: ({ addUtilities: T }) => {
      T({
        ".block": {
          display: "block"
        },
        ".inline-block": {
          display: "inline-block"
        },
        ".inline": {
          display: "inline"
        },
        ".flex": {
          display: "flex"
        },
        ".inline-flex": {
          display: "inline-flex"
        },
        ".table": {
          display: "table"
        },
        ".inline-table": {
          display: "inline-table"
        },
        ".table-caption": {
          display: "table-caption"
        },
        ".table-cell": {
          display: "table-cell"
        },
        ".table-column": {
          display: "table-column"
        },
        ".table-column-group": {
          display: "table-column-group"
        },
        ".table-footer-group": {
          display: "table-footer-group"
        },
        ".table-header-group": {
          display: "table-header-group"
        },
        ".table-row-group": {
          display: "table-row-group"
        },
        ".table-row": {
          display: "table-row"
        },
        ".flow-root": {
          display: "flow-root"
        },
        ".grid": {
          display: "grid"
        },
        ".inline-grid": {
          display: "inline-grid"
        },
        ".contents": {
          display: "contents"
        },
        ".list-item": {
          display: "list-item"
        },
        ".hidden": {
          display: "none"
        }
      });
    },
    aspectRatio: (0, u.default)("aspectRatio", [
      [
        "aspect",
        [
          "aspect-ratio"
        ]
      ]
    ]),
    height: (0, u.default)("height", [
      [
        "h",
        [
          "height"
        ]
      ]
    ]),
    maxHeight: (0, u.default)("maxHeight", [
      [
        "max-h",
        [
          "maxHeight"
        ]
      ]
    ]),
    minHeight: (0, u.default)("minHeight", [
      [
        "min-h",
        [
          "minHeight"
        ]
      ]
    ]),
    width: (0, u.default)("width", [
      [
        "w",
        [
          "width"
        ]
      ]
    ]),
    minWidth: (0, u.default)("minWidth", [
      [
        "min-w",
        [
          "minWidth"
        ]
      ]
    ]),
    maxWidth: (0, u.default)("maxWidth", [
      [
        "max-w",
        [
          "maxWidth"
        ]
      ]
    ]),
    flex: (0, u.default)("flex"),
    flexShrink: (0, u.default)("flexShrink", [
      [
        "flex-shrink",
        [
          "flex-shrink"
        ]
      ],
      [
        "shrink",
        [
          "flex-shrink"
        ]
      ]
    ]),
    flexGrow: (0, u.default)("flexGrow", [
      [
        "flex-grow",
        [
          "flex-grow"
        ]
      ],
      [
        "grow",
        [
          "flex-grow"
        ]
      ]
    ]),
    flexBasis: (0, u.default)("flexBasis", [
      [
        "basis",
        [
          "flex-basis"
        ]
      ]
    ]),
    tableLayout: ({ addUtilities: T }) => {
      T({
        ".table-auto": {
          "table-layout": "auto"
        },
        ".table-fixed": {
          "table-layout": "fixed"
        }
      });
    },
    captionSide: ({ addUtilities: T }) => {
      T({
        ".caption-top": {
          "caption-side": "top"
        },
        ".caption-bottom": {
          "caption-side": "bottom"
        }
      });
    },
    borderCollapse: ({ addUtilities: T }) => {
      T({
        ".border-collapse": {
          "border-collapse": "collapse"
        },
        ".border-separate": {
          "border-collapse": "separate"
        }
      });
    },
    borderSpacing: ({ addDefaults: T, matchUtilities: v, theme: w }) => {
      T("border-spacing", {
        "--tw-border-spacing-x": 0,
        "--tw-border-spacing-y": 0
      }), v({
        "border-spacing": (O) => ({
          "--tw-border-spacing-x": O,
          "--tw-border-spacing-y": O,
          "@defaults border-spacing": {},
          "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
        }),
        "border-spacing-x": (O) => ({
          "--tw-border-spacing-x": O,
          "@defaults border-spacing": {},
          "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
        }),
        "border-spacing-y": (O) => ({
          "--tw-border-spacing-y": O,
          "@defaults border-spacing": {},
          "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
        })
      }, {
        values: w("borderSpacing")
      });
    },
    transformOrigin: (0, u.default)("transformOrigin", [
      [
        "origin",
        [
          "transformOrigin"
        ]
      ]
    ]),
    translate: (0, u.default)("translate", [
      [
        [
          "translate-x",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-translate-x",
            [
              "transform",
              D
            ]
          ]
        ],
        [
          "translate-y",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-translate-y",
            [
              "transform",
              D
            ]
          ]
        ]
      ]
    ], {
      supportsNegativeValues: !0
    }),
    rotate: (0, u.default)("rotate", [
      [
        "rotate",
        [
          [
            "@defaults transform",
            {}
          ],
          "--tw-rotate",
          [
            "transform",
            D
          ]
        ]
      ]
    ], {
      supportsNegativeValues: !0
    }),
    skew: (0, u.default)("skew", [
      [
        [
          "skew-x",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-skew-x",
            [
              "transform",
              D
            ]
          ]
        ],
        [
          "skew-y",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-skew-y",
            [
              "transform",
              D
            ]
          ]
        ]
      ]
    ], {
      supportsNegativeValues: !0
    }),
    scale: (0, u.default)("scale", [
      [
        "scale",
        [
          [
            "@defaults transform",
            {}
          ],
          "--tw-scale-x",
          "--tw-scale-y",
          [
            "transform",
            D
          ]
        ]
      ],
      [
        [
          "scale-x",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-scale-x",
            [
              "transform",
              D
            ]
          ]
        ],
        [
          "scale-y",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-scale-y",
            [
              "transform",
              D
            ]
          ]
        ]
      ]
    ], {
      supportsNegativeValues: !0
    }),
    transform: ({ addDefaults: T, addUtilities: v }) => {
      T("transform", {
        "--tw-translate-x": "0",
        "--tw-translate-y": "0",
        "--tw-rotate": "0",
        "--tw-skew-x": "0",
        "--tw-skew-y": "0",
        "--tw-scale-x": "1",
        "--tw-scale-y": "1"
      }), v({
        ".transform": {
          "@defaults transform": {},
          transform: D
        },
        ".transform-cpu": {
          transform: D
        },
        ".transform-gpu": {
          transform: D.replace("translate(var(--tw-translate-x), var(--tw-translate-y))", "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)")
        },
        ".transform-none": {
          transform: "none"
        }
      });
    },
    animation: ({ matchUtilities: T, theme: v, config: w }) => {
      let O = (U) => `${w("prefix")}${(0, l.default)(U)}`;
      var G;
      let W = Object.fromEntries(Object.entries((G = v("keyframes")) !== null && G !== void 0 ? G : {}).map(([U, M]) => [
        U,
        {
          [`@keyframes ${O(U)}`]: M
        }
      ]));
      T({
        animate: (U) => {
          let M = (0, i.default)(U);
          return [
            ...M.flatMap((B) => W[B.name]),
            {
              animation: M.map(({ name: B, value: k }) => B === void 0 || W[B] === void 0 ? k : k.replace(B, O(B))).join(", ")
            }
          ];
        }
      }, {
        values: v("animation")
      });
    },
    cursor: (0, u.default)("cursor"),
    touchAction: ({ addDefaults: T, addUtilities: v }) => {
      T("touch-action", {
        "--tw-pan-x": " ",
        "--tw-pan-y": " ",
        "--tw-pinch-zoom": " "
      });
      let w = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
      v({
        ".touch-auto": {
          "touch-action": "auto"
        },
        ".touch-none": {
          "touch-action": "none"
        },
        ".touch-pan-x": {
          "@defaults touch-action": {},
          "--tw-pan-x": "pan-x",
          "touch-action": w
        },
        ".touch-pan-left": {
          "@defaults touch-action": {},
          "--tw-pan-x": "pan-left",
          "touch-action": w
        },
        ".touch-pan-right": {
          "@defaults touch-action": {},
          "--tw-pan-x": "pan-right",
          "touch-action": w
        },
        ".touch-pan-y": {
          "@defaults touch-action": {},
          "--tw-pan-y": "pan-y",
          "touch-action": w
        },
        ".touch-pan-up": {
          "@defaults touch-action": {},
          "--tw-pan-y": "pan-up",
          "touch-action": w
        },
        ".touch-pan-down": {
          "@defaults touch-action": {},
          "--tw-pan-y": "pan-down",
          "touch-action": w
        },
        ".touch-pinch-zoom": {
          "@defaults touch-action": {},
          "--tw-pinch-zoom": "pinch-zoom",
          "touch-action": w
        },
        ".touch-manipulation": {
          "touch-action": "manipulation"
        }
      });
    },
    userSelect: ({ addUtilities: T }) => {
      T({
        ".select-none": {
          "user-select": "none"
        },
        ".select-text": {
          "user-select": "text"
        },
        ".select-all": {
          "user-select": "all"
        },
        ".select-auto": {
          "user-select": "auto"
        }
      });
    },
    resize: ({ addUtilities: T }) => {
      T({
        ".resize-none": {
          resize: "none"
        },
        ".resize-y": {
          resize: "vertical"
        },
        ".resize-x": {
          resize: "horizontal"
        },
        ".resize": {
          resize: "both"
        }
      });
    },
    scrollSnapType: ({ addDefaults: T, addUtilities: v }) => {
      T("scroll-snap-type", {
        "--tw-scroll-snap-strictness": "proximity"
      }), v({
        ".snap-none": {
          "scroll-snap-type": "none"
        },
        ".snap-x": {
          "@defaults scroll-snap-type": {},
          "scroll-snap-type": "x var(--tw-scroll-snap-strictness)"
        },
        ".snap-y": {
          "@defaults scroll-snap-type": {},
          "scroll-snap-type": "y var(--tw-scroll-snap-strictness)"
        },
        ".snap-both": {
          "@defaults scroll-snap-type": {},
          "scroll-snap-type": "both var(--tw-scroll-snap-strictness)"
        },
        ".snap-mandatory": {
          "--tw-scroll-snap-strictness": "mandatory"
        },
        ".snap-proximity": {
          "--tw-scroll-snap-strictness": "proximity"
        }
      });
    },
    scrollSnapAlign: ({ addUtilities: T }) => {
      T({
        ".snap-start": {
          "scroll-snap-align": "start"
        },
        ".snap-end": {
          "scroll-snap-align": "end"
        },
        ".snap-center": {
          "scroll-snap-align": "center"
        },
        ".snap-align-none": {
          "scroll-snap-align": "none"
        }
      });
    },
    scrollSnapStop: ({ addUtilities: T }) => {
      T({
        ".snap-normal": {
          "scroll-snap-stop": "normal"
        },
        ".snap-always": {
          "scroll-snap-stop": "always"
        }
      });
    },
    scrollMargin: (0, u.default)("scrollMargin", [
      [
        "scroll-m",
        [
          "scroll-margin"
        ]
      ],
      [
        [
          "scroll-mx",
          [
            "scroll-margin-left",
            "scroll-margin-right"
          ]
        ],
        [
          "scroll-my",
          [
            "scroll-margin-top",
            "scroll-margin-bottom"
          ]
        ]
      ],
      [
        [
          "scroll-ms",
          [
            "scroll-margin-inline-start"
          ]
        ],
        [
          "scroll-me",
          [
            "scroll-margin-inline-end"
          ]
        ],
        [
          "scroll-mt",
          [
            "scroll-margin-top"
          ]
        ],
        [
          "scroll-mr",
          [
            "scroll-margin-right"
          ]
        ],
        [
          "scroll-mb",
          [
            "scroll-margin-bottom"
          ]
        ],
        [
          "scroll-ml",
          [
            "scroll-margin-left"
          ]
        ]
      ]
    ], {
      supportsNegativeValues: !0
    }),
    scrollPadding: (0, u.default)("scrollPadding", [
      [
        "scroll-p",
        [
          "scroll-padding"
        ]
      ],
      [
        [
          "scroll-px",
          [
            "scroll-padding-left",
            "scroll-padding-right"
          ]
        ],
        [
          "scroll-py",
          [
            "scroll-padding-top",
            "scroll-padding-bottom"
          ]
        ]
      ],
      [
        [
          "scroll-ps",
          [
            "scroll-padding-inline-start"
          ]
        ],
        [
          "scroll-pe",
          [
            "scroll-padding-inline-end"
          ]
        ],
        [
          "scroll-pt",
          [
            "scroll-padding-top"
          ]
        ],
        [
          "scroll-pr",
          [
            "scroll-padding-right"
          ]
        ],
        [
          "scroll-pb",
          [
            "scroll-padding-bottom"
          ]
        ],
        [
          "scroll-pl",
          [
            "scroll-padding-left"
          ]
        ]
      ]
    ]),
    listStylePosition: ({ addUtilities: T }) => {
      T({
        ".list-inside": {
          "list-style-position": "inside"
        },
        ".list-outside": {
          "list-style-position": "outside"
        }
      });
    },
    listStyleType: (0, u.default)("listStyleType", [
      [
        "list",
        [
          "listStyleType"
        ]
      ]
    ]),
    listStyleImage: (0, u.default)("listStyleImage", [
      [
        "list-image",
        [
          "listStyleImage"
        ]
      ]
    ]),
    appearance: ({ addUtilities: T }) => {
      T({
        ".appearance-none": {
          appearance: "none"
        }
      });
    },
    columns: (0, u.default)("columns", [
      [
        "columns",
        [
          "columns"
        ]
      ]
    ]),
    breakBefore: ({ addUtilities: T }) => {
      T({
        ".break-before-auto": {
          "break-before": "auto"
        },
        ".break-before-avoid": {
          "break-before": "avoid"
        },
        ".break-before-all": {
          "break-before": "all"
        },
        ".break-before-avoid-page": {
          "break-before": "avoid-page"
        },
        ".break-before-page": {
          "break-before": "page"
        },
        ".break-before-left": {
          "break-before": "left"
        },
        ".break-before-right": {
          "break-before": "right"
        },
        ".break-before-column": {
          "break-before": "column"
        }
      });
    },
    breakInside: ({ addUtilities: T }) => {
      T({
        ".break-inside-auto": {
          "break-inside": "auto"
        },
        ".break-inside-avoid": {
          "break-inside": "avoid"
        },
        ".break-inside-avoid-page": {
          "break-inside": "avoid-page"
        },
        ".break-inside-avoid-column": {
          "break-inside": "avoid-column"
        }
      });
    },
    breakAfter: ({ addUtilities: T }) => {
      T({
        ".break-after-auto": {
          "break-after": "auto"
        },
        ".break-after-avoid": {
          "break-after": "avoid"
        },
        ".break-after-all": {
          "break-after": "all"
        },
        ".break-after-avoid-page": {
          "break-after": "avoid-page"
        },
        ".break-after-page": {
          "break-after": "page"
        },
        ".break-after-left": {
          "break-after": "left"
        },
        ".break-after-right": {
          "break-after": "right"
        },
        ".break-after-column": {
          "break-after": "column"
        }
      });
    },
    gridAutoColumns: (0, u.default)("gridAutoColumns", [
      [
        "auto-cols",
        [
          "gridAutoColumns"
        ]
      ]
    ]),
    gridAutoFlow: ({ addUtilities: T }) => {
      T({
        ".grid-flow-row": {
          gridAutoFlow: "row"
        },
        ".grid-flow-col": {
          gridAutoFlow: "column"
        },
        ".grid-flow-dense": {
          gridAutoFlow: "dense"
        },
        ".grid-flow-row-dense": {
          gridAutoFlow: "row dense"
        },
        ".grid-flow-col-dense": {
          gridAutoFlow: "column dense"
        }
      });
    },
    gridAutoRows: (0, u.default)("gridAutoRows", [
      [
        "auto-rows",
        [
          "gridAutoRows"
        ]
      ]
    ]),
    gridTemplateColumns: (0, u.default)("gridTemplateColumns", [
      [
        "grid-cols",
        [
          "gridTemplateColumns"
        ]
      ]
    ]),
    gridTemplateRows: (0, u.default)("gridTemplateRows", [
      [
        "grid-rows",
        [
          "gridTemplateRows"
        ]
      ]
    ]),
    flexDirection: ({ addUtilities: T }) => {
      T({
        ".flex-row": {
          "flex-direction": "row"
        },
        ".flex-row-reverse": {
          "flex-direction": "row-reverse"
        },
        ".flex-col": {
          "flex-direction": "column"
        },
        ".flex-col-reverse": {
          "flex-direction": "column-reverse"
        }
      });
    },
    flexWrap: ({ addUtilities: T }) => {
      T({
        ".flex-wrap": {
          "flex-wrap": "wrap"
        },
        ".flex-wrap-reverse": {
          "flex-wrap": "wrap-reverse"
        },
        ".flex-nowrap": {
          "flex-wrap": "nowrap"
        }
      });
    },
    placeContent: ({ addUtilities: T }) => {
      T({
        ".place-content-center": {
          "place-content": "center"
        },
        ".place-content-start": {
          "place-content": "start"
        },
        ".place-content-end": {
          "place-content": "end"
        },
        ".place-content-between": {
          "place-content": "space-between"
        },
        ".place-content-around": {
          "place-content": "space-around"
        },
        ".place-content-evenly": {
          "place-content": "space-evenly"
        },
        ".place-content-baseline": {
          "place-content": "baseline"
        },
        ".place-content-stretch": {
          "place-content": "stretch"
        }
      });
    },
    placeItems: ({ addUtilities: T }) => {
      T({
        ".place-items-start": {
          "place-items": "start"
        },
        ".place-items-end": {
          "place-items": "end"
        },
        ".place-items-center": {
          "place-items": "center"
        },
        ".place-items-baseline": {
          "place-items": "baseline"
        },
        ".place-items-stretch": {
          "place-items": "stretch"
        }
      });
    },
    alignContent: ({ addUtilities: T }) => {
      T({
        ".content-normal": {
          "align-content": "normal"
        },
        ".content-center": {
          "align-content": "center"
        },
        ".content-start": {
          "align-content": "flex-start"
        },
        ".content-end": {
          "align-content": "flex-end"
        },
        ".content-between": {
          "align-content": "space-between"
        },
        ".content-around": {
          "align-content": "space-around"
        },
        ".content-evenly": {
          "align-content": "space-evenly"
        },
        ".content-baseline": {
          "align-content": "baseline"
        },
        ".content-stretch": {
          "align-content": "stretch"
        }
      });
    },
    alignItems: ({ addUtilities: T }) => {
      T({
        ".items-start": {
          "align-items": "flex-start"
        },
        ".items-end": {
          "align-items": "flex-end"
        },
        ".items-center": {
          "align-items": "center"
        },
        ".items-baseline": {
          "align-items": "baseline"
        },
        ".items-stretch": {
          "align-items": "stretch"
        }
      });
    },
    justifyContent: ({ addUtilities: T }) => {
      T({
        ".justify-normal": {
          "justify-content": "normal"
        },
        ".justify-start": {
          "justify-content": "flex-start"
        },
        ".justify-end": {
          "justify-content": "flex-end"
        },
        ".justify-center": {
          "justify-content": "center"
        },
        ".justify-between": {
          "justify-content": "space-between"
        },
        ".justify-around": {
          "justify-content": "space-around"
        },
        ".justify-evenly": {
          "justify-content": "space-evenly"
        },
        ".justify-stretch": {
          "justify-content": "stretch"
        }
      });
    },
    justifyItems: ({ addUtilities: T }) => {
      T({
        ".justify-items-start": {
          "justify-items": "start"
        },
        ".justify-items-end": {
          "justify-items": "end"
        },
        ".justify-items-center": {
          "justify-items": "center"
        },
        ".justify-items-stretch": {
          "justify-items": "stretch"
        }
      });
    },
    gap: (0, u.default)("gap", [
      [
        "gap",
        [
          "gap"
        ]
      ],
      [
        [
          "gap-x",
          [
            "columnGap"
          ]
        ],
        [
          "gap-y",
          [
            "rowGap"
          ]
        ]
      ]
    ]),
    space: ({ matchUtilities: T, addUtilities: v, theme: w }) => {
      T({
        "space-x": (O) => (O = O === "0" ? "0px" : O, {
          "& > :not([hidden]) ~ :not([hidden])": {
            "--tw-space-x-reverse": "0",
            "margin-right": `calc(${O} * var(--tw-space-x-reverse))`,
            "margin-left": `calc(${O} * calc(1 - var(--tw-space-x-reverse)))`
          }
        }),
        "space-y": (O) => (O = O === "0" ? "0px" : O, {
          "& > :not([hidden]) ~ :not([hidden])": {
            "--tw-space-y-reverse": "0",
            "margin-top": `calc(${O} * calc(1 - var(--tw-space-y-reverse)))`,
            "margin-bottom": `calc(${O} * var(--tw-space-y-reverse))`
          }
        })
      }, {
        values: w("space"),
        supportsNegativeValues: !0
      }), v({
        ".space-y-reverse > :not([hidden]) ~ :not([hidden])": {
          "--tw-space-y-reverse": "1"
        },
        ".space-x-reverse > :not([hidden]) ~ :not([hidden])": {
          "--tw-space-x-reverse": "1"
        }
      });
    },
    divideWidth: ({ matchUtilities: T, addUtilities: v, theme: w }) => {
      T({
        "divide-x": (O) => (O = O === "0" ? "0px" : O, {
          "& > :not([hidden]) ~ :not([hidden])": {
            "@defaults border-width": {},
            "--tw-divide-x-reverse": "0",
            "border-right-width": `calc(${O} * var(--tw-divide-x-reverse))`,
            "border-left-width": `calc(${O} * calc(1 - var(--tw-divide-x-reverse)))`
          }
        }),
        "divide-y": (O) => (O = O === "0" ? "0px" : O, {
          "& > :not([hidden]) ~ :not([hidden])": {
            "@defaults border-width": {},
            "--tw-divide-y-reverse": "0",
            "border-top-width": `calc(${O} * calc(1 - var(--tw-divide-y-reverse)))`,
            "border-bottom-width": `calc(${O} * var(--tw-divide-y-reverse))`
          }
        })
      }, {
        values: w("divideWidth"),
        type: [
          "line-width",
          "length",
          "any"
        ]
      }), v({
        ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": {
          "@defaults border-width": {},
          "--tw-divide-y-reverse": "1"
        },
        ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": {
          "@defaults border-width": {},
          "--tw-divide-x-reverse": "1"
        }
      });
    },
    divideStyle: ({ addUtilities: T }) => {
      T({
        ".divide-solid > :not([hidden]) ~ :not([hidden])": {
          "border-style": "solid"
        },
        ".divide-dashed > :not([hidden]) ~ :not([hidden])": {
          "border-style": "dashed"
        },
        ".divide-dotted > :not([hidden]) ~ :not([hidden])": {
          "border-style": "dotted"
        },
        ".divide-double > :not([hidden]) ~ :not([hidden])": {
          "border-style": "double"
        },
        ".divide-none > :not([hidden]) ~ :not([hidden])": {
          "border-style": "none"
        }
      });
    },
    divideColor: ({ matchUtilities: T, theme: v, corePlugins: w }) => {
      T({
        divide: (O) => w("divideOpacity") ? {
          "& > :not([hidden]) ~ :not([hidden])": (0, d.default)({
            color: O,
            property: "border-color",
            variable: "--tw-divide-opacity"
          })
        } : {
          "& > :not([hidden]) ~ :not([hidden])": {
            "border-color": (0, s.default)(O)
          }
        }
      }, {
        values: (({ DEFAULT: O, ...G }) => G)((0, f.default)(v("divideColor"))),
        type: [
          "color",
          "any"
        ]
      });
    },
    divideOpacity: ({ matchUtilities: T, theme: v }) => {
      T({
        "divide-opacity": (w) => ({
          "& > :not([hidden]) ~ :not([hidden])": {
            "--tw-divide-opacity": w
          }
        })
      }, {
        values: v("divideOpacity")
      });
    },
    placeSelf: ({ addUtilities: T }) => {
      T({
        ".place-self-auto": {
          "place-self": "auto"
        },
        ".place-self-start": {
          "place-self": "start"
        },
        ".place-self-end": {
          "place-self": "end"
        },
        ".place-self-center": {
          "place-self": "center"
        },
        ".place-self-stretch": {
          "place-self": "stretch"
        }
      });
    },
    alignSelf: ({ addUtilities: T }) => {
      T({
        ".self-auto": {
          "align-self": "auto"
        },
        ".self-start": {
          "align-self": "flex-start"
        },
        ".self-end": {
          "align-self": "flex-end"
        },
        ".self-center": {
          "align-self": "center"
        },
        ".self-stretch": {
          "align-self": "stretch"
        },
        ".self-baseline": {
          "align-self": "baseline"
        }
      });
    },
    justifySelf: ({ addUtilities: T }) => {
      T({
        ".justify-self-auto": {
          "justify-self": "auto"
        },
        ".justify-self-start": {
          "justify-self": "start"
        },
        ".justify-self-end": {
          "justify-self": "end"
        },
        ".justify-self-center": {
          "justify-self": "center"
        },
        ".justify-self-stretch": {
          "justify-self": "stretch"
        }
      });
    },
    overflow: ({ addUtilities: T }) => {
      T({
        ".overflow-auto": {
          overflow: "auto"
        },
        ".overflow-hidden": {
          overflow: "hidden"
        },
        ".overflow-clip": {
          overflow: "clip"
        },
        ".overflow-visible": {
          overflow: "visible"
        },
        ".overflow-scroll": {
          overflow: "scroll"
        },
        ".overflow-x-auto": {
          "overflow-x": "auto"
        },
        ".overflow-y-auto": {
          "overflow-y": "auto"
        },
        ".overflow-x-hidden": {
          "overflow-x": "hidden"
        },
        ".overflow-y-hidden": {
          "overflow-y": "hidden"
        },
        ".overflow-x-clip": {
          "overflow-x": "clip"
        },
        ".overflow-y-clip": {
          "overflow-y": "clip"
        },
        ".overflow-x-visible": {
          "overflow-x": "visible"
        },
        ".overflow-y-visible": {
          "overflow-y": "visible"
        },
        ".overflow-x-scroll": {
          "overflow-x": "scroll"
        },
        ".overflow-y-scroll": {
          "overflow-y": "scroll"
        }
      });
    },
    overscrollBehavior: ({ addUtilities: T }) => {
      T({
        ".overscroll-auto": {
          "overscroll-behavior": "auto"
        },
        ".overscroll-contain": {
          "overscroll-behavior": "contain"
        },
        ".overscroll-none": {
          "overscroll-behavior": "none"
        },
        ".overscroll-y-auto": {
          "overscroll-behavior-y": "auto"
        },
        ".overscroll-y-contain": {
          "overscroll-behavior-y": "contain"
        },
        ".overscroll-y-none": {
          "overscroll-behavior-y": "none"
        },
        ".overscroll-x-auto": {
          "overscroll-behavior-x": "auto"
        },
        ".overscroll-x-contain": {
          "overscroll-behavior-x": "contain"
        },
        ".overscroll-x-none": {
          "overscroll-behavior-x": "none"
        }
      });
    },
    scrollBehavior: ({ addUtilities: T }) => {
      T({
        ".scroll-auto": {
          "scroll-behavior": "auto"
        },
        ".scroll-smooth": {
          "scroll-behavior": "smooth"
        }
      });
    },
    textOverflow: ({ addUtilities: T }) => {
      T({
        ".truncate": {
          overflow: "hidden",
          "text-overflow": "ellipsis",
          "white-space": "nowrap"
        },
        ".overflow-ellipsis": {
          "text-overflow": "ellipsis"
        },
        ".text-ellipsis": {
          "text-overflow": "ellipsis"
        },
        ".text-clip": {
          "text-overflow": "clip"
        }
      });
    },
    hyphens: ({ addUtilities: T }) => {
      T({
        ".hyphens-none": {
          hyphens: "none"
        },
        ".hyphens-manual": {
          hyphens: "manual"
        },
        ".hyphens-auto": {
          hyphens: "auto"
        }
      });
    },
    whitespace: ({ addUtilities: T }) => {
      T({
        ".whitespace-normal": {
          "white-space": "normal"
        },
        ".whitespace-nowrap": {
          "white-space": "nowrap"
        },
        ".whitespace-pre": {
          "white-space": "pre"
        },
        ".whitespace-pre-line": {
          "white-space": "pre-line"
        },
        ".whitespace-pre-wrap": {
          "white-space": "pre-wrap"
        },
        ".whitespace-break-spaces": {
          "white-space": "break-spaces"
        }
      });
    },
    wordBreak: ({ addUtilities: T }) => {
      T({
        ".break-normal": {
          "overflow-wrap": "normal",
          "word-break": "normal"
        },
        ".break-words": {
          "overflow-wrap": "break-word"
        },
        ".break-all": {
          "word-break": "break-all"
        },
        ".break-keep": {
          "word-break": "keep-all"
        }
      });
    },
    borderRadius: (0, u.default)("borderRadius", [
      [
        "rounded",
        [
          "border-radius"
        ]
      ],
      [
        [
          "rounded-s",
          [
            "border-start-start-radius",
            "border-end-start-radius"
          ]
        ],
        [
          "rounded-e",
          [
            "border-start-end-radius",
            "border-end-end-radius"
          ]
        ],
        [
          "rounded-t",
          [
            "border-top-left-radius",
            "border-top-right-radius"
          ]
        ],
        [
          "rounded-r",
          [
            "border-top-right-radius",
            "border-bottom-right-radius"
          ]
        ],
        [
          "rounded-b",
          [
            "border-bottom-right-radius",
            "border-bottom-left-radius"
          ]
        ],
        [
          "rounded-l",
          [
            "border-top-left-radius",
            "border-bottom-left-radius"
          ]
        ]
      ],
      [
        [
          "rounded-ss",
          [
            "border-start-start-radius"
          ]
        ],
        [
          "rounded-se",
          [
            "border-start-end-radius"
          ]
        ],
        [
          "rounded-ee",
          [
            "border-end-end-radius"
          ]
        ],
        [
          "rounded-es",
          [
            "border-end-start-radius"
          ]
        ],
        [
          "rounded-tl",
          [
            "border-top-left-radius"
          ]
        ],
        [
          "rounded-tr",
          [
            "border-top-right-radius"
          ]
        ],
        [
          "rounded-br",
          [
            "border-bottom-right-radius"
          ]
        ],
        [
          "rounded-bl",
          [
            "border-bottom-left-radius"
          ]
        ]
      ]
    ]),
    borderWidth: (0, u.default)("borderWidth", [
      [
        "border",
        [
          [
            "@defaults border-width",
            {}
          ],
          "border-width"
        ]
      ],
      [
        [
          "border-x",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-left-width",
            "border-right-width"
          ]
        ],
        [
          "border-y",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-top-width",
            "border-bottom-width"
          ]
        ]
      ],
      [
        [
          "border-s",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-inline-start-width"
          ]
        ],
        [
          "border-e",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-inline-end-width"
          ]
        ],
        [
          "border-t",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-top-width"
          ]
        ],
        [
          "border-r",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-right-width"
          ]
        ],
        [
          "border-b",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-bottom-width"
          ]
        ],
        [
          "border-l",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-left-width"
          ]
        ]
      ]
    ], {
      type: [
        "line-width",
        "length"
      ]
    }),
    borderStyle: ({ addUtilities: T }) => {
      T({
        ".border-solid": {
          "border-style": "solid"
        },
        ".border-dashed": {
          "border-style": "dashed"
        },
        ".border-dotted": {
          "border-style": "dotted"
        },
        ".border-double": {
          "border-style": "double"
        },
        ".border-hidden": {
          "border-style": "hidden"
        },
        ".border-none": {
          "border-style": "none"
        }
      });
    },
    borderColor: ({ matchUtilities: T, theme: v, corePlugins: w }) => {
      T({
        border: (O) => w("borderOpacity") ? (0, d.default)({
          color: O,
          property: "border-color",
          variable: "--tw-border-opacity"
        }) : {
          "border-color": (0, s.default)(O)
        }
      }, {
        values: (({ DEFAULT: O, ...G }) => G)((0, f.default)(v("borderColor"))),
        type: [
          "color",
          "any"
        ]
      }), T({
        "border-x": (O) => w("borderOpacity") ? (0, d.default)({
          color: O,
          property: [
            "border-left-color",
            "border-right-color"
          ],
          variable: "--tw-border-opacity"
        }) : {
          "border-left-color": (0, s.default)(O),
          "border-right-color": (0, s.default)(O)
        },
        "border-y": (O) => w("borderOpacity") ? (0, d.default)({
          color: O,
          property: [
            "border-top-color",
            "border-bottom-color"
          ],
          variable: "--tw-border-opacity"
        }) : {
          "border-top-color": (0, s.default)(O),
          "border-bottom-color": (0, s.default)(O)
        }
      }, {
        values: (({ DEFAULT: O, ...G }) => G)((0, f.default)(v("borderColor"))),
        type: [
          "color",
          "any"
        ]
      }), T({
        "border-s": (O) => w("borderOpacity") ? (0, d.default)({
          color: O,
          property: "border-inline-start-color",
          variable: "--tw-border-opacity"
        }) : {
          "border-inline-start-color": (0, s.default)(O)
        },
        "border-e": (O) => w("borderOpacity") ? (0, d.default)({
          color: O,
          property: "border-inline-end-color",
          variable: "--tw-border-opacity"
        }) : {
          "border-inline-end-color": (0, s.default)(O)
        },
        "border-t": (O) => w("borderOpacity") ? (0, d.default)({
          color: O,
          property: "border-top-color",
          variable: "--tw-border-opacity"
        }) : {
          "border-top-color": (0, s.default)(O)
        },
        "border-r": (O) => w("borderOpacity") ? (0, d.default)({
          color: O,
          property: "border-right-color",
          variable: "--tw-border-opacity"
        }) : {
          "border-right-color": (0, s.default)(O)
        },
        "border-b": (O) => w("borderOpacity") ? (0, d.default)({
          color: O,
          property: "border-bottom-color",
          variable: "--tw-border-opacity"
        }) : {
          "border-bottom-color": (0, s.default)(O)
        },
        "border-l": (O) => w("borderOpacity") ? (0, d.default)({
          color: O,
          property: "border-left-color",
          variable: "--tw-border-opacity"
        }) : {
          "border-left-color": (0, s.default)(O)
        }
      }, {
        values: (({ DEFAULT: O, ...G }) => G)((0, f.default)(v("borderColor"))),
        type: [
          "color",
          "any"
        ]
      });
    },
    borderOpacity: (0, u.default)("borderOpacity", [
      [
        "border-opacity",
        [
          "--tw-border-opacity"
        ]
      ]
    ]),
    backgroundColor: ({ matchUtilities: T, theme: v, corePlugins: w }) => {
      T({
        bg: (O) => w("backgroundOpacity") ? (0, d.default)({
          color: O,
          property: "background-color",
          variable: "--tw-bg-opacity"
        }) : {
          "background-color": (0, s.default)(O)
        }
      }, {
        values: (0, f.default)(v("backgroundColor")),
        type: [
          "color",
          "any"
        ]
      });
    },
    backgroundOpacity: (0, u.default)("backgroundOpacity", [
      [
        "bg-opacity",
        [
          "--tw-bg-opacity"
        ]
      ]
    ]),
    backgroundImage: (0, u.default)("backgroundImage", [
      [
        "bg",
        [
          "background-image"
        ]
      ]
    ], {
      type: [
        "lookup",
        "image",
        "url"
      ]
    }),
    gradientColorStops: (() => {
      function T(v) {
        return (0, d.withAlphaValue)(v, 0, "rgb(255 255 255 / 0)");
      }
      return function({ matchUtilities: v, theme: w, addDefaults: O }) {
        O("gradient-color-stops", {
          "--tw-gradient-from-position": " ",
          "--tw-gradient-via-position": " ",
          "--tw-gradient-to-position": " "
        });
        let G = {
          values: (0, f.default)(w("gradientColorStops")),
          type: [
            "color",
            "any"
          ]
        }, W = {
          values: w("gradientColorStopPositions"),
          type: [
            "length",
            "percentage"
          ]
        };
        v({
          from: (U) => {
            let M = T(U);
            return {
              "@defaults gradient-color-stops": {},
              "--tw-gradient-from": `${(0, s.default)(U)} var(--tw-gradient-from-position)`,
              "--tw-gradient-to": `${M} var(--tw-gradient-to-position)`,
              "--tw-gradient-stops": "var(--tw-gradient-from), var(--tw-gradient-to)"
            };
          }
        }, G), v({
          from: (U) => ({
            "--tw-gradient-from-position": U
          })
        }, W), v({
          via: (U) => {
            let M = T(U);
            return {
              "@defaults gradient-color-stops": {},
              "--tw-gradient-to": `${M}  var(--tw-gradient-to-position)`,
              "--tw-gradient-stops": `var(--tw-gradient-from), ${(0, s.default)(U)} var(--tw-gradient-via-position), var(--tw-gradient-to)`
            };
          }
        }, G), v({
          via: (U) => ({
            "--tw-gradient-via-position": U
          })
        }, W), v({
          to: (U) => ({
            "@defaults gradient-color-stops": {},
            "--tw-gradient-to": `${(0, s.default)(U)} var(--tw-gradient-to-position)`
          })
        }, G), v({
          to: (U) => ({
            "--tw-gradient-to-position": U
          })
        }, W);
      };
    })(),
    boxDecorationBreak: ({ addUtilities: T }) => {
      T({
        ".decoration-slice": {
          "box-decoration-break": "slice"
        },
        ".decoration-clone": {
          "box-decoration-break": "clone"
        },
        ".box-decoration-slice": {
          "box-decoration-break": "slice"
        },
        ".box-decoration-clone": {
          "box-decoration-break": "clone"
        }
      });
    },
    backgroundSize: (0, u.default)("backgroundSize", [
      [
        "bg",
        [
          "background-size"
        ]
      ]
    ], {
      type: [
        "lookup",
        "length",
        "percentage",
        "size"
      ]
    }),
    backgroundAttachment: ({ addUtilities: T }) => {
      T({
        ".bg-fixed": {
          "background-attachment": "fixed"
        },
        ".bg-local": {
          "background-attachment": "local"
        },
        ".bg-scroll": {
          "background-attachment": "scroll"
        }
      });
    },
    backgroundClip: ({ addUtilities: T }) => {
      T({
        ".bg-clip-border": {
          "background-clip": "border-box"
        },
        ".bg-clip-padding": {
          "background-clip": "padding-box"
        },
        ".bg-clip-content": {
          "background-clip": "content-box"
        },
        ".bg-clip-text": {
          "background-clip": "text"
        }
      });
    },
    backgroundPosition: (0, u.default)("backgroundPosition", [
      [
        "bg",
        [
          "background-position"
        ]
      ]
    ], {
      type: [
        "lookup",
        [
          "position",
          {
            preferOnConflict: !0
          }
        ]
      ]
    }),
    backgroundRepeat: ({ addUtilities: T }) => {
      T({
        ".bg-repeat": {
          "background-repeat": "repeat"
        },
        ".bg-no-repeat": {
          "background-repeat": "no-repeat"
        },
        ".bg-repeat-x": {
          "background-repeat": "repeat-x"
        },
        ".bg-repeat-y": {
          "background-repeat": "repeat-y"
        },
        ".bg-repeat-round": {
          "background-repeat": "round"
        },
        ".bg-repeat-space": {
          "background-repeat": "space"
        }
      });
    },
    backgroundOrigin: ({ addUtilities: T }) => {
      T({
        ".bg-origin-border": {
          "background-origin": "border-box"
        },
        ".bg-origin-padding": {
          "background-origin": "padding-box"
        },
        ".bg-origin-content": {
          "background-origin": "content-box"
        }
      });
    },
    fill: ({ matchUtilities: T, theme: v }) => {
      T({
        fill: (w) => ({
          fill: (0, s.default)(w)
        })
      }, {
        values: (0, f.default)(v("fill")),
        type: [
          "color",
          "any"
        ]
      });
    },
    stroke: ({ matchUtilities: T, theme: v }) => {
      T({
        stroke: (w) => ({
          stroke: (0, s.default)(w)
        })
      }, {
        values: (0, f.default)(v("stroke")),
        type: [
          "color",
          "url",
          "any"
        ]
      });
    },
    strokeWidth: (0, u.default)("strokeWidth", [
      [
        "stroke",
        [
          "stroke-width"
        ]
      ]
    ], {
      type: [
        "length",
        "number",
        "percentage"
      ]
    }),
    objectFit: ({ addUtilities: T }) => {
      T({
        ".object-contain": {
          "object-fit": "contain"
        },
        ".object-cover": {
          "object-fit": "cover"
        },
        ".object-fill": {
          "object-fit": "fill"
        },
        ".object-none": {
          "object-fit": "none"
        },
        ".object-scale-down": {
          "object-fit": "scale-down"
        }
      });
    },
    objectPosition: (0, u.default)("objectPosition", [
      [
        "object",
        [
          "object-position"
        ]
      ]
    ]),
    padding: (0, u.default)("padding", [
      [
        "p",
        [
          "padding"
        ]
      ],
      [
        [
          "px",
          [
            "padding-left",
            "padding-right"
          ]
        ],
        [
          "py",
          [
            "padding-top",
            "padding-bottom"
          ]
        ]
      ],
      [
        [
          "ps",
          [
            "padding-inline-start"
          ]
        ],
        [
          "pe",
          [
            "padding-inline-end"
          ]
        ],
        [
          "pt",
          [
            "padding-top"
          ]
        ],
        [
          "pr",
          [
            "padding-right"
          ]
        ],
        [
          "pb",
          [
            "padding-bottom"
          ]
        ],
        [
          "pl",
          [
            "padding-left"
          ]
        ]
      ]
    ]),
    textAlign: ({ addUtilities: T }) => {
      T({
        ".text-left": {
          "text-align": "left"
        },
        ".text-center": {
          "text-align": "center"
        },
        ".text-right": {
          "text-align": "right"
        },
        ".text-justify": {
          "text-align": "justify"
        },
        ".text-start": {
          "text-align": "start"
        },
        ".text-end": {
          "text-align": "end"
        }
      });
    },
    textIndent: (0, u.default)("textIndent", [
      [
        "indent",
        [
          "text-indent"
        ]
      ]
    ], {
      supportsNegativeValues: !0
    }),
    verticalAlign: ({ addUtilities: T, matchUtilities: v }) => {
      T({
        ".align-baseline": {
          "vertical-align": "baseline"
        },
        ".align-top": {
          "vertical-align": "top"
        },
        ".align-middle": {
          "vertical-align": "middle"
        },
        ".align-bottom": {
          "vertical-align": "bottom"
        },
        ".align-text-top": {
          "vertical-align": "text-top"
        },
        ".align-text-bottom": {
          "vertical-align": "text-bottom"
        },
        ".align-sub": {
          "vertical-align": "sub"
        },
        ".align-super": {
          "vertical-align": "super"
        }
      }), v({
        align: (w) => ({
          "vertical-align": w
        })
      });
    },
    fontFamily: ({ matchUtilities: T, theme: v }) => {
      T({
        font: (w) => {
          let [O, G = {}] = Array.isArray(w) && (0, o.default)(w[1]) ? w : [
            w
          ], { fontFeatureSettings: W, fontVariationSettings: U } = G;
          return {
            "font-family": Array.isArray(O) ? O.join(", ") : O,
            ...W === void 0 ? {} : {
              "font-feature-settings": W
            },
            ...U === void 0 ? {} : {
              "font-variation-settings": U
            }
          };
        }
      }, {
        values: v("fontFamily"),
        type: [
          "lookup",
          "generic-name",
          "family-name"
        ]
      });
    },
    fontSize: ({ matchUtilities: T, theme: v }) => {
      T({
        text: (w, { modifier: O }) => {
          let [G, W] = Array.isArray(w) ? w : [
            w
          ];
          if (O)
            return {
              "font-size": G,
              "line-height": O
            };
          let { lineHeight: U, letterSpacing: M, fontWeight: B } = (0, o.default)(W) ? W : {
            lineHeight: W
          };
          return {
            "font-size": G,
            ...U === void 0 ? {} : {
              "line-height": U
            },
            ...M === void 0 ? {} : {
              "letter-spacing": M
            },
            ...B === void 0 ? {} : {
              "font-weight": B
            }
          };
        }
      }, {
        values: v("fontSize"),
        modifiers: v("lineHeight"),
        type: [
          "absolute-size",
          "relative-size",
          "length",
          "percentage"
        ]
      });
    },
    fontWeight: (0, u.default)("fontWeight", [
      [
        "font",
        [
          "fontWeight"
        ]
      ]
    ], {
      type: [
        "lookup",
        "number",
        "any"
      ]
    }),
    textTransform: ({ addUtilities: T }) => {
      T({
        ".uppercase": {
          "text-transform": "uppercase"
        },
        ".lowercase": {
          "text-transform": "lowercase"
        },
        ".capitalize": {
          "text-transform": "capitalize"
        },
        ".normal-case": {
          "text-transform": "none"
        }
      });
    },
    fontStyle: ({ addUtilities: T }) => {
      T({
        ".italic": {
          "font-style": "italic"
        },
        ".not-italic": {
          "font-style": "normal"
        }
      });
    },
    fontVariantNumeric: ({ addDefaults: T, addUtilities: v }) => {
      let w = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
      T("font-variant-numeric", {
        "--tw-ordinal": " ",
        "--tw-slashed-zero": " ",
        "--tw-numeric-figure": " ",
        "--tw-numeric-spacing": " ",
        "--tw-numeric-fraction": " "
      }), v({
        ".normal-nums": {
          "font-variant-numeric": "normal"
        },
        ".ordinal": {
          "@defaults font-variant-numeric": {},
          "--tw-ordinal": "ordinal",
          "font-variant-numeric": w
        },
        ".slashed-zero": {
          "@defaults font-variant-numeric": {},
          "--tw-slashed-zero": "slashed-zero",
          "font-variant-numeric": w
        },
        ".lining-nums": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-figure": "lining-nums",
          "font-variant-numeric": w
        },
        ".oldstyle-nums": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-figure": "oldstyle-nums",
          "font-variant-numeric": w
        },
        ".proportional-nums": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-spacing": "proportional-nums",
          "font-variant-numeric": w
        },
        ".tabular-nums": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-spacing": "tabular-nums",
          "font-variant-numeric": w
        },
        ".diagonal-fractions": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-fraction": "diagonal-fractions",
          "font-variant-numeric": w
        },
        ".stacked-fractions": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-fraction": "stacked-fractions",
          "font-variant-numeric": w
        }
      });
    },
    lineHeight: (0, u.default)("lineHeight", [
      [
        "leading",
        [
          "lineHeight"
        ]
      ]
    ]),
    letterSpacing: (0, u.default)("letterSpacing", [
      [
        "tracking",
        [
          "letterSpacing"
        ]
      ]
    ], {
      supportsNegativeValues: !0
    }),
    textColor: ({ matchUtilities: T, theme: v, corePlugins: w }) => {
      T({
        text: (O) => w("textOpacity") ? (0, d.default)({
          color: O,
          property: "color",
          variable: "--tw-text-opacity"
        }) : {
          color: (0, s.default)(O)
        }
      }, {
        values: (0, f.default)(v("textColor")),
        type: [
          "color",
          "any"
        ]
      });
    },
    textOpacity: (0, u.default)("textOpacity", [
      [
        "text-opacity",
        [
          "--tw-text-opacity"
        ]
      ]
    ]),
    textDecoration: ({ addUtilities: T }) => {
      T({
        ".underline": {
          "text-decoration-line": "underline"
        },
        ".overline": {
          "text-decoration-line": "overline"
        },
        ".line-through": {
          "text-decoration-line": "line-through"
        },
        ".no-underline": {
          "text-decoration-line": "none"
        }
      });
    },
    textDecorationColor: ({ matchUtilities: T, theme: v }) => {
      T({
        decoration: (w) => ({
          "text-decoration-color": (0, s.default)(w)
        })
      }, {
        values: (0, f.default)(v("textDecorationColor")),
        type: [
          "color",
          "any"
        ]
      });
    },
    textDecorationStyle: ({ addUtilities: T }) => {
      T({
        ".decoration-solid": {
          "text-decoration-style": "solid"
        },
        ".decoration-double": {
          "text-decoration-style": "double"
        },
        ".decoration-dotted": {
          "text-decoration-style": "dotted"
        },
        ".decoration-dashed": {
          "text-decoration-style": "dashed"
        },
        ".decoration-wavy": {
          "text-decoration-style": "wavy"
        }
      });
    },
    textDecorationThickness: (0, u.default)("textDecorationThickness", [
      [
        "decoration",
        [
          "text-decoration-thickness"
        ]
      ]
    ], {
      type: [
        "length",
        "percentage"
      ]
    }),
    textUnderlineOffset: (0, u.default)("textUnderlineOffset", [
      [
        "underline-offset",
        [
          "text-underline-offset"
        ]
      ]
    ], {
      type: [
        "length",
        "percentage",
        "any"
      ]
    }),
    fontSmoothing: ({ addUtilities: T }) => {
      T({
        ".antialiased": {
          "-webkit-font-smoothing": "antialiased",
          "-moz-osx-font-smoothing": "grayscale"
        },
        ".subpixel-antialiased": {
          "-webkit-font-smoothing": "auto",
          "-moz-osx-font-smoothing": "auto"
        }
      });
    },
    placeholderColor: ({ matchUtilities: T, theme: v, corePlugins: w }) => {
      T({
        placeholder: (O) => w("placeholderOpacity") ? {
          "&::placeholder": (0, d.default)({
            color: O,
            property: "color",
            variable: "--tw-placeholder-opacity"
          })
        } : {
          "&::placeholder": {
            color: (0, s.default)(O)
          }
        }
      }, {
        values: (0, f.default)(v("placeholderColor")),
        type: [
          "color",
          "any"
        ]
      });
    },
    placeholderOpacity: ({ matchUtilities: T, theme: v }) => {
      T({
        "placeholder-opacity": (w) => ({
          "&::placeholder": {
            "--tw-placeholder-opacity": w
          }
        })
      }, {
        values: v("placeholderOpacity")
      });
    },
    caretColor: ({ matchUtilities: T, theme: v }) => {
      T({
        caret: (w) => ({
          "caret-color": (0, s.default)(w)
        })
      }, {
        values: (0, f.default)(v("caretColor")),
        type: [
          "color",
          "any"
        ]
      });
    },
    accentColor: ({ matchUtilities: T, theme: v }) => {
      T({
        accent: (w) => ({
          "accent-color": (0, s.default)(w)
        })
      }, {
        values: (0, f.default)(v("accentColor")),
        type: [
          "color",
          "any"
        ]
      });
    },
    opacity: (0, u.default)("opacity", [
      [
        "opacity",
        [
          "opacity"
        ]
      ]
    ]),
    backgroundBlendMode: ({ addUtilities: T }) => {
      T({
        ".bg-blend-normal": {
          "background-blend-mode": "normal"
        },
        ".bg-blend-multiply": {
          "background-blend-mode": "multiply"
        },
        ".bg-blend-screen": {
          "background-blend-mode": "screen"
        },
        ".bg-blend-overlay": {
          "background-blend-mode": "overlay"
        },
        ".bg-blend-darken": {
          "background-blend-mode": "darken"
        },
        ".bg-blend-lighten": {
          "background-blend-mode": "lighten"
        },
        ".bg-blend-color-dodge": {
          "background-blend-mode": "color-dodge"
        },
        ".bg-blend-color-burn": {
          "background-blend-mode": "color-burn"
        },
        ".bg-blend-hard-light": {
          "background-blend-mode": "hard-light"
        },
        ".bg-blend-soft-light": {
          "background-blend-mode": "soft-light"
        },
        ".bg-blend-difference": {
          "background-blend-mode": "difference"
        },
        ".bg-blend-exclusion": {
          "background-blend-mode": "exclusion"
        },
        ".bg-blend-hue": {
          "background-blend-mode": "hue"
        },
        ".bg-blend-saturation": {
          "background-blend-mode": "saturation"
        },
        ".bg-blend-color": {
          "background-blend-mode": "color"
        },
        ".bg-blend-luminosity": {
          "background-blend-mode": "luminosity"
        }
      });
    },
    mixBlendMode: ({ addUtilities: T }) => {
      T({
        ".mix-blend-normal": {
          "mix-blend-mode": "normal"
        },
        ".mix-blend-multiply": {
          "mix-blend-mode": "multiply"
        },
        ".mix-blend-screen": {
          "mix-blend-mode": "screen"
        },
        ".mix-blend-overlay": {
          "mix-blend-mode": "overlay"
        },
        ".mix-blend-darken": {
          "mix-blend-mode": "darken"
        },
        ".mix-blend-lighten": {
          "mix-blend-mode": "lighten"
        },
        ".mix-blend-color-dodge": {
          "mix-blend-mode": "color-dodge"
        },
        ".mix-blend-color-burn": {
          "mix-blend-mode": "color-burn"
        },
        ".mix-blend-hard-light": {
          "mix-blend-mode": "hard-light"
        },
        ".mix-blend-soft-light": {
          "mix-blend-mode": "soft-light"
        },
        ".mix-blend-difference": {
          "mix-blend-mode": "difference"
        },
        ".mix-blend-exclusion": {
          "mix-blend-mode": "exclusion"
        },
        ".mix-blend-hue": {
          "mix-blend-mode": "hue"
        },
        ".mix-blend-saturation": {
          "mix-blend-mode": "saturation"
        },
        ".mix-blend-color": {
          "mix-blend-mode": "color"
        },
        ".mix-blend-luminosity": {
          "mix-blend-mode": "luminosity"
        },
        ".mix-blend-plus-lighter": {
          "mix-blend-mode": "plus-lighter"
        }
      });
    },
    boxShadow: (() => {
      let T = (0, m.default)("boxShadow"), v = [
        "var(--tw-ring-offset-shadow, 0 0 #0000)",
        "var(--tw-ring-shadow, 0 0 #0000)",
        "var(--tw-shadow)"
      ].join(", ");
      return function({ matchUtilities: w, addDefaults: O, theme: G }) {
        O(" box-shadow", {
          "--tw-ring-offset-shadow": "0 0 #0000",
          "--tw-ring-shadow": "0 0 #0000",
          "--tw-shadow": "0 0 #0000",
          "--tw-shadow-colored": "0 0 #0000"
        }), w({
          shadow: (W) => {
            W = T(W);
            let U = (0, E.parseBoxShadowValue)(W);
            for (let M of U)
              M.valid && (M.color = "var(--tw-shadow-color)");
            return {
              "@defaults box-shadow": {},
              "--tw-shadow": W === "none" ? "0 0 #0000" : W,
              "--tw-shadow-colored": W === "none" ? "0 0 #0000" : (0, E.formatBoxShadowValue)(U),
              "box-shadow": v
            };
          }
        }, {
          values: G("boxShadow"),
          type: [
            "shadow"
          ]
        });
      };
    })(),
    boxShadowColor: ({ matchUtilities: T, theme: v }) => {
      T({
        shadow: (w) => ({
          "--tw-shadow-color": (0, s.default)(w),
          "--tw-shadow": "var(--tw-shadow-colored)"
        })
      }, {
        values: (0, f.default)(v("boxShadowColor")),
        type: [
          "color",
          "any"
        ]
      });
    },
    outlineStyle: ({ addUtilities: T }) => {
      T({
        ".outline-none": {
          outline: "2px solid transparent",
          "outline-offset": "2px"
        },
        ".outline": {
          "outline-style": "solid"
        },
        ".outline-dashed": {
          "outline-style": "dashed"
        },
        ".outline-dotted": {
          "outline-style": "dotted"
        },
        ".outline-double": {
          "outline-style": "double"
        }
      });
    },
    outlineWidth: (0, u.default)("outlineWidth", [
      [
        "outline",
        [
          "outline-width"
        ]
      ]
    ], {
      type: [
        "length",
        "number",
        "percentage"
      ]
    }),
    outlineOffset: (0, u.default)("outlineOffset", [
      [
        "outline-offset",
        [
          "outline-offset"
        ]
      ]
    ], {
      type: [
        "length",
        "number",
        "percentage",
        "any"
      ],
      supportsNegativeValues: !0
    }),
    outlineColor: ({ matchUtilities: T, theme: v }) => {
      T({
        outline: (w) => ({
          "outline-color": (0, s.default)(w)
        })
      }, {
        values: (0, f.default)(v("outlineColor")),
        type: [
          "color",
          "any"
        ]
      });
    },
    ringWidth: ({ matchUtilities: T, addDefaults: v, addUtilities: w, theme: O, config: G }) => {
      let W = (() => {
        var U, M;
        if ((0, g.flagEnabled)(G(), "respectDefaultRingColorOpacity"))
          return O("ringColor.DEFAULT");
        let B = O("ringOpacity.DEFAULT", "0.5");
        return !((U = O("ringColor")) === null || U === void 0) && U.DEFAULT ? (0, d.withAlphaValue)((M = O("ringColor")) === null || M === void 0 ? void 0 : M.DEFAULT, B, `rgb(147 197 253 / ${B})`) : `rgb(147 197 253 / ${B})`;
      })();
      v("ring-width", {
        "--tw-ring-inset": " ",
        "--tw-ring-offset-width": O("ringOffsetWidth.DEFAULT", "0px"),
        "--tw-ring-offset-color": O("ringOffsetColor.DEFAULT", "#fff"),
        "--tw-ring-color": W,
        "--tw-ring-offset-shadow": "0 0 #0000",
        "--tw-ring-shadow": "0 0 #0000",
        "--tw-shadow": "0 0 #0000",
        "--tw-shadow-colored": "0 0 #0000"
      }), T({
        ring: (U) => ({
          "@defaults ring-width": {},
          "--tw-ring-offset-shadow": "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)",
          "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${U} + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
          "box-shadow": [
            "var(--tw-ring-offset-shadow)",
            "var(--tw-ring-shadow)",
            "var(--tw-shadow, 0 0 #0000)"
          ].join(", ")
        })
      }, {
        values: O("ringWidth"),
        type: "length"
      }), w({
        ".ring-inset": {
          "@defaults ring-width": {},
          "--tw-ring-inset": "inset"
        }
      });
    },
    ringColor: ({ matchUtilities: T, theme: v, corePlugins: w }) => {
      T({
        ring: (O) => w("ringOpacity") ? (0, d.default)({
          color: O,
          property: "--tw-ring-color",
          variable: "--tw-ring-opacity"
        }) : {
          "--tw-ring-color": (0, s.default)(O)
        }
      }, {
        values: Object.fromEntries(Object.entries((0, f.default)(v("ringColor"))).filter(([O]) => O !== "DEFAULT")),
        type: [
          "color",
          "any"
        ]
      });
    },
    ringOpacity: (T) => {
      let { config: v } = T;
      return (0, u.default)("ringOpacity", [
        [
          "ring-opacity",
          [
            "--tw-ring-opacity"
          ]
        ]
      ], {
        filterDefault: !(0, g.flagEnabled)(v(), "respectDefaultRingColorOpacity")
      })(T);
    },
    ringOffsetWidth: (0, u.default)("ringOffsetWidth", [
      [
        "ring-offset",
        [
          "--tw-ring-offset-width"
        ]
      ]
    ], {
      type: "length"
    }),
    ringOffsetColor: ({ matchUtilities: T, theme: v }) => {
      T({
        "ring-offset": (w) => ({
          "--tw-ring-offset-color": (0, s.default)(w)
        })
      }, {
        values: (0, f.default)(v("ringOffsetColor")),
        type: [
          "color",
          "any"
        ]
      });
    },
    blur: ({ matchUtilities: T, theme: v }) => {
      T({
        blur: (w) => ({
          "--tw-blur": `blur(${w})`,
          "@defaults filter": {},
          filter: j
        })
      }, {
        values: v("blur")
      });
    },
    brightness: ({ matchUtilities: T, theme: v }) => {
      T({
        brightness: (w) => ({
          "--tw-brightness": `brightness(${w})`,
          "@defaults filter": {},
          filter: j
        })
      }, {
        values: v("brightness")
      });
    },
    contrast: ({ matchUtilities: T, theme: v }) => {
      T({
        contrast: (w) => ({
          "--tw-contrast": `contrast(${w})`,
          "@defaults filter": {},
          filter: j
        })
      }, {
        values: v("contrast")
      });
    },
    dropShadow: ({ matchUtilities: T, theme: v }) => {
      T({
        "drop-shadow": (w) => ({
          "--tw-drop-shadow": Array.isArray(w) ? w.map((O) => `drop-shadow(${O})`).join(" ") : `drop-shadow(${w})`,
          "@defaults filter": {},
          filter: j
        })
      }, {
        values: v("dropShadow")
      });
    },
    grayscale: ({ matchUtilities: T, theme: v }) => {
      T({
        grayscale: (w) => ({
          "--tw-grayscale": `grayscale(${w})`,
          "@defaults filter": {},
          filter: j
        })
      }, {
        values: v("grayscale")
      });
    },
    hueRotate: ({ matchUtilities: T, theme: v }) => {
      T({
        "hue-rotate": (w) => ({
          "--tw-hue-rotate": `hue-rotate(${w})`,
          "@defaults filter": {},
          filter: j
        })
      }, {
        values: v("hueRotate"),
        supportsNegativeValues: !0
      });
    },
    invert: ({ matchUtilities: T, theme: v }) => {
      T({
        invert: (w) => ({
          "--tw-invert": `invert(${w})`,
          "@defaults filter": {},
          filter: j
        })
      }, {
        values: v("invert")
      });
    },
    saturate: ({ matchUtilities: T, theme: v }) => {
      T({
        saturate: (w) => ({
          "--tw-saturate": `saturate(${w})`,
          "@defaults filter": {},
          filter: j
        })
      }, {
        values: v("saturate")
      });
    },
    sepia: ({ matchUtilities: T, theme: v }) => {
      T({
        sepia: (w) => ({
          "--tw-sepia": `sepia(${w})`,
          "@defaults filter": {},
          filter: j
        })
      }, {
        values: v("sepia")
      });
    },
    filter: ({ addDefaults: T, addUtilities: v }) => {
      T("filter", {
        "--tw-blur": " ",
        "--tw-brightness": " ",
        "--tw-contrast": " ",
        "--tw-grayscale": " ",
        "--tw-hue-rotate": " ",
        "--tw-invert": " ",
        "--tw-saturate": " ",
        "--tw-sepia": " ",
        "--tw-drop-shadow": " "
      }), v({
        ".filter": {
          "@defaults filter": {},
          filter: j
        },
        ".filter-none": {
          filter: "none"
        }
      });
    },
    backdropBlur: ({ matchUtilities: T, theme: v }) => {
      T({
        "backdrop-blur": (w) => ({
          "--tw-backdrop-blur": `blur(${w})`,
          "@defaults backdrop-filter": {},
          "backdrop-filter": F
        })
      }, {
        values: v("backdropBlur")
      });
    },
    backdropBrightness: ({ matchUtilities: T, theme: v }) => {
      T({
        "backdrop-brightness": (w) => ({
          "--tw-backdrop-brightness": `brightness(${w})`,
          "@defaults backdrop-filter": {},
          "backdrop-filter": F
        })
      }, {
        values: v("backdropBrightness")
      });
    },
    backdropContrast: ({ matchUtilities: T, theme: v }) => {
      T({
        "backdrop-contrast": (w) => ({
          "--tw-backdrop-contrast": `contrast(${w})`,
          "@defaults backdrop-filter": {},
          "backdrop-filter": F
        })
      }, {
        values: v("backdropContrast")
      });
    },
    backdropGrayscale: ({ matchUtilities: T, theme: v }) => {
      T({
        "backdrop-grayscale": (w) => ({
          "--tw-backdrop-grayscale": `grayscale(${w})`,
          "@defaults backdrop-filter": {},
          "backdrop-filter": F
        })
      }, {
        values: v("backdropGrayscale")
      });
    },
    backdropHueRotate: ({ matchUtilities: T, theme: v }) => {
      T({
        "backdrop-hue-rotate": (w) => ({
          "--tw-backdrop-hue-rotate": `hue-rotate(${w})`,
          "@defaults backdrop-filter": {},
          "backdrop-filter": F
        })
      }, {
        values: v("backdropHueRotate"),
        supportsNegativeValues: !0
      });
    },
    backdropInvert: ({ matchUtilities: T, theme: v }) => {
      T({
        "backdrop-invert": (w) => ({
          "--tw-backdrop-invert": `invert(${w})`,
          "@defaults backdrop-filter": {},
          "backdrop-filter": F
        })
      }, {
        values: v("backdropInvert")
      });
    },
    backdropOpacity: ({ matchUtilities: T, theme: v }) => {
      T({
        "backdrop-opacity": (w) => ({
          "--tw-backdrop-opacity": `opacity(${w})`,
          "@defaults backdrop-filter": {},
          "backdrop-filter": F
        })
      }, {
        values: v("backdropOpacity")
      });
    },
    backdropSaturate: ({ matchUtilities: T, theme: v }) => {
      T({
        "backdrop-saturate": (w) => ({
          "--tw-backdrop-saturate": `saturate(${w})`,
          "@defaults backdrop-filter": {},
          "backdrop-filter": F
        })
      }, {
        values: v("backdropSaturate")
      });
    },
    backdropSepia: ({ matchUtilities: T, theme: v }) => {
      T({
        "backdrop-sepia": (w) => ({
          "--tw-backdrop-sepia": `sepia(${w})`,
          "@defaults backdrop-filter": {},
          "backdrop-filter": F
        })
      }, {
        values: v("backdropSepia")
      });
    },
    backdropFilter: ({ addDefaults: T, addUtilities: v }) => {
      T("backdrop-filter", {
        "--tw-backdrop-blur": " ",
        "--tw-backdrop-brightness": " ",
        "--tw-backdrop-contrast": " ",
        "--tw-backdrop-grayscale": " ",
        "--tw-backdrop-hue-rotate": " ",
        "--tw-backdrop-invert": " ",
        "--tw-backdrop-opacity": " ",
        "--tw-backdrop-saturate": " ",
        "--tw-backdrop-sepia": " "
      }), v({
        ".backdrop-filter": {
          "@defaults backdrop-filter": {},
          "backdrop-filter": F
        },
        ".backdrop-filter-none": {
          "backdrop-filter": "none"
        }
      });
    },
    transitionProperty: ({ matchUtilities: T, theme: v }) => {
      let w = v("transitionTimingFunction.DEFAULT"), O = v("transitionDuration.DEFAULT");
      T({
        transition: (G) => ({
          "transition-property": G,
          ...G === "none" ? {} : {
            "transition-timing-function": w,
            "transition-duration": O
          }
        })
      }, {
        values: v("transitionProperty")
      });
    },
    transitionDelay: (0, u.default)("transitionDelay", [
      [
        "delay",
        [
          "transitionDelay"
        ]
      ]
    ]),
    transitionDuration: (0, u.default)("transitionDuration", [
      [
        "duration",
        [
          "transitionDuration"
        ]
      ]
    ], {
      filterDefault: !0
    }),
    transitionTimingFunction: (0, u.default)("transitionTimingFunction", [
      [
        "ease",
        [
          "transitionTimingFunction"
        ]
      ]
    ], {
      filterDefault: !0
    }),
    willChange: (0, u.default)("willChange", [
      [
        "will-change",
        [
          "will-change"
        ]
      ]
    ]),
    content: (0, u.default)("content", [
      [
        "content",
        [
          "--tw-content",
          [
            "content",
            "var(--tw-content)"
          ]
        ]
      ]
    ])
  };
})(vT);
var Xa = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(o, m) {
    for (var h in m)
      Object.defineProperty(o, h, {
        enumerable: !0,
        get: m[h]
      });
  }
  e(t, {
    env: function() {
      return c;
    },
    contextMap: function() {
      return u;
    },
    configContextMap: function() {
      return r;
    },
    contextSourcesMap: function() {
      return l;
    },
    sourceHashMap: function() {
      return i;
    },
    NOT_ON_DEMAND: function() {
      return f;
    },
    NONE: function() {
      return d;
    },
    resolveDebug: function() {
      return s;
    }
  });
  const n = /* @__PURE__ */ a(wT);
  function a(o) {
    return o && o.__esModule ? o : {
      default: o
    };
  }
  const c = typeof Ve.process < "u" ? {
    NODE_ENV: Ve.process.env.NODE_ENV,
    DEBUG: s(Ve.process.env.DEBUG),
    ENGINE: n.default.tailwindcss.engine
  } : {
    NODE_ENV: "production",
    DEBUG: !1,
    ENGINE: n.default.tailwindcss.engine
  }, u = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), f = new String("*"), d = Symbol("__NONE__");
  function s(o) {
    if (o === void 0)
      return !1;
    if (o === "true" || o === "1")
      return !0;
    if (o === "false" || o === "0")
      return !1;
    if (o === "*")
      return !0;
    let m = o.split(",").map((h) => h.split(":")[0]);
    return m.includes("-tailwindcss") ? !1 : !!m.includes("tailwindcss");
  }
})(Xa);
var Ey = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(
    t,
    // Arbitrary values must contain balanced brackets (), [] and {}. Escaped
    // values don't count, and brackets inside quotes also don't count.
    //
    // E.g.: w-[this-is]w-[weird-and-invalid]
    // E.g.: w-[this-is\\]w-\\[weird-but-valid]
    // E.g.: content-['this-is-also-valid]-weirdly-enough']
    "default",
    {
      enumerable: !0,
      get: function() {
        return c;
      }
    }
  );
  let e = /* @__PURE__ */ new Map([
    [
      "{",
      "}"
    ],
    [
      "[",
      "]"
    ],
    [
      "(",
      ")"
    ]
  ]), n = new Map(Array.from(e.entries()).map(([u, r]) => [
    r,
    u
  ])), a = /* @__PURE__ */ new Set([
    '"',
    "'",
    "`"
  ]);
  function c(u) {
    let r = [], l = !1;
    for (let i = 0; i < u.length; i++) {
      let f = u[i];
      if (f === ":" && !l && r.length === 0)
        return !1;
      if (a.has(f) && u[i - 1] !== "\\" && (l = !l), !l && u[i - 1] !== "\\") {
        if (e.has(f))
          r.push(f);
        else if (n.has(f)) {
          let d = n.get(f);
          if (r.length <= 0 || r.pop() !== d)
            return !1;
        }
      }
    }
    return !(r.length > 0);
  }
})(Ey);
var Nh = {}, _y = {}, Nd = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "movePseudos", {
    enumerable: !0,
    get: function() {
      return n;
    }
  });
  let e = {
    "::after": [
      "terminal",
      "jumpable"
    ],
    "::backdrop": [
      "terminal"
    ],
    "::before": [
      "terminal",
      "jumpable"
    ],
    "::cue": [
      "terminal"
    ],
    "::cue-region": [
      "terminal"
    ],
    "::first-letter": [
      "terminal",
      "jumpable"
    ],
    "::first-line": [
      "terminal",
      "jumpable"
    ],
    "::grammar-error": [
      "terminal"
    ],
    "::marker": [
      "terminal"
    ],
    "::part": [
      "terminal",
      "actionable"
    ],
    "::placeholder": [
      "terminal"
    ],
    "::selection": [
      "terminal"
    ],
    "::slotted": [
      "terminal"
    ],
    "::spelling-error": [
      "terminal"
    ],
    "::target-text": [
      "terminal"
    ],
    // other
    "::file-selector-button": [
      "terminal",
      "actionable"
    ],
    "::-webkit-progress-bar": [
      "terminal",
      "actionable"
    ],
    // Webkit scroll bar pseudo elements can be combined with user-action pseudo classes
    "::-webkit-scrollbar": [
      "terminal",
      "actionable"
    ],
    "::-webkit-scrollbar-button": [
      "terminal",
      "actionable"
    ],
    "::-webkit-scrollbar-thumb": [
      "terminal",
      "actionable"
    ],
    "::-webkit-scrollbar-track": [
      "terminal",
      "actionable"
    ],
    "::-webkit-scrollbar-track-piece": [
      "terminal",
      "actionable"
    ],
    "::-webkit-scrollbar-corner": [
      "terminal",
      "actionable"
    ],
    "::-webkit-resizer": [
      "terminal",
      "actionable"
    ],
    // Note: As a rule, double colons (::) should be used instead of a single colon
    // (:). This distinguishes pseudo-classes from pseudo-elements. However, since
    // this distinction was not present in older versions of the W3C spec, most
    // browsers support both syntaxes for the original pseudo-elements.
    ":after": [
      "terminal",
      "jumpable"
    ],
    ":before": [
      "terminal",
      "jumpable"
    ],
    ":first-letter": [
      "terminal",
      "jumpable"
    ],
    ":first-line": [
      "terminal",
      "jumpable"
    ],
    // The default value is used when the pseudo-element is not recognized
    // Because it's not recognized, we don't know if it's terminal or not
    // So we assume it can't be moved AND can have user-action pseudo classes attached to it
    __default__: [
      "actionable"
    ]
  };
  function n(i) {
    let [f] = a(i);
    return f.forEach(([d, s]) => d.removeChild(s)), i.nodes.push(...f.map(([, d]) => d)), i;
  }
  function a(i) {
    let f = [], d = null;
    for (let o of i.nodes)
      if (o.type === "combinator")
        f = f.filter(([, m]) => l(m).includes("jumpable")), d = null;
      else if (o.type === "pseudo") {
        u(o) ? (d = o, f.push([
          i,
          o,
          null
        ])) : d && r(o, d) ? f.push([
          i,
          o,
          d
        ]) : d = null;
        var s;
        for (let m of (s = o.nodes) !== null && s !== void 0 ? s : []) {
          let [h, y] = a(m);
          d = y || d, f.push(...h);
        }
      }
    return [
      f,
      d
    ];
  }
  function c(i) {
    return i.value.startsWith("::") || e[i.value] !== void 0;
  }
  function u(i) {
    return c(i) && l(i).includes("terminal");
  }
  function r(i, f) {
    return i.type !== "pseudo" || c(i) ? !1 : l(f).includes("actionable");
  }
  function l(i) {
    var f;
    return (f = e[i.value]) !== null && f !== void 0 ? f : e.__default__;
  }
})(Nd);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(y, b) {
    for (var E in b)
      Object.defineProperty(y, E, {
        enumerable: !0,
        get: b[E]
      });
  }
  e(t, {
    formatVariantSelector: function() {
      return f;
    },
    eliminateIrrelevantSelectors: function() {
      return o;
    },
    finalizeSelector: function() {
      return m;
    },
    handleMergePseudo: function() {
      return h;
    }
  });
  const n = /* @__PURE__ */ l(Ws), a = /* @__PURE__ */ l(sy), c = /* @__PURE__ */ l(rl), u = /* @__PURE__ */ l(Od), r = Nd;
  function l(y) {
    return y && y.__esModule ? y : {
      default: y
    };
  }
  let i = ":merge";
  function f(y, { context: b, candidate: E }) {
    var S;
    let g = (S = b == null ? void 0 : b.tailwindConfig.prefix) !== null && S !== void 0 ? S : "", P = y.map((N) => {
      let C = (0, n.default)().astSync(N.format);
      return {
        ...N,
        ast: N.isArbitraryVariant ? C : (0, u.default)(g, C)
      };
    }), R = n.default.root({
      nodes: [
        n.default.selector({
          nodes: [
            n.default.className({
              value: (0, c.default)(E)
            })
          ]
        })
      ]
    });
    for (let { ast: N } of P)
      [R, N] = h(R, N), N.walkNesting((C) => C.replaceWith(...R.nodes[0].nodes)), R = N;
    return R;
  }
  function d(y) {
    let b = [];
    for (; y.prev() && y.prev().type !== "combinator"; )
      y = y.prev();
    for (; y && y.type !== "combinator"; )
      b.push(y), y = y.next();
    return b;
  }
  function s(y) {
    return y.sort((b, E) => b.type === "tag" && E.type === "class" ? -1 : b.type === "class" && E.type === "tag" ? 1 : b.type === "class" && E.type === "pseudo" && E.value.startsWith("::") ? -1 : b.type === "pseudo" && b.value.startsWith("::") && E.type === "class" ? 1 : y.index(b) - y.index(E)), y;
  }
  function o(y, b) {
    let E = !1;
    y.walk((S) => {
      if (S.type === "class" && S.value === b)
        return E = !0, !1;
    }), E || y.remove();
  }
  function m(y, b, { context: E, candidate: S, base: g }) {
    var P, R;
    let N = (R = E == null || (P = E.tailwindConfig) === null || P === void 0 ? void 0 : P.separator) !== null && R !== void 0 ? R : ":";
    g = g ?? S.split(new RegExp(`\\${N}(?![^[]*\\])`)).pop();
    let C = (0, n.default)().astSync(y);
    C.walkClasses((F) => {
      F.raws && F.value.includes(g) && (F.raws.value = (0, c.default)((0, a.default)(F.raws.value)));
    }), C.each((F) => o(F, g));
    let I = Array.isArray(b) ? f(b, {
      context: E,
      candidate: S
    }) : b;
    if (I === null)
      return C.toString();
    let D = n.default.comment({
      value: "/*__simple__*/"
    }), j = n.default.comment({
      value: "/*__simple__*/"
    });
    return C.walkClasses((F) => {
      if (F.value !== g)
        return;
      let _ = F.parent, T = I.nodes[0].nodes;
      if (_.nodes.length === 1) {
        F.replaceWith(...T);
        return;
      }
      let v = d(F);
      _.insertBefore(v[0], D), _.insertAfter(v[v.length - 1], j);
      for (let O of T)
        _.insertBefore(v[0], O.clone());
      F.remove(), v = d(D);
      let w = _.index(D);
      _.nodes.splice(w, v.length, ...s(n.default.selector({
        nodes: v
      })).nodes), D.remove(), j.remove();
    }), C.walkPseudos((F) => {
      F.value === i && F.replaceWith(F.nodes);
    }), C.each((F) => (0, r.movePseudos)(F)), C.toString();
  }
  function h(y, b) {
    let E = [];
    return y.walkPseudos((S) => {
      S.value === i && E.push({
        pseudo: S,
        value: S.nodes[0].toString()
      });
    }), b.walkPseudos((S) => {
      if (S.value !== i)
        return;
      let g = S.nodes[0].toString(), P = E.find((I) => I.value === g);
      if (!P)
        return;
      let R = [], N = S.next();
      for (; N && N.type !== "combinator"; )
        R.push(N), N = N.next();
      let C = N;
      P.pseudo.parent.insertAfter(P.pseudo, n.default.selector({
        nodes: R.map((I) => I.clone())
      })), S.remove(), R.forEach((I) => I.remove()), C && C.type === "combinator" && C.remove();
    }), [
      y,
      b
    ];
  }
})(_y);
var Sy = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "applyImportantSelector", {
    enumerable: !0,
    get: function() {
      return c;
    }
  });
  const e = /* @__PURE__ */ a(Ws), n = Nd;
  function a(u) {
    return u && u.__esModule ? u : {
      default: u
    };
  }
  function c(u, r) {
    let l = (0, e.default)().astSync(u);
    return l.each((i) => {
      i.nodes[0].type === "pseudo" && i.nodes[0].value === ":is" && i.nodes.every((d) => d.type !== "combinator") || (i.nodes = [
        e.default.pseudo({
          value: ":is",
          nodes: [
            i.clone()
          ]
        })
      ]), (0, n.movePseudos)(i);
    }), `${r} ${l.toString()}`;
  }
})(Sy);
var oE;
function wy() {
  return oE || (oE = 1, function(t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    });
    function e($, Y) {
      for (var H in Y)
        Object.defineProperty($, H, {
          enumerable: !0,
          get: Y[H]
        });
    }
    e(t, {
      getClassNameFromSelector: function() {
        return N;
      },
      resolveMatches: function() {
        return B;
      },
      generateRules: function() {
        return z;
      }
    });
    const n = /* @__PURE__ */ S(vi), a = /* @__PURE__ */ S(Ws), c = /* @__PURE__ */ S(py), u = /* @__PURE__ */ S(tl), r = /* @__PURE__ */ S(Od), l = Pu, i = /* @__PURE__ */ S(Bi), f = /* @__PURE__ */ P(Xa), d = _y, s = vy, o = Iu, m = ab(), h = /* @__PURE__ */ S(Ey), y = Ou, b = _s, E = Sy;
    function S($) {
      return $ && $.__esModule ? $ : {
        default: $
      };
    }
    function g($) {
      if (typeof WeakMap != "function")
        return null;
      var Y = /* @__PURE__ */ new WeakMap(), H = /* @__PURE__ */ new WeakMap();
      return (g = function(Q) {
        return Q ? H : Y;
      })($);
    }
    function P($, Y) {
      if (!Y && $ && $.__esModule)
        return $;
      if ($ === null || typeof $ != "object" && typeof $ != "function")
        return {
          default: $
        };
      var H = g(Y);
      if (H && H.has($))
        return H.get($);
      var Q = {}, X = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var ne in $)
        if (ne !== "default" && Object.prototype.hasOwnProperty.call($, ne)) {
          var ye = X ? Object.getOwnPropertyDescriptor($, ne) : null;
          ye && (ye.get || ye.set) ? Object.defineProperty(Q, ne, ye) : Q[ne] = $[ne];
        }
      return Q.default = $, H && H.set($, Q), Q;
    }
    let R = (0, a.default)(($) => $.first.filter(({ type: Y }) => Y === "class").pop().value);
    function N($) {
      return R.transformSync($);
    }
    function* C($) {
      let Y = 1 / 0;
      for (; Y >= 0; ) {
        let H, Q = !1;
        if (Y === 1 / 0 && $.endsWith("]")) {
          let ye = $.indexOf("[");
          $[ye - 1] === "-" ? H = ye - 1 : $[ye - 1] === "/" ? (H = ye - 1, Q = !0) : H = -1;
        } else
          Y === 1 / 0 && $.includes("/") ? (H = $.lastIndexOf("/"), Q = !0) : H = $.lastIndexOf("-", Y);
        if (H < 0)
          break;
        let X = $.slice(0, H), ne = $.slice(Q ? H : H + 1);
        Y = H - 1, !(X === "" || ne === "/") && (yield [
          X,
          ne
        ]);
      }
    }
    function I($, Y) {
      if ($.length === 0 || Y.tailwindConfig.prefix === "")
        return $;
      for (let H of $) {
        let [Q] = H;
        if (Q.options.respectPrefix) {
          let X = n.default.root({
            nodes: [
              H[1].clone()
            ]
          }), ne = H[1].raws.tailwind.classCandidate;
          X.walkRules((ye) => {
            let ve = ne.startsWith("-");
            ye.selector = (0, r.default)(Y.tailwindConfig.prefix, ye.selector, ve);
          }), H[1] = X.nodes[0];
        }
      }
      return $;
    }
    function D($, Y) {
      if ($.length === 0)
        return $;
      let H = [];
      for (let [Q, X] of $) {
        let ne = n.default.root({
          nodes: [
            X.clone()
          ]
        });
        ne.walkRules((ye) => {
          let ve = (0, a.default)().astSync(ye.selector);
          ve.each((de) => (0, d.eliminateIrrelevantSelectors)(de, Y)), (0, l.updateAllClasses)(ve, (de) => de === Y ? `!${de}` : de), ye.selector = ve.toString(), ye.walkDecls((de) => de.important = !0);
        }), H.push([
          {
            ...Q,
            important: !0
          },
          ne.nodes[0]
        ]);
      }
      return H;
    }
    function j($, Y, H) {
      if (Y.length === 0)
        return Y;
      let Q = {
        modifier: null,
        value: f.NONE
      };
      {
        let [ne, ...ye] = (0, y.splitAtTopLevelOnly)($, "/");
        if (ye.length > 1 && (ne = ne + "/" + ye.slice(0, -1).join("/"), ye = ye.slice(-1)), ye.length && !H.variantMap.has($) && ($ = ne, Q.modifier = ye[0], !(0, b.flagEnabled)(H.tailwindConfig, "generalizedModifiers")))
          return [];
      }
      if ($.endsWith("]") && !$.startsWith("[")) {
        let ne = /(.)(-?)\[(.*)\]/g.exec($);
        if (ne) {
          let [, ye, ve, de] = ne;
          if (ye === "@" && ve === "-")
            return [];
          if (ye !== "@" && ve === "")
            return [];
          $ = $.replace(`${ve}[${de}]`, ""), Q.value = de;
        }
      }
      if (q($) && !H.variantMap.has($)) {
        let ne = H.offsets.recordVariant($), ye = (0, o.normalize)($.slice(1, -1)), ve = (0, y.splitAtTopLevelOnly)(ye, ",");
        if (ve.length > 1)
          return [];
        if (!ve.every(m.isValidVariantFormatString))
          return [];
        let de = ve.map((oe, re) => [
          H.offsets.applyParallelOffset(ne, re),
          (0, m.parseVariant)(oe.trim())
        ]);
        H.variantMap.set($, de);
      }
      if (H.variantMap.has($)) {
        let ne = q($), ye = H.variantMap.get($).slice(), ve = [];
        for (let [de, oe] of Y) {
          if (de.layer === "user")
            continue;
          let re = n.default.root({
            nodes: [
              oe.clone()
            ]
          });
          for (let [ae, le, ue] of ye) {
            let De = function() {
              ie.raws.neededBackup || (ie.raws.neededBackup = !0, ie.walkRules((me) => me.raws.originalSelector = me.selector));
            }, Ee = function(me) {
              return De(), ie.each((se) => {
                se.type === "rule" && (se.selectors = se.selectors.map((Z) => me({
                  get className() {
                    return N(Z);
                  },
                  selector: Z
                })));
              }), ie;
            }, ie = (ue ?? re).clone(), we = [], Ae = le({
              // Public API
              get container() {
                return De(), ie;
              },
              separator: H.tailwindConfig.separator,
              modifySelectors: Ee,
              // Private API for now
              wrap(me) {
                let se = ie.nodes;
                ie.removeAll(), me.append(se), ie.append(me);
              },
              format(me) {
                we.push({
                  format: me,
                  isArbitraryVariant: ne
                });
              },
              args: Q
            });
            if (Array.isArray(Ae)) {
              for (let [me, se] of Ae.entries())
                ye.push([
                  H.offsets.applyParallelOffset(ae, me),
                  se,
                  // If the clone has been modified we have to pass that back
                  // though so each rule can use the modified container
                  ie.clone()
                ]);
              continue;
            }
            if (typeof Ae == "string" && we.push({
              format: Ae,
              isArbitraryVariant: ne
            }), Ae === null)
              continue;
            ie.raws.neededBackup && (delete ie.raws.neededBackup, ie.walkRules((me) => {
              let se = me.raws.originalSelector;
              if (!se || (delete me.raws.originalSelector, se === me.selector))
                return;
              let Z = me.selector, pe = (0, a.default)((be) => {
                be.walkClasses((_e) => {
                  _e.value = `${$}${H.tailwindConfig.separator}${_e.value}`;
                });
              }).processSync(se);
              we.push({
                format: Z.replace(pe, "&"),
                isArbitraryVariant: ne
              }), me.selector = se;
            })), ie.nodes[0].raws.tailwind = {
              ...ie.nodes[0].raws.tailwind,
              parentLayer: de.layer
            };
            var X;
            let Me = [
              {
                ...de,
                sort: H.offsets.applyVariantOffset(de.sort, ae, Object.assign(Q, H.variantOptions.get($))),
                collectedFormats: ((X = de.collectedFormats) !== null && X !== void 0 ? X : []).concat(we)
              },
              ie.nodes[0]
            ];
            ve.push(Me);
          }
        }
        return ve;
      }
      return [];
    }
    function F($, Y, H = {}) {
      return !(0, u.default)($) && !Array.isArray($) ? [
        [
          $
        ],
        H
      ] : Array.isArray($) ? F($[0], Y, $[1]) : (Y.has($) || Y.set($, (0, c.default)($)), [
        Y.get($),
        H
      ]);
    }
    const _ = /^[a-z_-]/;
    function T($) {
      return _.test($);
    }
    function v($) {
      if (!$.includes("://"))
        return !1;
      try {
        const Y = new URL($);
        return Y.scheme !== "" && Y.host !== "";
      } catch {
        return !1;
      }
    }
    function w($) {
      let Y = !0;
      return $.walkDecls((H) => {
        if (!O(H.prop, H.value))
          return Y = !1, !1;
      }), Y;
    }
    function O($, Y) {
      if (v(`${$}:${Y}`))
        return !1;
      try {
        return n.default.parse(`a{${$}:${Y}}`).toResult(), !0;
      } catch {
        return !1;
      }
    }
    function G($, Y) {
      var H;
      let [, Q, X] = (H = $.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/)) !== null && H !== void 0 ? H : [];
      if (X === void 0 || !T(Q) || !(0, h.default)(X))
        return null;
      let ne = (0, o.normalize)(X);
      return O(Q, ne) ? [
        [
          {
            sort: Y.offsets.arbitraryProperty(),
            layer: "utilities"
          },
          () => ({
            [(0, s.asClass)($)]: {
              [Q]: ne
            }
          })
        ]
      ] : null;
    }
    function* W($, Y) {
      Y.candidateRuleMap.has($) && (yield [
        Y.candidateRuleMap.get($),
        "DEFAULT"
      ]), yield* function* (ve) {
        ve !== null && (yield [
          ve,
          "DEFAULT"
        ]);
      }(G($, Y));
      let H = $, Q = !1;
      const X = Y.tailwindConfig.prefix, ne = X.length, ye = H.startsWith(X) || H.startsWith(`-${X}`);
      H[ne] === "-" && ye && (Q = !0, H = X + H.slice(ne + 1)), Q && Y.candidateRuleMap.has(H) && (yield [
        Y.candidateRuleMap.get(H),
        "-DEFAULT"
      ]);
      for (let [ve, de] of C(H))
        Y.candidateRuleMap.has(ve) && (yield [
          Y.candidateRuleMap.get(ve),
          Q ? `-${de}` : de
        ]);
    }
    function U($, Y) {
      return $ === f.NOT_ON_DEMAND ? [
        f.NOT_ON_DEMAND
      ] : (0, y.splitAtTopLevelOnly)($, Y);
    }
    function* M($, Y) {
      for (const X of $) {
        var H, Q;
        X[1].raws.tailwind = {
          ...X[1].raws.tailwind,
          classCandidate: Y,
          preserveSource: (Q = (H = X[0].options) === null || H === void 0 ? void 0 : H.preserveSource) !== null && Q !== void 0 ? Q : !1
        }, yield X;
      }
    }
    function* B($, Y, H = $) {
      let Q = Y.tailwindConfig.separator, [X, ...ne] = U($, Q).reverse(), ye = !1;
      if (X.startsWith("!") && (ye = !0, X = X.slice(1)), (0, b.flagEnabled)(Y.tailwindConfig, "variantGrouping") && X.startsWith("(") && X.endsWith(")")) {
        let le = ne.slice().reverse().join(Q);
        for (let ue of (0, y.splitAtTopLevelOnly)(X.slice(1, -1), ","))
          yield* B(le + Q + ue, Y, H);
      }
      for (let le of W(X, Y)) {
        let ue = [], ie = /* @__PURE__ */ new Map(), [we, De] = le, Ee = we.length === 1;
        for (let [Ae, Me] of we) {
          let me = [];
          if (typeof Me == "function")
            for (let se of [].concat(Me(De, {
              isOnlyPlugin: Ee
            }))) {
              let [Z, pe] = F(se, Y.postCssNodeCache);
              for (let be of Z)
                me.push([
                  {
                    ...Ae,
                    options: {
                      ...Ae.options,
                      ...pe
                    }
                  },
                  be
                ]);
            }
          else if (De === "DEFAULT" || De === "-DEFAULT") {
            let se = Me, [Z, pe] = F(se, Y.postCssNodeCache);
            for (let be of Z)
              me.push([
                {
                  ...Ae,
                  options: {
                    ...Ae.options,
                    ...pe
                  }
                },
                be
              ]);
          }
          if (me.length > 0) {
            var ve, de, oe;
            let se = Array.from((0, l.getMatchingTypes)((de = (ve = Ae.options) === null || ve === void 0 ? void 0 : ve.types) !== null && de !== void 0 ? de : [], De, (oe = Ae.options) !== null && oe !== void 0 ? oe : {}, Y.tailwindConfig)).map(([Z, pe]) => pe);
            se.length > 0 && ie.set(me, se), ue.push(me);
          }
        }
        if (q(De)) {
          if (ue.length > 1) {
            let me = function(Z) {
              return Z.length === 1 ? Z[0] : Z.find((pe) => {
                let be = ie.get(pe);
                return pe.some(([{ options: _e }, Ie]) => w(Ie) ? _e.types.some(({ type: We, preferOnConflict: tt }) => be.includes(We) && tt) : !1);
              });
            }, [Ae, Me] = ue.reduce((Z, pe) => (pe.some(([{ options: _e }]) => _e.types.some(({ type: Ie }) => Ie === "any")) ? Z[0].push(pe) : Z[1].push(pe), Z), [
              [],
              []
            ]);
            var re;
            let se = (re = me(Me)) !== null && re !== void 0 ? re : me(Ae);
            if (se)
              ue = [
                se
              ];
            else {
              var ae;
              let Z = ue.map((be) => /* @__PURE__ */ new Set([
                ...(ae = ie.get(be)) !== null && ae !== void 0 ? ae : []
              ]));
              for (let be of Z)
                for (let _e of be) {
                  let Ie = !1;
                  for (let We of Z)
                    be !== We && We.has(_e) && (We.delete(_e), Ie = !0);
                  Ie && be.delete(_e);
                }
              let pe = [];
              for (let [be, _e] of Z.entries())
                for (let Ie of _e) {
                  let We = ue[be].map(([, tt]) => tt).flat().map((tt) => tt.toString().split(`
`).slice(1, -1).map((Ye) => Ye.trim()).map((Ye) => `      ${Ye}`).join(`
`)).join(`

`);
                  pe.push(`  Use \`${$.replace("[", `[${Ie}:`)}\` for \`${We.trim()}\``);
                  break;
                }
              i.default.warn([
                `The class \`${$}\` is ambiguous and matches multiple utilities.`,
                ...pe,
                `If this is content and not a class, replace it with \`${$.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`
              ]);
              continue;
            }
          }
          ue = ue.map((Ae) => Ae.filter((Me) => w(Me[1])));
        }
        ue = ue.flat(), ue = Array.from(M(ue, X)), ue = I(ue, Y), ye && (ue = D(ue, X));
        for (let Ae of ne)
          ue = j(Ae, ue, Y);
        for (let Ae of ue)
          Ae[1].raws.tailwind = {
            ...Ae[1].raws.tailwind,
            candidate: $
          }, Ae = k(Ae, {
            context: Y,
            candidate: $,
            original: H
          }), Ae !== null && (yield Ae);
      }
    }
    function k($, { context: Y, candidate: H, original: Q }) {
      if (!$[0].collectedFormats)
        return $;
      let X = !0, ne;
      try {
        ne = (0, d.formatVariantSelector)($[0].collectedFormats, {
          context: Y,
          candidate: H
        });
      } catch {
        return null;
      }
      let ye = n.default.root({
        nodes: [
          $[1].clone()
        ]
      });
      return ye.walkRules((ve) => {
        if (!K(ve))
          try {
            ve.selector = (0, d.finalizeSelector)(ve.selector, ne, {
              candidate: Q,
              context: Y
            });
          } catch {
            return X = !1, !1;
          }
      }), X ? ($[1] = ye.nodes[0], $) : null;
    }
    function K($) {
      return $.parent && $.parent.type === "atrule" && $.parent.name === "keyframes";
    }
    function te($) {
      if ($ === !0)
        return (Y) => {
          K(Y) || Y.walkDecls((H) => {
            H.parent.type === "rule" && !K(H.parent) && (H.important = !0);
          });
        };
      if (typeof $ == "string")
        return (Y) => {
          K(Y) || (Y.selectors = Y.selectors.map((H) => (0, E.applyImportantSelector)(H, $)));
        };
    }
    function z($, Y) {
      let H = [], Q = te(Y.tailwindConfig.important);
      for (let ne of $) {
        if (Y.notClassCache.has(ne))
          continue;
        if (Y.candidateRuleCache.has(ne)) {
          H = H.concat(Array.from(Y.candidateRuleCache.get(ne)));
          continue;
        }
        let ye = Array.from(B(ne, Y));
        if (ye.length === 0) {
          Y.notClassCache.add(ne);
          continue;
        }
        Y.classCache.set(ne, ye);
        var X;
        let ve = (X = Y.candidateRuleCache.get(ne)) !== null && X !== void 0 ? X : /* @__PURE__ */ new Set();
        Y.candidateRuleCache.set(ne, ve);
        for (const de of ye) {
          let [{ sort: oe, options: re }, ae] = de;
          if (re.respectImportant && Q) {
            let ue = n.default.root({
              nodes: [
                ae.clone()
              ]
            });
            ue.walkRules(Q), ae = ue.nodes[0];
          }
          let le = [
            oe,
            ae
          ];
          ve.add(le), Y.ruleCache.add(le), H.push(le);
        }
      }
      return H;
    }
    function q($) {
      return $.startsWith("[") && $.endsWith("]");
    }
  }(Nh)), Nh;
}
var AT = {}, Yt = {}, B1 = { exports: {} }, $1 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(t, e) {
  var n = fa, a = n.Buffer;
  function c(r, l) {
    for (var i in r)
      l[i] = r[i];
  }
  a.from && a.alloc && a.allocUnsafe && a.allocUnsafeSlow ? t.exports = n : (c(n, e), e.Buffer = u);
  function u(r, l, i) {
    return a(r, l, i);
  }
  u.prototype = Object.create(a.prototype), c(a, u), u.from = function(r, l, i) {
    if (typeof r == "number")
      throw new TypeError("Argument must not be a number");
    return a(r, l, i);
  }, u.alloc = function(r, l, i) {
    if (typeof r != "number")
      throw new TypeError("Argument must be a number");
    var f = a(r);
    return l !== void 0 ? typeof i == "string" ? f.fill(l, i) : f.fill(l) : f.fill(0), f;
  }, u.allocUnsafe = function(r) {
    if (typeof r != "number")
      throw new TypeError("Argument must be a number");
    return a(r);
  }, u.allocUnsafeSlow = function(r) {
    if (typeof r != "number")
      throw new TypeError("Argument must be a number");
    return n.SlowBuffer(r);
  };
})($1, $1.exports);
var er = $1.exports, Rh = 65536, f7 = 4294967295;
function d7() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var p7 = er.Buffer, Nf = Bt.crypto || Bt.msCrypto;
Nf && Nf.getRandomValues ? B1.exports = h7 : B1.exports = d7;
function h7(t, e) {
  if (t > f7)
    throw new RangeError("requested too many random bytes");
  var n = p7.allocUnsafe(t);
  if (t > 0)
    if (t > Rh)
      for (var a = 0; a < t; a += Rh)
        Nf.getRandomValues(n.slice(a, a + Rh));
    else
      Nf.getRandomValues(n);
  return typeof e == "function" ? Ve.process.nextTick(function() {
    e(null, n);
  }) : n;
}
var nl = B1.exports, U1 = { exports: {} }, xT = Tu.EventEmitter, Mh, lE;
function m7() {
  if (lE)
    return Mh;
  lE = 1;
  function t(h, y) {
    var b = Object.keys(h);
    if (Object.getOwnPropertySymbols) {
      var E = Object.getOwnPropertySymbols(h);
      y && (E = E.filter(function(S) {
        return Object.getOwnPropertyDescriptor(h, S).enumerable;
      })), b.push.apply(b, E);
    }
    return b;
  }
  function e(h) {
    for (var y = 1; y < arguments.length; y++) {
      var b = arguments[y] != null ? arguments[y] : {};
      y % 2 ? t(Object(b), !0).forEach(function(E) {
        n(h, E, b[E]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(h, Object.getOwnPropertyDescriptors(b)) : t(Object(b)).forEach(function(E) {
        Object.defineProperty(h, E, Object.getOwnPropertyDescriptor(b, E));
      });
    }
    return h;
  }
  function n(h, y, b) {
    return y = r(y), y in h ? Object.defineProperty(h, y, { value: b, enumerable: !0, configurable: !0, writable: !0 }) : h[y] = b, h;
  }
  function a(h, y) {
    if (!(h instanceof y))
      throw new TypeError("Cannot call a class as a function");
  }
  function c(h, y) {
    for (var b = 0; b < y.length; b++) {
      var E = y[b];
      E.enumerable = E.enumerable || !1, E.configurable = !0, "value" in E && (E.writable = !0), Object.defineProperty(h, r(E.key), E);
    }
  }
  function u(h, y, b) {
    return y && c(h.prototype, y), b && c(h, b), Object.defineProperty(h, "prototype", { writable: !1 }), h;
  }
  function r(h) {
    var y = l(h, "string");
    return typeof y == "symbol" ? y : String(y);
  }
  function l(h, y) {
    if (typeof h != "object" || h === null)
      return h;
    var b = h[Symbol.toPrimitive];
    if (b !== void 0) {
      var E = b.call(h, y || "default");
      if (typeof E != "object")
        return E;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (y === "string" ? String : Number)(h);
  }
  var i = fa, f = i.Buffer, d = xr, s = d.inspect, o = s && s.custom || "inspect";
  function m(h, y, b) {
    f.prototype.copy.call(h, y, b);
  }
  return Mh = /* @__PURE__ */ function() {
    function h() {
      a(this, h), this.head = null, this.tail = null, this.length = 0;
    }
    return u(h, [{
      key: "push",
      value: function(b) {
        var E = {
          data: b,
          next: null
        };
        this.length > 0 ? this.tail.next = E : this.head = E, this.tail = E, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(b) {
        var E = {
          data: b,
          next: this.head
        };
        this.length === 0 && (this.tail = E), this.head = E, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var b = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, b;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(b) {
        if (this.length === 0)
          return "";
        for (var E = this.head, S = "" + E.data; E = E.next; )
          S += b + E.data;
        return S;
      }
    }, {
      key: "concat",
      value: function(b) {
        if (this.length === 0)
          return f.alloc(0);
        for (var E = f.allocUnsafe(b >>> 0), S = this.head, g = 0; S; )
          m(S.data, E, g), g += S.data.length, S = S.next;
        return E;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(b, E) {
        var S;
        return b < this.head.data.length ? (S = this.head.data.slice(0, b), this.head.data = this.head.data.slice(b)) : b === this.head.data.length ? S = this.shift() : S = E ? this._getString(b) : this._getBuffer(b), S;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(b) {
        var E = this.head, S = 1, g = E.data;
        for (b -= g.length; E = E.next; ) {
          var P = E.data, R = b > P.length ? P.length : b;
          if (R === P.length ? g += P : g += P.slice(0, b), b -= R, b === 0) {
            R === P.length ? (++S, E.next ? this.head = E.next : this.head = this.tail = null) : (this.head = E, E.data = P.slice(R));
            break;
          }
          ++S;
        }
        return this.length -= S, g;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(b) {
        var E = f.allocUnsafe(b), S = this.head, g = 1;
        for (S.data.copy(E), b -= S.data.length; S = S.next; ) {
          var P = S.data, R = b > P.length ? P.length : b;
          if (P.copy(E, E.length - b, 0, R), b -= R, b === 0) {
            R === P.length ? (++g, S.next ? this.head = S.next : this.head = this.tail = null) : (this.head = S, S.data = P.slice(R));
            break;
          }
          ++g;
        }
        return this.length -= g, E;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: o,
      value: function(b, E) {
        return s(this, e(e({}, E), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), h;
  }(), Mh;
}
function y7(t, e) {
  var n = this, a = this._readableState && this._readableState.destroyed, c = this._writableState && this._writableState.destroyed;
  return a || c ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, Ve.process.nextTick(V1, this, t)) : Ve.process.nextTick(V1, this, t)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(t || null, function(u) {
    !e && u ? n._writableState ? n._writableState.errorEmitted ? Ve.process.nextTick(lf, n) : (n._writableState.errorEmitted = !0, Ve.process.nextTick(uE, n, u)) : Ve.process.nextTick(uE, n, u) : e ? (Ve.process.nextTick(lf, n), e(u)) : Ve.process.nextTick(lf, n);
  }), this);
}
function uE(t, e) {
  V1(t, e), lf(t);
}
function lf(t) {
  t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
}
function b7() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function V1(t, e) {
  t.emit("error", e);
}
function g7(t, e) {
  var n = t._readableState, a = t._writableState;
  n && n.autoDestroy || a && a.autoDestroy ? t.destroy(e) : t.emit("error", e);
}
var PT = {
  destroy: y7,
  undestroy: b7,
  errorOrDestroy: g7
}, Ja = {};
function v7(t, e) {
  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
}
var CT = {};
function Si(t, e, n) {
  n || (n = Error);
  function a(u, r, l) {
    return typeof e == "string" ? e : e(u, r, l);
  }
  var c = /* @__PURE__ */ function(u) {
    v7(r, u);
    function r(l, i, f) {
      return u.call(this, a(l, i, f)) || this;
    }
    return r;
  }(n);
  c.prototype.name = n.name, c.prototype.code = t, CT[t] = c;
}
function cE(t, e) {
  if (Array.isArray(t)) {
    var n = t.length;
    return t = t.map(function(a) {
      return String(a);
    }), n > 2 ? "one of ".concat(e, " ").concat(t.slice(0, n - 1).join(", "), ", or ") + t[n - 1] : n === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
  } else
    return "of ".concat(e, " ").concat(String(t));
}
function E7(t, e, n) {
  return t.substr(!n || n < 0 ? 0 : +n, e.length) === e;
}
function _7(t, e, n) {
  return (n === void 0 || n > t.length) && (n = t.length), t.substring(n - e.length, n) === e;
}
function S7(t, e, n) {
  return typeof n != "number" && (n = 0), n + e.length > t.length ? !1 : t.indexOf(e, n) !== -1;
}
Si("ERR_INVALID_OPT_VALUE", function(t, e) {
  return 'The value "' + e + '" is invalid for option "' + t + '"';
}, TypeError);
Si("ERR_INVALID_ARG_TYPE", function(t, e, n) {
  var a;
  typeof e == "string" && E7(e, "not ") ? (a = "must not be", e = e.replace(/^not /, "")) : a = "must be";
  var c;
  if (_7(t, " argument"))
    c = "The ".concat(t, " ").concat(a, " ").concat(cE(e, "type"));
  else {
    var u = S7(t, ".") ? "property" : "argument";
    c = 'The "'.concat(t, '" ').concat(u, " ").concat(a, " ").concat(cE(e, "type"));
  }
  return c += ". Received type ".concat(typeof n), c;
}, TypeError);
Si("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
Si("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
  return "The " + t + " method is not implemented";
});
Si("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
Si("ERR_STREAM_DESTROYED", function(t) {
  return "Cannot call " + t + " after a stream was destroyed";
});
Si("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
Si("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
Si("ERR_STREAM_WRITE_AFTER_END", "write after end");
Si("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
Si("ERR_UNKNOWN_ENCODING", function(t) {
  return "Unknown encoding: " + t;
}, TypeError);
Si("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
Ja.codes = CT;
var w7 = Ja.codes.ERR_INVALID_OPT_VALUE;
function T7(t, e, n) {
  return t.highWaterMark != null ? t.highWaterMark : e ? t[n] : null;
}
function A7(t, e, n, a) {
  var c = T7(e, a, n);
  if (c != null) {
    if (!(isFinite(c) && Math.floor(c) === c) || c < 0) {
      var u = a ? n : "highWaterMark";
      throw new w7(u, c);
    }
    return Math.floor(c);
  }
  return t.objectMode ? 16 : 16 * 1024;
}
var IT = {
  getHighWaterMark: A7
}, Lh, fE;
function OT() {
  if (fE)
    return Lh;
  fE = 1, Lh = I;
  function t(q) {
    var $ = this;
    this.next = null, this.entry = null, this.finish = function() {
      z($, q);
    };
  }
  var e;
  I.WritableState = N;
  var n = {
    deprecate: rT
  }, a = xT, c = fa.Buffer, u = (typeof Bt < "u" ? Bt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function r(q) {
    return c.from(q);
  }
  function l(q) {
    return c.isBuffer(q) || q instanceof u;
  }
  var i = PT, f = IT, d = f.getHighWaterMark, s = Ja.codes, o = s.ERR_INVALID_ARG_TYPE, m = s.ERR_METHOD_NOT_IMPLEMENTED, h = s.ERR_MULTIPLE_CALLBACK, y = s.ERR_STREAM_CANNOT_PIPE, b = s.ERR_STREAM_DESTROYED, E = s.ERR_STREAM_NULL_VALUES, S = s.ERR_STREAM_WRITE_AFTER_END, g = s.ERR_UNKNOWN_ENCODING, P = i.errorOrDestroy;
  Zt(I, a);
  function R() {
  }
  function N(q, $, Y) {
    e = e || Fo(), q = q || {}, typeof Y != "boolean" && (Y = $ instanceof e), this.objectMode = !!q.objectMode, Y && (this.objectMode = this.objectMode || !!q.writableObjectMode), this.highWaterMark = d(this, q, "writableHighWaterMark", Y), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var H = q.decodeStrings === !1;
    this.decodeStrings = !H, this.defaultEncoding = q.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Q) {
      O($, Q);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = q.emitClose !== !1, this.autoDestroy = !!q.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  N.prototype.getBuffer = function() {
    for (var $ = this.bufferedRequest, Y = []; $; )
      Y.push($), $ = $.next;
    return Y;
  }, function() {
    try {
      Object.defineProperty(N.prototype, "buffer", {
        get: n.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var C;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (C = Function.prototype[Symbol.hasInstance], Object.defineProperty(I, Symbol.hasInstance, {
    value: function($) {
      return C.call(this, $) ? !0 : this !== I ? !1 : $ && $._writableState instanceof N;
    }
  })) : C = function($) {
    return $ instanceof this;
  };
  function I(q) {
    e = e || Fo();
    var $ = this instanceof e;
    if (!$ && !C.call(I, this))
      return new I(q);
    this._writableState = new N(q, this, $), this.writable = !0, q && (typeof q.write == "function" && (this._write = q.write), typeof q.writev == "function" && (this._writev = q.writev), typeof q.destroy == "function" && (this._destroy = q.destroy), typeof q.final == "function" && (this._final = q.final)), a.call(this);
  }
  I.prototype.pipe = function() {
    P(this, new y());
  };
  function D(q, $) {
    var Y = new S();
    P(q, Y), Ve.process.nextTick($, Y);
  }
  function j(q, $, Y, H) {
    var Q;
    return Y === null ? Q = new E() : typeof Y != "string" && !$.objectMode && (Q = new o("chunk", ["string", "Buffer"], Y)), Q ? (P(q, Q), Ve.process.nextTick(H, Q), !1) : !0;
  }
  I.prototype.write = function(q, $, Y) {
    var H = this._writableState, Q = !1, X = !H.objectMode && l(q);
    return X && !c.isBuffer(q) && (q = r(q)), typeof $ == "function" && (Y = $, $ = null), X ? $ = "buffer" : $ || ($ = H.defaultEncoding), typeof Y != "function" && (Y = R), H.ending ? D(this, Y) : (X || j(this, H, q, Y)) && (H.pendingcb++, Q = _(this, H, X, q, $, Y)), Q;
  }, I.prototype.cork = function() {
    this._writableState.corked++;
  }, I.prototype.uncork = function() {
    var q = this._writableState;
    q.corked && (q.corked--, !q.writing && !q.corked && !q.bufferProcessing && q.bufferedRequest && U(this, q));
  }, I.prototype.setDefaultEncoding = function($) {
    if (typeof $ == "string" && ($ = $.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf(($ + "").toLowerCase()) > -1))
      throw new g($);
    return this._writableState.defaultEncoding = $, this;
  }, Object.defineProperty(I.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function F(q, $, Y) {
    return !q.objectMode && q.decodeStrings !== !1 && typeof $ == "string" && ($ = c.from($, Y)), $;
  }
  Object.defineProperty(I.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function _(q, $, Y, H, Q, X) {
    if (!Y) {
      var ne = F($, H, Q);
      H !== ne && (Y = !0, Q = "buffer", H = ne);
    }
    var ye = $.objectMode ? 1 : H.length;
    $.length += ye;
    var ve = $.length < $.highWaterMark;
    if (ve || ($.needDrain = !0), $.writing || $.corked) {
      var de = $.lastBufferedRequest;
      $.lastBufferedRequest = {
        chunk: H,
        encoding: Q,
        isBuf: Y,
        callback: X,
        next: null
      }, de ? de.next = $.lastBufferedRequest : $.bufferedRequest = $.lastBufferedRequest, $.bufferedRequestCount += 1;
    } else
      T(q, $, !1, ye, H, Q, X);
    return ve;
  }
  function T(q, $, Y, H, Q, X, ne) {
    $.writelen = H, $.writecb = ne, $.writing = !0, $.sync = !0, $.destroyed ? $.onwrite(new b("write")) : Y ? q._writev(Q, $.onwrite) : q._write(Q, X, $.onwrite), $.sync = !1;
  }
  function v(q, $, Y, H, Q) {
    --$.pendingcb, Y ? (Ve.process.nextTick(Q, H), Ve.process.nextTick(K, q, $), q._writableState.errorEmitted = !0, P(q, H)) : (Q(H), q._writableState.errorEmitted = !0, P(q, H), K(q, $));
  }
  function w(q) {
    q.writing = !1, q.writecb = null, q.length -= q.writelen, q.writelen = 0;
  }
  function O(q, $) {
    var Y = q._writableState, H = Y.sync, Q = Y.writecb;
    if (typeof Q != "function")
      throw new h();
    if (w(Y), $)
      v(q, Y, H, $, Q);
    else {
      var X = M(Y) || q.destroyed;
      !X && !Y.corked && !Y.bufferProcessing && Y.bufferedRequest && U(q, Y), H ? Ve.process.nextTick(G, q, Y, X, Q) : G(q, Y, X, Q);
    }
  }
  function G(q, $, Y, H) {
    Y || W(q, $), $.pendingcb--, H(), K(q, $);
  }
  function W(q, $) {
    $.length === 0 && $.needDrain && ($.needDrain = !1, q.emit("drain"));
  }
  function U(q, $) {
    $.bufferProcessing = !0;
    var Y = $.bufferedRequest;
    if (q._writev && Y && Y.next) {
      var H = $.bufferedRequestCount, Q = new Array(H), X = $.corkedRequestsFree;
      X.entry = Y;
      for (var ne = 0, ye = !0; Y; )
        Q[ne] = Y, Y.isBuf || (ye = !1), Y = Y.next, ne += 1;
      Q.allBuffers = ye, T(q, $, !0, $.length, Q, "", X.finish), $.pendingcb++, $.lastBufferedRequest = null, X.next ? ($.corkedRequestsFree = X.next, X.next = null) : $.corkedRequestsFree = new t($), $.bufferedRequestCount = 0;
    } else {
      for (; Y; ) {
        var ve = Y.chunk, de = Y.encoding, oe = Y.callback, re = $.objectMode ? 1 : ve.length;
        if (T(q, $, !1, re, ve, de, oe), Y = Y.next, $.bufferedRequestCount--, $.writing)
          break;
      }
      Y === null && ($.lastBufferedRequest = null);
    }
    $.bufferedRequest = Y, $.bufferProcessing = !1;
  }
  I.prototype._write = function(q, $, Y) {
    Y(new m("_write()"));
  }, I.prototype._writev = null, I.prototype.end = function(q, $, Y) {
    var H = this._writableState;
    return typeof q == "function" ? (Y = q, q = null, $ = null) : typeof $ == "function" && (Y = $, $ = null), q != null && this.write(q, $), H.corked && (H.corked = 1, this.uncork()), H.ending || te(this, H, Y), this;
  }, Object.defineProperty(I.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function M(q) {
    return q.ending && q.length === 0 && q.bufferedRequest === null && !q.finished && !q.writing;
  }
  function B(q, $) {
    q._final(function(Y) {
      $.pendingcb--, Y && P(q, Y), $.prefinished = !0, q.emit("prefinish"), K(q, $);
    });
  }
  function k(q, $) {
    !$.prefinished && !$.finalCalled && (typeof q._final == "function" && !$.destroyed ? ($.pendingcb++, $.finalCalled = !0, Ve.process.nextTick(B, q, $)) : ($.prefinished = !0, q.emit("prefinish")));
  }
  function K(q, $) {
    var Y = M($);
    if (Y && (k(q, $), $.pendingcb === 0 && ($.finished = !0, q.emit("finish"), $.autoDestroy))) {
      var H = q._readableState;
      (!H || H.autoDestroy && H.endEmitted) && q.destroy();
    }
    return Y;
  }
  function te(q, $, Y) {
    $.ending = !0, K(q, $), Y && ($.finished ? Ve.process.nextTick(Y) : q.once("finish", Y)), $.ended = !0, q.writable = !1;
  }
  function z(q, $, Y) {
    var H = q.entry;
    for (q.entry = null; H; ) {
      var Q = H.callback;
      $.pendingcb--, Q(Y), H = H.next;
    }
    $.corkedRequestsFree.next = q;
  }
  return Object.defineProperty(I.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function($) {
      this._writableState && (this._writableState.destroyed = $);
    }
  }), I.prototype.destroy = i.destroy, I.prototype._undestroy = i.undestroy, I.prototype._destroy = function(q, $) {
    $(q);
  }, Lh;
}
var jh, dE;
function Fo() {
  if (dE)
    return jh;
  dE = 1;
  var t = Object.keys || function(f) {
    var d = [];
    for (var s in f)
      d.push(s);
    return d;
  };
  jh = r;
  var e = DT(), n = OT();
  Zt(r, e);
  for (var a = t(n.prototype), c = 0; c < a.length; c++) {
    var u = a[c];
    r.prototype[u] || (r.prototype[u] = n.prototype[u]);
  }
  function r(f) {
    if (!(this instanceof r))
      return new r(f);
    e.call(this, f), n.call(this, f), this.allowHalfOpen = !0, f && (f.readable === !1 && (this.readable = !1), f.writable === !1 && (this.writable = !1), f.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", l)));
  }
  Object.defineProperty(r.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(r.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(r.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function l() {
    this._writableState.ended || Ve.process.nextTick(i, this);
  }
  function i(f) {
    f.end();
  }
  return Object.defineProperty(r.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(d) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = d, this._writableState.destroyed = d);
    }
  }), jh;
}
var Rf = {}, Ty = er.Buffer, pE = Ty.isEncoding || function(t) {
  switch (t = "" + t, t && t.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function x7(t) {
  if (!t)
    return "utf8";
  for (var e; ; )
    switch (t) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return t;
      default:
        if (e)
          return;
        t = ("" + t).toLowerCase(), e = !0;
    }
}
function P7(t) {
  var e = x7(t);
  if (typeof e != "string" && (Ty.isEncoding === pE || !pE(t)))
    throw new Error("Unknown encoding: " + t);
  return e || t;
}
Rf.StringDecoder = Ru;
function Ru(t) {
  this.encoding = P7(t);
  var e;
  switch (this.encoding) {
    case "utf16le":
      this.text = N7, this.end = R7, e = 4;
      break;
    case "utf8":
      this.fillLast = O7, e = 4;
      break;
    case "base64":
      this.text = M7, this.end = L7, e = 3;
      break;
    default:
      this.write = j7, this.end = F7;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Ty.allocUnsafe(e);
}
Ru.prototype.write = function(t) {
  if (t.length === 0)
    return "";
  var e, n;
  if (this.lastNeed) {
    if (e = this.fillLast(t), e === void 0)
      return "";
    n = this.lastNeed, this.lastNeed = 0;
  } else
    n = 0;
  return n < t.length ? e ? e + this.text(t, n) : this.text(t, n) : e || "";
};
Ru.prototype.end = D7;
Ru.prototype.text = k7;
Ru.prototype.fillLast = function(t) {
  if (this.lastNeed <= t.length)
    return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
};
function Fh(t) {
  return t <= 127 ? 0 : t >> 5 === 6 ? 2 : t >> 4 === 14 ? 3 : t >> 3 === 30 ? 4 : t >> 6 === 2 ? -1 : -2;
}
function C7(t, e, n) {
  var a = e.length - 1;
  if (a < n)
    return 0;
  var c = Fh(e[a]);
  return c >= 0 ? (c > 0 && (t.lastNeed = c - 1), c) : --a < n || c === -2 ? 0 : (c = Fh(e[a]), c >= 0 ? (c > 0 && (t.lastNeed = c - 2), c) : --a < n || c === -2 ? 0 : (c = Fh(e[a]), c >= 0 ? (c > 0 && (c === 2 ? c = 0 : t.lastNeed = c - 3), c) : 0));
}
function I7(t, e, n) {
  if ((e[0] & 192) !== 128)
    return t.lastNeed = 0, "";
  if (t.lastNeed > 1 && e.length > 1) {
    if ((e[1] & 192) !== 128)
      return t.lastNeed = 1, "";
    if (t.lastNeed > 2 && e.length > 2 && (e[2] & 192) !== 128)
      return t.lastNeed = 2, "";
  }
}
function O7(t) {
  var e = this.lastTotal - this.lastNeed, n = I7(this, t);
  if (n !== void 0)
    return n;
  if (this.lastNeed <= t.length)
    return t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  t.copy(this.lastChar, e, 0, t.length), this.lastNeed -= t.length;
}
function k7(t, e) {
  var n = C7(this, t, e);
  if (!this.lastNeed)
    return t.toString("utf8", e);
  this.lastTotal = n;
  var a = t.length - (n - this.lastNeed);
  return t.copy(this.lastChar, 0, a), t.toString("utf8", e, a);
}
function D7(t) {
  var e = t && t.length ? this.write(t) : "";
  return this.lastNeed ? e + "" : e;
}
function N7(t, e) {
  if ((t.length - e) % 2 === 0) {
    var n = t.toString("utf16le", e);
    if (n) {
      var a = n.charCodeAt(n.length - 1);
      if (a >= 55296 && a <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], n.slice(0, -1);
    }
    return n;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1);
}
function R7(t) {
  var e = t && t.length ? this.write(t) : "";
  if (this.lastNeed) {
    var n = this.lastTotal - this.lastNeed;
    return e + this.lastChar.toString("utf16le", 0, n);
  }
  return e;
}
function M7(t, e) {
  var n = (t.length - e) % 3;
  return n === 0 ? t.toString("base64", e) : (this.lastNeed = 3 - n, this.lastTotal = 3, n === 1 ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - n));
}
function L7(t) {
  var e = t && t.length ? this.write(t) : "";
  return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
}
function j7(t) {
  return t.toString(this.encoding);
}
function F7(t) {
  return t && t.length ? this.write(t) : "";
}
var hE = Ja.codes.ERR_STREAM_PREMATURE_CLOSE;
function B7(t) {
  var e = !1;
  return function() {
    if (!e) {
      e = !0;
      for (var n = arguments.length, a = new Array(n), c = 0; c < n; c++)
        a[c] = arguments[c];
      t.apply(this, a);
    }
  };
}
function $7() {
}
function U7(t) {
  return t.setHeader && typeof t.abort == "function";
}
function kT(t, e, n) {
  if (typeof e == "function")
    return kT(t, null, e);
  e || (e = {}), n = B7(n || $7);
  var a = e.readable || e.readable !== !1 && t.readable, c = e.writable || e.writable !== !1 && t.writable, u = function() {
    t.writable || l();
  }, r = t._writableState && t._writableState.finished, l = function() {
    c = !1, r = !0, a || n.call(t);
  }, i = t._readableState && t._readableState.endEmitted, f = function() {
    a = !1, i = !0, c || n.call(t);
  }, d = function(h) {
    n.call(t, h);
  }, s = function() {
    var h;
    if (a && !i)
      return (!t._readableState || !t._readableState.ended) && (h = new hE()), n.call(t, h);
    if (c && !r)
      return (!t._writableState || !t._writableState.ended) && (h = new hE()), n.call(t, h);
  }, o = function() {
    t.req.on("finish", l);
  };
  return U7(t) ? (t.on("complete", l), t.on("abort", s), t.req ? o() : t.on("request", o)) : c && !t._writableState && (t.on("end", u), t.on("close", u)), t.on("end", f), t.on("finish", l), e.error !== !1 && t.on("error", d), t.on("close", s), function() {
    t.removeListener("complete", l), t.removeListener("abort", s), t.removeListener("request", o), t.req && t.req.removeListener("finish", l), t.removeListener("end", u), t.removeListener("close", u), t.removeListener("finish", l), t.removeListener("end", f), t.removeListener("error", d), t.removeListener("close", s);
  };
}
var Ay = kT, Bh, mE;
function V7() {
  if (mE)
    return Bh;
  mE = 1;
  var t;
  function e(g, P, R) {
    return P = n(P), P in g ? Object.defineProperty(g, P, { value: R, enumerable: !0, configurable: !0, writable: !0 }) : g[P] = R, g;
  }
  function n(g) {
    var P = a(g, "string");
    return typeof P == "symbol" ? P : String(P);
  }
  function a(g, P) {
    if (typeof g != "object" || g === null)
      return g;
    var R = g[Symbol.toPrimitive];
    if (R !== void 0) {
      var N = R.call(g, P || "default");
      if (typeof N != "object")
        return N;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (P === "string" ? String : Number)(g);
  }
  var c = Ay, u = Symbol("lastResolve"), r = Symbol("lastReject"), l = Symbol("error"), i = Symbol("ended"), f = Symbol("lastPromise"), d = Symbol("handlePromise"), s = Symbol("stream");
  function o(g, P) {
    return {
      value: g,
      done: P
    };
  }
  function m(g) {
    var P = g[u];
    if (P !== null) {
      var R = g[s].read();
      R !== null && (g[f] = null, g[u] = null, g[r] = null, P(o(R, !1)));
    }
  }
  function h(g) {
    Ve.process.nextTick(m, g);
  }
  function y(g, P) {
    return function(R, N) {
      g.then(function() {
        if (P[i]) {
          R(o(void 0, !0));
          return;
        }
        P[d](R, N);
      }, N);
    };
  }
  var b = Object.getPrototypeOf(function() {
  }), E = Object.setPrototypeOf((t = {
    get stream() {
      return this[s];
    },
    next: function() {
      var P = this, R = this[l];
      if (R !== null)
        return Promise.reject(R);
      if (this[i])
        return Promise.resolve(o(void 0, !0));
      if (this[s].destroyed)
        return new Promise(function(D, j) {
          Ve.process.nextTick(function() {
            P[l] ? j(P[l]) : D(o(void 0, !0));
          });
        });
      var N = this[f], C;
      if (N)
        C = new Promise(y(N, this));
      else {
        var I = this[s].read();
        if (I !== null)
          return Promise.resolve(o(I, !1));
        C = new Promise(this[d]);
      }
      return this[f] = C, C;
    }
  }, e(t, Symbol.asyncIterator, function() {
    return this;
  }), e(t, "return", function() {
    var P = this;
    return new Promise(function(R, N) {
      P[s].destroy(null, function(C) {
        if (C) {
          N(C);
          return;
        }
        R(o(void 0, !0));
      });
    });
  }), t), b), S = function(P) {
    var R, N = Object.create(E, (R = {}, e(R, s, {
      value: P,
      writable: !0
    }), e(R, u, {
      value: null,
      writable: !0
    }), e(R, r, {
      value: null,
      writable: !0
    }), e(R, l, {
      value: null,
      writable: !0
    }), e(R, i, {
      value: P._readableState.endEmitted,
      writable: !0
    }), e(R, d, {
      value: function(I, D) {
        var j = N[s].read();
        j ? (N[f] = null, N[u] = null, N[r] = null, I(o(j, !1))) : (N[u] = I, N[r] = D);
      },
      writable: !0
    }), R));
    return N[f] = null, c(P, function(C) {
      if (C && C.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var I = N[r];
        I !== null && (N[f] = null, N[u] = null, N[r] = null, I(C)), N[l] = C;
        return;
      }
      var D = N[u];
      D !== null && (N[f] = null, N[u] = null, N[r] = null, D(o(void 0, !0))), N[i] = !0;
    }), P.on("readable", h.bind(null, N)), N;
  };
  return Bh = S, Bh;
}
var $h, yE;
function W7() {
  return yE || (yE = 1, $h = function() {
    throw new Error("Readable.from is not available in the browser");
  }), $h;
}
var Uh, bE;
function DT() {
  if (bE)
    return Uh;
  bE = 1, Uh = D;
  var t;
  D.ReadableState = I, Tu.EventEmitter;
  var e = function(ne, ye) {
    return ne.listeners(ye).length;
  }, n = xT, a = fa.Buffer, c = (typeof Bt < "u" ? Bt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function u(X) {
    return a.from(X);
  }
  function r(X) {
    return a.isBuffer(X) || X instanceof c;
  }
  var l = xr, i;
  l && l.debuglog ? i = l.debuglog("stream") : i = function() {
  };
  var f = m7(), d = PT, s = IT, o = s.getHighWaterMark, m = Ja.codes, h = m.ERR_INVALID_ARG_TYPE, y = m.ERR_STREAM_PUSH_AFTER_EOF, b = m.ERR_METHOD_NOT_IMPLEMENTED, E = m.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, S, g, P;
  Zt(D, n);
  var R = d.errorOrDestroy, N = ["error", "close", "destroy", "pause", "resume"];
  function C(X, ne, ye) {
    if (typeof X.prependListener == "function")
      return X.prependListener(ne, ye);
    !X._events || !X._events[ne] ? X.on(ne, ye) : Array.isArray(X._events[ne]) ? X._events[ne].unshift(ye) : X._events[ne] = [ye, X._events[ne]];
  }
  function I(X, ne, ye) {
    t = t || Fo(), X = X || {}, typeof ye != "boolean" && (ye = ne instanceof t), this.objectMode = !!X.objectMode, ye && (this.objectMode = this.objectMode || !!X.readableObjectMode), this.highWaterMark = o(this, X, "readableHighWaterMark", ye), this.buffer = new f(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = X.emitClose !== !1, this.autoDestroy = !!X.autoDestroy, this.destroyed = !1, this.defaultEncoding = X.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, X.encoding && (S || (S = Rf.StringDecoder), this.decoder = new S(X.encoding), this.encoding = X.encoding);
  }
  function D(X) {
    if (t = t || Fo(), !(this instanceof D))
      return new D(X);
    var ne = this instanceof t;
    this._readableState = new I(X, this, ne), this.readable = !0, X && (typeof X.read == "function" && (this._read = X.read), typeof X.destroy == "function" && (this._destroy = X.destroy)), n.call(this);
  }
  Object.defineProperty(D.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(ne) {
      this._readableState && (this._readableState.destroyed = ne);
    }
  }), D.prototype.destroy = d.destroy, D.prototype._undestroy = d.undestroy, D.prototype._destroy = function(X, ne) {
    ne(X);
  }, D.prototype.push = function(X, ne) {
    var ye = this._readableState, ve;
    return ye.objectMode ? ve = !0 : typeof X == "string" && (ne = ne || ye.defaultEncoding, ne !== ye.encoding && (X = a.from(X, ne), ne = ""), ve = !0), j(this, X, ne, !1, ve);
  }, D.prototype.unshift = function(X) {
    return j(this, X, null, !0, !1);
  };
  function j(X, ne, ye, ve, de) {
    i("readableAddChunk", ne);
    var oe = X._readableState;
    if (ne === null)
      oe.reading = !1, O(X, oe);
    else {
      var re;
      if (de || (re = _(oe, ne)), re)
        R(X, re);
      else if (oe.objectMode || ne && ne.length > 0)
        if (typeof ne != "string" && !oe.objectMode && Object.getPrototypeOf(ne) !== a.prototype && (ne = u(ne)), ve)
          oe.endEmitted ? R(X, new E()) : F(X, oe, ne, !0);
        else if (oe.ended)
          R(X, new y());
        else {
          if (oe.destroyed)
            return !1;
          oe.reading = !1, oe.decoder && !ye ? (ne = oe.decoder.write(ne), oe.objectMode || ne.length !== 0 ? F(X, oe, ne, !1) : U(X, oe)) : F(X, oe, ne, !1);
        }
      else
        ve || (oe.reading = !1, U(X, oe));
    }
    return !oe.ended && (oe.length < oe.highWaterMark || oe.length === 0);
  }
  function F(X, ne, ye, ve) {
    ne.flowing && ne.length === 0 && !ne.sync ? (ne.awaitDrain = 0, X.emit("data", ye)) : (ne.length += ne.objectMode ? 1 : ye.length, ve ? ne.buffer.unshift(ye) : ne.buffer.push(ye), ne.needReadable && G(X)), U(X, ne);
  }
  function _(X, ne) {
    var ye;
    return !r(ne) && typeof ne != "string" && ne !== void 0 && !X.objectMode && (ye = new h("chunk", ["string", "Buffer", "Uint8Array"], ne)), ye;
  }
  D.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, D.prototype.setEncoding = function(X) {
    S || (S = Rf.StringDecoder);
    var ne = new S(X);
    this._readableState.decoder = ne, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var ye = this._readableState.buffer.head, ve = ""; ye !== null; )
      ve += ne.write(ye.data), ye = ye.next;
    return this._readableState.buffer.clear(), ve !== "" && this._readableState.buffer.push(ve), this._readableState.length = ve.length, this;
  };
  var T = 1073741824;
  function v(X) {
    return X >= T ? X = T : (X--, X |= X >>> 1, X |= X >>> 2, X |= X >>> 4, X |= X >>> 8, X |= X >>> 16, X++), X;
  }
  function w(X, ne) {
    return X <= 0 || ne.length === 0 && ne.ended ? 0 : ne.objectMode ? 1 : X !== X ? ne.flowing && ne.length ? ne.buffer.head.data.length : ne.length : (X > ne.highWaterMark && (ne.highWaterMark = v(X)), X <= ne.length ? X : ne.ended ? ne.length : (ne.needReadable = !0, 0));
  }
  D.prototype.read = function(X) {
    i("read", X), X = parseInt(X, 10);
    var ne = this._readableState, ye = X;
    if (X !== 0 && (ne.emittedReadable = !1), X === 0 && ne.needReadable && ((ne.highWaterMark !== 0 ? ne.length >= ne.highWaterMark : ne.length > 0) || ne.ended))
      return i("read: emitReadable", ne.length, ne.ended), ne.length === 0 && ne.ended ? Y(this) : G(this), null;
    if (X = w(X, ne), X === 0 && ne.ended)
      return ne.length === 0 && Y(this), null;
    var ve = ne.needReadable;
    i("need readable", ve), (ne.length === 0 || ne.length - X < ne.highWaterMark) && (ve = !0, i("length less than watermark", ve)), ne.ended || ne.reading ? (ve = !1, i("reading or ended", ve)) : ve && (i("do read"), ne.reading = !0, ne.sync = !0, ne.length === 0 && (ne.needReadable = !0), this._read(ne.highWaterMark), ne.sync = !1, ne.reading || (X = w(ye, ne)));
    var de;
    return X > 0 ? de = $(X, ne) : de = null, de === null ? (ne.needReadable = ne.length <= ne.highWaterMark, X = 0) : (ne.length -= X, ne.awaitDrain = 0), ne.length === 0 && (ne.ended || (ne.needReadable = !0), ye !== X && ne.ended && Y(this)), de !== null && this.emit("data", de), de;
  };
  function O(X, ne) {
    if (i("onEofChunk"), !ne.ended) {
      if (ne.decoder) {
        var ye = ne.decoder.end();
        ye && ye.length && (ne.buffer.push(ye), ne.length += ne.objectMode ? 1 : ye.length);
      }
      ne.ended = !0, ne.sync ? G(X) : (ne.needReadable = !1, ne.emittedReadable || (ne.emittedReadable = !0, W(X)));
    }
  }
  function G(X) {
    var ne = X._readableState;
    i("emitReadable", ne.needReadable, ne.emittedReadable), ne.needReadable = !1, ne.emittedReadable || (i("emitReadable", ne.flowing), ne.emittedReadable = !0, Ve.process.nextTick(W, X));
  }
  function W(X) {
    var ne = X._readableState;
    i("emitReadable_", ne.destroyed, ne.length, ne.ended), !ne.destroyed && (ne.length || ne.ended) && (X.emit("readable"), ne.emittedReadable = !1), ne.needReadable = !ne.flowing && !ne.ended && ne.length <= ne.highWaterMark, q(X);
  }
  function U(X, ne) {
    ne.readingMore || (ne.readingMore = !0, Ve.process.nextTick(M, X, ne));
  }
  function M(X, ne) {
    for (; !ne.reading && !ne.ended && (ne.length < ne.highWaterMark || ne.flowing && ne.length === 0); ) {
      var ye = ne.length;
      if (i("maybeReadMore read 0"), X.read(0), ye === ne.length)
        break;
    }
    ne.readingMore = !1;
  }
  D.prototype._read = function(X) {
    R(this, new b("_read()"));
  }, D.prototype.pipe = function(X, ne) {
    var ye = this, ve = this._readableState;
    switch (ve.pipesCount) {
      case 0:
        ve.pipes = X;
        break;
      case 1:
        ve.pipes = [ve.pipes, X];
        break;
      default:
        ve.pipes.push(X);
        break;
    }
    ve.pipesCount += 1, i("pipe count=%d opts=%j", ve.pipesCount, ne);
    var de = (!ne || ne.end !== !1) && X !== Ve.process.stdout && X !== Ve.process.stderr, oe = de ? ae : Me;
    ve.endEmitted ? Ve.process.nextTick(oe) : ye.once("end", oe), X.on("unpipe", re);
    function re(me, se) {
      i("onunpipe"), me === ye && se && se.hasUnpiped === !1 && (se.hasUnpiped = !0, ie());
    }
    function ae() {
      i("onend"), X.end();
    }
    var le = B(ye);
    X.on("drain", le);
    var ue = !1;
    function ie() {
      i("cleanup"), X.removeListener("close", Ee), X.removeListener("finish", Ae), X.removeListener("drain", le), X.removeListener("error", De), X.removeListener("unpipe", re), ye.removeListener("end", ae), ye.removeListener("end", Me), ye.removeListener("data", we), ue = !0, ve.awaitDrain && (!X._writableState || X._writableState.needDrain) && le();
    }
    ye.on("data", we);
    function we(me) {
      i("ondata");
      var se = X.write(me);
      i("dest.write", se), se === !1 && ((ve.pipesCount === 1 && ve.pipes === X || ve.pipesCount > 1 && Q(ve.pipes, X) !== -1) && !ue && (i("false write response, pause", ve.awaitDrain), ve.awaitDrain++), ye.pause());
    }
    function De(me) {
      i("onerror", me), Me(), X.removeListener("error", De), e(X, "error") === 0 && R(X, me);
    }
    C(X, "error", De);
    function Ee() {
      X.removeListener("finish", Ae), Me();
    }
    X.once("close", Ee);
    function Ae() {
      i("onfinish"), X.removeListener("close", Ee), Me();
    }
    X.once("finish", Ae);
    function Me() {
      i("unpipe"), ye.unpipe(X);
    }
    return X.emit("pipe", ye), ve.flowing || (i("pipe resume"), ye.resume()), X;
  };
  function B(X) {
    return function() {
      var ye = X._readableState;
      i("pipeOnDrain", ye.awaitDrain), ye.awaitDrain && ye.awaitDrain--, ye.awaitDrain === 0 && e(X, "data") && (ye.flowing = !0, q(X));
    };
  }
  D.prototype.unpipe = function(X) {
    var ne = this._readableState, ye = {
      hasUnpiped: !1
    };
    if (ne.pipesCount === 0)
      return this;
    if (ne.pipesCount === 1)
      return X && X !== ne.pipes ? this : (X || (X = ne.pipes), ne.pipes = null, ne.pipesCount = 0, ne.flowing = !1, X && X.emit("unpipe", this, ye), this);
    if (!X) {
      var ve = ne.pipes, de = ne.pipesCount;
      ne.pipes = null, ne.pipesCount = 0, ne.flowing = !1;
      for (var oe = 0; oe < de; oe++)
        ve[oe].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var re = Q(ne.pipes, X);
    return re === -1 ? this : (ne.pipes.splice(re, 1), ne.pipesCount -= 1, ne.pipesCount === 1 && (ne.pipes = ne.pipes[0]), X.emit("unpipe", this, ye), this);
  }, D.prototype.on = function(X, ne) {
    var ye = n.prototype.on.call(this, X, ne), ve = this._readableState;
    return X === "data" ? (ve.readableListening = this.listenerCount("readable") > 0, ve.flowing !== !1 && this.resume()) : X === "readable" && !ve.endEmitted && !ve.readableListening && (ve.readableListening = ve.needReadable = !0, ve.flowing = !1, ve.emittedReadable = !1, i("on readable", ve.length, ve.reading), ve.length ? G(this) : ve.reading || Ve.process.nextTick(K, this)), ye;
  }, D.prototype.addListener = D.prototype.on, D.prototype.removeListener = function(X, ne) {
    var ye = n.prototype.removeListener.call(this, X, ne);
    return X === "readable" && Ve.process.nextTick(k, this), ye;
  }, D.prototype.removeAllListeners = function(X) {
    var ne = n.prototype.removeAllListeners.apply(this, arguments);
    return (X === "readable" || X === void 0) && Ve.process.nextTick(k, this), ne;
  };
  function k(X) {
    var ne = X._readableState;
    ne.readableListening = X.listenerCount("readable") > 0, ne.resumeScheduled && !ne.paused ? ne.flowing = !0 : X.listenerCount("data") > 0 && X.resume();
  }
  function K(X) {
    i("readable nexttick read 0"), X.read(0);
  }
  D.prototype.resume = function() {
    var X = this._readableState;
    return X.flowing || (i("resume"), X.flowing = !X.readableListening, te(this, X)), X.paused = !1, this;
  };
  function te(X, ne) {
    ne.resumeScheduled || (ne.resumeScheduled = !0, Ve.process.nextTick(z, X, ne));
  }
  function z(X, ne) {
    i("resume", ne.reading), ne.reading || X.read(0), ne.resumeScheduled = !1, X.emit("resume"), q(X), ne.flowing && !ne.reading && X.read(0);
  }
  D.prototype.pause = function() {
    return i("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (i("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function q(X) {
    var ne = X._readableState;
    for (i("flow", ne.flowing); ne.flowing && X.read() !== null; )
      ;
  }
  D.prototype.wrap = function(X) {
    var ne = this, ye = this._readableState, ve = !1;
    X.on("end", function() {
      if (i("wrapped end"), ye.decoder && !ye.ended) {
        var re = ye.decoder.end();
        re && re.length && ne.push(re);
      }
      ne.push(null);
    }), X.on("data", function(re) {
      if (i("wrapped data"), ye.decoder && (re = ye.decoder.write(re)), !(ye.objectMode && re == null) && !(!ye.objectMode && (!re || !re.length))) {
        var ae = ne.push(re);
        ae || (ve = !0, X.pause());
      }
    });
    for (var de in X)
      this[de] === void 0 && typeof X[de] == "function" && (this[de] = function(ae) {
        return function() {
          return X[ae].apply(X, arguments);
        };
      }(de));
    for (var oe = 0; oe < N.length; oe++)
      X.on(N[oe], this.emit.bind(this, N[oe]));
    return this._read = function(re) {
      i("wrapped _read", re), ve && (ve = !1, X.resume());
    }, this;
  }, typeof Symbol == "function" && (D.prototype[Symbol.asyncIterator] = function() {
    return g === void 0 && (g = V7()), g(this);
  }), Object.defineProperty(D.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(D.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(D.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(ne) {
      this._readableState && (this._readableState.flowing = ne);
    }
  }), D._fromList = $, Object.defineProperty(D.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function $(X, ne) {
    if (ne.length === 0)
      return null;
    var ye;
    return ne.objectMode ? ye = ne.buffer.shift() : !X || X >= ne.length ? (ne.decoder ? ye = ne.buffer.join("") : ne.buffer.length === 1 ? ye = ne.buffer.first() : ye = ne.buffer.concat(ne.length), ne.buffer.clear()) : ye = ne.buffer.consume(X, ne.decoder), ye;
  }
  function Y(X) {
    var ne = X._readableState;
    i("endReadable", ne.endEmitted), ne.endEmitted || (ne.ended = !0, Ve.process.nextTick(H, ne, X));
  }
  function H(X, ne) {
    if (i("endReadableNT", X.endEmitted, X.length), !X.endEmitted && X.length === 0 && (X.endEmitted = !0, ne.readable = !1, ne.emit("end"), X.autoDestroy)) {
      var ye = ne._writableState;
      (!ye || ye.autoDestroy && ye.finished) && ne.destroy();
    }
  }
  typeof Symbol == "function" && (D.from = function(X, ne) {
    return P === void 0 && (P = W7()), P(D, X, ne);
  });
  function Q(X, ne) {
    for (var ye = 0, ve = X.length; ye < ve; ye++)
      if (X[ye] === ne)
        return ye;
    return -1;
  }
  return Uh;
}
var NT = js, Rd = Ja.codes, H7 = Rd.ERR_METHOD_NOT_IMPLEMENTED, q7 = Rd.ERR_MULTIPLE_CALLBACK, G7 = Rd.ERR_TRANSFORM_ALREADY_TRANSFORMING, z7 = Rd.ERR_TRANSFORM_WITH_LENGTH_0, Md = Fo();
Zt(js, Md);
function K7(t, e) {
  var n = this._transformState;
  n.transforming = !1;
  var a = n.writecb;
  if (a === null)
    return this.emit("error", new q7());
  n.writechunk = null, n.writecb = null, e != null && this.push(e), a(t);
  var c = this._readableState;
  c.reading = !1, (c.needReadable || c.length < c.highWaterMark) && this._read(c.highWaterMark);
}
function js(t) {
  if (!(this instanceof js))
    return new js(t);
  Md.call(this, t), this._transformState = {
    afterTransform: K7.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", Y7);
}
function Y7() {
  var t = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, n) {
    gE(t, e, n);
  }) : gE(this, null, null);
}
js.prototype.push = function(t, e) {
  return this._transformState.needTransform = !1, Md.prototype.push.call(this, t, e);
};
js.prototype._transform = function(t, e, n) {
  n(new H7("_transform()"));
};
js.prototype._write = function(t, e, n) {
  var a = this._transformState;
  if (a.writecb = n, a.writechunk = t, a.writeencoding = e, !a.transforming) {
    var c = this._readableState;
    (a.needTransform || c.needReadable || c.length < c.highWaterMark) && this._read(c.highWaterMark);
  }
};
js.prototype._read = function(t) {
  var e = this._transformState;
  e.writechunk !== null && !e.transforming ? (e.transforming = !0, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = !0;
};
js.prototype._destroy = function(t, e) {
  Md.prototype._destroy.call(this, t, function(n) {
    e(n);
  });
};
function gE(t, e, n) {
  if (e)
    return t.emit("error", e);
  if (n != null && t.push(n), t._writableState.length)
    throw new z7();
  if (t._transformState.transforming)
    throw new G7();
  return t.push(null);
}
var X7 = uu, RT = NT;
Zt(uu, RT);
function uu(t) {
  if (!(this instanceof uu))
    return new uu(t);
  RT.call(this, t);
}
uu.prototype._transform = function(t, e, n) {
  n(null, t);
};
var Vh;
function J7(t) {
  var e = !1;
  return function() {
    e || (e = !0, t.apply(void 0, arguments));
  };
}
var MT = Ja.codes, Q7 = MT.ERR_MISSING_ARGS, Z7 = MT.ERR_STREAM_DESTROYED;
function vE(t) {
  if (t)
    throw t;
}
function e8(t) {
  return t.setHeader && typeof t.abort == "function";
}
function t8(t, e, n, a) {
  a = J7(a);
  var c = !1;
  t.on("close", function() {
    c = !0;
  }), Vh === void 0 && (Vh = Ay), Vh(t, {
    readable: e,
    writable: n
  }, function(r) {
    if (r)
      return a(r);
    c = !0, a();
  });
  var u = !1;
  return function(r) {
    if (!c && !u) {
      if (u = !0, e8(t))
        return t.abort();
      if (typeof t.destroy == "function")
        return t.destroy();
      a(r || new Z7("pipe"));
    }
  };
}
function EE(t) {
  t();
}
function r8(t, e) {
  return t.pipe(e);
}
function n8(t) {
  return !t.length || typeof t[t.length - 1] != "function" ? vE : t.pop();
}
function i8() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  var a = n8(e);
  if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
    throw new Q7("streams");
  var c, u = e.map(function(r, l) {
    var i = l < e.length - 1, f = l > 0;
    return t8(r, i, f, function(d) {
      c || (c = d), d && u.forEach(EE), !i && (u.forEach(EE), a(c));
    });
  });
  return e.reduce(r8);
}
var s8 = i8;
(function(t, e) {
  e = t.exports = DT(), e.Stream = e, e.Readable = e, e.Writable = OT(), e.Duplex = Fo(), e.Transform = NT, e.PassThrough = X7, e.finished = Ay, e.pipeline = s8;
})(U1, U1.exports);
var LT = U1.exports, Mf = er.Buffer, jT = LT.Transform, a8 = Zt;
function o8(t, e) {
  if (!Mf.isBuffer(t) && typeof t != "string")
    throw new TypeError(e + " must be a string or a buffer");
}
function ha(t) {
  jT.call(this), this._block = Mf.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
a8(ha, jT);
ha.prototype._transform = function(t, e, n) {
  var a = null;
  try {
    this.update(t, e);
  } catch (c) {
    a = c;
  }
  n(a);
};
ha.prototype._flush = function(t) {
  var e = null;
  try {
    this.push(this.digest());
  } catch (n) {
    e = n;
  }
  t(e);
};
ha.prototype.update = function(t, e) {
  if (o8(t, "Data"), this._finalized)
    throw new Error("Digest already called");
  Mf.isBuffer(t) || (t = Mf.from(t, e));
  for (var n = this._block, a = 0; this._blockOffset + t.length - a >= this._blockSize; ) {
    for (var c = this._blockOffset; c < this._blockSize; )
      n[c++] = t[a++];
    this._update(), this._blockOffset = 0;
  }
  for (; a < t.length; )
    n[this._blockOffset++] = t[a++];
  for (var u = 0, r = t.length * 8; r > 0; ++u)
    this._length[u] += r, r = this._length[u] / 4294967296 | 0, r > 0 && (this._length[u] -= 4294967296 * r);
  return this;
};
ha.prototype._update = function() {
  throw new Error("_update is not implemented");
};
ha.prototype.digest = function(t) {
  if (this._finalized)
    throw new Error("Digest already called");
  this._finalized = !0;
  var e = this._digest();
  t !== void 0 && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
  for (var n = 0; n < 4; ++n)
    this._length[n] = 0;
  return e;
};
ha.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var FT = ha, l8 = Zt, BT = FT, u8 = er.Buffer, c8 = new Array(16);
function Ld() {
  BT.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
l8(Ld, BT);
Ld.prototype._update = function() {
  for (var t = c8, e = 0; e < 16; ++e)
    t[e] = this._block.readInt32LE(e * 4);
  var n = this._a, a = this._b, c = this._c, u = this._d;
  n = _n(n, a, c, u, t[0], 3614090360, 7), u = _n(u, n, a, c, t[1], 3905402710, 12), c = _n(c, u, n, a, t[2], 606105819, 17), a = _n(a, c, u, n, t[3], 3250441966, 22), n = _n(n, a, c, u, t[4], 4118548399, 7), u = _n(u, n, a, c, t[5], 1200080426, 12), c = _n(c, u, n, a, t[6], 2821735955, 17), a = _n(a, c, u, n, t[7], 4249261313, 22), n = _n(n, a, c, u, t[8], 1770035416, 7), u = _n(u, n, a, c, t[9], 2336552879, 12), c = _n(c, u, n, a, t[10], 4294925233, 17), a = _n(a, c, u, n, t[11], 2304563134, 22), n = _n(n, a, c, u, t[12], 1804603682, 7), u = _n(u, n, a, c, t[13], 4254626195, 12), c = _n(c, u, n, a, t[14], 2792965006, 17), a = _n(a, c, u, n, t[15], 1236535329, 22), n = Sn(n, a, c, u, t[1], 4129170786, 5), u = Sn(u, n, a, c, t[6], 3225465664, 9), c = Sn(c, u, n, a, t[11], 643717713, 14), a = Sn(a, c, u, n, t[0], 3921069994, 20), n = Sn(n, a, c, u, t[5], 3593408605, 5), u = Sn(u, n, a, c, t[10], 38016083, 9), c = Sn(c, u, n, a, t[15], 3634488961, 14), a = Sn(a, c, u, n, t[4], 3889429448, 20), n = Sn(n, a, c, u, t[9], 568446438, 5), u = Sn(u, n, a, c, t[14], 3275163606, 9), c = Sn(c, u, n, a, t[3], 4107603335, 14), a = Sn(a, c, u, n, t[8], 1163531501, 20), n = Sn(n, a, c, u, t[13], 2850285829, 5), u = Sn(u, n, a, c, t[2], 4243563512, 9), c = Sn(c, u, n, a, t[7], 1735328473, 14), a = Sn(a, c, u, n, t[12], 2368359562, 20), n = wn(n, a, c, u, t[5], 4294588738, 4), u = wn(u, n, a, c, t[8], 2272392833, 11), c = wn(c, u, n, a, t[11], 1839030562, 16), a = wn(a, c, u, n, t[14], 4259657740, 23), n = wn(n, a, c, u, t[1], 2763975236, 4), u = wn(u, n, a, c, t[4], 1272893353, 11), c = wn(c, u, n, a, t[7], 4139469664, 16), a = wn(a, c, u, n, t[10], 3200236656, 23), n = wn(n, a, c, u, t[13], 681279174, 4), u = wn(u, n, a, c, t[0], 3936430074, 11), c = wn(c, u, n, a, t[3], 3572445317, 16), a = wn(a, c, u, n, t[6], 76029189, 23), n = wn(n, a, c, u, t[9], 3654602809, 4), u = wn(u, n, a, c, t[12], 3873151461, 11), c = wn(c, u, n, a, t[15], 530742520, 16), a = wn(a, c, u, n, t[2], 3299628645, 23), n = Tn(n, a, c, u, t[0], 4096336452, 6), u = Tn(u, n, a, c, t[7], 1126891415, 10), c = Tn(c, u, n, a, t[14], 2878612391, 15), a = Tn(a, c, u, n, t[5], 4237533241, 21), n = Tn(n, a, c, u, t[12], 1700485571, 6), u = Tn(u, n, a, c, t[3], 2399980690, 10), c = Tn(c, u, n, a, t[10], 4293915773, 15), a = Tn(a, c, u, n, t[1], 2240044497, 21), n = Tn(n, a, c, u, t[8], 1873313359, 6), u = Tn(u, n, a, c, t[15], 4264355552, 10), c = Tn(c, u, n, a, t[6], 2734768916, 15), a = Tn(a, c, u, n, t[13], 1309151649, 21), n = Tn(n, a, c, u, t[4], 4149444226, 6), u = Tn(u, n, a, c, t[11], 3174756917, 10), c = Tn(c, u, n, a, t[2], 718787259, 15), a = Tn(a, c, u, n, t[9], 3951481745, 21), this._a = this._a + n | 0, this._b = this._b + a | 0, this._c = this._c + c | 0, this._d = this._d + u | 0;
};
Ld.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var t = u8.allocUnsafe(16);
  return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
};
function jd(t, e) {
  return t << e | t >>> 32 - e;
}
function _n(t, e, n, a, c, u, r) {
  return jd(t + (e & n | ~e & a) + c + u | 0, r) + e | 0;
}
function Sn(t, e, n, a, c, u, r) {
  return jd(t + (e & a | n & ~a) + c + u | 0, r) + e | 0;
}
function wn(t, e, n, a, c, u, r) {
  return jd(t + (e ^ n ^ a) + c + u | 0, r) + e | 0;
}
function Tn(t, e, n, a, c, u, r) {
  return jd(t + (n ^ (e | ~a)) + c + u | 0, r) + e | 0;
}
var xy = Ld, Wh = fa.Buffer, f8 = Zt, $T = FT, d8 = new Array(16), Pl = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], Cl = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], Il = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], Ol = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], kl = [0, 1518500249, 1859775393, 2400959708, 2840853838], Dl = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function Fd() {
  $T.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
f8(Fd, $T);
Fd.prototype._update = function() {
  for (var t = d8, e = 0; e < 16; ++e)
    t[e] = this._block.readInt32LE(e * 4);
  for (var n = this._a | 0, a = this._b | 0, c = this._c | 0, u = this._d | 0, r = this._e | 0, l = this._a | 0, i = this._b | 0, f = this._c | 0, d = this._d | 0, s = this._e | 0, o = 0; o < 80; o += 1) {
    var m, h;
    o < 16 ? (m = _E(n, a, c, u, r, t[Pl[o]], kl[0], Il[o]), h = AE(l, i, f, d, s, t[Cl[o]], Dl[0], Ol[o])) : o < 32 ? (m = SE(n, a, c, u, r, t[Pl[o]], kl[1], Il[o]), h = TE(l, i, f, d, s, t[Cl[o]], Dl[1], Ol[o])) : o < 48 ? (m = wE(n, a, c, u, r, t[Pl[o]], kl[2], Il[o]), h = wE(l, i, f, d, s, t[Cl[o]], Dl[2], Ol[o])) : o < 64 ? (m = TE(n, a, c, u, r, t[Pl[o]], kl[3], Il[o]), h = SE(l, i, f, d, s, t[Cl[o]], Dl[3], Ol[o])) : (m = AE(n, a, c, u, r, t[Pl[o]], kl[4], Il[o]), h = _E(l, i, f, d, s, t[Cl[o]], Dl[4], Ol[o])), n = r, r = u, u = Ua(c, 10), c = a, a = m, l = s, s = d, d = Ua(f, 10), f = i, i = h;
  }
  var y = this._b + c + d | 0;
  this._b = this._c + u + s | 0, this._c = this._d + r + l | 0, this._d = this._e + n + i | 0, this._e = this._a + a + f | 0, this._a = y;
};
Fd.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var t = Wh.alloc ? Wh.alloc(20) : new Wh(20);
  return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t;
};
function Ua(t, e) {
  return t << e | t >>> 32 - e;
}
function _E(t, e, n, a, c, u, r, l) {
  return Ua(t + (e ^ n ^ a) + u + r | 0, l) + c | 0;
}
function SE(t, e, n, a, c, u, r, l) {
  return Ua(t + (e & n | ~e & a) + u + r | 0, l) + c | 0;
}
function wE(t, e, n, a, c, u, r, l) {
  return Ua(t + ((e | ~n) ^ a) + u + r | 0, l) + c | 0;
}
function TE(t, e, n, a, c, u, r, l) {
  return Ua(t + (e & a | n & ~a) + u + r | 0, l) + c | 0;
}
function AE(t, e, n, a, c, u, r, l) {
  return Ua(t + (e ^ (n | ~a)) + u + r | 0, l) + c | 0;
}
var Py = Fd, UT = { exports: {} }, VT = er.Buffer;
function Bd(t, e) {
  this._block = VT.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0;
}
Bd.prototype.update = function(t, e) {
  typeof t == "string" && (e = e || "utf8", t = VT.from(t, e));
  for (var n = this._block, a = this._blockSize, c = t.length, u = this._len, r = 0; r < c; ) {
    for (var l = u % a, i = Math.min(c - r, a - l), f = 0; f < i; f++)
      n[l + f] = t[r + f];
    u += i, r += i, u % a === 0 && this._update(n);
  }
  return this._len += c, this;
};
Bd.prototype.digest = function(t) {
  var e = this._len % this._blockSize;
  this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var n = this._len * 8;
  if (n <= 4294967295)
    this._block.writeUInt32BE(n, this._blockSize - 4);
  else {
    var a = (n & 4294967295) >>> 0, c = (n - a) / 4294967296;
    this._block.writeUInt32BE(c, this._blockSize - 8), this._block.writeUInt32BE(a, this._blockSize - 4);
  }
  this._update(this._block);
  var u = this._hash();
  return t ? u.toString(t) : u;
};
Bd.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var il = Bd, p8 = Zt, WT = il, h8 = er.Buffer, m8 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], y8 = new Array(80);
function Mu() {
  this.init(), this._w = y8, WT.call(this, 64, 56);
}
p8(Mu, WT);
Mu.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function b8(t) {
  return t << 5 | t >>> 27;
}
function g8(t) {
  return t << 30 | t >>> 2;
}
function v8(t, e, n, a) {
  return t === 0 ? e & n | ~e & a : t === 2 ? e & n | e & a | n & a : e ^ n ^ a;
}
Mu.prototype._update = function(t) {
  for (var e = this._w, n = this._a | 0, a = this._b | 0, c = this._c | 0, u = this._d | 0, r = this._e | 0, l = 0; l < 16; ++l)
    e[l] = t.readInt32BE(l * 4);
  for (; l < 80; ++l)
    e[l] = e[l - 3] ^ e[l - 8] ^ e[l - 14] ^ e[l - 16];
  for (var i = 0; i < 80; ++i) {
    var f = ~~(i / 20), d = b8(n) + v8(f, a, c, u) + r + e[i] + m8[f] | 0;
    r = u, u = c, c = g8(a), a = n, n = d;
  }
  this._a = n + this._a | 0, this._b = a + this._b | 0, this._c = c + this._c | 0, this._d = u + this._d | 0, this._e = r + this._e | 0;
};
Mu.prototype._hash = function() {
  var t = h8.allocUnsafe(20);
  return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
};
var E8 = Mu, _8 = Zt, HT = il, S8 = er.Buffer, w8 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], T8 = new Array(80);
function Lu() {
  this.init(), this._w = T8, HT.call(this, 64, 56);
}
_8(Lu, HT);
Lu.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function A8(t) {
  return t << 1 | t >>> 31;
}
function x8(t) {
  return t << 5 | t >>> 27;
}
function P8(t) {
  return t << 30 | t >>> 2;
}
function C8(t, e, n, a) {
  return t === 0 ? e & n | ~e & a : t === 2 ? e & n | e & a | n & a : e ^ n ^ a;
}
Lu.prototype._update = function(t) {
  for (var e = this._w, n = this._a | 0, a = this._b | 0, c = this._c | 0, u = this._d | 0, r = this._e | 0, l = 0; l < 16; ++l)
    e[l] = t.readInt32BE(l * 4);
  for (; l < 80; ++l)
    e[l] = A8(e[l - 3] ^ e[l - 8] ^ e[l - 14] ^ e[l - 16]);
  for (var i = 0; i < 80; ++i) {
    var f = ~~(i / 20), d = x8(n) + C8(f, a, c, u) + r + e[i] + w8[f] | 0;
    r = u, u = c, c = P8(a), a = n, n = d;
  }
  this._a = n + this._a | 0, this._b = a + this._b | 0, this._c = c + this._c | 0, this._d = u + this._d | 0, this._e = r + this._e | 0;
};
Lu.prototype._hash = function() {
  var t = S8.allocUnsafe(20);
  return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
};
var I8 = Lu, O8 = Zt, qT = il, k8 = er.Buffer, D8 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], N8 = new Array(64);
function ju() {
  this.init(), this._w = N8, qT.call(this, 64, 56);
}
O8(ju, qT);
ju.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function R8(t, e, n) {
  return n ^ t & (e ^ n);
}
function M8(t, e, n) {
  return t & e | n & (t | e);
}
function L8(t) {
  return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
}
function j8(t) {
  return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
}
function F8(t) {
  return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
}
function B8(t) {
  return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10;
}
ju.prototype._update = function(t) {
  for (var e = this._w, n = this._a | 0, a = this._b | 0, c = this._c | 0, u = this._d | 0, r = this._e | 0, l = this._f | 0, i = this._g | 0, f = this._h | 0, d = 0; d < 16; ++d)
    e[d] = t.readInt32BE(d * 4);
  for (; d < 64; ++d)
    e[d] = B8(e[d - 2]) + e[d - 7] + F8(e[d - 15]) + e[d - 16] | 0;
  for (var s = 0; s < 64; ++s) {
    var o = f + j8(r) + R8(r, l, i) + D8[s] + e[s] | 0, m = L8(n) + M8(n, a, c) | 0;
    f = i, i = l, l = r, r = u + o | 0, u = c, c = a, a = n, n = o + m | 0;
  }
  this._a = n + this._a | 0, this._b = a + this._b | 0, this._c = c + this._c | 0, this._d = u + this._d | 0, this._e = r + this._e | 0, this._f = l + this._f | 0, this._g = i + this._g | 0, this._h = f + this._h | 0;
};
ju.prototype._hash = function() {
  var t = k8.allocUnsafe(32);
  return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
};
var GT = ju, $8 = Zt, U8 = GT, V8 = il, W8 = er.Buffer, H8 = new Array(64);
function $d() {
  this.init(), this._w = H8, V8.call(this, 64, 56);
}
$8($d, U8);
$d.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
$d.prototype._hash = function() {
  var t = W8.allocUnsafe(28);
  return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
};
var q8 = $d, G8 = Zt, zT = il, z8 = er.Buffer, xE = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], K8 = new Array(160);
function Fu() {
  this.init(), this._w = K8, zT.call(this, 128, 112);
}
G8(Fu, zT);
Fu.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function PE(t, e, n) {
  return n ^ t & (e ^ n);
}
function CE(t, e, n) {
  return t & e | n & (t | e);
}
function IE(t, e) {
  return (t >>> 28 | e << 4) ^ (e >>> 2 | t << 30) ^ (e >>> 7 | t << 25);
}
function OE(t, e) {
  return (t >>> 14 | e << 18) ^ (t >>> 18 | e << 14) ^ (e >>> 9 | t << 23);
}
function Y8(t, e) {
  return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ t >>> 7;
}
function X8(t, e) {
  return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ (t >>> 7 | e << 25);
}
function J8(t, e) {
  return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ t >>> 6;
}
function Q8(t, e) {
  return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ (t >>> 6 | e << 26);
}
function sn(t, e) {
  return t >>> 0 < e >>> 0 ? 1 : 0;
}
Fu.prototype._update = function(t) {
  for (var e = this._w, n = this._ah | 0, a = this._bh | 0, c = this._ch | 0, u = this._dh | 0, r = this._eh | 0, l = this._fh | 0, i = this._gh | 0, f = this._hh | 0, d = this._al | 0, s = this._bl | 0, o = this._cl | 0, m = this._dl | 0, h = this._el | 0, y = this._fl | 0, b = this._gl | 0, E = this._hl | 0, S = 0; S < 32; S += 2)
    e[S] = t.readInt32BE(S * 4), e[S + 1] = t.readInt32BE(S * 4 + 4);
  for (; S < 160; S += 2) {
    var g = e[S - 30], P = e[S - 15 * 2 + 1], R = Y8(g, P), N = X8(P, g);
    g = e[S - 2 * 2], P = e[S - 2 * 2 + 1];
    var C = J8(g, P), I = Q8(P, g), D = e[S - 7 * 2], j = e[S - 7 * 2 + 1], F = e[S - 16 * 2], _ = e[S - 16 * 2 + 1], T = N + j | 0, v = R + D + sn(T, N) | 0;
    T = T + I | 0, v = v + C + sn(T, I) | 0, T = T + _ | 0, v = v + F + sn(T, _) | 0, e[S] = v, e[S + 1] = T;
  }
  for (var w = 0; w < 160; w += 2) {
    v = e[w], T = e[w + 1];
    var O = CE(n, a, c), G = CE(d, s, o), W = IE(n, d), U = IE(d, n), M = OE(r, h), B = OE(h, r), k = xE[w], K = xE[w + 1], te = PE(r, l, i), z = PE(h, y, b), q = E + B | 0, $ = f + M + sn(q, E) | 0;
    q = q + z | 0, $ = $ + te + sn(q, z) | 0, q = q + K | 0, $ = $ + k + sn(q, K) | 0, q = q + T | 0, $ = $ + v + sn(q, T) | 0;
    var Y = U + G | 0, H = W + O + sn(Y, U) | 0;
    f = i, E = b, i = l, b = y, l = r, y = h, h = m + q | 0, r = u + $ + sn(h, m) | 0, u = c, m = o, c = a, o = s, a = n, s = d, d = q + Y | 0, n = $ + H + sn(d, q) | 0;
  }
  this._al = this._al + d | 0, this._bl = this._bl + s | 0, this._cl = this._cl + o | 0, this._dl = this._dl + m | 0, this._el = this._el + h | 0, this._fl = this._fl + y | 0, this._gl = this._gl + b | 0, this._hl = this._hl + E | 0, this._ah = this._ah + n + sn(this._al, d) | 0, this._bh = this._bh + a + sn(this._bl, s) | 0, this._ch = this._ch + c + sn(this._cl, o) | 0, this._dh = this._dh + u + sn(this._dl, m) | 0, this._eh = this._eh + r + sn(this._el, h) | 0, this._fh = this._fh + l + sn(this._fl, y) | 0, this._gh = this._gh + i + sn(this._gl, b) | 0, this._hh = this._hh + f + sn(this._hl, E) | 0;
};
Fu.prototype._hash = function() {
  var t = z8.allocUnsafe(64);
  function e(n, a, c) {
    t.writeInt32BE(n, c), t.writeInt32BE(a, c + 4);
  }
  return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t;
};
var KT = Fu, Z8 = Zt, eM = KT, tM = il, rM = er.Buffer, nM = new Array(160);
function Ud() {
  this.init(), this._w = nM, tM.call(this, 128, 112);
}
Z8(Ud, eM);
Ud.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
Ud.prototype._hash = function() {
  var t = rM.allocUnsafe(48);
  function e(n, a, c) {
    t.writeInt32BE(n, c), t.writeInt32BE(a, c + 4);
  }
  return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t;
};
var iM = Ud, Qa = UT.exports = function(e) {
  e = e.toLowerCase();
  var n = Qa[e];
  if (!n)
    throw new Error(e + " is not supported (we accept pull requests)");
  return new n();
};
Qa.sha = E8;
Qa.sha1 = I8;
Qa.sha224 = q8;
Qa.sha256 = GT;
Qa.sha384 = iM;
Qa.sha512 = KT;
var Cy = UT.exports, YT = er.Buffer, XT = xr.Transform, sM = Rf.StringDecoder, aM = Zt;
function $i(t) {
  XT.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
aM($i, XT);
$i.prototype.update = function(t, e, n) {
  typeof t == "string" && (t = YT.from(t, e));
  var a = this._update(t);
  return this.hashMode ? this : (n && (a = this._toString(a, n)), a);
};
$i.prototype.setAutoPadding = function() {
};
$i.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
$i.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
$i.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
$i.prototype._transform = function(t, e, n) {
  var a;
  try {
    this.hashMode ? this._update(t) : this.push(this._update(t));
  } catch (c) {
    a = c;
  } finally {
    n(a);
  }
};
$i.prototype._flush = function(t) {
  var e;
  try {
    this.push(this.__final());
  } catch (n) {
    e = n;
  }
  t(e);
};
$i.prototype._finalOrDigest = function(t) {
  var e = this.__final() || YT.alloc(0);
  return t && (e = this._toString(e, t, !0)), e;
};
$i.prototype._toString = function(t, e, n) {
  if (this._decoder || (this._decoder = new sM(e), this._encoding = e), this._encoding !== e)
    throw new Error("can't switch encodings");
  var a = this._decoder.write(t);
  return n && (a += this._decoder.end()), a;
};
var ma = $i, oM = Zt, lM = xy, uM = Py, cM = Cy, JT = ma;
function Vd(t) {
  JT.call(this, "digest"), this._hash = t;
}
oM(Vd, JT);
Vd.prototype._update = function(t) {
  this._hash.update(t);
};
Vd.prototype._final = function() {
  return this._hash.digest();
};
var Bu = function(e) {
  return e = e.toLowerCase(), e === "md5" ? new lM() : e === "rmd160" || e === "ripemd160" ? new uM() : new Vd(cM(e));
}, fM = Zt, Ra = er.Buffer, QT = ma, dM = Ra.alloc(128), ho = 64;
function Wd(t, e) {
  QT.call(this, "digest"), typeof e == "string" && (e = Ra.from(e)), this._alg = t, this._key = e, e.length > ho ? e = t(e) : e.length < ho && (e = Ra.concat([e, dM], ho));
  for (var n = this._ipad = Ra.allocUnsafe(ho), a = this._opad = Ra.allocUnsafe(ho), c = 0; c < ho; c++)
    n[c] = e[c] ^ 54, a[c] = e[c] ^ 92;
  this._hash = [n];
}
fM(Wd, QT);
Wd.prototype._update = function(t) {
  this._hash.push(t);
};
Wd.prototype._final = function() {
  var t = this._alg(Ra.concat(this._hash));
  return this._alg(Ra.concat([this._opad, t]));
};
var pM = Wd, hM = xy, ZT = function(t) {
  return new hM().update(t).digest();
}, mM = Zt, yM = pM, eA = ma, Ul = er.Buffer, bM = ZT, W1 = Py, H1 = Cy, gM = Ul.alloc(128);
function cu(t, e) {
  eA.call(this, "digest"), typeof e == "string" && (e = Ul.from(e));
  var n = t === "sha512" || t === "sha384" ? 128 : 64;
  if (this._alg = t, this._key = e, e.length > n) {
    var a = t === "rmd160" ? new W1() : H1(t);
    e = a.update(e).digest();
  } else
    e.length < n && (e = Ul.concat([e, gM], n));
  for (var c = this._ipad = Ul.allocUnsafe(n), u = this._opad = Ul.allocUnsafe(n), r = 0; r < n; r++)
    c[r] = e[r] ^ 54, u[r] = e[r] ^ 92;
  this._hash = t === "rmd160" ? new W1() : H1(t), this._hash.update(c);
}
mM(cu, eA);
cu.prototype._update = function(t) {
  this._hash.update(t);
};
cu.prototype._final = function() {
  var t = this._hash.digest(), e = this._alg === "rmd160" ? new W1() : H1(this._alg);
  return e.update(this._opad).update(t).digest();
};
var tA = function(e, n) {
  return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new cu("rmd160", n) : e === "md5" ? new yM(bM, n) : new cu(e, n);
};
const vM = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, EM = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, _M = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, SM = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, wM = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, TM = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, AM = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, xM = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, PM = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, CM = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, IM = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, rA = {
  sha224WithRSAEncryption: vM,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption: EM,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption: _M,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption: SM,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: wM,
  sha224: TM,
  sha384: AM,
  sha512: xM,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA: PM,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA: CM,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption: IM,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var OM = rA, Hd = {}, kM = Math.pow(2, 30) - 1, nA = function(t, e) {
  if (typeof t != "number")
    throw new TypeError("Iterations not a number");
  if (t < 0)
    throw new TypeError("Bad iterations");
  if (typeof e != "number")
    throw new TypeError("Key length not a number");
  if (e < 0 || e > kM || e !== e)
    throw new TypeError("Bad key length");
}, uf;
if (Bt.process && Bt.process.browser)
  uf = "utf-8";
else if (Bt.process && Bt.process.version) {
  var DM = parseInt(Ve.process.version.split(".")[0].slice(1), 10);
  uf = DM >= 6 ? "utf-8" : "binary";
} else
  uf = "utf-8";
var iA = uf, Hh = er.Buffer, sA = function(t, e, n) {
  if (Hh.isBuffer(t))
    return t;
  if (typeof t == "string")
    return Hh.from(t, e);
  if (ArrayBuffer.isView(t))
    return Hh.from(t.buffer);
  throw new TypeError(n + " must be a string, a Buffer, a typed array or a DataView");
}, NM = ZT, RM = Py, MM = Cy, Ma = er.Buffer, LM = nA, kE = iA, DE = sA, jM = Ma.alloc(128), cf = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};
function aA(t, e, n) {
  var a = FM(t), c = t === "sha512" || t === "sha384" ? 128 : 64;
  e.length > c ? e = a(e) : e.length < c && (e = Ma.concat([e, jM], c));
  for (var u = Ma.allocUnsafe(c + cf[t]), r = Ma.allocUnsafe(c + cf[t]), l = 0; l < c; l++)
    u[l] = e[l] ^ 54, r[l] = e[l] ^ 92;
  var i = Ma.allocUnsafe(c + n + 4);
  u.copy(i, 0, 0, c), this.ipad1 = i, this.ipad2 = u, this.opad = r, this.alg = t, this.blocksize = c, this.hash = a, this.size = cf[t];
}
aA.prototype.run = function(t, e) {
  t.copy(e, this.blocksize);
  var n = this.hash(e);
  return n.copy(this.opad, this.blocksize), this.hash(this.opad);
};
function FM(t) {
  function e(a) {
    return MM(t).update(a).digest();
  }
  function n(a) {
    return new RM().update(a).digest();
  }
  return t === "rmd160" || t === "ripemd160" ? n : t === "md5" ? NM : e;
}
function BM(t, e, n, a, c) {
  LM(n, a), t = DE(t, kE, "Password"), e = DE(e, kE, "Salt"), c = c || "sha1";
  var u = new aA(c, t, e.length), r = Ma.allocUnsafe(a), l = Ma.allocUnsafe(e.length + 4);
  e.copy(l, 0, 0, e.length);
  for (var i = 0, f = cf[c], d = Math.ceil(a / f), s = 1; s <= d; s++) {
    l.writeUInt32BE(s, e.length);
    for (var o = u.run(l, u.ipad1), m = o, h = 1; h < n; h++) {
      m = u.run(m, u.ipad2);
      for (var y = 0; y < f; y++)
        o[y] ^= m[y];
    }
    o.copy(r, i), i += f;
  }
  return r;
}
var oA = BM, lA = er.Buffer, $M = nA, NE = iA, RE = oA, ME = sA, Mc, Ql = Bt.crypto && Bt.crypto.subtle, UM = {
  sha: "SHA-1",
  "sha-1": "SHA-1",
  sha1: "SHA-1",
  sha256: "SHA-256",
  "sha-256": "SHA-256",
  sha384: "SHA-384",
  "sha-384": "SHA-384",
  "sha-512": "SHA-512",
  sha512: "SHA-512"
}, qh = [];
function VM(t) {
  if (Bt.process && !Bt.process.browser || !Ql || !Ql.importKey || !Ql.deriveBits)
    return Promise.resolve(!1);
  if (qh[t] !== void 0)
    return qh[t];
  Mc = Mc || lA.alloc(8);
  var e = uA(Mc, Mc, 10, 128, t).then(function() {
    return !0;
  }).catch(function() {
    return !1;
  });
  return qh[t] = e, e;
}
var wa;
function q1() {
  return wa || (Bt.process && Bt.process.nextTick ? wa = Bt.process.nextTick : Bt.queueMicrotask ? wa = Bt.queueMicrotask : Bt.setImmediate ? wa = Bt.setImmediate : wa = Bt.setTimeout, wa);
}
function uA(t, e, n, a, c) {
  return Ql.importKey(
    "raw",
    t,
    { name: "PBKDF2" },
    !1,
    ["deriveBits"]
  ).then(function(u) {
    return Ql.deriveBits({
      name: "PBKDF2",
      salt: e,
      iterations: n,
      hash: {
        name: c
      }
    }, u, a << 3);
  }).then(function(u) {
    return lA.from(u);
  });
}
function WM(t, e) {
  t.then(function(n) {
    q1()(function() {
      e(null, n);
    });
  }, function(n) {
    q1()(function() {
      e(n);
    });
  });
}
var HM = function(t, e, n, a, c, u) {
  typeof c == "function" && (u = c, c = void 0), c = c || "sha1";
  var r = UM[c.toLowerCase()];
  if (!r || typeof Bt.Promise != "function") {
    q1()(function() {
      var l;
      try {
        l = RE(t, e, n, a, c);
      } catch (i) {
        return u(i);
      }
      u(null, l);
    });
    return;
  }
  if ($M(n, a), t = ME(t, NE, "Password"), e = ME(e, NE, "Salt"), typeof u != "function")
    throw new Error("No callback provided to pbkdf2");
  WM(VM(r).then(function(l) {
    return l ? uA(t, e, n, a, r) : RE(t, e, n, a, c);
  }), u);
};
Hd.pbkdf2 = HM;
Hd.pbkdf2Sync = oA;
var Mi = {}, sl = {}, ei = {};
ei.readUInt32BE = function(e, n) {
  var a = e[0 + n] << 24 | e[1 + n] << 16 | e[2 + n] << 8 | e[3 + n];
  return a >>> 0;
};
ei.writeUInt32BE = function(e, n, a) {
  e[0 + a] = n >>> 24, e[1 + a] = n >>> 16 & 255, e[2 + a] = n >>> 8 & 255, e[3 + a] = n & 255;
};
ei.ip = function(e, n, a, c) {
  for (var u = 0, r = 0, l = 6; l >= 0; l -= 2) {
    for (var i = 0; i <= 24; i += 8)
      u <<= 1, u |= n >>> i + l & 1;
    for (var i = 0; i <= 24; i += 8)
      u <<= 1, u |= e >>> i + l & 1;
  }
  for (var l = 6; l >= 0; l -= 2) {
    for (var i = 1; i <= 25; i += 8)
      r <<= 1, r |= n >>> i + l & 1;
    for (var i = 1; i <= 25; i += 8)
      r <<= 1, r |= e >>> i + l & 1;
  }
  a[c + 0] = u >>> 0, a[c + 1] = r >>> 0;
};
ei.rip = function(e, n, a, c) {
  for (var u = 0, r = 0, l = 0; l < 4; l++)
    for (var i = 24; i >= 0; i -= 8)
      u <<= 1, u |= n >>> i + l & 1, u <<= 1, u |= e >>> i + l & 1;
  for (var l = 4; l < 8; l++)
    for (var i = 24; i >= 0; i -= 8)
      r <<= 1, r |= n >>> i + l & 1, r <<= 1, r |= e >>> i + l & 1;
  a[c + 0] = u >>> 0, a[c + 1] = r >>> 0;
};
ei.pc1 = function(e, n, a, c) {
  for (var u = 0, r = 0, l = 7; l >= 5; l--) {
    for (var i = 0; i <= 24; i += 8)
      u <<= 1, u |= n >> i + l & 1;
    for (var i = 0; i <= 24; i += 8)
      u <<= 1, u |= e >> i + l & 1;
  }
  for (var i = 0; i <= 24; i += 8)
    u <<= 1, u |= n >> i + l & 1;
  for (var l = 1; l <= 3; l++) {
    for (var i = 0; i <= 24; i += 8)
      r <<= 1, r |= n >> i + l & 1;
    for (var i = 0; i <= 24; i += 8)
      r <<= 1, r |= e >> i + l & 1;
  }
  for (var i = 0; i <= 24; i += 8)
    r <<= 1, r |= e >> i + l & 1;
  a[c + 0] = u >>> 0, a[c + 1] = r >>> 0;
};
ei.r28shl = function(e, n) {
  return e << n & 268435455 | e >>> 28 - n;
};
var Lc = [
  // inL => outL
  14,
  11,
  17,
  4,
  27,
  23,
  25,
  0,
  13,
  22,
  7,
  18,
  5,
  9,
  16,
  24,
  2,
  20,
  12,
  21,
  1,
  8,
  15,
  26,
  // inR => outR
  15,
  4,
  25,
  19,
  9,
  1,
  26,
  16,
  5,
  11,
  23,
  8,
  12,
  7,
  17,
  0,
  22,
  3,
  10,
  14,
  6,
  20,
  27,
  24
];
ei.pc2 = function(e, n, a, c) {
  for (var u = 0, r = 0, l = Lc.length >>> 1, i = 0; i < l; i++)
    u <<= 1, u |= e >>> Lc[i] & 1;
  for (var i = l; i < Lc.length; i++)
    r <<= 1, r |= n >>> Lc[i] & 1;
  a[c + 0] = u >>> 0, a[c + 1] = r >>> 0;
};
ei.expand = function(e, n, a) {
  var c = 0, u = 0;
  c = (e & 1) << 5 | e >>> 27;
  for (var r = 23; r >= 15; r -= 4)
    c <<= 6, c |= e >>> r & 63;
  for (var r = 11; r >= 3; r -= 4)
    u |= e >>> r & 63, u <<= 6;
  u |= (e & 31) << 1 | e >>> 31, n[a + 0] = c >>> 0, n[a + 1] = u >>> 0;
};
var LE = [
  14,
  0,
  4,
  15,
  13,
  7,
  1,
  4,
  2,
  14,
  15,
  2,
  11,
  13,
  8,
  1,
  3,
  10,
  10,
  6,
  6,
  12,
  12,
  11,
  5,
  9,
  9,
  5,
  0,
  3,
  7,
  8,
  4,
  15,
  1,
  12,
  14,
  8,
  8,
  2,
  13,
  4,
  6,
  9,
  2,
  1,
  11,
  7,
  15,
  5,
  12,
  11,
  9,
  3,
  7,
  14,
  3,
  10,
  10,
  0,
  5,
  6,
  0,
  13,
  15,
  3,
  1,
  13,
  8,
  4,
  14,
  7,
  6,
  15,
  11,
  2,
  3,
  8,
  4,
  14,
  9,
  12,
  7,
  0,
  2,
  1,
  13,
  10,
  12,
  6,
  0,
  9,
  5,
  11,
  10,
  5,
  0,
  13,
  14,
  8,
  7,
  10,
  11,
  1,
  10,
  3,
  4,
  15,
  13,
  4,
  1,
  2,
  5,
  11,
  8,
  6,
  12,
  7,
  6,
  12,
  9,
  0,
  3,
  5,
  2,
  14,
  15,
  9,
  10,
  13,
  0,
  7,
  9,
  0,
  14,
  9,
  6,
  3,
  3,
  4,
  15,
  6,
  5,
  10,
  1,
  2,
  13,
  8,
  12,
  5,
  7,
  14,
  11,
  12,
  4,
  11,
  2,
  15,
  8,
  1,
  13,
  1,
  6,
  10,
  4,
  13,
  9,
  0,
  8,
  6,
  15,
  9,
  3,
  8,
  0,
  7,
  11,
  4,
  1,
  15,
  2,
  14,
  12,
  3,
  5,
  11,
  10,
  5,
  14,
  2,
  7,
  12,
  7,
  13,
  13,
  8,
  14,
  11,
  3,
  5,
  0,
  6,
  6,
  15,
  9,
  0,
  10,
  3,
  1,
  4,
  2,
  7,
  8,
  2,
  5,
  12,
  11,
  1,
  12,
  10,
  4,
  14,
  15,
  9,
  10,
  3,
  6,
  15,
  9,
  0,
  0,
  6,
  12,
  10,
  11,
  1,
  7,
  13,
  13,
  8,
  15,
  9,
  1,
  4,
  3,
  5,
  14,
  11,
  5,
  12,
  2,
  7,
  8,
  2,
  4,
  14,
  2,
  14,
  12,
  11,
  4,
  2,
  1,
  12,
  7,
  4,
  10,
  7,
  11,
  13,
  6,
  1,
  8,
  5,
  5,
  0,
  3,
  15,
  15,
  10,
  13,
  3,
  0,
  9,
  14,
  8,
  9,
  6,
  4,
  11,
  2,
  8,
  1,
  12,
  11,
  7,
  10,
  1,
  13,
  14,
  7,
  2,
  8,
  13,
  15,
  6,
  9,
  15,
  12,
  0,
  5,
  9,
  6,
  10,
  3,
  4,
  0,
  5,
  14,
  3,
  12,
  10,
  1,
  15,
  10,
  4,
  15,
  2,
  9,
  7,
  2,
  12,
  6,
  9,
  8,
  5,
  0,
  6,
  13,
  1,
  3,
  13,
  4,
  14,
  14,
  0,
  7,
  11,
  5,
  3,
  11,
  8,
  9,
  4,
  14,
  3,
  15,
  2,
  5,
  12,
  2,
  9,
  8,
  5,
  12,
  15,
  3,
  10,
  7,
  11,
  0,
  14,
  4,
  1,
  10,
  7,
  1,
  6,
  13,
  0,
  11,
  8,
  6,
  13,
  4,
  13,
  11,
  0,
  2,
  11,
  14,
  7,
  15,
  4,
  0,
  9,
  8,
  1,
  13,
  10,
  3,
  14,
  12,
  3,
  9,
  5,
  7,
  12,
  5,
  2,
  10,
  15,
  6,
  8,
  1,
  6,
  1,
  6,
  4,
  11,
  11,
  13,
  13,
  8,
  12,
  1,
  3,
  4,
  7,
  10,
  14,
  7,
  10,
  9,
  15,
  5,
  6,
  0,
  8,
  15,
  0,
  14,
  5,
  2,
  9,
  3,
  2,
  12,
  13,
  1,
  2,
  15,
  8,
  13,
  4,
  8,
  6,
  10,
  15,
  3,
  11,
  7,
  1,
  4,
  10,
  12,
  9,
  5,
  3,
  6,
  14,
  11,
  5,
  0,
  0,
  14,
  12,
  9,
  7,
  2,
  7,
  2,
  11,
  1,
  4,
  14,
  1,
  7,
  9,
  4,
  12,
  10,
  14,
  8,
  2,
  13,
  0,
  15,
  6,
  12,
  10,
  9,
  13,
  0,
  15,
  3,
  3,
  5,
  5,
  6,
  8,
  11
];
ei.substitute = function(e, n) {
  for (var a = 0, c = 0; c < 4; c++) {
    var u = e >>> 18 - c * 6 & 63, r = LE[c * 64 + u];
    a <<= 4, a |= r;
  }
  for (var c = 0; c < 4; c++) {
    var u = n >>> 18 - c * 6 & 63, r = LE[4 * 64 + c * 64 + u];
    a <<= 4, a |= r;
  }
  return a >>> 0;
};
var jE = [
  16,
  25,
  12,
  11,
  3,
  20,
  4,
  15,
  31,
  17,
  9,
  6,
  27,
  14,
  1,
  22,
  30,
  24,
  8,
  18,
  0,
  5,
  29,
  23,
  13,
  19,
  2,
  26,
  10,
  21,
  28,
  7
];
ei.permute = function(e) {
  for (var n = 0, a = 0; a < jE.length; a++)
    n <<= 1, n |= e >>> jE[a] & 1;
  return n >>> 0;
};
ei.padSplit = function(e, n, a) {
  for (var c = e.toString(2); c.length < n; )
    c = "0" + c;
  for (var u = [], r = 0; r < n; r += a)
    u.push(c.slice(r, r + a));
  return u.join(" ");
};
var wi = cA;
function cA(t, e) {
  if (!t)
    throw new Error(e || "Assertion failed");
}
cA.equal = function(e, n, a) {
  if (e != n)
    throw new Error(a || "Assertion failed: " + e + " != " + n);
};
var qM = wi;
function Ti(t) {
  this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = t.padding !== !1;
}
var Iy = Ti;
Ti.prototype._init = function() {
};
Ti.prototype.update = function(e) {
  return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e);
};
Ti.prototype._buffer = function(e, n) {
  for (var a = Math.min(this.buffer.length - this.bufferOff, e.length - n), c = 0; c < a; c++)
    this.buffer[this.bufferOff + c] = e[n + c];
  return this.bufferOff += a, a;
};
Ti.prototype._flushBuffer = function(e, n) {
  return this._update(this.buffer, 0, e, n), this.bufferOff = 0, this.blockSize;
};
Ti.prototype._updateEncrypt = function(e) {
  var n = 0, a = 0, c = (this.bufferOff + e.length) / this.blockSize | 0, u = new Array(c * this.blockSize);
  this.bufferOff !== 0 && (n += this._buffer(e, n), this.bufferOff === this.buffer.length && (a += this._flushBuffer(u, a)));
  for (var r = e.length - (e.length - n) % this.blockSize; n < r; n += this.blockSize)
    this._update(e, n, u, a), a += this.blockSize;
  for (; n < e.length; n++, this.bufferOff++)
    this.buffer[this.bufferOff] = e[n];
  return u;
};
Ti.prototype._updateDecrypt = function(e) {
  for (var n = 0, a = 0, c = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, u = new Array(c * this.blockSize); c > 0; c--)
    n += this._buffer(e, n), a += this._flushBuffer(u, a);
  return n += this._buffer(e, n), u;
};
Ti.prototype.final = function(e) {
  var n;
  e && (n = this.update(e));
  var a;
  return this.type === "encrypt" ? a = this._finalEncrypt() : a = this._finalDecrypt(), n ? n.concat(a) : a;
};
Ti.prototype._pad = function(e, n) {
  if (n === 0)
    return !1;
  for (; n < e.length; )
    e[n++] = 0;
  return !0;
};
Ti.prototype._finalEncrypt = function() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];
  var e = new Array(this.blockSize);
  return this._update(this.buffer, 0, e, 0), e;
};
Ti.prototype._unpad = function(e) {
  return e;
};
Ti.prototype._finalDecrypt = function() {
  qM.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
  var e = new Array(this.blockSize);
  return this._flushBuffer(e, 0), this._unpad(e);
};
var fA = wi, GM = Zt, tn = ei, dA = Iy;
function zM() {
  this.tmp = new Array(2), this.keys = null;
}
function hs(t) {
  dA.call(this, t);
  var e = new zM();
  this._desState = e, this.deriveKeys(e, t.key);
}
GM(hs, dA);
var pA = hs;
hs.create = function(e) {
  return new hs(e);
};
var KM = [
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1
];
hs.prototype.deriveKeys = function(e, n) {
  e.keys = new Array(16 * 2), fA.equal(n.length, this.blockSize, "Invalid key length");
  var a = tn.readUInt32BE(n, 0), c = tn.readUInt32BE(n, 4);
  tn.pc1(a, c, e.tmp, 0), a = e.tmp[0], c = e.tmp[1];
  for (var u = 0; u < e.keys.length; u += 2) {
    var r = KM[u >>> 1];
    a = tn.r28shl(a, r), c = tn.r28shl(c, r), tn.pc2(a, c, e.keys, u);
  }
};
hs.prototype._update = function(e, n, a, c) {
  var u = this._desState, r = tn.readUInt32BE(e, n), l = tn.readUInt32BE(e, n + 4);
  tn.ip(r, l, u.tmp, 0), r = u.tmp[0], l = u.tmp[1], this.type === "encrypt" ? this._encrypt(u, r, l, u.tmp, 0) : this._decrypt(u, r, l, u.tmp, 0), r = u.tmp[0], l = u.tmp[1], tn.writeUInt32BE(a, r, c), tn.writeUInt32BE(a, l, c + 4);
};
hs.prototype._pad = function(e, n) {
  if (this.padding === !1)
    return !1;
  for (var a = e.length - n, c = n; c < e.length; c++)
    e[c] = a;
  return !0;
};
hs.prototype._unpad = function(e) {
  if (this.padding === !1)
    return e;
  for (var n = e[e.length - 1], a = e.length - n; a < e.length; a++)
    fA.equal(e[a], n);
  return e.slice(0, e.length - n);
};
hs.prototype._encrypt = function(e, n, a, c, u) {
  for (var r = n, l = a, i = 0; i < e.keys.length; i += 2) {
    var f = e.keys[i], d = e.keys[i + 1];
    tn.expand(l, e.tmp, 0), f ^= e.tmp[0], d ^= e.tmp[1];
    var s = tn.substitute(f, d), o = tn.permute(s), m = l;
    l = (r ^ o) >>> 0, r = m;
  }
  tn.rip(l, r, c, u);
};
hs.prototype._decrypt = function(e, n, a, c, u) {
  for (var r = a, l = n, i = e.keys.length - 2; i >= 0; i -= 2) {
    var f = e.keys[i], d = e.keys[i + 1];
    tn.expand(r, e.tmp, 0), f ^= e.tmp[0], d ^= e.tmp[1];
    var s = tn.substitute(f, d), o = tn.permute(s), m = r;
    r = (l ^ o) >>> 0, l = m;
  }
  tn.rip(r, l, c, u);
};
var hA = {}, YM = wi, XM = Zt, Lf = {};
function JM(t) {
  YM.equal(t.length, 8, "Invalid IV length"), this.iv = new Array(8);
  for (var e = 0; e < this.iv.length; e++)
    this.iv[e] = t[e];
}
function QM(t) {
  function e(u) {
    t.call(this, u), this._cbcInit();
  }
  XM(e, t);
  for (var n = Object.keys(Lf), a = 0; a < n.length; a++) {
    var c = n[a];
    e.prototype[c] = Lf[c];
  }
  return e.create = function(r) {
    return new e(r);
  }, e;
}
hA.instantiate = QM;
Lf._cbcInit = function() {
  var e = new JM(this.options.iv);
  this._cbcState = e;
};
Lf._update = function(e, n, a, c) {
  var u = this._cbcState, r = this.constructor.super_.prototype, l = u.iv;
  if (this.type === "encrypt") {
    for (var i = 0; i < this.blockSize; i++)
      l[i] ^= e[n + i];
    r._update.call(this, l, 0, a, c);
    for (var i = 0; i < this.blockSize; i++)
      l[i] = a[c + i];
  } else {
    r._update.call(this, e, n, a, c);
    for (var i = 0; i < this.blockSize; i++)
      a[c + i] ^= l[i];
    for (var i = 0; i < this.blockSize; i++)
      l[i] = e[n + i];
  }
};
var ZM = wi, eL = Zt, mA = Iy, Js = pA;
function tL(t, e) {
  ZM.equal(e.length, 24, "Invalid key length");
  var n = e.slice(0, 8), a = e.slice(8, 16), c = e.slice(16, 24);
  t === "encrypt" ? this.ciphers = [
    Js.create({ type: "encrypt", key: n }),
    Js.create({ type: "decrypt", key: a }),
    Js.create({ type: "encrypt", key: c })
  ] : this.ciphers = [
    Js.create({ type: "decrypt", key: c }),
    Js.create({ type: "encrypt", key: a }),
    Js.create({ type: "decrypt", key: n })
  ];
}
function Va(t) {
  mA.call(this, t);
  var e = new tL(this.type, this.options.key);
  this._edeState = e;
}
eL(Va, mA);
var rL = Va;
Va.create = function(e) {
  return new Va(e);
};
Va.prototype._update = function(e, n, a, c) {
  var u = this._edeState;
  u.ciphers[0]._update(e, n, a, c), u.ciphers[1]._update(a, c, a, c), u.ciphers[2]._update(a, c, a, c);
};
Va.prototype._pad = Js.prototype._pad;
Va.prototype._unpad = Js.prototype._unpad;
sl.utils = ei;
sl.Cipher = Iy;
sl.DES = pA;
sl.CBC = hA;
sl.EDE = rL;
var yA = ma, Cs = sl, nL = Zt, Ia = er.Buffer, fu = {
  "des-ede3-cbc": Cs.CBC.instantiate(Cs.EDE),
  "des-ede3": Cs.EDE,
  "des-ede-cbc": Cs.CBC.instantiate(Cs.EDE),
  "des-ede": Cs.EDE,
  "des-cbc": Cs.CBC.instantiate(Cs.DES),
  "des-ecb": Cs.DES
};
fu.des = fu["des-cbc"];
fu.des3 = fu["des-ede3-cbc"];
var iL = qd;
nL(qd, yA);
function qd(t) {
  yA.call(this);
  var e = t.mode.toLowerCase(), n = fu[e], a;
  t.decrypt ? a = "decrypt" : a = "encrypt";
  var c = t.key;
  Ia.isBuffer(c) || (c = Ia.from(c)), (e === "des-ede" || e === "des-ede-cbc") && (c = Ia.concat([c, c.slice(0, 8)]));
  var u = t.iv;
  Ia.isBuffer(u) || (u = Ia.from(u)), this._des = n.create({
    key: c,
    iv: u,
    type: a
  });
}
qd.prototype._update = function(t) {
  return Ia.from(this._des.update(t));
};
qd.prototype._final = function() {
  return Ia.from(this._des.final());
};
var Qn = {}, Oy = {}, ky = {};
ky.encrypt = function(t, e) {
  return t._cipher.encryptBlock(e);
};
ky.decrypt = function(t, e) {
  return t._cipher.decryptBlock(e);
};
var Dy = {}, $u = function(e, n) {
  for (var a = Math.min(e.length, n.length), c = new Ve.Buffer(a), u = 0; u < a; ++u)
    c[u] = e[u] ^ n[u];
  return c;
}, bA = $u;
Dy.encrypt = function(t, e) {
  var n = bA(e, t._prev);
  return t._prev = t._cipher.encryptBlock(n), t._prev;
};
Dy.decrypt = function(t, e) {
  var n = t._prev;
  t._prev = e;
  var a = t._cipher.decryptBlock(e);
  return bA(a, n);
};
var gA = {}, Vl = er.Buffer, sL = $u;
function FE(t, e, n) {
  var a = e.length, c = sL(e, t._cache);
  return t._cache = t._cache.slice(a), t._prev = Vl.concat([t._prev, n ? e : c]), c;
}
gA.encrypt = function(t, e, n) {
  for (var a = Vl.allocUnsafe(0), c; e.length; )
    if (t._cache.length === 0 && (t._cache = t._cipher.encryptBlock(t._prev), t._prev = Vl.allocUnsafe(0)), t._cache.length <= e.length)
      c = t._cache.length, a = Vl.concat([a, FE(t, e.slice(0, c), n)]), e = e.slice(c);
    else {
      a = Vl.concat([a, FE(t, e, n)]);
      break;
    }
  return a;
};
var vA = {}, G1 = er.Buffer;
function aL(t, e, n) {
  var a = t._cipher.encryptBlock(t._prev), c = a[0] ^ e;
  return t._prev = G1.concat([
    t._prev.slice(1),
    G1.from([n ? e : c])
  ]), c;
}
vA.encrypt = function(t, e, n) {
  for (var a = e.length, c = G1.allocUnsafe(a), u = -1; ++u < a; )
    c[u] = aL(t, e[u], n);
  return c;
};
var EA = {}, ff = er.Buffer;
function oL(t, e, n) {
  for (var a, c = -1, u = 8, r = 0, l, i; ++c < u; )
    a = t._cipher.encryptBlock(t._prev), l = e & 1 << 7 - c ? 128 : 0, i = a[0] ^ l, r += (i & 128) >> c % 8, t._prev = lL(t._prev, n ? l : i);
  return r;
}
function lL(t, e) {
  var n = t.length, a = -1, c = ff.allocUnsafe(t.length);
  for (t = ff.concat([t, ff.from([e])]); ++a < n; )
    c[a] = t[a] << 1 | t[a + 1] >> 7;
  return c;
}
EA.encrypt = function(t, e, n) {
  for (var a = e.length, c = ff.allocUnsafe(a), u = -1; ++u < a; )
    c[u] = oL(t, e[u], n);
  return c;
};
var _A = {}, uL = $u;
function cL(t) {
  return t._prev = t._cipher.encryptBlock(t._prev), t._prev;
}
_A.encrypt = function(t, e) {
  for (; t._cache.length < e.length; )
    t._cache = Ve.Buffer.concat([t._cache, cL(t)]);
  var n = t._cache.slice(0, e.length);
  return t._cache = t._cache.slice(e.length), uL(e, n);
};
var z1 = {};
function fL(t) {
  for (var e = t.length, n; e--; )
    if (n = t.readUInt8(e), n === 255)
      t.writeUInt8(0, e);
    else {
      n++, t.writeUInt8(n, e);
      break;
    }
}
var SA = fL, dL = $u, BE = er.Buffer, pL = SA;
function hL(t) {
  var e = t._cipher.encryptBlockRaw(t._prev);
  return pL(t._prev), e;
}
var Gh = 16;
z1.encrypt = function(t, e) {
  var n = Math.ceil(e.length / Gh), a = t._cache.length;
  t._cache = BE.concat([
    t._cache,
    BE.allocUnsafe(n * Gh)
  ]);
  for (var c = 0; c < n; c++) {
    var u = hL(t), r = a + c * Gh;
    t._cache.writeUInt32BE(u[0], r + 0), t._cache.writeUInt32BE(u[1], r + 4), t._cache.writeUInt32BE(u[2], r + 8), t._cache.writeUInt32BE(u[3], r + 12);
  }
  var l = t._cache.slice(0, e.length);
  return t._cache = t._cache.slice(e.length), dL(e, l);
};
const mL = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, yL = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, bL = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, wA = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128: mL,
  aes192: yL,
  aes256: bL,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var gL = {
  ECB: ky,
  CBC: Dy,
  CFB: gA,
  CFB8: vA,
  CFB1: EA,
  OFB: _A,
  CTR: z1,
  GCM: z1
}, df = wA;
for (var $E in df)
  df[$E].module = gL[df[$E].mode];
var Ny = df, Uu = {}, jf = er.Buffer;
function Ry(t) {
  jf.isBuffer(t) || (t = jf.from(t));
  for (var e = t.length / 4 | 0, n = new Array(e), a = 0; a < e; a++)
    n[a] = t.readUInt32BE(a * 4);
  return n;
}
function zh(t) {
  for (var e = 0; e < t.length; t++)
    t[e] = 0;
}
function TA(t, e, n, a, c) {
  for (var u = n[0], r = n[1], l = n[2], i = n[3], f = t[0] ^ e[0], d = t[1] ^ e[1], s = t[2] ^ e[2], o = t[3] ^ e[3], m, h, y, b, E = 4, S = 1; S < c; S++)
    m = u[f >>> 24] ^ r[d >>> 16 & 255] ^ l[s >>> 8 & 255] ^ i[o & 255] ^ e[E++], h = u[d >>> 24] ^ r[s >>> 16 & 255] ^ l[o >>> 8 & 255] ^ i[f & 255] ^ e[E++], y = u[s >>> 24] ^ r[o >>> 16 & 255] ^ l[f >>> 8 & 255] ^ i[d & 255] ^ e[E++], b = u[o >>> 24] ^ r[f >>> 16 & 255] ^ l[d >>> 8 & 255] ^ i[s & 255] ^ e[E++], f = m, d = h, s = y, o = b;
  return m = (a[f >>> 24] << 24 | a[d >>> 16 & 255] << 16 | a[s >>> 8 & 255] << 8 | a[o & 255]) ^ e[E++], h = (a[d >>> 24] << 24 | a[s >>> 16 & 255] << 16 | a[o >>> 8 & 255] << 8 | a[f & 255]) ^ e[E++], y = (a[s >>> 24] << 24 | a[o >>> 16 & 255] << 16 | a[f >>> 8 & 255] << 8 | a[d & 255]) ^ e[E++], b = (a[o >>> 24] << 24 | a[f >>> 16 & 255] << 16 | a[d >>> 8 & 255] << 8 | a[s & 255]) ^ e[E++], m = m >>> 0, h = h >>> 0, y = y >>> 0, b = b >>> 0, [m, h, y, b];
}
var vL = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], Yr = function() {
  for (var t = new Array(256), e = 0; e < 256; e++)
    e < 128 ? t[e] = e << 1 : t[e] = e << 1 ^ 283;
  for (var n = [], a = [], c = [[], [], [], []], u = [[], [], [], []], r = 0, l = 0, i = 0; i < 256; ++i) {
    var f = l ^ l << 1 ^ l << 2 ^ l << 3 ^ l << 4;
    f = f >>> 8 ^ f & 255 ^ 99, n[r] = f, a[f] = r;
    var d = t[r], s = t[d], o = t[s], m = t[f] * 257 ^ f * 16843008;
    c[0][r] = m << 24 | m >>> 8, c[1][r] = m << 16 | m >>> 16, c[2][r] = m << 8 | m >>> 24, c[3][r] = m, m = o * 16843009 ^ s * 65537 ^ d * 257 ^ r * 16843008, u[0][f] = m << 24 | m >>> 8, u[1][f] = m << 16 | m >>> 16, u[2][f] = m << 8 | m >>> 24, u[3][f] = m, r === 0 ? r = l = 1 : (r = d ^ t[t[t[o ^ d]]], l ^= t[t[l]]);
  }
  return {
    SBOX: n,
    INV_SBOX: a,
    SUB_MIX: c,
    INV_SUB_MIX: u
  };
}();
function bi(t) {
  this._key = Ry(t), this._reset();
}
bi.blockSize = 4 * 4;
bi.keySize = 256 / 8;
bi.prototype.blockSize = bi.blockSize;
bi.prototype.keySize = bi.keySize;
bi.prototype._reset = function() {
  for (var t = this._key, e = t.length, n = e + 6, a = (n + 1) * 4, c = [], u = 0; u < e; u++)
    c[u] = t[u];
  for (u = e; u < a; u++) {
    var r = c[u - 1];
    u % e === 0 ? (r = r << 8 | r >>> 24, r = Yr.SBOX[r >>> 24] << 24 | Yr.SBOX[r >>> 16 & 255] << 16 | Yr.SBOX[r >>> 8 & 255] << 8 | Yr.SBOX[r & 255], r ^= vL[u / e | 0] << 24) : e > 6 && u % e === 4 && (r = Yr.SBOX[r >>> 24] << 24 | Yr.SBOX[r >>> 16 & 255] << 16 | Yr.SBOX[r >>> 8 & 255] << 8 | Yr.SBOX[r & 255]), c[u] = c[u - e] ^ r;
  }
  for (var l = [], i = 0; i < a; i++) {
    var f = a - i, d = c[f - (i % 4 ? 0 : 4)];
    i < 4 || f <= 4 ? l[i] = d : l[i] = Yr.INV_SUB_MIX[0][Yr.SBOX[d >>> 24]] ^ Yr.INV_SUB_MIX[1][Yr.SBOX[d >>> 16 & 255]] ^ Yr.INV_SUB_MIX[2][Yr.SBOX[d >>> 8 & 255]] ^ Yr.INV_SUB_MIX[3][Yr.SBOX[d & 255]];
  }
  this._nRounds = n, this._keySchedule = c, this._invKeySchedule = l;
};
bi.prototype.encryptBlockRaw = function(t) {
  return t = Ry(t), TA(t, this._keySchedule, Yr.SUB_MIX, Yr.SBOX, this._nRounds);
};
bi.prototype.encryptBlock = function(t) {
  var e = this.encryptBlockRaw(t), n = jf.allocUnsafe(16);
  return n.writeUInt32BE(e[0], 0), n.writeUInt32BE(e[1], 4), n.writeUInt32BE(e[2], 8), n.writeUInt32BE(e[3], 12), n;
};
bi.prototype.decryptBlock = function(t) {
  t = Ry(t);
  var e = t[1];
  t[1] = t[3], t[3] = e;
  var n = TA(t, this._invKeySchedule, Yr.INV_SUB_MIX, Yr.INV_SBOX, this._nRounds), a = jf.allocUnsafe(16);
  return a.writeUInt32BE(n[0], 0), a.writeUInt32BE(n[3], 4), a.writeUInt32BE(n[2], 8), a.writeUInt32BE(n[1], 12), a;
};
bi.prototype.scrub = function() {
  zh(this._keySchedule), zh(this._invKeySchedule), zh(this._key);
};
Uu.AES = bi;
var Bo = er.Buffer, EL = Bo.alloc(16, 0);
function _L(t) {
  return [
    t.readUInt32BE(0),
    t.readUInt32BE(4),
    t.readUInt32BE(8),
    t.readUInt32BE(12)
  ];
}
function AA(t) {
  var e = Bo.allocUnsafe(16);
  return e.writeUInt32BE(t[0] >>> 0, 0), e.writeUInt32BE(t[1] >>> 0, 4), e.writeUInt32BE(t[2] >>> 0, 8), e.writeUInt32BE(t[3] >>> 0, 12), e;
}
function Vu(t) {
  this.h = t, this.state = Bo.alloc(16, 0), this.cache = Bo.allocUnsafe(0);
}
Vu.prototype.ghash = function(t) {
  for (var e = -1; ++e < t.length; )
    this.state[e] ^= t[e];
  this._multiply();
};
Vu.prototype._multiply = function() {
  for (var t = _L(this.h), e = [0, 0, 0, 0], n, a, c, u = -1; ++u < 128; ) {
    for (a = (this.state[~~(u / 8)] & 1 << 7 - u % 8) !== 0, a && (e[0] ^= t[0], e[1] ^= t[1], e[2] ^= t[2], e[3] ^= t[3]), c = (t[3] & 1) !== 0, n = 3; n > 0; n--)
      t[n] = t[n] >>> 1 | (t[n - 1] & 1) << 31;
    t[0] = t[0] >>> 1, c && (t[0] = t[0] ^ 225 << 24);
  }
  this.state = AA(e);
};
Vu.prototype.update = function(t) {
  this.cache = Bo.concat([this.cache, t]);
  for (var e; this.cache.length >= 16; )
    e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e);
};
Vu.prototype.final = function(t, e) {
  return this.cache.length && this.ghash(Bo.concat([this.cache, EL], 16)), this.ghash(AA([0, t, 0, e])), this.state;
};
var SL = Vu, wL = Uu, Un = er.Buffer, xA = ma, TL = Zt, PA = SL, AL = $u, xL = SA;
function PL(t, e) {
  var n = 0;
  t.length !== e.length && n++;
  for (var a = Math.min(t.length, e.length), c = 0; c < a; ++c)
    n += t[c] ^ e[c];
  return n;
}
function CL(t, e, n) {
  if (e.length === 12)
    return t._finID = Un.concat([e, Un.from([0, 0, 0, 1])]), Un.concat([e, Un.from([0, 0, 0, 2])]);
  var a = new PA(n), c = e.length, u = c % 16;
  a.update(e), u && (u = 16 - u, a.update(Un.alloc(u, 0))), a.update(Un.alloc(8, 0));
  var r = c * 8, l = Un.alloc(8);
  l.writeUIntBE(r, 0, 8), a.update(l), t._finID = a.state;
  var i = Un.from(t._finID);
  return xL(i), i;
}
function Za(t, e, n, a) {
  xA.call(this);
  var c = Un.alloc(4, 0);
  this._cipher = new wL.AES(e);
  var u = this._cipher.encryptBlock(c);
  this._ghash = new PA(u), n = CL(this, n, u), this._prev = Un.from(n), this._cache = Un.allocUnsafe(0), this._secCache = Un.allocUnsafe(0), this._decrypt = a, this._alen = 0, this._len = 0, this._mode = t, this._authTag = null, this._called = !1;
}
TL(Za, xA);
Za.prototype._update = function(t) {
  if (!this._called && this._alen) {
    var e = 16 - this._alen % 16;
    e < 16 && (e = Un.alloc(e, 0), this._ghash.update(e));
  }
  this._called = !0;
  var n = this._mode.encrypt(this, t);
  return this._decrypt ? this._ghash.update(t) : this._ghash.update(n), this._len += t.length, n;
};
Za.prototype._final = function() {
  if (this._decrypt && !this._authTag)
    throw new Error("Unsupported state or unable to authenticate data");
  var t = AL(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && PL(t, this._authTag))
    throw new Error("Unsupported state or unable to authenticate data");
  this._authTag = t, this._cipher.scrub();
};
Za.prototype.getAuthTag = function() {
  if (this._decrypt || !Un.isBuffer(this._authTag))
    throw new Error("Attempting to get auth tag in unsupported state");
  return this._authTag;
};
Za.prototype.setAuthTag = function(e) {
  if (!this._decrypt)
    throw new Error("Attempting to set auth tag in unsupported state");
  this._authTag = e;
};
Za.prototype.setAAD = function(e) {
  if (this._called)
    throw new Error("Attempting to set AAD in unsupported state");
  this._ghash.update(e), this._alen += e.length;
};
var CA = Za, IL = Uu, Kh = er.Buffer, IA = ma, OL = Zt;
function Gd(t, e, n, a) {
  IA.call(this), this._cipher = new IL.AES(e), this._prev = Kh.from(n), this._cache = Kh.allocUnsafe(0), this._secCache = Kh.allocUnsafe(0), this._decrypt = a, this._mode = t;
}
OL(Gd, IA);
Gd.prototype._update = function(t) {
  return this._mode.encrypt(this, t, this._decrypt);
};
Gd.prototype._final = function() {
  this._cipher.scrub();
};
var OA = Gd, Ta = er.Buffer, kL = xy;
function DL(t, e, n, a) {
  if (Ta.isBuffer(t) || (t = Ta.from(t, "binary")), e && (Ta.isBuffer(e) || (e = Ta.from(e, "binary")), e.length !== 8))
    throw new RangeError("salt should be Buffer with 8 byte length");
  for (var c = n / 8, u = Ta.alloc(c), r = Ta.alloc(a || 0), l = Ta.alloc(0); c > 0 || a > 0; ) {
    var i = new kL();
    i.update(l), i.update(t), e && i.update(e), l = i.digest();
    var f = 0;
    if (c > 0) {
      var d = u.length - c;
      f = Math.min(c, l.length), l.copy(u, d, 0, f), c -= f;
    }
    if (f < l.length && a > 0) {
      var s = r.length - a, o = Math.min(a, l.length - f);
      l.copy(r, s, f, f + o), a -= o;
    }
  }
  return l.fill(0), { key: u, iv: r };
}
var zd = DL, kA = Ny, NL = CA, Fs = er.Buffer, RL = OA, DA = ma, ML = Uu, LL = zd, jL = Zt;
function Wu(t, e, n) {
  DA.call(this), this._cache = new Kd(), this._cipher = new ML.AES(e), this._prev = Fs.from(n), this._mode = t, this._autopadding = !0;
}
jL(Wu, DA);
Wu.prototype._update = function(t) {
  this._cache.add(t);
  for (var e, n, a = []; e = this._cache.get(); )
    n = this._mode.encrypt(this, e), a.push(n);
  return Fs.concat(a);
};
var FL = Fs.alloc(16, 16);
Wu.prototype._final = function() {
  var t = this._cache.flush();
  if (this._autopadding)
    return t = this._mode.encrypt(this, t), this._cipher.scrub(), t;
  if (!t.equals(FL))
    throw this._cipher.scrub(), new Error("data not multiple of block length");
};
Wu.prototype.setAutoPadding = function(t) {
  return this._autopadding = !!t, this;
};
function Kd() {
  this.cache = Fs.allocUnsafe(0);
}
Kd.prototype.add = function(t) {
  this.cache = Fs.concat([this.cache, t]);
};
Kd.prototype.get = function() {
  if (this.cache.length > 15) {
    var t = this.cache.slice(0, 16);
    return this.cache = this.cache.slice(16), t;
  }
  return null;
};
Kd.prototype.flush = function() {
  for (var t = 16 - this.cache.length, e = Fs.allocUnsafe(t), n = -1; ++n < t; )
    e.writeUInt8(t, n);
  return Fs.concat([this.cache, e]);
};
function NA(t, e, n) {
  var a = kA[t.toLowerCase()];
  if (!a)
    throw new TypeError("invalid suite type");
  if (typeof e == "string" && (e = Fs.from(e)), e.length !== a.key / 8)
    throw new TypeError("invalid key length " + e.length);
  if (typeof n == "string" && (n = Fs.from(n)), a.mode !== "GCM" && n.length !== a.iv)
    throw new TypeError("invalid iv length " + n.length);
  return a.type === "stream" ? new RL(a.module, e, n) : a.type === "auth" ? new NL(a.module, e, n) : new Wu(a.module, e, n);
}
function BL(t, e) {
  var n = kA[t.toLowerCase()];
  if (!n)
    throw new TypeError("invalid suite type");
  var a = LL(e, !1, n.key, n.iv);
  return NA(t, a.key, a.iv);
}
Oy.createCipheriv = NA;
Oy.createCipher = BL;
var My = {}, $L = CA, $o = er.Buffer, RA = Ny, UL = OA, MA = ma, VL = Uu, WL = zd, HL = Zt;
function Hu(t, e, n) {
  MA.call(this), this._cache = new Yd(), this._last = void 0, this._cipher = new VL.AES(e), this._prev = $o.from(n), this._mode = t, this._autopadding = !0;
}
HL(Hu, MA);
Hu.prototype._update = function(t) {
  this._cache.add(t);
  for (var e, n, a = []; e = this._cache.get(this._autopadding); )
    n = this._mode.decrypt(this, e), a.push(n);
  return $o.concat(a);
};
Hu.prototype._final = function() {
  var t = this._cache.flush();
  if (this._autopadding)
    return qL(this._mode.decrypt(this, t));
  if (t)
    throw new Error("data not multiple of block length");
};
Hu.prototype.setAutoPadding = function(t) {
  return this._autopadding = !!t, this;
};
function Yd() {
  this.cache = $o.allocUnsafe(0);
}
Yd.prototype.add = function(t) {
  this.cache = $o.concat([this.cache, t]);
};
Yd.prototype.get = function(t) {
  var e;
  if (t) {
    if (this.cache.length > 16)
      return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
  } else if (this.cache.length >= 16)
    return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
  return null;
};
Yd.prototype.flush = function() {
  if (this.cache.length)
    return this.cache;
};
function qL(t) {
  var e = t[15];
  if (e < 1 || e > 16)
    throw new Error("unable to decrypt data");
  for (var n = -1; ++n < e; )
    if (t[n + (16 - e)] !== e)
      throw new Error("unable to decrypt data");
  if (e !== 16)
    return t.slice(0, 16 - e);
}
function LA(t, e, n) {
  var a = RA[t.toLowerCase()];
  if (!a)
    throw new TypeError("invalid suite type");
  if (typeof n == "string" && (n = $o.from(n)), a.mode !== "GCM" && n.length !== a.iv)
    throw new TypeError("invalid iv length " + n.length);
  if (typeof e == "string" && (e = $o.from(e)), e.length !== a.key / 8)
    throw new TypeError("invalid key length " + e.length);
  return a.type === "stream" ? new UL(a.module, e, n, !0) : a.type === "auth" ? new $L(a.module, e, n, !0) : new Hu(a.module, e, n);
}
function GL(t, e) {
  var n = RA[t.toLowerCase()];
  if (!n)
    throw new TypeError("invalid suite type");
  var a = WL(e, !1, n.key, n.iv);
  return LA(t, a.key, a.iv);
}
My.createDecipher = GL;
My.createDecipheriv = LA;
var jA = Oy, FA = My, zL = wA;
function KL() {
  return Object.keys(zL);
}
Qn.createCipher = Qn.Cipher = jA.createCipher;
Qn.createCipheriv = Qn.Cipheriv = jA.createCipheriv;
Qn.createDecipher = Qn.Decipher = FA.createDecipher;
Qn.createDecipheriv = Qn.Decipheriv = FA.createDecipheriv;
Qn.listCiphers = Qn.getCiphers = KL;
var BA = {};
(function(t) {
  t["des-ecb"] = {
    key: 8,
    iv: 0
  }, t["des-cbc"] = t.des = {
    key: 8,
    iv: 8
  }, t["des-ede3-cbc"] = t.des3 = {
    key: 24,
    iv: 8
  }, t["des-ede3"] = {
    key: 24,
    iv: 0
  }, t["des-ede-cbc"] = {
    key: 16,
    iv: 8
  }, t["des-ede"] = {
    key: 16,
    iv: 0
  };
})(BA);
var $A = iL, Ly = Qn, ta = Ny, Ms = BA, UA = zd;
function YL(t, e) {
  t = t.toLowerCase();
  var n, a;
  if (ta[t])
    n = ta[t].key, a = ta[t].iv;
  else if (Ms[t])
    n = Ms[t].key * 8, a = Ms[t].iv;
  else
    throw new TypeError("invalid suite type");
  var c = UA(e, !1, n, a);
  return VA(t, c.key, c.iv);
}
function XL(t, e) {
  t = t.toLowerCase();
  var n, a;
  if (ta[t])
    n = ta[t].key, a = ta[t].iv;
  else if (Ms[t])
    n = Ms[t].key * 8, a = Ms[t].iv;
  else
    throw new TypeError("invalid suite type");
  var c = UA(e, !1, n, a);
  return WA(t, c.key, c.iv);
}
function VA(t, e, n) {
  if (t = t.toLowerCase(), ta[t])
    return Ly.createCipheriv(t, e, n);
  if (Ms[t])
    return new $A({ key: e, iv: n, mode: t });
  throw new TypeError("invalid suite type");
}
function WA(t, e, n) {
  if (t = t.toLowerCase(), ta[t])
    return Ly.createDecipheriv(t, e, n);
  if (Ms[t])
    return new $A({ key: e, iv: n, mode: t, decrypt: !0 });
  throw new TypeError("invalid suite type");
}
function JL() {
  return Object.keys(Ms).concat(Ly.getCiphers());
}
Mi.createCipher = Mi.Cipher = YL;
Mi.createCipheriv = Mi.Cipheriv = VA;
Mi.createDecipher = Mi.Decipher = XL;
Mi.createDecipheriv = Mi.Decipheriv = WA;
Mi.listCiphers = Mi.getCiphers = JL;
var Aa = {}, jy = { exports: {} };
jy.exports;
(function(t) {
  (function(e, n) {
    function a(F, _) {
      if (!F)
        throw new Error(_ || "Assertion failed");
    }
    function c(F, _) {
      F.super_ = _;
      var T = function() {
      };
      T.prototype = _.prototype, F.prototype = new T(), F.prototype.constructor = F;
    }
    function u(F, _, T) {
      if (u.isBN(F))
        return F;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, F !== null && ((_ === "le" || _ === "be") && (T = _, _ = 10), this._init(F || 0, _ || 10, T || "be"));
    }
    typeof e == "object" ? e.exports = u : n.BN = u, u.BN = u, u.wordSize = 26;
    var r;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? r = window.Buffer : r = xr.Buffer;
    } catch {
    }
    u.isBN = function(_) {
      return _ instanceof u ? !0 : _ !== null && typeof _ == "object" && _.constructor.wordSize === u.wordSize && Array.isArray(_.words);
    }, u.max = function(_, T) {
      return _.cmp(T) > 0 ? _ : T;
    }, u.min = function(_, T) {
      return _.cmp(T) < 0 ? _ : T;
    }, u.prototype._init = function(_, T, v) {
      if (typeof _ == "number")
        return this._initNumber(_, T, v);
      if (typeof _ == "object")
        return this._initArray(_, T, v);
      T === "hex" && (T = 16), a(T === (T | 0) && T >= 2 && T <= 36), _ = _.toString().replace(/\s+/g, "");
      var w = 0;
      _[0] === "-" && (w++, this.negative = 1), w < _.length && (T === 16 ? this._parseHex(_, w, v) : (this._parseBase(_, T, w), v === "le" && this._initArray(this.toArray(), T, v)));
    }, u.prototype._initNumber = function(_, T, v) {
      _ < 0 && (this.negative = 1, _ = -_), _ < 67108864 ? (this.words = [_ & 67108863], this.length = 1) : _ < 4503599627370496 ? (this.words = [
        _ & 67108863,
        _ / 67108864 & 67108863
      ], this.length = 2) : (a(_ < 9007199254740992), this.words = [
        _ & 67108863,
        _ / 67108864 & 67108863,
        1
      ], this.length = 3), v === "le" && this._initArray(this.toArray(), T, v);
    }, u.prototype._initArray = function(_, T, v) {
      if (a(typeof _.length == "number"), _.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(_.length / 3), this.words = new Array(this.length);
      for (var w = 0; w < this.length; w++)
        this.words[w] = 0;
      var O, G, W = 0;
      if (v === "be")
        for (w = _.length - 1, O = 0; w >= 0; w -= 3)
          G = _[w] | _[w - 1] << 8 | _[w - 2] << 16, this.words[O] |= G << W & 67108863, this.words[O + 1] = G >>> 26 - W & 67108863, W += 24, W >= 26 && (W -= 26, O++);
      else if (v === "le")
        for (w = 0, O = 0; w < _.length; w += 3)
          G = _[w] | _[w + 1] << 8 | _[w + 2] << 16, this.words[O] |= G << W & 67108863, this.words[O + 1] = G >>> 26 - W & 67108863, W += 24, W >= 26 && (W -= 26, O++);
      return this.strip();
    };
    function l(F, _) {
      var T = F.charCodeAt(_);
      return T >= 65 && T <= 70 ? T - 55 : T >= 97 && T <= 102 ? T - 87 : T - 48 & 15;
    }
    function i(F, _, T) {
      var v = l(F, T);
      return T - 1 >= _ && (v |= l(F, T - 1) << 4), v;
    }
    u.prototype._parseHex = function(_, T, v) {
      this.length = Math.ceil((_.length - T) / 6), this.words = new Array(this.length);
      for (var w = 0; w < this.length; w++)
        this.words[w] = 0;
      var O = 0, G = 0, W;
      if (v === "be")
        for (w = _.length - 1; w >= T; w -= 2)
          W = i(_, T, w) << O, this.words[G] |= W & 67108863, O >= 18 ? (O -= 18, G += 1, this.words[G] |= W >>> 26) : O += 8;
      else {
        var U = _.length - T;
        for (w = U % 2 === 0 ? T + 1 : T; w < _.length; w += 2)
          W = i(_, T, w) << O, this.words[G] |= W & 67108863, O >= 18 ? (O -= 18, G += 1, this.words[G] |= W >>> 26) : O += 8;
      }
      this.strip();
    };
    function f(F, _, T, v) {
      for (var w = 0, O = Math.min(F.length, T), G = _; G < O; G++) {
        var W = F.charCodeAt(G) - 48;
        w *= v, W >= 49 ? w += W - 49 + 10 : W >= 17 ? w += W - 17 + 10 : w += W;
      }
      return w;
    }
    u.prototype._parseBase = function(_, T, v) {
      this.words = [0], this.length = 1;
      for (var w = 0, O = 1; O <= 67108863; O *= T)
        w++;
      w--, O = O / T | 0;
      for (var G = _.length - v, W = G % w, U = Math.min(G, G - W) + v, M = 0, B = v; B < U; B += w)
        M = f(_, B, B + w, T), this.imuln(O), this.words[0] + M < 67108864 ? this.words[0] += M : this._iaddn(M);
      if (W !== 0) {
        var k = 1;
        for (M = f(_, B, _.length, T), B = 0; B < W; B++)
          k *= T;
        this.imuln(k), this.words[0] + M < 67108864 ? this.words[0] += M : this._iaddn(M);
      }
      this.strip();
    }, u.prototype.copy = function(_) {
      _.words = new Array(this.length);
      for (var T = 0; T < this.length; T++)
        _.words[T] = this.words[T];
      _.length = this.length, _.negative = this.negative, _.red = this.red;
    }, u.prototype.clone = function() {
      var _ = new u(null);
      return this.copy(_), _;
    }, u.prototype._expand = function(_) {
      for (; this.length < _; )
        this.words[this.length++] = 0;
      return this;
    }, u.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, u.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, u.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var d = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], s = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], o = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    u.prototype.toString = function(_, T) {
      _ = _ || 10, T = T | 0 || 1;
      var v;
      if (_ === 16 || _ === "hex") {
        v = "";
        for (var w = 0, O = 0, G = 0; G < this.length; G++) {
          var W = this.words[G], U = ((W << w | O) & 16777215).toString(16);
          O = W >>> 24 - w & 16777215, O !== 0 || G !== this.length - 1 ? v = d[6 - U.length] + U + v : v = U + v, w += 2, w >= 26 && (w -= 26, G--);
        }
        for (O !== 0 && (v = O.toString(16) + v); v.length % T !== 0; )
          v = "0" + v;
        return this.negative !== 0 && (v = "-" + v), v;
      }
      if (_ === (_ | 0) && _ >= 2 && _ <= 36) {
        var M = s[_], B = o[_];
        v = "";
        var k = this.clone();
        for (k.negative = 0; !k.isZero(); ) {
          var K = k.modn(B).toString(_);
          k = k.idivn(B), k.isZero() ? v = K + v : v = d[M - K.length] + K + v;
        }
        for (this.isZero() && (v = "0" + v); v.length % T !== 0; )
          v = "0" + v;
        return this.negative !== 0 && (v = "-" + v), v;
      }
      a(!1, "Base should be between 2 and 36");
    }, u.prototype.toNumber = function() {
      var _ = this.words[0];
      return this.length === 2 ? _ += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? _ += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && a(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -_ : _;
    }, u.prototype.toJSON = function() {
      return this.toString(16);
    }, u.prototype.toBuffer = function(_, T) {
      return a(typeof r < "u"), this.toArrayLike(r, _, T);
    }, u.prototype.toArray = function(_, T) {
      return this.toArrayLike(Array, _, T);
    }, u.prototype.toArrayLike = function(_, T, v) {
      var w = this.byteLength(), O = v || Math.max(1, w);
      a(w <= O, "byte array longer than desired length"), a(O > 0, "Requested array length <= 0"), this.strip();
      var G = T === "le", W = new _(O), U, M, B = this.clone();
      if (G) {
        for (M = 0; !B.isZero(); M++)
          U = B.andln(255), B.iushrn(8), W[M] = U;
        for (; M < O; M++)
          W[M] = 0;
      } else {
        for (M = 0; M < O - w; M++)
          W[M] = 0;
        for (M = 0; !B.isZero(); M++)
          U = B.andln(255), B.iushrn(8), W[O - M - 1] = U;
      }
      return W;
    }, Math.clz32 ? u.prototype._countBits = function(_) {
      return 32 - Math.clz32(_);
    } : u.prototype._countBits = function(_) {
      var T = _, v = 0;
      return T >= 4096 && (v += 13, T >>>= 13), T >= 64 && (v += 7, T >>>= 7), T >= 8 && (v += 4, T >>>= 4), T >= 2 && (v += 2, T >>>= 2), v + T;
    }, u.prototype._zeroBits = function(_) {
      if (_ === 0)
        return 26;
      var T = _, v = 0;
      return T & 8191 || (v += 13, T >>>= 13), T & 127 || (v += 7, T >>>= 7), T & 15 || (v += 4, T >>>= 4), T & 3 || (v += 2, T >>>= 2), T & 1 || v++, v;
    }, u.prototype.bitLength = function() {
      var _ = this.words[this.length - 1], T = this._countBits(_);
      return (this.length - 1) * 26 + T;
    };
    function m(F) {
      for (var _ = new Array(F.bitLength()), T = 0; T < _.length; T++) {
        var v = T / 26 | 0, w = T % 26;
        _[T] = (F.words[v] & 1 << w) >>> w;
      }
      return _;
    }
    u.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var _ = 0, T = 0; T < this.length; T++) {
        var v = this._zeroBits(this.words[T]);
        if (_ += v, v !== 26)
          break;
      }
      return _;
    }, u.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, u.prototype.toTwos = function(_) {
      return this.negative !== 0 ? this.abs().inotn(_).iaddn(1) : this.clone();
    }, u.prototype.fromTwos = function(_) {
      return this.testn(_ - 1) ? this.notn(_).iaddn(1).ineg() : this.clone();
    }, u.prototype.isNeg = function() {
      return this.negative !== 0;
    }, u.prototype.neg = function() {
      return this.clone().ineg();
    }, u.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, u.prototype.iuor = function(_) {
      for (; this.length < _.length; )
        this.words[this.length++] = 0;
      for (var T = 0; T < _.length; T++)
        this.words[T] = this.words[T] | _.words[T];
      return this.strip();
    }, u.prototype.ior = function(_) {
      return a((this.negative | _.negative) === 0), this.iuor(_);
    }, u.prototype.or = function(_) {
      return this.length > _.length ? this.clone().ior(_) : _.clone().ior(this);
    }, u.prototype.uor = function(_) {
      return this.length > _.length ? this.clone().iuor(_) : _.clone().iuor(this);
    }, u.prototype.iuand = function(_) {
      var T;
      this.length > _.length ? T = _ : T = this;
      for (var v = 0; v < T.length; v++)
        this.words[v] = this.words[v] & _.words[v];
      return this.length = T.length, this.strip();
    }, u.prototype.iand = function(_) {
      return a((this.negative | _.negative) === 0), this.iuand(_);
    }, u.prototype.and = function(_) {
      return this.length > _.length ? this.clone().iand(_) : _.clone().iand(this);
    }, u.prototype.uand = function(_) {
      return this.length > _.length ? this.clone().iuand(_) : _.clone().iuand(this);
    }, u.prototype.iuxor = function(_) {
      var T, v;
      this.length > _.length ? (T = this, v = _) : (T = _, v = this);
      for (var w = 0; w < v.length; w++)
        this.words[w] = T.words[w] ^ v.words[w];
      if (this !== T)
        for (; w < T.length; w++)
          this.words[w] = T.words[w];
      return this.length = T.length, this.strip();
    }, u.prototype.ixor = function(_) {
      return a((this.negative | _.negative) === 0), this.iuxor(_);
    }, u.prototype.xor = function(_) {
      return this.length > _.length ? this.clone().ixor(_) : _.clone().ixor(this);
    }, u.prototype.uxor = function(_) {
      return this.length > _.length ? this.clone().iuxor(_) : _.clone().iuxor(this);
    }, u.prototype.inotn = function(_) {
      a(typeof _ == "number" && _ >= 0);
      var T = Math.ceil(_ / 26) | 0, v = _ % 26;
      this._expand(T), v > 0 && T--;
      for (var w = 0; w < T; w++)
        this.words[w] = ~this.words[w] & 67108863;
      return v > 0 && (this.words[w] = ~this.words[w] & 67108863 >> 26 - v), this.strip();
    }, u.prototype.notn = function(_) {
      return this.clone().inotn(_);
    }, u.prototype.setn = function(_, T) {
      a(typeof _ == "number" && _ >= 0);
      var v = _ / 26 | 0, w = _ % 26;
      return this._expand(v + 1), T ? this.words[v] = this.words[v] | 1 << w : this.words[v] = this.words[v] & ~(1 << w), this.strip();
    }, u.prototype.iadd = function(_) {
      var T;
      if (this.negative !== 0 && _.negative === 0)
        return this.negative = 0, T = this.isub(_), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && _.negative !== 0)
        return _.negative = 0, T = this.isub(_), _.negative = 1, T._normSign();
      var v, w;
      this.length > _.length ? (v = this, w = _) : (v = _, w = this);
      for (var O = 0, G = 0; G < w.length; G++)
        T = (v.words[G] | 0) + (w.words[G] | 0) + O, this.words[G] = T & 67108863, O = T >>> 26;
      for (; O !== 0 && G < v.length; G++)
        T = (v.words[G] | 0) + O, this.words[G] = T & 67108863, O = T >>> 26;
      if (this.length = v.length, O !== 0)
        this.words[this.length] = O, this.length++;
      else if (v !== this)
        for (; G < v.length; G++)
          this.words[G] = v.words[G];
      return this;
    }, u.prototype.add = function(_) {
      var T;
      return _.negative !== 0 && this.negative === 0 ? (_.negative = 0, T = this.sub(_), _.negative ^= 1, T) : _.negative === 0 && this.negative !== 0 ? (this.negative = 0, T = _.sub(this), this.negative = 1, T) : this.length > _.length ? this.clone().iadd(_) : _.clone().iadd(this);
    }, u.prototype.isub = function(_) {
      if (_.negative !== 0) {
        _.negative = 0;
        var T = this.iadd(_);
        return _.negative = 1, T._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(_), this.negative = 1, this._normSign();
      var v = this.cmp(_);
      if (v === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var w, O;
      v > 0 ? (w = this, O = _) : (w = _, O = this);
      for (var G = 0, W = 0; W < O.length; W++)
        T = (w.words[W] | 0) - (O.words[W] | 0) + G, G = T >> 26, this.words[W] = T & 67108863;
      for (; G !== 0 && W < w.length; W++)
        T = (w.words[W] | 0) + G, G = T >> 26, this.words[W] = T & 67108863;
      if (G === 0 && W < w.length && w !== this)
        for (; W < w.length; W++)
          this.words[W] = w.words[W];
      return this.length = Math.max(this.length, W), w !== this && (this.negative = 1), this.strip();
    }, u.prototype.sub = function(_) {
      return this.clone().isub(_);
    };
    function h(F, _, T) {
      T.negative = _.negative ^ F.negative;
      var v = F.length + _.length | 0;
      T.length = v, v = v - 1 | 0;
      var w = F.words[0] | 0, O = _.words[0] | 0, G = w * O, W = G & 67108863, U = G / 67108864 | 0;
      T.words[0] = W;
      for (var M = 1; M < v; M++) {
        for (var B = U >>> 26, k = U & 67108863, K = Math.min(M, _.length - 1), te = Math.max(0, M - F.length + 1); te <= K; te++) {
          var z = M - te | 0;
          w = F.words[z] | 0, O = _.words[te] | 0, G = w * O + k, B += G / 67108864 | 0, k = G & 67108863;
        }
        T.words[M] = k | 0, U = B | 0;
      }
      return U !== 0 ? T.words[M] = U | 0 : T.length--, T.strip();
    }
    var y = function(_, T, v) {
      var w = _.words, O = T.words, G = v.words, W = 0, U, M, B, k = w[0] | 0, K = k & 8191, te = k >>> 13, z = w[1] | 0, q = z & 8191, $ = z >>> 13, Y = w[2] | 0, H = Y & 8191, Q = Y >>> 13, X = w[3] | 0, ne = X & 8191, ye = X >>> 13, ve = w[4] | 0, de = ve & 8191, oe = ve >>> 13, re = w[5] | 0, ae = re & 8191, le = re >>> 13, ue = w[6] | 0, ie = ue & 8191, we = ue >>> 13, De = w[7] | 0, Ee = De & 8191, Ae = De >>> 13, Me = w[8] | 0, me = Me & 8191, se = Me >>> 13, Z = w[9] | 0, pe = Z & 8191, be = Z >>> 13, _e = O[0] | 0, Ie = _e & 8191, We = _e >>> 13, tt = O[1] | 0, Ye = tt & 8191, ht = tt >>> 13, ct = O[2] | 0, st = ct & 8191, Xe = ct >>> 13, Ke = O[3] | 0, Ce = Ke & 8191, xe = Ke >>> 13, He = O[4] | 0, Be = He & 8191, Ze = He >>> 13, nt = O[5] | 0, $e = nt & 8191, ut = nt >>> 13, vt = O[6] | 0, yt = vt & 8191, et = vt >>> 13, bt = O[7] | 0, lt = bt & 8191, Et = bt >>> 13, wt = O[8] | 0, Ne = wt & 8191, Je = wt >>> 13, ft = O[9] | 0, rt = ft & 8191, At = ft >>> 13;
      v.negative = _.negative ^ T.negative, v.length = 19, U = Math.imul(K, Ie), M = Math.imul(K, We), M = M + Math.imul(te, Ie) | 0, B = Math.imul(te, We);
      var Nt = (W + U | 0) + ((M & 8191) << 13) | 0;
      W = (B + (M >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, U = Math.imul(q, Ie), M = Math.imul(q, We), M = M + Math.imul($, Ie) | 0, B = Math.imul($, We), U = U + Math.imul(K, Ye) | 0, M = M + Math.imul(K, ht) | 0, M = M + Math.imul(te, Ye) | 0, B = B + Math.imul(te, ht) | 0;
      var Tt = (W + U | 0) + ((M & 8191) << 13) | 0;
      W = (B + (M >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, U = Math.imul(H, Ie), M = Math.imul(H, We), M = M + Math.imul(Q, Ie) | 0, B = Math.imul(Q, We), U = U + Math.imul(q, Ye) | 0, M = M + Math.imul(q, ht) | 0, M = M + Math.imul($, Ye) | 0, B = B + Math.imul($, ht) | 0, U = U + Math.imul(K, st) | 0, M = M + Math.imul(K, Xe) | 0, M = M + Math.imul(te, st) | 0, B = B + Math.imul(te, Xe) | 0;
      var Ot = (W + U | 0) + ((M & 8191) << 13) | 0;
      W = (B + (M >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, U = Math.imul(ne, Ie), M = Math.imul(ne, We), M = M + Math.imul(ye, Ie) | 0, B = Math.imul(ye, We), U = U + Math.imul(H, Ye) | 0, M = M + Math.imul(H, ht) | 0, M = M + Math.imul(Q, Ye) | 0, B = B + Math.imul(Q, ht) | 0, U = U + Math.imul(q, st) | 0, M = M + Math.imul(q, Xe) | 0, M = M + Math.imul($, st) | 0, B = B + Math.imul($, Xe) | 0, U = U + Math.imul(K, Ce) | 0, M = M + Math.imul(K, xe) | 0, M = M + Math.imul(te, Ce) | 0, B = B + Math.imul(te, xe) | 0;
      var cr = (W + U | 0) + ((M & 8191) << 13) | 0;
      W = (B + (M >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, U = Math.imul(de, Ie), M = Math.imul(de, We), M = M + Math.imul(oe, Ie) | 0, B = Math.imul(oe, We), U = U + Math.imul(ne, Ye) | 0, M = M + Math.imul(ne, ht) | 0, M = M + Math.imul(ye, Ye) | 0, B = B + Math.imul(ye, ht) | 0, U = U + Math.imul(H, st) | 0, M = M + Math.imul(H, Xe) | 0, M = M + Math.imul(Q, st) | 0, B = B + Math.imul(Q, Xe) | 0, U = U + Math.imul(q, Ce) | 0, M = M + Math.imul(q, xe) | 0, M = M + Math.imul($, Ce) | 0, B = B + Math.imul($, xe) | 0, U = U + Math.imul(K, Be) | 0, M = M + Math.imul(K, Ze) | 0, M = M + Math.imul(te, Be) | 0, B = B + Math.imul(te, Ze) | 0;
      var Wt = (W + U | 0) + ((M & 8191) << 13) | 0;
      W = (B + (M >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, U = Math.imul(ae, Ie), M = Math.imul(ae, We), M = M + Math.imul(le, Ie) | 0, B = Math.imul(le, We), U = U + Math.imul(de, Ye) | 0, M = M + Math.imul(de, ht) | 0, M = M + Math.imul(oe, Ye) | 0, B = B + Math.imul(oe, ht) | 0, U = U + Math.imul(ne, st) | 0, M = M + Math.imul(ne, Xe) | 0, M = M + Math.imul(ye, st) | 0, B = B + Math.imul(ye, Xe) | 0, U = U + Math.imul(H, Ce) | 0, M = M + Math.imul(H, xe) | 0, M = M + Math.imul(Q, Ce) | 0, B = B + Math.imul(Q, xe) | 0, U = U + Math.imul(q, Be) | 0, M = M + Math.imul(q, Ze) | 0, M = M + Math.imul($, Be) | 0, B = B + Math.imul($, Ze) | 0, U = U + Math.imul(K, $e) | 0, M = M + Math.imul(K, ut) | 0, M = M + Math.imul(te, $e) | 0, B = B + Math.imul(te, ut) | 0;
      var Jt = (W + U | 0) + ((M & 8191) << 13) | 0;
      W = (B + (M >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, U = Math.imul(ie, Ie), M = Math.imul(ie, We), M = M + Math.imul(we, Ie) | 0, B = Math.imul(we, We), U = U + Math.imul(ae, Ye) | 0, M = M + Math.imul(ae, ht) | 0, M = M + Math.imul(le, Ye) | 0, B = B + Math.imul(le, ht) | 0, U = U + Math.imul(de, st) | 0, M = M + Math.imul(de, Xe) | 0, M = M + Math.imul(oe, st) | 0, B = B + Math.imul(oe, Xe) | 0, U = U + Math.imul(ne, Ce) | 0, M = M + Math.imul(ne, xe) | 0, M = M + Math.imul(ye, Ce) | 0, B = B + Math.imul(ye, xe) | 0, U = U + Math.imul(H, Be) | 0, M = M + Math.imul(H, Ze) | 0, M = M + Math.imul(Q, Be) | 0, B = B + Math.imul(Q, Ze) | 0, U = U + Math.imul(q, $e) | 0, M = M + Math.imul(q, ut) | 0, M = M + Math.imul($, $e) | 0, B = B + Math.imul($, ut) | 0, U = U + Math.imul(K, yt) | 0, M = M + Math.imul(K, et) | 0, M = M + Math.imul(te, yt) | 0, B = B + Math.imul(te, et) | 0;
      var pr = (W + U | 0) + ((M & 8191) << 13) | 0;
      W = (B + (M >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, U = Math.imul(Ee, Ie), M = Math.imul(Ee, We), M = M + Math.imul(Ae, Ie) | 0, B = Math.imul(Ae, We), U = U + Math.imul(ie, Ye) | 0, M = M + Math.imul(ie, ht) | 0, M = M + Math.imul(we, Ye) | 0, B = B + Math.imul(we, ht) | 0, U = U + Math.imul(ae, st) | 0, M = M + Math.imul(ae, Xe) | 0, M = M + Math.imul(le, st) | 0, B = B + Math.imul(le, Xe) | 0, U = U + Math.imul(de, Ce) | 0, M = M + Math.imul(de, xe) | 0, M = M + Math.imul(oe, Ce) | 0, B = B + Math.imul(oe, xe) | 0, U = U + Math.imul(ne, Be) | 0, M = M + Math.imul(ne, Ze) | 0, M = M + Math.imul(ye, Be) | 0, B = B + Math.imul(ye, Ze) | 0, U = U + Math.imul(H, $e) | 0, M = M + Math.imul(H, ut) | 0, M = M + Math.imul(Q, $e) | 0, B = B + Math.imul(Q, ut) | 0, U = U + Math.imul(q, yt) | 0, M = M + Math.imul(q, et) | 0, M = M + Math.imul($, yt) | 0, B = B + Math.imul($, et) | 0, U = U + Math.imul(K, lt) | 0, M = M + Math.imul(K, Et) | 0, M = M + Math.imul(te, lt) | 0, B = B + Math.imul(te, Et) | 0;
      var $r = (W + U | 0) + ((M & 8191) << 13) | 0;
      W = (B + (M >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, U = Math.imul(me, Ie), M = Math.imul(me, We), M = M + Math.imul(se, Ie) | 0, B = Math.imul(se, We), U = U + Math.imul(Ee, Ye) | 0, M = M + Math.imul(Ee, ht) | 0, M = M + Math.imul(Ae, Ye) | 0, B = B + Math.imul(Ae, ht) | 0, U = U + Math.imul(ie, st) | 0, M = M + Math.imul(ie, Xe) | 0, M = M + Math.imul(we, st) | 0, B = B + Math.imul(we, Xe) | 0, U = U + Math.imul(ae, Ce) | 0, M = M + Math.imul(ae, xe) | 0, M = M + Math.imul(le, Ce) | 0, B = B + Math.imul(le, xe) | 0, U = U + Math.imul(de, Be) | 0, M = M + Math.imul(de, Ze) | 0, M = M + Math.imul(oe, Be) | 0, B = B + Math.imul(oe, Ze) | 0, U = U + Math.imul(ne, $e) | 0, M = M + Math.imul(ne, ut) | 0, M = M + Math.imul(ye, $e) | 0, B = B + Math.imul(ye, ut) | 0, U = U + Math.imul(H, yt) | 0, M = M + Math.imul(H, et) | 0, M = M + Math.imul(Q, yt) | 0, B = B + Math.imul(Q, et) | 0, U = U + Math.imul(q, lt) | 0, M = M + Math.imul(q, Et) | 0, M = M + Math.imul($, lt) | 0, B = B + Math.imul($, Et) | 0, U = U + Math.imul(K, Ne) | 0, M = M + Math.imul(K, Je) | 0, M = M + Math.imul(te, Ne) | 0, B = B + Math.imul(te, Je) | 0;
      var Ur = (W + U | 0) + ((M & 8191) << 13) | 0;
      W = (B + (M >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, U = Math.imul(pe, Ie), M = Math.imul(pe, We), M = M + Math.imul(be, Ie) | 0, B = Math.imul(be, We), U = U + Math.imul(me, Ye) | 0, M = M + Math.imul(me, ht) | 0, M = M + Math.imul(se, Ye) | 0, B = B + Math.imul(se, ht) | 0, U = U + Math.imul(Ee, st) | 0, M = M + Math.imul(Ee, Xe) | 0, M = M + Math.imul(Ae, st) | 0, B = B + Math.imul(Ae, Xe) | 0, U = U + Math.imul(ie, Ce) | 0, M = M + Math.imul(ie, xe) | 0, M = M + Math.imul(we, Ce) | 0, B = B + Math.imul(we, xe) | 0, U = U + Math.imul(ae, Be) | 0, M = M + Math.imul(ae, Ze) | 0, M = M + Math.imul(le, Be) | 0, B = B + Math.imul(le, Ze) | 0, U = U + Math.imul(de, $e) | 0, M = M + Math.imul(de, ut) | 0, M = M + Math.imul(oe, $e) | 0, B = B + Math.imul(oe, ut) | 0, U = U + Math.imul(ne, yt) | 0, M = M + Math.imul(ne, et) | 0, M = M + Math.imul(ye, yt) | 0, B = B + Math.imul(ye, et) | 0, U = U + Math.imul(H, lt) | 0, M = M + Math.imul(H, Et) | 0, M = M + Math.imul(Q, lt) | 0, B = B + Math.imul(Q, Et) | 0, U = U + Math.imul(q, Ne) | 0, M = M + Math.imul(q, Je) | 0, M = M + Math.imul($, Ne) | 0, B = B + Math.imul($, Je) | 0, U = U + Math.imul(K, rt) | 0, M = M + Math.imul(K, At) | 0, M = M + Math.imul(te, rt) | 0, B = B + Math.imul(te, At) | 0;
      var _r = (W + U | 0) + ((M & 8191) << 13) | 0;
      W = (B + (M >>> 13) | 0) + (_r >>> 26) | 0, _r &= 67108863, U = Math.imul(pe, Ye), M = Math.imul(pe, ht), M = M + Math.imul(be, Ye) | 0, B = Math.imul(be, ht), U = U + Math.imul(me, st) | 0, M = M + Math.imul(me, Xe) | 0, M = M + Math.imul(se, st) | 0, B = B + Math.imul(se, Xe) | 0, U = U + Math.imul(Ee, Ce) | 0, M = M + Math.imul(Ee, xe) | 0, M = M + Math.imul(Ae, Ce) | 0, B = B + Math.imul(Ae, xe) | 0, U = U + Math.imul(ie, Be) | 0, M = M + Math.imul(ie, Ze) | 0, M = M + Math.imul(we, Be) | 0, B = B + Math.imul(we, Ze) | 0, U = U + Math.imul(ae, $e) | 0, M = M + Math.imul(ae, ut) | 0, M = M + Math.imul(le, $e) | 0, B = B + Math.imul(le, ut) | 0, U = U + Math.imul(de, yt) | 0, M = M + Math.imul(de, et) | 0, M = M + Math.imul(oe, yt) | 0, B = B + Math.imul(oe, et) | 0, U = U + Math.imul(ne, lt) | 0, M = M + Math.imul(ne, Et) | 0, M = M + Math.imul(ye, lt) | 0, B = B + Math.imul(ye, Et) | 0, U = U + Math.imul(H, Ne) | 0, M = M + Math.imul(H, Je) | 0, M = M + Math.imul(Q, Ne) | 0, B = B + Math.imul(Q, Je) | 0, U = U + Math.imul(q, rt) | 0, M = M + Math.imul(q, At) | 0, M = M + Math.imul($, rt) | 0, B = B + Math.imul($, At) | 0;
      var qn = (W + U | 0) + ((M & 8191) << 13) | 0;
      W = (B + (M >>> 13) | 0) + (qn >>> 26) | 0, qn &= 67108863, U = Math.imul(pe, st), M = Math.imul(pe, Xe), M = M + Math.imul(be, st) | 0, B = Math.imul(be, Xe), U = U + Math.imul(me, Ce) | 0, M = M + Math.imul(me, xe) | 0, M = M + Math.imul(se, Ce) | 0, B = B + Math.imul(se, xe) | 0, U = U + Math.imul(Ee, Be) | 0, M = M + Math.imul(Ee, Ze) | 0, M = M + Math.imul(Ae, Be) | 0, B = B + Math.imul(Ae, Ze) | 0, U = U + Math.imul(ie, $e) | 0, M = M + Math.imul(ie, ut) | 0, M = M + Math.imul(we, $e) | 0, B = B + Math.imul(we, ut) | 0, U = U + Math.imul(ae, yt) | 0, M = M + Math.imul(ae, et) | 0, M = M + Math.imul(le, yt) | 0, B = B + Math.imul(le, et) | 0, U = U + Math.imul(de, lt) | 0, M = M + Math.imul(de, Et) | 0, M = M + Math.imul(oe, lt) | 0, B = B + Math.imul(oe, Et) | 0, U = U + Math.imul(ne, Ne) | 0, M = M + Math.imul(ne, Je) | 0, M = M + Math.imul(ye, Ne) | 0, B = B + Math.imul(ye, Je) | 0, U = U + Math.imul(H, rt) | 0, M = M + Math.imul(H, At) | 0, M = M + Math.imul(Q, rt) | 0, B = B + Math.imul(Q, At) | 0;
      var Mn = (W + U | 0) + ((M & 8191) << 13) | 0;
      W = (B + (M >>> 13) | 0) + (Mn >>> 26) | 0, Mn &= 67108863, U = Math.imul(pe, Ce), M = Math.imul(pe, xe), M = M + Math.imul(be, Ce) | 0, B = Math.imul(be, xe), U = U + Math.imul(me, Be) | 0, M = M + Math.imul(me, Ze) | 0, M = M + Math.imul(se, Be) | 0, B = B + Math.imul(se, Ze) | 0, U = U + Math.imul(Ee, $e) | 0, M = M + Math.imul(Ee, ut) | 0, M = M + Math.imul(Ae, $e) | 0, B = B + Math.imul(Ae, ut) | 0, U = U + Math.imul(ie, yt) | 0, M = M + Math.imul(ie, et) | 0, M = M + Math.imul(we, yt) | 0, B = B + Math.imul(we, et) | 0, U = U + Math.imul(ae, lt) | 0, M = M + Math.imul(ae, Et) | 0, M = M + Math.imul(le, lt) | 0, B = B + Math.imul(le, Et) | 0, U = U + Math.imul(de, Ne) | 0, M = M + Math.imul(de, Je) | 0, M = M + Math.imul(oe, Ne) | 0, B = B + Math.imul(oe, Je) | 0, U = U + Math.imul(ne, rt) | 0, M = M + Math.imul(ne, At) | 0, M = M + Math.imul(ye, rt) | 0, B = B + Math.imul(ye, At) | 0;
      var Ln = (W + U | 0) + ((M & 8191) << 13) | 0;
      W = (B + (M >>> 13) | 0) + (Ln >>> 26) | 0, Ln &= 67108863, U = Math.imul(pe, Be), M = Math.imul(pe, Ze), M = M + Math.imul(be, Be) | 0, B = Math.imul(be, Ze), U = U + Math.imul(me, $e) | 0, M = M + Math.imul(me, ut) | 0, M = M + Math.imul(se, $e) | 0, B = B + Math.imul(se, ut) | 0, U = U + Math.imul(Ee, yt) | 0, M = M + Math.imul(Ee, et) | 0, M = M + Math.imul(Ae, yt) | 0, B = B + Math.imul(Ae, et) | 0, U = U + Math.imul(ie, lt) | 0, M = M + Math.imul(ie, Et) | 0, M = M + Math.imul(we, lt) | 0, B = B + Math.imul(we, Et) | 0, U = U + Math.imul(ae, Ne) | 0, M = M + Math.imul(ae, Je) | 0, M = M + Math.imul(le, Ne) | 0, B = B + Math.imul(le, Je) | 0, U = U + Math.imul(de, rt) | 0, M = M + Math.imul(de, At) | 0, M = M + Math.imul(oe, rt) | 0, B = B + Math.imul(oe, At) | 0;
      var mn = (W + U | 0) + ((M & 8191) << 13) | 0;
      W = (B + (M >>> 13) | 0) + (mn >>> 26) | 0, mn &= 67108863, U = Math.imul(pe, $e), M = Math.imul(pe, ut), M = M + Math.imul(be, $e) | 0, B = Math.imul(be, ut), U = U + Math.imul(me, yt) | 0, M = M + Math.imul(me, et) | 0, M = M + Math.imul(se, yt) | 0, B = B + Math.imul(se, et) | 0, U = U + Math.imul(Ee, lt) | 0, M = M + Math.imul(Ee, Et) | 0, M = M + Math.imul(Ae, lt) | 0, B = B + Math.imul(Ae, Et) | 0, U = U + Math.imul(ie, Ne) | 0, M = M + Math.imul(ie, Je) | 0, M = M + Math.imul(we, Ne) | 0, B = B + Math.imul(we, Je) | 0, U = U + Math.imul(ae, rt) | 0, M = M + Math.imul(ae, At) | 0, M = M + Math.imul(le, rt) | 0, B = B + Math.imul(le, At) | 0;
      var jn = (W + U | 0) + ((M & 8191) << 13) | 0;
      W = (B + (M >>> 13) | 0) + (jn >>> 26) | 0, jn &= 67108863, U = Math.imul(pe, yt), M = Math.imul(pe, et), M = M + Math.imul(be, yt) | 0, B = Math.imul(be, et), U = U + Math.imul(me, lt) | 0, M = M + Math.imul(me, Et) | 0, M = M + Math.imul(se, lt) | 0, B = B + Math.imul(se, Et) | 0, U = U + Math.imul(Ee, Ne) | 0, M = M + Math.imul(Ee, Je) | 0, M = M + Math.imul(Ae, Ne) | 0, B = B + Math.imul(Ae, Je) | 0, U = U + Math.imul(ie, rt) | 0, M = M + Math.imul(ie, At) | 0, M = M + Math.imul(we, rt) | 0, B = B + Math.imul(we, At) | 0;
      var yn = (W + U | 0) + ((M & 8191) << 13) | 0;
      W = (B + (M >>> 13) | 0) + (yn >>> 26) | 0, yn &= 67108863, U = Math.imul(pe, lt), M = Math.imul(pe, Et), M = M + Math.imul(be, lt) | 0, B = Math.imul(be, Et), U = U + Math.imul(me, Ne) | 0, M = M + Math.imul(me, Je) | 0, M = M + Math.imul(se, Ne) | 0, B = B + Math.imul(se, Je) | 0, U = U + Math.imul(Ee, rt) | 0, M = M + Math.imul(Ee, At) | 0, M = M + Math.imul(Ae, rt) | 0, B = B + Math.imul(Ae, At) | 0;
      var bn = (W + U | 0) + ((M & 8191) << 13) | 0;
      W = (B + (M >>> 13) | 0) + (bn >>> 26) | 0, bn &= 67108863, U = Math.imul(pe, Ne), M = Math.imul(pe, Je), M = M + Math.imul(be, Ne) | 0, B = Math.imul(be, Je), U = U + Math.imul(me, rt) | 0, M = M + Math.imul(me, At) | 0, M = M + Math.imul(se, rt) | 0, B = B + Math.imul(se, At) | 0;
      var En = (W + U | 0) + ((M & 8191) << 13) | 0;
      W = (B + (M >>> 13) | 0) + (En >>> 26) | 0, En &= 67108863, U = Math.imul(pe, rt), M = Math.imul(pe, At), M = M + Math.imul(be, rt) | 0, B = Math.imul(be, At);
      var Vr = (W + U | 0) + ((M & 8191) << 13) | 0;
      return W = (B + (M >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, G[0] = Nt, G[1] = Tt, G[2] = Ot, G[3] = cr, G[4] = Wt, G[5] = Jt, G[6] = pr, G[7] = $r, G[8] = Ur, G[9] = _r, G[10] = qn, G[11] = Mn, G[12] = Ln, G[13] = mn, G[14] = jn, G[15] = yn, G[16] = bn, G[17] = En, G[18] = Vr, W !== 0 && (G[19] = W, v.length++), v;
    };
    Math.imul || (y = h);
    function b(F, _, T) {
      T.negative = _.negative ^ F.negative, T.length = F.length + _.length;
      for (var v = 0, w = 0, O = 0; O < T.length - 1; O++) {
        var G = w;
        w = 0;
        for (var W = v & 67108863, U = Math.min(O, _.length - 1), M = Math.max(0, O - F.length + 1); M <= U; M++) {
          var B = O - M, k = F.words[B] | 0, K = _.words[M] | 0, te = k * K, z = te & 67108863;
          G = G + (te / 67108864 | 0) | 0, z = z + W | 0, W = z & 67108863, G = G + (z >>> 26) | 0, w += G >>> 26, G &= 67108863;
        }
        T.words[O] = W, v = G, G = w;
      }
      return v !== 0 ? T.words[O] = v : T.length--, T.strip();
    }
    function E(F, _, T) {
      var v = new S();
      return v.mulp(F, _, T);
    }
    u.prototype.mulTo = function(_, T) {
      var v, w = this.length + _.length;
      return this.length === 10 && _.length === 10 ? v = y(this, _, T) : w < 63 ? v = h(this, _, T) : w < 1024 ? v = b(this, _, T) : v = E(this, _, T), v;
    };
    function S(F, _) {
      this.x = F, this.y = _;
    }
    S.prototype.makeRBT = function(_) {
      for (var T = new Array(_), v = u.prototype._countBits(_) - 1, w = 0; w < _; w++)
        T[w] = this.revBin(w, v, _);
      return T;
    }, S.prototype.revBin = function(_, T, v) {
      if (_ === 0 || _ === v - 1)
        return _;
      for (var w = 0, O = 0; O < T; O++)
        w |= (_ & 1) << T - O - 1, _ >>= 1;
      return w;
    }, S.prototype.permute = function(_, T, v, w, O, G) {
      for (var W = 0; W < G; W++)
        w[W] = T[_[W]], O[W] = v[_[W]];
    }, S.prototype.transform = function(_, T, v, w, O, G) {
      this.permute(G, _, T, v, w, O);
      for (var W = 1; W < O; W <<= 1)
        for (var U = W << 1, M = Math.cos(2 * Math.PI / U), B = Math.sin(2 * Math.PI / U), k = 0; k < O; k += U)
          for (var K = M, te = B, z = 0; z < W; z++) {
            var q = v[k + z], $ = w[k + z], Y = v[k + z + W], H = w[k + z + W], Q = K * Y - te * H;
            H = K * H + te * Y, Y = Q, v[k + z] = q + Y, w[k + z] = $ + H, v[k + z + W] = q - Y, w[k + z + W] = $ - H, z !== U && (Q = M * K - B * te, te = M * te + B * K, K = Q);
          }
    }, S.prototype.guessLen13b = function(_, T) {
      var v = Math.max(T, _) | 1, w = v & 1, O = 0;
      for (v = v / 2 | 0; v; v = v >>> 1)
        O++;
      return 1 << O + 1 + w;
    }, S.prototype.conjugate = function(_, T, v) {
      if (!(v <= 1))
        for (var w = 0; w < v / 2; w++) {
          var O = _[w];
          _[w] = _[v - w - 1], _[v - w - 1] = O, O = T[w], T[w] = -T[v - w - 1], T[v - w - 1] = -O;
        }
    }, S.prototype.normalize13b = function(_, T) {
      for (var v = 0, w = 0; w < T / 2; w++) {
        var O = Math.round(_[2 * w + 1] / T) * 8192 + Math.round(_[2 * w] / T) + v;
        _[w] = O & 67108863, O < 67108864 ? v = 0 : v = O / 67108864 | 0;
      }
      return _;
    }, S.prototype.convert13b = function(_, T, v, w) {
      for (var O = 0, G = 0; G < T; G++)
        O = O + (_[G] | 0), v[2 * G] = O & 8191, O = O >>> 13, v[2 * G + 1] = O & 8191, O = O >>> 13;
      for (G = 2 * T; G < w; ++G)
        v[G] = 0;
      a(O === 0), a((O & -8192) === 0);
    }, S.prototype.stub = function(_) {
      for (var T = new Array(_), v = 0; v < _; v++)
        T[v] = 0;
      return T;
    }, S.prototype.mulp = function(_, T, v) {
      var w = 2 * this.guessLen13b(_.length, T.length), O = this.makeRBT(w), G = this.stub(w), W = new Array(w), U = new Array(w), M = new Array(w), B = new Array(w), k = new Array(w), K = new Array(w), te = v.words;
      te.length = w, this.convert13b(_.words, _.length, W, w), this.convert13b(T.words, T.length, B, w), this.transform(W, G, U, M, w, O), this.transform(B, G, k, K, w, O);
      for (var z = 0; z < w; z++) {
        var q = U[z] * k[z] - M[z] * K[z];
        M[z] = U[z] * K[z] + M[z] * k[z], U[z] = q;
      }
      return this.conjugate(U, M, w), this.transform(U, M, te, G, w, O), this.conjugate(te, G, w), this.normalize13b(te, w), v.negative = _.negative ^ T.negative, v.length = _.length + T.length, v.strip();
    }, u.prototype.mul = function(_) {
      var T = new u(null);
      return T.words = new Array(this.length + _.length), this.mulTo(_, T);
    }, u.prototype.mulf = function(_) {
      var T = new u(null);
      return T.words = new Array(this.length + _.length), E(this, _, T);
    }, u.prototype.imul = function(_) {
      return this.clone().mulTo(_, this);
    }, u.prototype.imuln = function(_) {
      a(typeof _ == "number"), a(_ < 67108864);
      for (var T = 0, v = 0; v < this.length; v++) {
        var w = (this.words[v] | 0) * _, O = (w & 67108863) + (T & 67108863);
        T >>= 26, T += w / 67108864 | 0, T += O >>> 26, this.words[v] = O & 67108863;
      }
      return T !== 0 && (this.words[v] = T, this.length++), this;
    }, u.prototype.muln = function(_) {
      return this.clone().imuln(_);
    }, u.prototype.sqr = function() {
      return this.mul(this);
    }, u.prototype.isqr = function() {
      return this.imul(this.clone());
    }, u.prototype.pow = function(_) {
      var T = m(_);
      if (T.length === 0)
        return new u(1);
      for (var v = this, w = 0; w < T.length && T[w] === 0; w++, v = v.sqr())
        ;
      if (++w < T.length)
        for (var O = v.sqr(); w < T.length; w++, O = O.sqr())
          T[w] !== 0 && (v = v.mul(O));
      return v;
    }, u.prototype.iushln = function(_) {
      a(typeof _ == "number" && _ >= 0);
      var T = _ % 26, v = (_ - T) / 26, w = 67108863 >>> 26 - T << 26 - T, O;
      if (T !== 0) {
        var G = 0;
        for (O = 0; O < this.length; O++) {
          var W = this.words[O] & w, U = (this.words[O] | 0) - W << T;
          this.words[O] = U | G, G = W >>> 26 - T;
        }
        G && (this.words[O] = G, this.length++);
      }
      if (v !== 0) {
        for (O = this.length - 1; O >= 0; O--)
          this.words[O + v] = this.words[O];
        for (O = 0; O < v; O++)
          this.words[O] = 0;
        this.length += v;
      }
      return this.strip();
    }, u.prototype.ishln = function(_) {
      return a(this.negative === 0), this.iushln(_);
    }, u.prototype.iushrn = function(_, T, v) {
      a(typeof _ == "number" && _ >= 0);
      var w;
      T ? w = (T - T % 26) / 26 : w = 0;
      var O = _ % 26, G = Math.min((_ - O) / 26, this.length), W = 67108863 ^ 67108863 >>> O << O, U = v;
      if (w -= G, w = Math.max(0, w), U) {
        for (var M = 0; M < G; M++)
          U.words[M] = this.words[M];
        U.length = G;
      }
      if (G !== 0)
        if (this.length > G)
          for (this.length -= G, M = 0; M < this.length; M++)
            this.words[M] = this.words[M + G];
        else
          this.words[0] = 0, this.length = 1;
      var B = 0;
      for (M = this.length - 1; M >= 0 && (B !== 0 || M >= w); M--) {
        var k = this.words[M] | 0;
        this.words[M] = B << 26 - O | k >>> O, B = k & W;
      }
      return U && B !== 0 && (U.words[U.length++] = B), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, u.prototype.ishrn = function(_, T, v) {
      return a(this.negative === 0), this.iushrn(_, T, v);
    }, u.prototype.shln = function(_) {
      return this.clone().ishln(_);
    }, u.prototype.ushln = function(_) {
      return this.clone().iushln(_);
    }, u.prototype.shrn = function(_) {
      return this.clone().ishrn(_);
    }, u.prototype.ushrn = function(_) {
      return this.clone().iushrn(_);
    }, u.prototype.testn = function(_) {
      a(typeof _ == "number" && _ >= 0);
      var T = _ % 26, v = (_ - T) / 26, w = 1 << T;
      if (this.length <= v)
        return !1;
      var O = this.words[v];
      return !!(O & w);
    }, u.prototype.imaskn = function(_) {
      a(typeof _ == "number" && _ >= 0);
      var T = _ % 26, v = (_ - T) / 26;
      if (a(this.negative === 0, "imaskn works only with positive numbers"), this.length <= v)
        return this;
      if (T !== 0 && v++, this.length = Math.min(v, this.length), T !== 0) {
        var w = 67108863 ^ 67108863 >>> T << T;
        this.words[this.length - 1] &= w;
      }
      return this.strip();
    }, u.prototype.maskn = function(_) {
      return this.clone().imaskn(_);
    }, u.prototype.iaddn = function(_) {
      return a(typeof _ == "number"), a(_ < 67108864), _ < 0 ? this.isubn(-_) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < _ ? (this.words[0] = _ - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(_), this.negative = 1, this) : this._iaddn(_);
    }, u.prototype._iaddn = function(_) {
      this.words[0] += _;
      for (var T = 0; T < this.length && this.words[T] >= 67108864; T++)
        this.words[T] -= 67108864, T === this.length - 1 ? this.words[T + 1] = 1 : this.words[T + 1]++;
      return this.length = Math.max(this.length, T + 1), this;
    }, u.prototype.isubn = function(_) {
      if (a(typeof _ == "number"), a(_ < 67108864), _ < 0)
        return this.iaddn(-_);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(_), this.negative = 1, this;
      if (this.words[0] -= _, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var T = 0; T < this.length && this.words[T] < 0; T++)
          this.words[T] += 67108864, this.words[T + 1] -= 1;
      return this.strip();
    }, u.prototype.addn = function(_) {
      return this.clone().iaddn(_);
    }, u.prototype.subn = function(_) {
      return this.clone().isubn(_);
    }, u.prototype.iabs = function() {
      return this.negative = 0, this;
    }, u.prototype.abs = function() {
      return this.clone().iabs();
    }, u.prototype._ishlnsubmul = function(_, T, v) {
      var w = _.length + v, O;
      this._expand(w);
      var G, W = 0;
      for (O = 0; O < _.length; O++) {
        G = (this.words[O + v] | 0) + W;
        var U = (_.words[O] | 0) * T;
        G -= U & 67108863, W = (G >> 26) - (U / 67108864 | 0), this.words[O + v] = G & 67108863;
      }
      for (; O < this.length - v; O++)
        G = (this.words[O + v] | 0) + W, W = G >> 26, this.words[O + v] = G & 67108863;
      if (W === 0)
        return this.strip();
      for (a(W === -1), W = 0, O = 0; O < this.length; O++)
        G = -(this.words[O] | 0) + W, W = G >> 26, this.words[O] = G & 67108863;
      return this.negative = 1, this.strip();
    }, u.prototype._wordDiv = function(_, T) {
      var v = this.length - _.length, w = this.clone(), O = _, G = O.words[O.length - 1] | 0, W = this._countBits(G);
      v = 26 - W, v !== 0 && (O = O.ushln(v), w.iushln(v), G = O.words[O.length - 1] | 0);
      var U = w.length - O.length, M;
      if (T !== "mod") {
        M = new u(null), M.length = U + 1, M.words = new Array(M.length);
        for (var B = 0; B < M.length; B++)
          M.words[B] = 0;
      }
      var k = w.clone()._ishlnsubmul(O, 1, U);
      k.negative === 0 && (w = k, M && (M.words[U] = 1));
      for (var K = U - 1; K >= 0; K--) {
        var te = (w.words[O.length + K] | 0) * 67108864 + (w.words[O.length + K - 1] | 0);
        for (te = Math.min(te / G | 0, 67108863), w._ishlnsubmul(O, te, K); w.negative !== 0; )
          te--, w.negative = 0, w._ishlnsubmul(O, 1, K), w.isZero() || (w.negative ^= 1);
        M && (M.words[K] = te);
      }
      return M && M.strip(), w.strip(), T !== "div" && v !== 0 && w.iushrn(v), {
        div: M || null,
        mod: w
      };
    }, u.prototype.divmod = function(_, T, v) {
      if (a(!_.isZero()), this.isZero())
        return {
          div: new u(0),
          mod: new u(0)
        };
      var w, O, G;
      return this.negative !== 0 && _.negative === 0 ? (G = this.neg().divmod(_, T), T !== "mod" && (w = G.div.neg()), T !== "div" && (O = G.mod.neg(), v && O.negative !== 0 && O.iadd(_)), {
        div: w,
        mod: O
      }) : this.negative === 0 && _.negative !== 0 ? (G = this.divmod(_.neg(), T), T !== "mod" && (w = G.div.neg()), {
        div: w,
        mod: G.mod
      }) : this.negative & _.negative ? (G = this.neg().divmod(_.neg(), T), T !== "div" && (O = G.mod.neg(), v && O.negative !== 0 && O.isub(_)), {
        div: G.div,
        mod: O
      }) : _.length > this.length || this.cmp(_) < 0 ? {
        div: new u(0),
        mod: this
      } : _.length === 1 ? T === "div" ? {
        div: this.divn(_.words[0]),
        mod: null
      } : T === "mod" ? {
        div: null,
        mod: new u(this.modn(_.words[0]))
      } : {
        div: this.divn(_.words[0]),
        mod: new u(this.modn(_.words[0]))
      } : this._wordDiv(_, T);
    }, u.prototype.div = function(_) {
      return this.divmod(_, "div", !1).div;
    }, u.prototype.mod = function(_) {
      return this.divmod(_, "mod", !1).mod;
    }, u.prototype.umod = function(_) {
      return this.divmod(_, "mod", !0).mod;
    }, u.prototype.divRound = function(_) {
      var T = this.divmod(_);
      if (T.mod.isZero())
        return T.div;
      var v = T.div.negative !== 0 ? T.mod.isub(_) : T.mod, w = _.ushrn(1), O = _.andln(1), G = v.cmp(w);
      return G < 0 || O === 1 && G === 0 ? T.div : T.div.negative !== 0 ? T.div.isubn(1) : T.div.iaddn(1);
    }, u.prototype.modn = function(_) {
      a(_ <= 67108863);
      for (var T = (1 << 26) % _, v = 0, w = this.length - 1; w >= 0; w--)
        v = (T * v + (this.words[w] | 0)) % _;
      return v;
    }, u.prototype.idivn = function(_) {
      a(_ <= 67108863);
      for (var T = 0, v = this.length - 1; v >= 0; v--) {
        var w = (this.words[v] | 0) + T * 67108864;
        this.words[v] = w / _ | 0, T = w % _;
      }
      return this.strip();
    }, u.prototype.divn = function(_) {
      return this.clone().idivn(_);
    }, u.prototype.egcd = function(_) {
      a(_.negative === 0), a(!_.isZero());
      var T = this, v = _.clone();
      T.negative !== 0 ? T = T.umod(_) : T = T.clone();
      for (var w = new u(1), O = new u(0), G = new u(0), W = new u(1), U = 0; T.isEven() && v.isEven(); )
        T.iushrn(1), v.iushrn(1), ++U;
      for (var M = v.clone(), B = T.clone(); !T.isZero(); ) {
        for (var k = 0, K = 1; !(T.words[0] & K) && k < 26; ++k, K <<= 1)
          ;
        if (k > 0)
          for (T.iushrn(k); k-- > 0; )
            (w.isOdd() || O.isOdd()) && (w.iadd(M), O.isub(B)), w.iushrn(1), O.iushrn(1);
        for (var te = 0, z = 1; !(v.words[0] & z) && te < 26; ++te, z <<= 1)
          ;
        if (te > 0)
          for (v.iushrn(te); te-- > 0; )
            (G.isOdd() || W.isOdd()) && (G.iadd(M), W.isub(B)), G.iushrn(1), W.iushrn(1);
        T.cmp(v) >= 0 ? (T.isub(v), w.isub(G), O.isub(W)) : (v.isub(T), G.isub(w), W.isub(O));
      }
      return {
        a: G,
        b: W,
        gcd: v.iushln(U)
      };
    }, u.prototype._invmp = function(_) {
      a(_.negative === 0), a(!_.isZero());
      var T = this, v = _.clone();
      T.negative !== 0 ? T = T.umod(_) : T = T.clone();
      for (var w = new u(1), O = new u(0), G = v.clone(); T.cmpn(1) > 0 && v.cmpn(1) > 0; ) {
        for (var W = 0, U = 1; !(T.words[0] & U) && W < 26; ++W, U <<= 1)
          ;
        if (W > 0)
          for (T.iushrn(W); W-- > 0; )
            w.isOdd() && w.iadd(G), w.iushrn(1);
        for (var M = 0, B = 1; !(v.words[0] & B) && M < 26; ++M, B <<= 1)
          ;
        if (M > 0)
          for (v.iushrn(M); M-- > 0; )
            O.isOdd() && O.iadd(G), O.iushrn(1);
        T.cmp(v) >= 0 ? (T.isub(v), w.isub(O)) : (v.isub(T), O.isub(w));
      }
      var k;
      return T.cmpn(1) === 0 ? k = w : k = O, k.cmpn(0) < 0 && k.iadd(_), k;
    }, u.prototype.gcd = function(_) {
      if (this.isZero())
        return _.abs();
      if (_.isZero())
        return this.abs();
      var T = this.clone(), v = _.clone();
      T.negative = 0, v.negative = 0;
      for (var w = 0; T.isEven() && v.isEven(); w++)
        T.iushrn(1), v.iushrn(1);
      do {
        for (; T.isEven(); )
          T.iushrn(1);
        for (; v.isEven(); )
          v.iushrn(1);
        var O = T.cmp(v);
        if (O < 0) {
          var G = T;
          T = v, v = G;
        } else if (O === 0 || v.cmpn(1) === 0)
          break;
        T.isub(v);
      } while (!0);
      return v.iushln(w);
    }, u.prototype.invm = function(_) {
      return this.egcd(_).a.umod(_);
    }, u.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, u.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, u.prototype.andln = function(_) {
      return this.words[0] & _;
    }, u.prototype.bincn = function(_) {
      a(typeof _ == "number");
      var T = _ % 26, v = (_ - T) / 26, w = 1 << T;
      if (this.length <= v)
        return this._expand(v + 1), this.words[v] |= w, this;
      for (var O = w, G = v; O !== 0 && G < this.length; G++) {
        var W = this.words[G] | 0;
        W += O, O = W >>> 26, W &= 67108863, this.words[G] = W;
      }
      return O !== 0 && (this.words[G] = O, this.length++), this;
    }, u.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, u.prototype.cmpn = function(_) {
      var T = _ < 0;
      if (this.negative !== 0 && !T)
        return -1;
      if (this.negative === 0 && T)
        return 1;
      this.strip();
      var v;
      if (this.length > 1)
        v = 1;
      else {
        T && (_ = -_), a(_ <= 67108863, "Number is too big");
        var w = this.words[0] | 0;
        v = w === _ ? 0 : w < _ ? -1 : 1;
      }
      return this.negative !== 0 ? -v | 0 : v;
    }, u.prototype.cmp = function(_) {
      if (this.negative !== 0 && _.negative === 0)
        return -1;
      if (this.negative === 0 && _.negative !== 0)
        return 1;
      var T = this.ucmp(_);
      return this.negative !== 0 ? -T | 0 : T;
    }, u.prototype.ucmp = function(_) {
      if (this.length > _.length)
        return 1;
      if (this.length < _.length)
        return -1;
      for (var T = 0, v = this.length - 1; v >= 0; v--) {
        var w = this.words[v] | 0, O = _.words[v] | 0;
        if (w !== O) {
          w < O ? T = -1 : w > O && (T = 1);
          break;
        }
      }
      return T;
    }, u.prototype.gtn = function(_) {
      return this.cmpn(_) === 1;
    }, u.prototype.gt = function(_) {
      return this.cmp(_) === 1;
    }, u.prototype.gten = function(_) {
      return this.cmpn(_) >= 0;
    }, u.prototype.gte = function(_) {
      return this.cmp(_) >= 0;
    }, u.prototype.ltn = function(_) {
      return this.cmpn(_) === -1;
    }, u.prototype.lt = function(_) {
      return this.cmp(_) === -1;
    }, u.prototype.lten = function(_) {
      return this.cmpn(_) <= 0;
    }, u.prototype.lte = function(_) {
      return this.cmp(_) <= 0;
    }, u.prototype.eqn = function(_) {
      return this.cmpn(_) === 0;
    }, u.prototype.eq = function(_) {
      return this.cmp(_) === 0;
    }, u.red = function(_) {
      return new D(_);
    }, u.prototype.toRed = function(_) {
      return a(!this.red, "Already a number in reduction context"), a(this.negative === 0, "red works only with positives"), _.convertTo(this)._forceRed(_);
    }, u.prototype.fromRed = function() {
      return a(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, u.prototype._forceRed = function(_) {
      return this.red = _, this;
    }, u.prototype.forceRed = function(_) {
      return a(!this.red, "Already a number in reduction context"), this._forceRed(_);
    }, u.prototype.redAdd = function(_) {
      return a(this.red, "redAdd works only with red numbers"), this.red.add(this, _);
    }, u.prototype.redIAdd = function(_) {
      return a(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, _);
    }, u.prototype.redSub = function(_) {
      return a(this.red, "redSub works only with red numbers"), this.red.sub(this, _);
    }, u.prototype.redISub = function(_) {
      return a(this.red, "redISub works only with red numbers"), this.red.isub(this, _);
    }, u.prototype.redShl = function(_) {
      return a(this.red, "redShl works only with red numbers"), this.red.shl(this, _);
    }, u.prototype.redMul = function(_) {
      return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, _), this.red.mul(this, _);
    }, u.prototype.redIMul = function(_) {
      return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, _), this.red.imul(this, _);
    }, u.prototype.redSqr = function() {
      return a(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, u.prototype.redISqr = function() {
      return a(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, u.prototype.redSqrt = function() {
      return a(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, u.prototype.redInvm = function() {
      return a(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, u.prototype.redNeg = function() {
      return a(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, u.prototype.redPow = function(_) {
      return a(this.red && !_.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, _);
    };
    var g = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function P(F, _) {
      this.name = F, this.p = new u(_, 16), this.n = this.p.bitLength(), this.k = new u(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    P.prototype._tmp = function() {
      var _ = new u(null);
      return _.words = new Array(Math.ceil(this.n / 13)), _;
    }, P.prototype.ireduce = function(_) {
      var T = _, v;
      do
        this.split(T, this.tmp), T = this.imulK(T), T = T.iadd(this.tmp), v = T.bitLength();
      while (v > this.n);
      var w = v < this.n ? -1 : T.ucmp(this.p);
      return w === 0 ? (T.words[0] = 0, T.length = 1) : w > 0 ? T.isub(this.p) : T.strip !== void 0 ? T.strip() : T._strip(), T;
    }, P.prototype.split = function(_, T) {
      _.iushrn(this.n, 0, T);
    }, P.prototype.imulK = function(_) {
      return _.imul(this.k);
    };
    function R() {
      P.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    c(R, P), R.prototype.split = function(_, T) {
      for (var v = 4194303, w = Math.min(_.length, 9), O = 0; O < w; O++)
        T.words[O] = _.words[O];
      if (T.length = w, _.length <= 9) {
        _.words[0] = 0, _.length = 1;
        return;
      }
      var G = _.words[9];
      for (T.words[T.length++] = G & v, O = 10; O < _.length; O++) {
        var W = _.words[O] | 0;
        _.words[O - 10] = (W & v) << 4 | G >>> 22, G = W;
      }
      G >>>= 22, _.words[O - 10] = G, G === 0 && _.length > 10 ? _.length -= 10 : _.length -= 9;
    }, R.prototype.imulK = function(_) {
      _.words[_.length] = 0, _.words[_.length + 1] = 0, _.length += 2;
      for (var T = 0, v = 0; v < _.length; v++) {
        var w = _.words[v] | 0;
        T += w * 977, _.words[v] = T & 67108863, T = w * 64 + (T / 67108864 | 0);
      }
      return _.words[_.length - 1] === 0 && (_.length--, _.words[_.length - 1] === 0 && _.length--), _;
    };
    function N() {
      P.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    c(N, P);
    function C() {
      P.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    c(C, P);
    function I() {
      P.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    c(I, P), I.prototype.imulK = function(_) {
      for (var T = 0, v = 0; v < _.length; v++) {
        var w = (_.words[v] | 0) * 19 + T, O = w & 67108863;
        w >>>= 26, _.words[v] = O, T = w;
      }
      return T !== 0 && (_.words[_.length++] = T), _;
    }, u._prime = function(_) {
      if (g[_])
        return g[_];
      var T;
      if (_ === "k256")
        T = new R();
      else if (_ === "p224")
        T = new N();
      else if (_ === "p192")
        T = new C();
      else if (_ === "p25519")
        T = new I();
      else
        throw new Error("Unknown prime " + _);
      return g[_] = T, T;
    };
    function D(F) {
      if (typeof F == "string") {
        var _ = u._prime(F);
        this.m = _.p, this.prime = _;
      } else
        a(F.gtn(1), "modulus must be greater than 1"), this.m = F, this.prime = null;
    }
    D.prototype._verify1 = function(_) {
      a(_.negative === 0, "red works only with positives"), a(_.red, "red works only with red numbers");
    }, D.prototype._verify2 = function(_, T) {
      a((_.negative | T.negative) === 0, "red works only with positives"), a(
        _.red && _.red === T.red,
        "red works only with red numbers"
      );
    }, D.prototype.imod = function(_) {
      return this.prime ? this.prime.ireduce(_)._forceRed(this) : _.umod(this.m)._forceRed(this);
    }, D.prototype.neg = function(_) {
      return _.isZero() ? _.clone() : this.m.sub(_)._forceRed(this);
    }, D.prototype.add = function(_, T) {
      this._verify2(_, T);
      var v = _.add(T);
      return v.cmp(this.m) >= 0 && v.isub(this.m), v._forceRed(this);
    }, D.prototype.iadd = function(_, T) {
      this._verify2(_, T);
      var v = _.iadd(T);
      return v.cmp(this.m) >= 0 && v.isub(this.m), v;
    }, D.prototype.sub = function(_, T) {
      this._verify2(_, T);
      var v = _.sub(T);
      return v.cmpn(0) < 0 && v.iadd(this.m), v._forceRed(this);
    }, D.prototype.isub = function(_, T) {
      this._verify2(_, T);
      var v = _.isub(T);
      return v.cmpn(0) < 0 && v.iadd(this.m), v;
    }, D.prototype.shl = function(_, T) {
      return this._verify1(_), this.imod(_.ushln(T));
    }, D.prototype.imul = function(_, T) {
      return this._verify2(_, T), this.imod(_.imul(T));
    }, D.prototype.mul = function(_, T) {
      return this._verify2(_, T), this.imod(_.mul(T));
    }, D.prototype.isqr = function(_) {
      return this.imul(_, _.clone());
    }, D.prototype.sqr = function(_) {
      return this.mul(_, _);
    }, D.prototype.sqrt = function(_) {
      if (_.isZero())
        return _.clone();
      var T = this.m.andln(3);
      if (a(T % 2 === 1), T === 3) {
        var v = this.m.add(new u(1)).iushrn(2);
        return this.pow(_, v);
      }
      for (var w = this.m.subn(1), O = 0; !w.isZero() && w.andln(1) === 0; )
        O++, w.iushrn(1);
      a(!w.isZero());
      var G = new u(1).toRed(this), W = G.redNeg(), U = this.m.subn(1).iushrn(1), M = this.m.bitLength();
      for (M = new u(2 * M * M).toRed(this); this.pow(M, U).cmp(W) !== 0; )
        M.redIAdd(W);
      for (var B = this.pow(M, w), k = this.pow(_, w.addn(1).iushrn(1)), K = this.pow(_, w), te = O; K.cmp(G) !== 0; ) {
        for (var z = K, q = 0; z.cmp(G) !== 0; q++)
          z = z.redSqr();
        a(q < te);
        var $ = this.pow(B, new u(1).iushln(te - q - 1));
        k = k.redMul($), B = $.redSqr(), K = K.redMul(B), te = q;
      }
      return k;
    }, D.prototype.invm = function(_) {
      var T = _._invmp(this.m);
      return T.negative !== 0 ? (T.negative = 0, this.imod(T).redNeg()) : this.imod(T);
    }, D.prototype.pow = function(_, T) {
      if (T.isZero())
        return new u(1).toRed(this);
      if (T.cmpn(1) === 0)
        return _.clone();
      var v = 4, w = new Array(1 << v);
      w[0] = new u(1).toRed(this), w[1] = _;
      for (var O = 2; O < w.length; O++)
        w[O] = this.mul(w[O - 1], _);
      var G = w[0], W = 0, U = 0, M = T.bitLength() % 26;
      for (M === 0 && (M = 26), O = T.length - 1; O >= 0; O--) {
        for (var B = T.words[O], k = M - 1; k >= 0; k--) {
          var K = B >> k & 1;
          if (G !== w[0] && (G = this.sqr(G)), K === 0 && W === 0) {
            U = 0;
            continue;
          }
          W <<= 1, W |= K, U++, !(U !== v && (O !== 0 || k !== 0)) && (G = this.mul(G, w[W]), U = 0, W = 0);
        }
        M = 26;
      }
      return G;
    }, D.prototype.convertTo = function(_) {
      var T = _.umod(this.m);
      return T === _ ? T.clone() : T;
    }, D.prototype.convertFrom = function(_) {
      var T = _.clone();
      return T.red = null, T;
    }, u.mont = function(_) {
      return new j(_);
    };
    function j(F) {
      D.call(this, F), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new u(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    c(j, D), j.prototype.convertTo = function(_) {
      return this.imod(_.ushln(this.shift));
    }, j.prototype.convertFrom = function(_) {
      var T = this.imod(_.mul(this.rinv));
      return T.red = null, T;
    }, j.prototype.imul = function(_, T) {
      if (_.isZero() || T.isZero())
        return _.words[0] = 0, _.length = 1, _;
      var v = _.imul(T), w = v.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = v.isub(w).iushrn(this.shift), G = O;
      return O.cmp(this.m) >= 0 ? G = O.isub(this.m) : O.cmpn(0) < 0 && (G = O.iadd(this.m)), G._forceRed(this);
    }, j.prototype.mul = function(_, T) {
      if (_.isZero() || T.isZero())
        return new u(0)._forceRed(this);
      var v = _.mul(T), w = v.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = v.isub(w).iushrn(this.shift), G = O;
      return O.cmp(this.m) >= 0 ? G = O.isub(this.m) : O.cmpn(0) < 0 && (G = O.iadd(this.m)), G._forceRed(this);
    }, j.prototype.invm = function(_) {
      var T = this.imod(_._invmp(this.m).mul(this.r2));
      return T._forceRed(this);
    };
  })(t, Bt);
})(jy);
var pn = jy.exports, jc = { exports: {} }, UE;
function Fy() {
  if (UE)
    return jc.exports;
  UE = 1;
  var t;
  jc.exports = function(c) {
    return t || (t = new e(null)), t.generate(c);
  };
  function e(a) {
    this.rand = a;
  }
  if (jc.exports.Rand = e, e.prototype.generate = function(c) {
    return this._rand(c);
  }, e.prototype._rand = function(c) {
    if (this.rand.getBytes)
      return this.rand.getBytes(c);
    for (var u = new Uint8Array(c), r = 0; r < u.length; r++)
      u[r] = this.rand.getByte();
    return u;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? e.prototype._rand = function(c) {
      var u = new Uint8Array(c);
      return self.crypto.getRandomValues(u), u;
    } : self.msCrypto && self.msCrypto.getRandomValues ? e.prototype._rand = function(c) {
      var u = new Uint8Array(c);
      return self.msCrypto.getRandomValues(u), u;
    } : typeof window == "object" && (e.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var n = sb();
      if (typeof n.randomBytes != "function")
        throw new Error("Not supported");
      e.prototype._rand = function(c) {
        return n.randomBytes(c);
      };
    } catch {
    }
  return jc.exports;
}
var Yh, VE;
function HA() {
  if (VE)
    return Yh;
  VE = 1;
  var t = pn, e = Fy();
  function n(a) {
    this.rand = a || new e.Rand();
  }
  return Yh = n, n.create = function(c) {
    return new n(c);
  }, n.prototype._randbelow = function(c) {
    var u = c.bitLength(), r = Math.ceil(u / 8);
    do
      var l = new t(this.rand.generate(r));
    while (l.cmp(c) >= 0);
    return l;
  }, n.prototype._randrange = function(c, u) {
    var r = u.sub(c);
    return c.add(this._randbelow(r));
  }, n.prototype.test = function(c, u, r) {
    var l = c.bitLength(), i = t.mont(c), f = new t(1).toRed(i);
    u || (u = Math.max(1, l / 48 | 0));
    for (var d = c.subn(1), s = 0; !d.testn(s); s++)
      ;
    for (var o = c.shrn(s), m = d.toRed(i), h = !0; u > 0; u--) {
      var y = this._randrange(new t(2), d);
      r && r(y);
      var b = y.toRed(i).redPow(o);
      if (!(b.cmp(f) === 0 || b.cmp(m) === 0)) {
        for (var E = 1; E < s; E++) {
          if (b = b.redSqr(), b.cmp(f) === 0)
            return !1;
          if (b.cmp(m) === 0)
            break;
        }
        if (E === s)
          return !1;
      }
    }
    return h;
  }, n.prototype.getDivisor = function(c, u) {
    var r = c.bitLength(), l = t.mont(c), i = new t(1).toRed(l);
    u || (u = Math.max(1, r / 48 | 0));
    for (var f = c.subn(1), d = 0; !f.testn(d); d++)
      ;
    for (var s = c.shrn(d), o = f.toRed(l); u > 0; u--) {
      var m = this._randrange(new t(2), f), h = c.gcd(m);
      if (h.cmpn(1) !== 0)
        return h;
      var y = m.toRed(l).redPow(s);
      if (!(y.cmp(i) === 0 || y.cmp(o) === 0)) {
        for (var b = 1; b < d; b++) {
          if (y = y.redSqr(), y.cmp(i) === 0)
            return y.fromRed().subn(1).gcd(c);
          if (y.cmp(o) === 0)
            break;
        }
        if (b === d)
          return y = y.redSqr(), y.fromRed().subn(1).gcd(c);
      }
    }
    return !1;
  }, Yh;
}
var Xh, WE;
function qA() {
  if (WE)
    return Xh;
  WE = 1;
  var t = nl;
  Xh = b, b.simpleSieve = h, b.fermatTest = y;
  var e = pn, n = new e(24), a = HA(), c = new a(), u = new e(1), r = new e(2), l = new e(5);
  new e(16), new e(8);
  var i = new e(10), f = new e(3);
  new e(7);
  var d = new e(11), s = new e(4);
  new e(12);
  var o = null;
  function m() {
    if (o !== null)
      return o;
    var E = 1048576, S = [];
    S[0] = 2;
    for (var g = 1, P = 3; P < E; P += 2) {
      for (var R = Math.ceil(Math.sqrt(P)), N = 0; N < g && S[N] <= R && P % S[N] !== 0; N++)
        ;
      g !== N && S[N] <= R || (S[g++] = P);
    }
    return o = S, S;
  }
  function h(E) {
    for (var S = m(), g = 0; g < S.length; g++)
      if (E.modn(S[g]) === 0)
        return E.cmpn(S[g]) === 0;
    return !0;
  }
  function y(E) {
    var S = e.mont(E);
    return r.toRed(S).redPow(E.subn(1)).fromRed().cmpn(1) === 0;
  }
  function b(E, S) {
    if (E < 16)
      return S === 2 || S === 5 ? new e([140, 123]) : new e([140, 39]);
    S = new e(S);
    for (var g, P; ; ) {
      for (g = new e(t(Math.ceil(E / 8))); g.bitLength() > E; )
        g.ishrn(1);
      if (g.isEven() && g.iadd(u), g.testn(1) || g.iadd(r), S.cmp(r)) {
        if (!S.cmp(l))
          for (; g.mod(i).cmp(f); )
            g.iadd(s);
      } else
        for (; g.mod(n).cmp(d); )
          g.iadd(s);
      if (P = g.shrn(1), h(P) && h(g) && y(P) && y(g) && c.test(P) && c.test(g))
        return g;
    }
  }
  return Xh;
}
const QL = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, ZL = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, ej = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, tj = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, rj = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, nj = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, ij = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, sj = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, aj = {
  modp1: QL,
  modp2: ZL,
  modp5: ej,
  modp14: tj,
  modp15: rj,
  modp16: nj,
  modp17: ij,
  modp18: sj
};
var Jh, HE;
function oj() {
  if (HE)
    return Jh;
  HE = 1;
  var t = pn, e = HA(), n = new e(), a = new t(24), c = new t(11), u = new t(10), r = new t(3), l = new t(7), i = qA(), f = nl;
  Jh = h;
  function d(b, E) {
    return E = E || "utf8", Ve.Buffer.isBuffer(b) || (b = new Ve.Buffer(b, E)), this._pub = new t(b), this;
  }
  function s(b, E) {
    return E = E || "utf8", Ve.Buffer.isBuffer(b) || (b = new Ve.Buffer(b, E)), this._priv = new t(b), this;
  }
  var o = {};
  function m(b, E) {
    var S = E.toString("hex"), g = [S, b.toString(16)].join("_");
    if (g in o)
      return o[g];
    var P = 0;
    if (b.isEven() || !i.simpleSieve || !i.fermatTest(b) || !n.test(b))
      return P += 1, S === "02" || S === "05" ? P += 8 : P += 4, o[g] = P, P;
    n.test(b.shrn(1)) || (P += 2);
    var R;
    switch (S) {
      case "02":
        b.mod(a).cmp(c) && (P += 8);
        break;
      case "05":
        R = b.mod(u), R.cmp(r) && R.cmp(l) && (P += 8);
        break;
      default:
        P += 4;
    }
    return o[g] = P, P;
  }
  function h(b, E, S) {
    this.setGenerator(E), this.__prime = new t(b), this._prime = t.mont(this.__prime), this._primeLen = b.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, S ? (this.setPublicKey = d, this.setPrivateKey = s) : this._primeCode = 8;
  }
  Object.defineProperty(h.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = m(this.__prime, this.__gen)), this._primeCode;
    }
  }), h.prototype.generateKeys = function() {
    return this._priv || (this._priv = new t(f(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, h.prototype.computeSecret = function(b) {
    b = new t(b), b = b.toRed(this._prime);
    var E = b.redPow(this._priv).fromRed(), S = new Ve.Buffer(E.toArray()), g = this.getPrime();
    if (S.length < g.length) {
      var P = new Ve.Buffer(g.length - S.length);
      P.fill(0), S = Ve.Buffer.concat([P, S]);
    }
    return S;
  }, h.prototype.getPublicKey = function(E) {
    return y(this._pub, E);
  }, h.prototype.getPrivateKey = function(E) {
    return y(this._priv, E);
  }, h.prototype.getPrime = function(b) {
    return y(this.__prime, b);
  }, h.prototype.getGenerator = function(b) {
    return y(this._gen, b);
  }, h.prototype.setGenerator = function(b, E) {
    return E = E || "utf8", Ve.Buffer.isBuffer(b) || (b = new Ve.Buffer(b, E)), this.__gen = b, this._gen = new t(b), this;
  };
  function y(b, E) {
    var S = new Ve.Buffer(b.toArray());
    return E ? S.toString(E) : S;
  }
  return Jh;
}
var qE;
function lj() {
  if (qE)
    return Aa;
  qE = 1;
  var t = qA(), e = aj, n = oj();
  function a(r) {
    var l = new Ve.Buffer(e[r].prime, "hex"), i = new Ve.Buffer(e[r].gen, "hex");
    return new n(l, i);
  }
  var c = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function u(r, l, i, f) {
    return Ve.Buffer.isBuffer(l) || c[l] === void 0 ? u(r, "binary", l, i) : (l = l || "binary", f = f || "binary", i = i || new Ve.Buffer([2]), Ve.Buffer.isBuffer(i) || (i = new Ve.Buffer(i, f)), typeof r == "number" ? new n(t(r, i), i, !0) : (Ve.Buffer.isBuffer(r) || (r = new Ve.Buffer(r, l)), new n(r, i, !0)));
  }
  return Aa.DiffieHellmanGroup = Aa.createDiffieHellmanGroup = Aa.getDiffieHellman = a, Aa.createDiffieHellman = Aa.DiffieHellman = u, Aa;
}
var Nl = { exports: {} }, By = { exports: {} };
By.exports;
(function(t) {
  (function(e, n) {
    function a(T, v) {
      if (!T)
        throw new Error(v || "Assertion failed");
    }
    function c(T, v) {
      T.super_ = v;
      var w = function() {
      };
      w.prototype = v.prototype, T.prototype = new w(), T.prototype.constructor = T;
    }
    function u(T, v, w) {
      if (u.isBN(T))
        return T;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, T !== null && ((v === "le" || v === "be") && (w = v, v = 10), this._init(T || 0, v || 10, w || "be"));
    }
    typeof e == "object" ? e.exports = u : n.BN = u, u.BN = u, u.wordSize = 26;
    var r;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? r = window.Buffer : r = xr.Buffer;
    } catch {
    }
    u.isBN = function(v) {
      return v instanceof u ? !0 : v !== null && typeof v == "object" && v.constructor.wordSize === u.wordSize && Array.isArray(v.words);
    }, u.max = function(v, w) {
      return v.cmp(w) > 0 ? v : w;
    }, u.min = function(v, w) {
      return v.cmp(w) < 0 ? v : w;
    }, u.prototype._init = function(v, w, O) {
      if (typeof v == "number")
        return this._initNumber(v, w, O);
      if (typeof v == "object")
        return this._initArray(v, w, O);
      w === "hex" && (w = 16), a(w === (w | 0) && w >= 2 && w <= 36), v = v.toString().replace(/\s+/g, "");
      var G = 0;
      v[0] === "-" && (G++, this.negative = 1), G < v.length && (w === 16 ? this._parseHex(v, G, O) : (this._parseBase(v, w, G), O === "le" && this._initArray(this.toArray(), w, O)));
    }, u.prototype._initNumber = function(v, w, O) {
      v < 0 && (this.negative = 1, v = -v), v < 67108864 ? (this.words = [v & 67108863], this.length = 1) : v < 4503599627370496 ? (this.words = [
        v & 67108863,
        v / 67108864 & 67108863
      ], this.length = 2) : (a(v < 9007199254740992), this.words = [
        v & 67108863,
        v / 67108864 & 67108863,
        1
      ], this.length = 3), O === "le" && this._initArray(this.toArray(), w, O);
    }, u.prototype._initArray = function(v, w, O) {
      if (a(typeof v.length == "number"), v.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(v.length / 3), this.words = new Array(this.length);
      for (var G = 0; G < this.length; G++)
        this.words[G] = 0;
      var W, U, M = 0;
      if (O === "be")
        for (G = v.length - 1, W = 0; G >= 0; G -= 3)
          U = v[G] | v[G - 1] << 8 | v[G - 2] << 16, this.words[W] |= U << M & 67108863, this.words[W + 1] = U >>> 26 - M & 67108863, M += 24, M >= 26 && (M -= 26, W++);
      else if (O === "le")
        for (G = 0, W = 0; G < v.length; G += 3)
          U = v[G] | v[G + 1] << 8 | v[G + 2] << 16, this.words[W] |= U << M & 67108863, this.words[W + 1] = U >>> 26 - M & 67108863, M += 24, M >= 26 && (M -= 26, W++);
      return this._strip();
    };
    function l(T, v) {
      var w = T.charCodeAt(v);
      if (w >= 48 && w <= 57)
        return w - 48;
      if (w >= 65 && w <= 70)
        return w - 55;
      if (w >= 97 && w <= 102)
        return w - 87;
      a(!1, "Invalid character in " + T);
    }
    function i(T, v, w) {
      var O = l(T, w);
      return w - 1 >= v && (O |= l(T, w - 1) << 4), O;
    }
    u.prototype._parseHex = function(v, w, O) {
      this.length = Math.ceil((v.length - w) / 6), this.words = new Array(this.length);
      for (var G = 0; G < this.length; G++)
        this.words[G] = 0;
      var W = 0, U = 0, M;
      if (O === "be")
        for (G = v.length - 1; G >= w; G -= 2)
          M = i(v, w, G) << W, this.words[U] |= M & 67108863, W >= 18 ? (W -= 18, U += 1, this.words[U] |= M >>> 26) : W += 8;
      else {
        var B = v.length - w;
        for (G = B % 2 === 0 ? w + 1 : w; G < v.length; G += 2)
          M = i(v, w, G) << W, this.words[U] |= M & 67108863, W >= 18 ? (W -= 18, U += 1, this.words[U] |= M >>> 26) : W += 8;
      }
      this._strip();
    };
    function f(T, v, w, O) {
      for (var G = 0, W = 0, U = Math.min(T.length, w), M = v; M < U; M++) {
        var B = T.charCodeAt(M) - 48;
        G *= O, B >= 49 ? W = B - 49 + 10 : B >= 17 ? W = B - 17 + 10 : W = B, a(B >= 0 && W < O, "Invalid character"), G += W;
      }
      return G;
    }
    u.prototype._parseBase = function(v, w, O) {
      this.words = [0], this.length = 1;
      for (var G = 0, W = 1; W <= 67108863; W *= w)
        G++;
      G--, W = W / w | 0;
      for (var U = v.length - O, M = U % G, B = Math.min(U, U - M) + O, k = 0, K = O; K < B; K += G)
        k = f(v, K, K + G, w), this.imuln(W), this.words[0] + k < 67108864 ? this.words[0] += k : this._iaddn(k);
      if (M !== 0) {
        var te = 1;
        for (k = f(v, K, v.length, w), K = 0; K < M; K++)
          te *= w;
        this.imuln(te), this.words[0] + k < 67108864 ? this.words[0] += k : this._iaddn(k);
      }
      this._strip();
    }, u.prototype.copy = function(v) {
      v.words = new Array(this.length);
      for (var w = 0; w < this.length; w++)
        v.words[w] = this.words[w];
      v.length = this.length, v.negative = this.negative, v.red = this.red;
    };
    function d(T, v) {
      T.words = v.words, T.length = v.length, T.negative = v.negative, T.red = v.red;
    }
    if (u.prototype._move = function(v) {
      d(v, this);
    }, u.prototype.clone = function() {
      var v = new u(null);
      return this.copy(v), v;
    }, u.prototype._expand = function(v) {
      for (; this.length < v; )
        this.words[this.length++] = 0;
      return this;
    }, u.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, u.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        u.prototype[Symbol.for("nodejs.util.inspect.custom")] = s;
      } catch {
        u.prototype.inspect = s;
      }
    else
      u.prototype.inspect = s;
    function s() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var o = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], m = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], h = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    u.prototype.toString = function(v, w) {
      v = v || 10, w = w | 0 || 1;
      var O;
      if (v === 16 || v === "hex") {
        O = "";
        for (var G = 0, W = 0, U = 0; U < this.length; U++) {
          var M = this.words[U], B = ((M << G | W) & 16777215).toString(16);
          W = M >>> 24 - G & 16777215, G += 2, G >= 26 && (G -= 26, U--), W !== 0 || U !== this.length - 1 ? O = o[6 - B.length] + B + O : O = B + O;
        }
        for (W !== 0 && (O = W.toString(16) + O); O.length % w !== 0; )
          O = "0" + O;
        return this.negative !== 0 && (O = "-" + O), O;
      }
      if (v === (v | 0) && v >= 2 && v <= 36) {
        var k = m[v], K = h[v];
        O = "";
        var te = this.clone();
        for (te.negative = 0; !te.isZero(); ) {
          var z = te.modrn(K).toString(v);
          te = te.idivn(K), te.isZero() ? O = z + O : O = o[k - z.length] + z + O;
        }
        for (this.isZero() && (O = "0" + O); O.length % w !== 0; )
          O = "0" + O;
        return this.negative !== 0 && (O = "-" + O), O;
      }
      a(!1, "Base should be between 2 and 36");
    }, u.prototype.toNumber = function() {
      var v = this.words[0];
      return this.length === 2 ? v += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? v += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && a(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -v : v;
    }, u.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, r && (u.prototype.toBuffer = function(v, w) {
      return this.toArrayLike(r, v, w);
    }), u.prototype.toArray = function(v, w) {
      return this.toArrayLike(Array, v, w);
    };
    var y = function(v, w) {
      return v.allocUnsafe ? v.allocUnsafe(w) : new v(w);
    };
    u.prototype.toArrayLike = function(v, w, O) {
      this._strip();
      var G = this.byteLength(), W = O || Math.max(1, G);
      a(G <= W, "byte array longer than desired length"), a(W > 0, "Requested array length <= 0");
      var U = y(v, W), M = w === "le" ? "LE" : "BE";
      return this["_toArrayLike" + M](U, G), U;
    }, u.prototype._toArrayLikeLE = function(v, w) {
      for (var O = 0, G = 0, W = 0, U = 0; W < this.length; W++) {
        var M = this.words[W] << U | G;
        v[O++] = M & 255, O < v.length && (v[O++] = M >> 8 & 255), O < v.length && (v[O++] = M >> 16 & 255), U === 6 ? (O < v.length && (v[O++] = M >> 24 & 255), G = 0, U = 0) : (G = M >>> 24, U += 2);
      }
      if (O < v.length)
        for (v[O++] = G; O < v.length; )
          v[O++] = 0;
    }, u.prototype._toArrayLikeBE = function(v, w) {
      for (var O = v.length - 1, G = 0, W = 0, U = 0; W < this.length; W++) {
        var M = this.words[W] << U | G;
        v[O--] = M & 255, O >= 0 && (v[O--] = M >> 8 & 255), O >= 0 && (v[O--] = M >> 16 & 255), U === 6 ? (O >= 0 && (v[O--] = M >> 24 & 255), G = 0, U = 0) : (G = M >>> 24, U += 2);
      }
      if (O >= 0)
        for (v[O--] = G; O >= 0; )
          v[O--] = 0;
    }, Math.clz32 ? u.prototype._countBits = function(v) {
      return 32 - Math.clz32(v);
    } : u.prototype._countBits = function(v) {
      var w = v, O = 0;
      return w >= 4096 && (O += 13, w >>>= 13), w >= 64 && (O += 7, w >>>= 7), w >= 8 && (O += 4, w >>>= 4), w >= 2 && (O += 2, w >>>= 2), O + w;
    }, u.prototype._zeroBits = function(v) {
      if (v === 0)
        return 26;
      var w = v, O = 0;
      return w & 8191 || (O += 13, w >>>= 13), w & 127 || (O += 7, w >>>= 7), w & 15 || (O += 4, w >>>= 4), w & 3 || (O += 2, w >>>= 2), w & 1 || O++, O;
    }, u.prototype.bitLength = function() {
      var v = this.words[this.length - 1], w = this._countBits(v);
      return (this.length - 1) * 26 + w;
    };
    function b(T) {
      for (var v = new Array(T.bitLength()), w = 0; w < v.length; w++) {
        var O = w / 26 | 0, G = w % 26;
        v[w] = T.words[O] >>> G & 1;
      }
      return v;
    }
    u.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var v = 0, w = 0; w < this.length; w++) {
        var O = this._zeroBits(this.words[w]);
        if (v += O, O !== 26)
          break;
      }
      return v;
    }, u.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, u.prototype.toTwos = function(v) {
      return this.negative !== 0 ? this.abs().inotn(v).iaddn(1) : this.clone();
    }, u.prototype.fromTwos = function(v) {
      return this.testn(v - 1) ? this.notn(v).iaddn(1).ineg() : this.clone();
    }, u.prototype.isNeg = function() {
      return this.negative !== 0;
    }, u.prototype.neg = function() {
      return this.clone().ineg();
    }, u.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, u.prototype.iuor = function(v) {
      for (; this.length < v.length; )
        this.words[this.length++] = 0;
      for (var w = 0; w < v.length; w++)
        this.words[w] = this.words[w] | v.words[w];
      return this._strip();
    }, u.prototype.ior = function(v) {
      return a((this.negative | v.negative) === 0), this.iuor(v);
    }, u.prototype.or = function(v) {
      return this.length > v.length ? this.clone().ior(v) : v.clone().ior(this);
    }, u.prototype.uor = function(v) {
      return this.length > v.length ? this.clone().iuor(v) : v.clone().iuor(this);
    }, u.prototype.iuand = function(v) {
      var w;
      this.length > v.length ? w = v : w = this;
      for (var O = 0; O < w.length; O++)
        this.words[O] = this.words[O] & v.words[O];
      return this.length = w.length, this._strip();
    }, u.prototype.iand = function(v) {
      return a((this.negative | v.negative) === 0), this.iuand(v);
    }, u.prototype.and = function(v) {
      return this.length > v.length ? this.clone().iand(v) : v.clone().iand(this);
    }, u.prototype.uand = function(v) {
      return this.length > v.length ? this.clone().iuand(v) : v.clone().iuand(this);
    }, u.prototype.iuxor = function(v) {
      var w, O;
      this.length > v.length ? (w = this, O = v) : (w = v, O = this);
      for (var G = 0; G < O.length; G++)
        this.words[G] = w.words[G] ^ O.words[G];
      if (this !== w)
        for (; G < w.length; G++)
          this.words[G] = w.words[G];
      return this.length = w.length, this._strip();
    }, u.prototype.ixor = function(v) {
      return a((this.negative | v.negative) === 0), this.iuxor(v);
    }, u.prototype.xor = function(v) {
      return this.length > v.length ? this.clone().ixor(v) : v.clone().ixor(this);
    }, u.prototype.uxor = function(v) {
      return this.length > v.length ? this.clone().iuxor(v) : v.clone().iuxor(this);
    }, u.prototype.inotn = function(v) {
      a(typeof v == "number" && v >= 0);
      var w = Math.ceil(v / 26) | 0, O = v % 26;
      this._expand(w), O > 0 && w--;
      for (var G = 0; G < w; G++)
        this.words[G] = ~this.words[G] & 67108863;
      return O > 0 && (this.words[G] = ~this.words[G] & 67108863 >> 26 - O), this._strip();
    }, u.prototype.notn = function(v) {
      return this.clone().inotn(v);
    }, u.prototype.setn = function(v, w) {
      a(typeof v == "number" && v >= 0);
      var O = v / 26 | 0, G = v % 26;
      return this._expand(O + 1), w ? this.words[O] = this.words[O] | 1 << G : this.words[O] = this.words[O] & ~(1 << G), this._strip();
    }, u.prototype.iadd = function(v) {
      var w;
      if (this.negative !== 0 && v.negative === 0)
        return this.negative = 0, w = this.isub(v), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && v.negative !== 0)
        return v.negative = 0, w = this.isub(v), v.negative = 1, w._normSign();
      var O, G;
      this.length > v.length ? (O = this, G = v) : (O = v, G = this);
      for (var W = 0, U = 0; U < G.length; U++)
        w = (O.words[U] | 0) + (G.words[U] | 0) + W, this.words[U] = w & 67108863, W = w >>> 26;
      for (; W !== 0 && U < O.length; U++)
        w = (O.words[U] | 0) + W, this.words[U] = w & 67108863, W = w >>> 26;
      if (this.length = O.length, W !== 0)
        this.words[this.length] = W, this.length++;
      else if (O !== this)
        for (; U < O.length; U++)
          this.words[U] = O.words[U];
      return this;
    }, u.prototype.add = function(v) {
      var w;
      return v.negative !== 0 && this.negative === 0 ? (v.negative = 0, w = this.sub(v), v.negative ^= 1, w) : v.negative === 0 && this.negative !== 0 ? (this.negative = 0, w = v.sub(this), this.negative = 1, w) : this.length > v.length ? this.clone().iadd(v) : v.clone().iadd(this);
    }, u.prototype.isub = function(v) {
      if (v.negative !== 0) {
        v.negative = 0;
        var w = this.iadd(v);
        return v.negative = 1, w._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(v), this.negative = 1, this._normSign();
      var O = this.cmp(v);
      if (O === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var G, W;
      O > 0 ? (G = this, W = v) : (G = v, W = this);
      for (var U = 0, M = 0; M < W.length; M++)
        w = (G.words[M] | 0) - (W.words[M] | 0) + U, U = w >> 26, this.words[M] = w & 67108863;
      for (; U !== 0 && M < G.length; M++)
        w = (G.words[M] | 0) + U, U = w >> 26, this.words[M] = w & 67108863;
      if (U === 0 && M < G.length && G !== this)
        for (; M < G.length; M++)
          this.words[M] = G.words[M];
      return this.length = Math.max(this.length, M), G !== this && (this.negative = 1), this._strip();
    }, u.prototype.sub = function(v) {
      return this.clone().isub(v);
    };
    function E(T, v, w) {
      w.negative = v.negative ^ T.negative;
      var O = T.length + v.length | 0;
      w.length = O, O = O - 1 | 0;
      var G = T.words[0] | 0, W = v.words[0] | 0, U = G * W, M = U & 67108863, B = U / 67108864 | 0;
      w.words[0] = M;
      for (var k = 1; k < O; k++) {
        for (var K = B >>> 26, te = B & 67108863, z = Math.min(k, v.length - 1), q = Math.max(0, k - T.length + 1); q <= z; q++) {
          var $ = k - q | 0;
          G = T.words[$] | 0, W = v.words[q] | 0, U = G * W + te, K += U / 67108864 | 0, te = U & 67108863;
        }
        w.words[k] = te | 0, B = K | 0;
      }
      return B !== 0 ? w.words[k] = B | 0 : w.length--, w._strip();
    }
    var S = function(v, w, O) {
      var G = v.words, W = w.words, U = O.words, M = 0, B, k, K, te = G[0] | 0, z = te & 8191, q = te >>> 13, $ = G[1] | 0, Y = $ & 8191, H = $ >>> 13, Q = G[2] | 0, X = Q & 8191, ne = Q >>> 13, ye = G[3] | 0, ve = ye & 8191, de = ye >>> 13, oe = G[4] | 0, re = oe & 8191, ae = oe >>> 13, le = G[5] | 0, ue = le & 8191, ie = le >>> 13, we = G[6] | 0, De = we & 8191, Ee = we >>> 13, Ae = G[7] | 0, Me = Ae & 8191, me = Ae >>> 13, se = G[8] | 0, Z = se & 8191, pe = se >>> 13, be = G[9] | 0, _e = be & 8191, Ie = be >>> 13, We = W[0] | 0, tt = We & 8191, Ye = We >>> 13, ht = W[1] | 0, ct = ht & 8191, st = ht >>> 13, Xe = W[2] | 0, Ke = Xe & 8191, Ce = Xe >>> 13, xe = W[3] | 0, He = xe & 8191, Be = xe >>> 13, Ze = W[4] | 0, nt = Ze & 8191, $e = Ze >>> 13, ut = W[5] | 0, vt = ut & 8191, yt = ut >>> 13, et = W[6] | 0, bt = et & 8191, lt = et >>> 13, Et = W[7] | 0, wt = Et & 8191, Ne = Et >>> 13, Je = W[8] | 0, ft = Je & 8191, rt = Je >>> 13, At = W[9] | 0, Nt = At & 8191, Tt = At >>> 13;
      O.negative = v.negative ^ w.negative, O.length = 19, B = Math.imul(z, tt), k = Math.imul(z, Ye), k = k + Math.imul(q, tt) | 0, K = Math.imul(q, Ye);
      var Ot = (M + B | 0) + ((k & 8191) << 13) | 0;
      M = (K + (k >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, B = Math.imul(Y, tt), k = Math.imul(Y, Ye), k = k + Math.imul(H, tt) | 0, K = Math.imul(H, Ye), B = B + Math.imul(z, ct) | 0, k = k + Math.imul(z, st) | 0, k = k + Math.imul(q, ct) | 0, K = K + Math.imul(q, st) | 0;
      var cr = (M + B | 0) + ((k & 8191) << 13) | 0;
      M = (K + (k >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, B = Math.imul(X, tt), k = Math.imul(X, Ye), k = k + Math.imul(ne, tt) | 0, K = Math.imul(ne, Ye), B = B + Math.imul(Y, ct) | 0, k = k + Math.imul(Y, st) | 0, k = k + Math.imul(H, ct) | 0, K = K + Math.imul(H, st) | 0, B = B + Math.imul(z, Ke) | 0, k = k + Math.imul(z, Ce) | 0, k = k + Math.imul(q, Ke) | 0, K = K + Math.imul(q, Ce) | 0;
      var Wt = (M + B | 0) + ((k & 8191) << 13) | 0;
      M = (K + (k >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, B = Math.imul(ve, tt), k = Math.imul(ve, Ye), k = k + Math.imul(de, tt) | 0, K = Math.imul(de, Ye), B = B + Math.imul(X, ct) | 0, k = k + Math.imul(X, st) | 0, k = k + Math.imul(ne, ct) | 0, K = K + Math.imul(ne, st) | 0, B = B + Math.imul(Y, Ke) | 0, k = k + Math.imul(Y, Ce) | 0, k = k + Math.imul(H, Ke) | 0, K = K + Math.imul(H, Ce) | 0, B = B + Math.imul(z, He) | 0, k = k + Math.imul(z, Be) | 0, k = k + Math.imul(q, He) | 0, K = K + Math.imul(q, Be) | 0;
      var Jt = (M + B | 0) + ((k & 8191) << 13) | 0;
      M = (K + (k >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, B = Math.imul(re, tt), k = Math.imul(re, Ye), k = k + Math.imul(ae, tt) | 0, K = Math.imul(ae, Ye), B = B + Math.imul(ve, ct) | 0, k = k + Math.imul(ve, st) | 0, k = k + Math.imul(de, ct) | 0, K = K + Math.imul(de, st) | 0, B = B + Math.imul(X, Ke) | 0, k = k + Math.imul(X, Ce) | 0, k = k + Math.imul(ne, Ke) | 0, K = K + Math.imul(ne, Ce) | 0, B = B + Math.imul(Y, He) | 0, k = k + Math.imul(Y, Be) | 0, k = k + Math.imul(H, He) | 0, K = K + Math.imul(H, Be) | 0, B = B + Math.imul(z, nt) | 0, k = k + Math.imul(z, $e) | 0, k = k + Math.imul(q, nt) | 0, K = K + Math.imul(q, $e) | 0;
      var pr = (M + B | 0) + ((k & 8191) << 13) | 0;
      M = (K + (k >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, B = Math.imul(ue, tt), k = Math.imul(ue, Ye), k = k + Math.imul(ie, tt) | 0, K = Math.imul(ie, Ye), B = B + Math.imul(re, ct) | 0, k = k + Math.imul(re, st) | 0, k = k + Math.imul(ae, ct) | 0, K = K + Math.imul(ae, st) | 0, B = B + Math.imul(ve, Ke) | 0, k = k + Math.imul(ve, Ce) | 0, k = k + Math.imul(de, Ke) | 0, K = K + Math.imul(de, Ce) | 0, B = B + Math.imul(X, He) | 0, k = k + Math.imul(X, Be) | 0, k = k + Math.imul(ne, He) | 0, K = K + Math.imul(ne, Be) | 0, B = B + Math.imul(Y, nt) | 0, k = k + Math.imul(Y, $e) | 0, k = k + Math.imul(H, nt) | 0, K = K + Math.imul(H, $e) | 0, B = B + Math.imul(z, vt) | 0, k = k + Math.imul(z, yt) | 0, k = k + Math.imul(q, vt) | 0, K = K + Math.imul(q, yt) | 0;
      var $r = (M + B | 0) + ((k & 8191) << 13) | 0;
      M = (K + (k >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, B = Math.imul(De, tt), k = Math.imul(De, Ye), k = k + Math.imul(Ee, tt) | 0, K = Math.imul(Ee, Ye), B = B + Math.imul(ue, ct) | 0, k = k + Math.imul(ue, st) | 0, k = k + Math.imul(ie, ct) | 0, K = K + Math.imul(ie, st) | 0, B = B + Math.imul(re, Ke) | 0, k = k + Math.imul(re, Ce) | 0, k = k + Math.imul(ae, Ke) | 0, K = K + Math.imul(ae, Ce) | 0, B = B + Math.imul(ve, He) | 0, k = k + Math.imul(ve, Be) | 0, k = k + Math.imul(de, He) | 0, K = K + Math.imul(de, Be) | 0, B = B + Math.imul(X, nt) | 0, k = k + Math.imul(X, $e) | 0, k = k + Math.imul(ne, nt) | 0, K = K + Math.imul(ne, $e) | 0, B = B + Math.imul(Y, vt) | 0, k = k + Math.imul(Y, yt) | 0, k = k + Math.imul(H, vt) | 0, K = K + Math.imul(H, yt) | 0, B = B + Math.imul(z, bt) | 0, k = k + Math.imul(z, lt) | 0, k = k + Math.imul(q, bt) | 0, K = K + Math.imul(q, lt) | 0;
      var Ur = (M + B | 0) + ((k & 8191) << 13) | 0;
      M = (K + (k >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, B = Math.imul(Me, tt), k = Math.imul(Me, Ye), k = k + Math.imul(me, tt) | 0, K = Math.imul(me, Ye), B = B + Math.imul(De, ct) | 0, k = k + Math.imul(De, st) | 0, k = k + Math.imul(Ee, ct) | 0, K = K + Math.imul(Ee, st) | 0, B = B + Math.imul(ue, Ke) | 0, k = k + Math.imul(ue, Ce) | 0, k = k + Math.imul(ie, Ke) | 0, K = K + Math.imul(ie, Ce) | 0, B = B + Math.imul(re, He) | 0, k = k + Math.imul(re, Be) | 0, k = k + Math.imul(ae, He) | 0, K = K + Math.imul(ae, Be) | 0, B = B + Math.imul(ve, nt) | 0, k = k + Math.imul(ve, $e) | 0, k = k + Math.imul(de, nt) | 0, K = K + Math.imul(de, $e) | 0, B = B + Math.imul(X, vt) | 0, k = k + Math.imul(X, yt) | 0, k = k + Math.imul(ne, vt) | 0, K = K + Math.imul(ne, yt) | 0, B = B + Math.imul(Y, bt) | 0, k = k + Math.imul(Y, lt) | 0, k = k + Math.imul(H, bt) | 0, K = K + Math.imul(H, lt) | 0, B = B + Math.imul(z, wt) | 0, k = k + Math.imul(z, Ne) | 0, k = k + Math.imul(q, wt) | 0, K = K + Math.imul(q, Ne) | 0;
      var _r = (M + B | 0) + ((k & 8191) << 13) | 0;
      M = (K + (k >>> 13) | 0) + (_r >>> 26) | 0, _r &= 67108863, B = Math.imul(Z, tt), k = Math.imul(Z, Ye), k = k + Math.imul(pe, tt) | 0, K = Math.imul(pe, Ye), B = B + Math.imul(Me, ct) | 0, k = k + Math.imul(Me, st) | 0, k = k + Math.imul(me, ct) | 0, K = K + Math.imul(me, st) | 0, B = B + Math.imul(De, Ke) | 0, k = k + Math.imul(De, Ce) | 0, k = k + Math.imul(Ee, Ke) | 0, K = K + Math.imul(Ee, Ce) | 0, B = B + Math.imul(ue, He) | 0, k = k + Math.imul(ue, Be) | 0, k = k + Math.imul(ie, He) | 0, K = K + Math.imul(ie, Be) | 0, B = B + Math.imul(re, nt) | 0, k = k + Math.imul(re, $e) | 0, k = k + Math.imul(ae, nt) | 0, K = K + Math.imul(ae, $e) | 0, B = B + Math.imul(ve, vt) | 0, k = k + Math.imul(ve, yt) | 0, k = k + Math.imul(de, vt) | 0, K = K + Math.imul(de, yt) | 0, B = B + Math.imul(X, bt) | 0, k = k + Math.imul(X, lt) | 0, k = k + Math.imul(ne, bt) | 0, K = K + Math.imul(ne, lt) | 0, B = B + Math.imul(Y, wt) | 0, k = k + Math.imul(Y, Ne) | 0, k = k + Math.imul(H, wt) | 0, K = K + Math.imul(H, Ne) | 0, B = B + Math.imul(z, ft) | 0, k = k + Math.imul(z, rt) | 0, k = k + Math.imul(q, ft) | 0, K = K + Math.imul(q, rt) | 0;
      var qn = (M + B | 0) + ((k & 8191) << 13) | 0;
      M = (K + (k >>> 13) | 0) + (qn >>> 26) | 0, qn &= 67108863, B = Math.imul(_e, tt), k = Math.imul(_e, Ye), k = k + Math.imul(Ie, tt) | 0, K = Math.imul(Ie, Ye), B = B + Math.imul(Z, ct) | 0, k = k + Math.imul(Z, st) | 0, k = k + Math.imul(pe, ct) | 0, K = K + Math.imul(pe, st) | 0, B = B + Math.imul(Me, Ke) | 0, k = k + Math.imul(Me, Ce) | 0, k = k + Math.imul(me, Ke) | 0, K = K + Math.imul(me, Ce) | 0, B = B + Math.imul(De, He) | 0, k = k + Math.imul(De, Be) | 0, k = k + Math.imul(Ee, He) | 0, K = K + Math.imul(Ee, Be) | 0, B = B + Math.imul(ue, nt) | 0, k = k + Math.imul(ue, $e) | 0, k = k + Math.imul(ie, nt) | 0, K = K + Math.imul(ie, $e) | 0, B = B + Math.imul(re, vt) | 0, k = k + Math.imul(re, yt) | 0, k = k + Math.imul(ae, vt) | 0, K = K + Math.imul(ae, yt) | 0, B = B + Math.imul(ve, bt) | 0, k = k + Math.imul(ve, lt) | 0, k = k + Math.imul(de, bt) | 0, K = K + Math.imul(de, lt) | 0, B = B + Math.imul(X, wt) | 0, k = k + Math.imul(X, Ne) | 0, k = k + Math.imul(ne, wt) | 0, K = K + Math.imul(ne, Ne) | 0, B = B + Math.imul(Y, ft) | 0, k = k + Math.imul(Y, rt) | 0, k = k + Math.imul(H, ft) | 0, K = K + Math.imul(H, rt) | 0, B = B + Math.imul(z, Nt) | 0, k = k + Math.imul(z, Tt) | 0, k = k + Math.imul(q, Nt) | 0, K = K + Math.imul(q, Tt) | 0;
      var Mn = (M + B | 0) + ((k & 8191) << 13) | 0;
      M = (K + (k >>> 13) | 0) + (Mn >>> 26) | 0, Mn &= 67108863, B = Math.imul(_e, ct), k = Math.imul(_e, st), k = k + Math.imul(Ie, ct) | 0, K = Math.imul(Ie, st), B = B + Math.imul(Z, Ke) | 0, k = k + Math.imul(Z, Ce) | 0, k = k + Math.imul(pe, Ke) | 0, K = K + Math.imul(pe, Ce) | 0, B = B + Math.imul(Me, He) | 0, k = k + Math.imul(Me, Be) | 0, k = k + Math.imul(me, He) | 0, K = K + Math.imul(me, Be) | 0, B = B + Math.imul(De, nt) | 0, k = k + Math.imul(De, $e) | 0, k = k + Math.imul(Ee, nt) | 0, K = K + Math.imul(Ee, $e) | 0, B = B + Math.imul(ue, vt) | 0, k = k + Math.imul(ue, yt) | 0, k = k + Math.imul(ie, vt) | 0, K = K + Math.imul(ie, yt) | 0, B = B + Math.imul(re, bt) | 0, k = k + Math.imul(re, lt) | 0, k = k + Math.imul(ae, bt) | 0, K = K + Math.imul(ae, lt) | 0, B = B + Math.imul(ve, wt) | 0, k = k + Math.imul(ve, Ne) | 0, k = k + Math.imul(de, wt) | 0, K = K + Math.imul(de, Ne) | 0, B = B + Math.imul(X, ft) | 0, k = k + Math.imul(X, rt) | 0, k = k + Math.imul(ne, ft) | 0, K = K + Math.imul(ne, rt) | 0, B = B + Math.imul(Y, Nt) | 0, k = k + Math.imul(Y, Tt) | 0, k = k + Math.imul(H, Nt) | 0, K = K + Math.imul(H, Tt) | 0;
      var Ln = (M + B | 0) + ((k & 8191) << 13) | 0;
      M = (K + (k >>> 13) | 0) + (Ln >>> 26) | 0, Ln &= 67108863, B = Math.imul(_e, Ke), k = Math.imul(_e, Ce), k = k + Math.imul(Ie, Ke) | 0, K = Math.imul(Ie, Ce), B = B + Math.imul(Z, He) | 0, k = k + Math.imul(Z, Be) | 0, k = k + Math.imul(pe, He) | 0, K = K + Math.imul(pe, Be) | 0, B = B + Math.imul(Me, nt) | 0, k = k + Math.imul(Me, $e) | 0, k = k + Math.imul(me, nt) | 0, K = K + Math.imul(me, $e) | 0, B = B + Math.imul(De, vt) | 0, k = k + Math.imul(De, yt) | 0, k = k + Math.imul(Ee, vt) | 0, K = K + Math.imul(Ee, yt) | 0, B = B + Math.imul(ue, bt) | 0, k = k + Math.imul(ue, lt) | 0, k = k + Math.imul(ie, bt) | 0, K = K + Math.imul(ie, lt) | 0, B = B + Math.imul(re, wt) | 0, k = k + Math.imul(re, Ne) | 0, k = k + Math.imul(ae, wt) | 0, K = K + Math.imul(ae, Ne) | 0, B = B + Math.imul(ve, ft) | 0, k = k + Math.imul(ve, rt) | 0, k = k + Math.imul(de, ft) | 0, K = K + Math.imul(de, rt) | 0, B = B + Math.imul(X, Nt) | 0, k = k + Math.imul(X, Tt) | 0, k = k + Math.imul(ne, Nt) | 0, K = K + Math.imul(ne, Tt) | 0;
      var mn = (M + B | 0) + ((k & 8191) << 13) | 0;
      M = (K + (k >>> 13) | 0) + (mn >>> 26) | 0, mn &= 67108863, B = Math.imul(_e, He), k = Math.imul(_e, Be), k = k + Math.imul(Ie, He) | 0, K = Math.imul(Ie, Be), B = B + Math.imul(Z, nt) | 0, k = k + Math.imul(Z, $e) | 0, k = k + Math.imul(pe, nt) | 0, K = K + Math.imul(pe, $e) | 0, B = B + Math.imul(Me, vt) | 0, k = k + Math.imul(Me, yt) | 0, k = k + Math.imul(me, vt) | 0, K = K + Math.imul(me, yt) | 0, B = B + Math.imul(De, bt) | 0, k = k + Math.imul(De, lt) | 0, k = k + Math.imul(Ee, bt) | 0, K = K + Math.imul(Ee, lt) | 0, B = B + Math.imul(ue, wt) | 0, k = k + Math.imul(ue, Ne) | 0, k = k + Math.imul(ie, wt) | 0, K = K + Math.imul(ie, Ne) | 0, B = B + Math.imul(re, ft) | 0, k = k + Math.imul(re, rt) | 0, k = k + Math.imul(ae, ft) | 0, K = K + Math.imul(ae, rt) | 0, B = B + Math.imul(ve, Nt) | 0, k = k + Math.imul(ve, Tt) | 0, k = k + Math.imul(de, Nt) | 0, K = K + Math.imul(de, Tt) | 0;
      var jn = (M + B | 0) + ((k & 8191) << 13) | 0;
      M = (K + (k >>> 13) | 0) + (jn >>> 26) | 0, jn &= 67108863, B = Math.imul(_e, nt), k = Math.imul(_e, $e), k = k + Math.imul(Ie, nt) | 0, K = Math.imul(Ie, $e), B = B + Math.imul(Z, vt) | 0, k = k + Math.imul(Z, yt) | 0, k = k + Math.imul(pe, vt) | 0, K = K + Math.imul(pe, yt) | 0, B = B + Math.imul(Me, bt) | 0, k = k + Math.imul(Me, lt) | 0, k = k + Math.imul(me, bt) | 0, K = K + Math.imul(me, lt) | 0, B = B + Math.imul(De, wt) | 0, k = k + Math.imul(De, Ne) | 0, k = k + Math.imul(Ee, wt) | 0, K = K + Math.imul(Ee, Ne) | 0, B = B + Math.imul(ue, ft) | 0, k = k + Math.imul(ue, rt) | 0, k = k + Math.imul(ie, ft) | 0, K = K + Math.imul(ie, rt) | 0, B = B + Math.imul(re, Nt) | 0, k = k + Math.imul(re, Tt) | 0, k = k + Math.imul(ae, Nt) | 0, K = K + Math.imul(ae, Tt) | 0;
      var yn = (M + B | 0) + ((k & 8191) << 13) | 0;
      M = (K + (k >>> 13) | 0) + (yn >>> 26) | 0, yn &= 67108863, B = Math.imul(_e, vt), k = Math.imul(_e, yt), k = k + Math.imul(Ie, vt) | 0, K = Math.imul(Ie, yt), B = B + Math.imul(Z, bt) | 0, k = k + Math.imul(Z, lt) | 0, k = k + Math.imul(pe, bt) | 0, K = K + Math.imul(pe, lt) | 0, B = B + Math.imul(Me, wt) | 0, k = k + Math.imul(Me, Ne) | 0, k = k + Math.imul(me, wt) | 0, K = K + Math.imul(me, Ne) | 0, B = B + Math.imul(De, ft) | 0, k = k + Math.imul(De, rt) | 0, k = k + Math.imul(Ee, ft) | 0, K = K + Math.imul(Ee, rt) | 0, B = B + Math.imul(ue, Nt) | 0, k = k + Math.imul(ue, Tt) | 0, k = k + Math.imul(ie, Nt) | 0, K = K + Math.imul(ie, Tt) | 0;
      var bn = (M + B | 0) + ((k & 8191) << 13) | 0;
      M = (K + (k >>> 13) | 0) + (bn >>> 26) | 0, bn &= 67108863, B = Math.imul(_e, bt), k = Math.imul(_e, lt), k = k + Math.imul(Ie, bt) | 0, K = Math.imul(Ie, lt), B = B + Math.imul(Z, wt) | 0, k = k + Math.imul(Z, Ne) | 0, k = k + Math.imul(pe, wt) | 0, K = K + Math.imul(pe, Ne) | 0, B = B + Math.imul(Me, ft) | 0, k = k + Math.imul(Me, rt) | 0, k = k + Math.imul(me, ft) | 0, K = K + Math.imul(me, rt) | 0, B = B + Math.imul(De, Nt) | 0, k = k + Math.imul(De, Tt) | 0, k = k + Math.imul(Ee, Nt) | 0, K = K + Math.imul(Ee, Tt) | 0;
      var En = (M + B | 0) + ((k & 8191) << 13) | 0;
      M = (K + (k >>> 13) | 0) + (En >>> 26) | 0, En &= 67108863, B = Math.imul(_e, wt), k = Math.imul(_e, Ne), k = k + Math.imul(Ie, wt) | 0, K = Math.imul(Ie, Ne), B = B + Math.imul(Z, ft) | 0, k = k + Math.imul(Z, rt) | 0, k = k + Math.imul(pe, ft) | 0, K = K + Math.imul(pe, rt) | 0, B = B + Math.imul(Me, Nt) | 0, k = k + Math.imul(Me, Tt) | 0, k = k + Math.imul(me, Nt) | 0, K = K + Math.imul(me, Tt) | 0;
      var Vr = (M + B | 0) + ((k & 8191) << 13) | 0;
      M = (K + (k >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, B = Math.imul(_e, ft), k = Math.imul(_e, rt), k = k + Math.imul(Ie, ft) | 0, K = Math.imul(Ie, rt), B = B + Math.imul(Z, Nt) | 0, k = k + Math.imul(Z, Tt) | 0, k = k + Math.imul(pe, Nt) | 0, K = K + Math.imul(pe, Tt) | 0;
      var zi = (M + B | 0) + ((k & 8191) << 13) | 0;
      M = (K + (k >>> 13) | 0) + (zi >>> 26) | 0, zi &= 67108863, B = Math.imul(_e, Nt), k = Math.imul(_e, Tt), k = k + Math.imul(Ie, Nt) | 0, K = Math.imul(Ie, Tt);
      var As = (M + B | 0) + ((k & 8191) << 13) | 0;
      return M = (K + (k >>> 13) | 0) + (As >>> 26) | 0, As &= 67108863, U[0] = Ot, U[1] = cr, U[2] = Wt, U[3] = Jt, U[4] = pr, U[5] = $r, U[6] = Ur, U[7] = _r, U[8] = qn, U[9] = Mn, U[10] = Ln, U[11] = mn, U[12] = jn, U[13] = yn, U[14] = bn, U[15] = En, U[16] = Vr, U[17] = zi, U[18] = As, M !== 0 && (U[19] = M, O.length++), O;
    };
    Math.imul || (S = E);
    function g(T, v, w) {
      w.negative = v.negative ^ T.negative, w.length = T.length + v.length;
      for (var O = 0, G = 0, W = 0; W < w.length - 1; W++) {
        var U = G;
        G = 0;
        for (var M = O & 67108863, B = Math.min(W, v.length - 1), k = Math.max(0, W - T.length + 1); k <= B; k++) {
          var K = W - k, te = T.words[K] | 0, z = v.words[k] | 0, q = te * z, $ = q & 67108863;
          U = U + (q / 67108864 | 0) | 0, $ = $ + M | 0, M = $ & 67108863, U = U + ($ >>> 26) | 0, G += U >>> 26, U &= 67108863;
        }
        w.words[W] = M, O = U, U = G;
      }
      return O !== 0 ? w.words[W] = O : w.length--, w._strip();
    }
    function P(T, v, w) {
      return g(T, v, w);
    }
    u.prototype.mulTo = function(v, w) {
      var O, G = this.length + v.length;
      return this.length === 10 && v.length === 10 ? O = S(this, v, w) : G < 63 ? O = E(this, v, w) : G < 1024 ? O = g(this, v, w) : O = P(this, v, w), O;
    }, u.prototype.mul = function(v) {
      var w = new u(null);
      return w.words = new Array(this.length + v.length), this.mulTo(v, w);
    }, u.prototype.mulf = function(v) {
      var w = new u(null);
      return w.words = new Array(this.length + v.length), P(this, v, w);
    }, u.prototype.imul = function(v) {
      return this.clone().mulTo(v, this);
    }, u.prototype.imuln = function(v) {
      var w = v < 0;
      w && (v = -v), a(typeof v == "number"), a(v < 67108864);
      for (var O = 0, G = 0; G < this.length; G++) {
        var W = (this.words[G] | 0) * v, U = (W & 67108863) + (O & 67108863);
        O >>= 26, O += W / 67108864 | 0, O += U >>> 26, this.words[G] = U & 67108863;
      }
      return O !== 0 && (this.words[G] = O, this.length++), w ? this.ineg() : this;
    }, u.prototype.muln = function(v) {
      return this.clone().imuln(v);
    }, u.prototype.sqr = function() {
      return this.mul(this);
    }, u.prototype.isqr = function() {
      return this.imul(this.clone());
    }, u.prototype.pow = function(v) {
      var w = b(v);
      if (w.length === 0)
        return new u(1);
      for (var O = this, G = 0; G < w.length && w[G] === 0; G++, O = O.sqr())
        ;
      if (++G < w.length)
        for (var W = O.sqr(); G < w.length; G++, W = W.sqr())
          w[G] !== 0 && (O = O.mul(W));
      return O;
    }, u.prototype.iushln = function(v) {
      a(typeof v == "number" && v >= 0);
      var w = v % 26, O = (v - w) / 26, G = 67108863 >>> 26 - w << 26 - w, W;
      if (w !== 0) {
        var U = 0;
        for (W = 0; W < this.length; W++) {
          var M = this.words[W] & G, B = (this.words[W] | 0) - M << w;
          this.words[W] = B | U, U = M >>> 26 - w;
        }
        U && (this.words[W] = U, this.length++);
      }
      if (O !== 0) {
        for (W = this.length - 1; W >= 0; W--)
          this.words[W + O] = this.words[W];
        for (W = 0; W < O; W++)
          this.words[W] = 0;
        this.length += O;
      }
      return this._strip();
    }, u.prototype.ishln = function(v) {
      return a(this.negative === 0), this.iushln(v);
    }, u.prototype.iushrn = function(v, w, O) {
      a(typeof v == "number" && v >= 0);
      var G;
      w ? G = (w - w % 26) / 26 : G = 0;
      var W = v % 26, U = Math.min((v - W) / 26, this.length), M = 67108863 ^ 67108863 >>> W << W, B = O;
      if (G -= U, G = Math.max(0, G), B) {
        for (var k = 0; k < U; k++)
          B.words[k] = this.words[k];
        B.length = U;
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, k = 0; k < this.length; k++)
            this.words[k] = this.words[k + U];
        else
          this.words[0] = 0, this.length = 1;
      var K = 0;
      for (k = this.length - 1; k >= 0 && (K !== 0 || k >= G); k--) {
        var te = this.words[k] | 0;
        this.words[k] = K << 26 - W | te >>> W, K = te & M;
      }
      return B && K !== 0 && (B.words[B.length++] = K), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, u.prototype.ishrn = function(v, w, O) {
      return a(this.negative === 0), this.iushrn(v, w, O);
    }, u.prototype.shln = function(v) {
      return this.clone().ishln(v);
    }, u.prototype.ushln = function(v) {
      return this.clone().iushln(v);
    }, u.prototype.shrn = function(v) {
      return this.clone().ishrn(v);
    }, u.prototype.ushrn = function(v) {
      return this.clone().iushrn(v);
    }, u.prototype.testn = function(v) {
      a(typeof v == "number" && v >= 0);
      var w = v % 26, O = (v - w) / 26, G = 1 << w;
      if (this.length <= O)
        return !1;
      var W = this.words[O];
      return !!(W & G);
    }, u.prototype.imaskn = function(v) {
      a(typeof v == "number" && v >= 0);
      var w = v % 26, O = (v - w) / 26;
      if (a(this.negative === 0, "imaskn works only with positive numbers"), this.length <= O)
        return this;
      if (w !== 0 && O++, this.length = Math.min(O, this.length), w !== 0) {
        var G = 67108863 ^ 67108863 >>> w << w;
        this.words[this.length - 1] &= G;
      }
      return this._strip();
    }, u.prototype.maskn = function(v) {
      return this.clone().imaskn(v);
    }, u.prototype.iaddn = function(v) {
      return a(typeof v == "number"), a(v < 67108864), v < 0 ? this.isubn(-v) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= v ? (this.words[0] = v - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(v), this.negative = 1, this) : this._iaddn(v);
    }, u.prototype._iaddn = function(v) {
      this.words[0] += v;
      for (var w = 0; w < this.length && this.words[w] >= 67108864; w++)
        this.words[w] -= 67108864, w === this.length - 1 ? this.words[w + 1] = 1 : this.words[w + 1]++;
      return this.length = Math.max(this.length, w + 1), this;
    }, u.prototype.isubn = function(v) {
      if (a(typeof v == "number"), a(v < 67108864), v < 0)
        return this.iaddn(-v);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(v), this.negative = 1, this;
      if (this.words[0] -= v, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var w = 0; w < this.length && this.words[w] < 0; w++)
          this.words[w] += 67108864, this.words[w + 1] -= 1;
      return this._strip();
    }, u.prototype.addn = function(v) {
      return this.clone().iaddn(v);
    }, u.prototype.subn = function(v) {
      return this.clone().isubn(v);
    }, u.prototype.iabs = function() {
      return this.negative = 0, this;
    }, u.prototype.abs = function() {
      return this.clone().iabs();
    }, u.prototype._ishlnsubmul = function(v, w, O) {
      var G = v.length + O, W;
      this._expand(G);
      var U, M = 0;
      for (W = 0; W < v.length; W++) {
        U = (this.words[W + O] | 0) + M;
        var B = (v.words[W] | 0) * w;
        U -= B & 67108863, M = (U >> 26) - (B / 67108864 | 0), this.words[W + O] = U & 67108863;
      }
      for (; W < this.length - O; W++)
        U = (this.words[W + O] | 0) + M, M = U >> 26, this.words[W + O] = U & 67108863;
      if (M === 0)
        return this._strip();
      for (a(M === -1), M = 0, W = 0; W < this.length; W++)
        U = -(this.words[W] | 0) + M, M = U >> 26, this.words[W] = U & 67108863;
      return this.negative = 1, this._strip();
    }, u.prototype._wordDiv = function(v, w) {
      var O = this.length - v.length, G = this.clone(), W = v, U = W.words[W.length - 1] | 0, M = this._countBits(U);
      O = 26 - M, O !== 0 && (W = W.ushln(O), G.iushln(O), U = W.words[W.length - 1] | 0);
      var B = G.length - W.length, k;
      if (w !== "mod") {
        k = new u(null), k.length = B + 1, k.words = new Array(k.length);
        for (var K = 0; K < k.length; K++)
          k.words[K] = 0;
      }
      var te = G.clone()._ishlnsubmul(W, 1, B);
      te.negative === 0 && (G = te, k && (k.words[B] = 1));
      for (var z = B - 1; z >= 0; z--) {
        var q = (G.words[W.length + z] | 0) * 67108864 + (G.words[W.length + z - 1] | 0);
        for (q = Math.min(q / U | 0, 67108863), G._ishlnsubmul(W, q, z); G.negative !== 0; )
          q--, G.negative = 0, G._ishlnsubmul(W, 1, z), G.isZero() || (G.negative ^= 1);
        k && (k.words[z] = q);
      }
      return k && k._strip(), G._strip(), w !== "div" && O !== 0 && G.iushrn(O), {
        div: k || null,
        mod: G
      };
    }, u.prototype.divmod = function(v, w, O) {
      if (a(!v.isZero()), this.isZero())
        return {
          div: new u(0),
          mod: new u(0)
        };
      var G, W, U;
      return this.negative !== 0 && v.negative === 0 ? (U = this.neg().divmod(v, w), w !== "mod" && (G = U.div.neg()), w !== "div" && (W = U.mod.neg(), O && W.negative !== 0 && W.iadd(v)), {
        div: G,
        mod: W
      }) : this.negative === 0 && v.negative !== 0 ? (U = this.divmod(v.neg(), w), w !== "mod" && (G = U.div.neg()), {
        div: G,
        mod: U.mod
      }) : this.negative & v.negative ? (U = this.neg().divmod(v.neg(), w), w !== "div" && (W = U.mod.neg(), O && W.negative !== 0 && W.isub(v)), {
        div: U.div,
        mod: W
      }) : v.length > this.length || this.cmp(v) < 0 ? {
        div: new u(0),
        mod: this
      } : v.length === 1 ? w === "div" ? {
        div: this.divn(v.words[0]),
        mod: null
      } : w === "mod" ? {
        div: null,
        mod: new u(this.modrn(v.words[0]))
      } : {
        div: this.divn(v.words[0]),
        mod: new u(this.modrn(v.words[0]))
      } : this._wordDiv(v, w);
    }, u.prototype.div = function(v) {
      return this.divmod(v, "div", !1).div;
    }, u.prototype.mod = function(v) {
      return this.divmod(v, "mod", !1).mod;
    }, u.prototype.umod = function(v) {
      return this.divmod(v, "mod", !0).mod;
    }, u.prototype.divRound = function(v) {
      var w = this.divmod(v);
      if (w.mod.isZero())
        return w.div;
      var O = w.div.negative !== 0 ? w.mod.isub(v) : w.mod, G = v.ushrn(1), W = v.andln(1), U = O.cmp(G);
      return U < 0 || W === 1 && U === 0 ? w.div : w.div.negative !== 0 ? w.div.isubn(1) : w.div.iaddn(1);
    }, u.prototype.modrn = function(v) {
      var w = v < 0;
      w && (v = -v), a(v <= 67108863);
      for (var O = (1 << 26) % v, G = 0, W = this.length - 1; W >= 0; W--)
        G = (O * G + (this.words[W] | 0)) % v;
      return w ? -G : G;
    }, u.prototype.modn = function(v) {
      return this.modrn(v);
    }, u.prototype.idivn = function(v) {
      var w = v < 0;
      w && (v = -v), a(v <= 67108863);
      for (var O = 0, G = this.length - 1; G >= 0; G--) {
        var W = (this.words[G] | 0) + O * 67108864;
        this.words[G] = W / v | 0, O = W % v;
      }
      return this._strip(), w ? this.ineg() : this;
    }, u.prototype.divn = function(v) {
      return this.clone().idivn(v);
    }, u.prototype.egcd = function(v) {
      a(v.negative === 0), a(!v.isZero());
      var w = this, O = v.clone();
      w.negative !== 0 ? w = w.umod(v) : w = w.clone();
      for (var G = new u(1), W = new u(0), U = new u(0), M = new u(1), B = 0; w.isEven() && O.isEven(); )
        w.iushrn(1), O.iushrn(1), ++B;
      for (var k = O.clone(), K = w.clone(); !w.isZero(); ) {
        for (var te = 0, z = 1; !(w.words[0] & z) && te < 26; ++te, z <<= 1)
          ;
        if (te > 0)
          for (w.iushrn(te); te-- > 0; )
            (G.isOdd() || W.isOdd()) && (G.iadd(k), W.isub(K)), G.iushrn(1), W.iushrn(1);
        for (var q = 0, $ = 1; !(O.words[0] & $) && q < 26; ++q, $ <<= 1)
          ;
        if (q > 0)
          for (O.iushrn(q); q-- > 0; )
            (U.isOdd() || M.isOdd()) && (U.iadd(k), M.isub(K)), U.iushrn(1), M.iushrn(1);
        w.cmp(O) >= 0 ? (w.isub(O), G.isub(U), W.isub(M)) : (O.isub(w), U.isub(G), M.isub(W));
      }
      return {
        a: U,
        b: M,
        gcd: O.iushln(B)
      };
    }, u.prototype._invmp = function(v) {
      a(v.negative === 0), a(!v.isZero());
      var w = this, O = v.clone();
      w.negative !== 0 ? w = w.umod(v) : w = w.clone();
      for (var G = new u(1), W = new u(0), U = O.clone(); w.cmpn(1) > 0 && O.cmpn(1) > 0; ) {
        for (var M = 0, B = 1; !(w.words[0] & B) && M < 26; ++M, B <<= 1)
          ;
        if (M > 0)
          for (w.iushrn(M); M-- > 0; )
            G.isOdd() && G.iadd(U), G.iushrn(1);
        for (var k = 0, K = 1; !(O.words[0] & K) && k < 26; ++k, K <<= 1)
          ;
        if (k > 0)
          for (O.iushrn(k); k-- > 0; )
            W.isOdd() && W.iadd(U), W.iushrn(1);
        w.cmp(O) >= 0 ? (w.isub(O), G.isub(W)) : (O.isub(w), W.isub(G));
      }
      var te;
      return w.cmpn(1) === 0 ? te = G : te = W, te.cmpn(0) < 0 && te.iadd(v), te;
    }, u.prototype.gcd = function(v) {
      if (this.isZero())
        return v.abs();
      if (v.isZero())
        return this.abs();
      var w = this.clone(), O = v.clone();
      w.negative = 0, O.negative = 0;
      for (var G = 0; w.isEven() && O.isEven(); G++)
        w.iushrn(1), O.iushrn(1);
      do {
        for (; w.isEven(); )
          w.iushrn(1);
        for (; O.isEven(); )
          O.iushrn(1);
        var W = w.cmp(O);
        if (W < 0) {
          var U = w;
          w = O, O = U;
        } else if (W === 0 || O.cmpn(1) === 0)
          break;
        w.isub(O);
      } while (!0);
      return O.iushln(G);
    }, u.prototype.invm = function(v) {
      return this.egcd(v).a.umod(v);
    }, u.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, u.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, u.prototype.andln = function(v) {
      return this.words[0] & v;
    }, u.prototype.bincn = function(v) {
      a(typeof v == "number");
      var w = v % 26, O = (v - w) / 26, G = 1 << w;
      if (this.length <= O)
        return this._expand(O + 1), this.words[O] |= G, this;
      for (var W = G, U = O; W !== 0 && U < this.length; U++) {
        var M = this.words[U] | 0;
        M += W, W = M >>> 26, M &= 67108863, this.words[U] = M;
      }
      return W !== 0 && (this.words[U] = W, this.length++), this;
    }, u.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, u.prototype.cmpn = function(v) {
      var w = v < 0;
      if (this.negative !== 0 && !w)
        return -1;
      if (this.negative === 0 && w)
        return 1;
      this._strip();
      var O;
      if (this.length > 1)
        O = 1;
      else {
        w && (v = -v), a(v <= 67108863, "Number is too big");
        var G = this.words[0] | 0;
        O = G === v ? 0 : G < v ? -1 : 1;
      }
      return this.negative !== 0 ? -O | 0 : O;
    }, u.prototype.cmp = function(v) {
      if (this.negative !== 0 && v.negative === 0)
        return -1;
      if (this.negative === 0 && v.negative !== 0)
        return 1;
      var w = this.ucmp(v);
      return this.negative !== 0 ? -w | 0 : w;
    }, u.prototype.ucmp = function(v) {
      if (this.length > v.length)
        return 1;
      if (this.length < v.length)
        return -1;
      for (var w = 0, O = this.length - 1; O >= 0; O--) {
        var G = this.words[O] | 0, W = v.words[O] | 0;
        if (G !== W) {
          G < W ? w = -1 : G > W && (w = 1);
          break;
        }
      }
      return w;
    }, u.prototype.gtn = function(v) {
      return this.cmpn(v) === 1;
    }, u.prototype.gt = function(v) {
      return this.cmp(v) === 1;
    }, u.prototype.gten = function(v) {
      return this.cmpn(v) >= 0;
    }, u.prototype.gte = function(v) {
      return this.cmp(v) >= 0;
    }, u.prototype.ltn = function(v) {
      return this.cmpn(v) === -1;
    }, u.prototype.lt = function(v) {
      return this.cmp(v) === -1;
    }, u.prototype.lten = function(v) {
      return this.cmpn(v) <= 0;
    }, u.prototype.lte = function(v) {
      return this.cmp(v) <= 0;
    }, u.prototype.eqn = function(v) {
      return this.cmpn(v) === 0;
    }, u.prototype.eq = function(v) {
      return this.cmp(v) === 0;
    }, u.red = function(v) {
      return new F(v);
    }, u.prototype.toRed = function(v) {
      return a(!this.red, "Already a number in reduction context"), a(this.negative === 0, "red works only with positives"), v.convertTo(this)._forceRed(v);
    }, u.prototype.fromRed = function() {
      return a(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, u.prototype._forceRed = function(v) {
      return this.red = v, this;
    }, u.prototype.forceRed = function(v) {
      return a(!this.red, "Already a number in reduction context"), this._forceRed(v);
    }, u.prototype.redAdd = function(v) {
      return a(this.red, "redAdd works only with red numbers"), this.red.add(this, v);
    }, u.prototype.redIAdd = function(v) {
      return a(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, v);
    }, u.prototype.redSub = function(v) {
      return a(this.red, "redSub works only with red numbers"), this.red.sub(this, v);
    }, u.prototype.redISub = function(v) {
      return a(this.red, "redISub works only with red numbers"), this.red.isub(this, v);
    }, u.prototype.redShl = function(v) {
      return a(this.red, "redShl works only with red numbers"), this.red.shl(this, v);
    }, u.prototype.redMul = function(v) {
      return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, v), this.red.mul(this, v);
    }, u.prototype.redIMul = function(v) {
      return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, v), this.red.imul(this, v);
    }, u.prototype.redSqr = function() {
      return a(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, u.prototype.redISqr = function() {
      return a(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, u.prototype.redSqrt = function() {
      return a(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, u.prototype.redInvm = function() {
      return a(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, u.prototype.redNeg = function() {
      return a(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, u.prototype.redPow = function(v) {
      return a(this.red && !v.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, v);
    };
    var R = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function N(T, v) {
      this.name = T, this.p = new u(v, 16), this.n = this.p.bitLength(), this.k = new u(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    N.prototype._tmp = function() {
      var v = new u(null);
      return v.words = new Array(Math.ceil(this.n / 13)), v;
    }, N.prototype.ireduce = function(v) {
      var w = v, O;
      do
        this.split(w, this.tmp), w = this.imulK(w), w = w.iadd(this.tmp), O = w.bitLength();
      while (O > this.n);
      var G = O < this.n ? -1 : w.ucmp(this.p);
      return G === 0 ? (w.words[0] = 0, w.length = 1) : G > 0 ? w.isub(this.p) : w.strip !== void 0 ? w.strip() : w._strip(), w;
    }, N.prototype.split = function(v, w) {
      v.iushrn(this.n, 0, w);
    }, N.prototype.imulK = function(v) {
      return v.imul(this.k);
    };
    function C() {
      N.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    c(C, N), C.prototype.split = function(v, w) {
      for (var O = 4194303, G = Math.min(v.length, 9), W = 0; W < G; W++)
        w.words[W] = v.words[W];
      if (w.length = G, v.length <= 9) {
        v.words[0] = 0, v.length = 1;
        return;
      }
      var U = v.words[9];
      for (w.words[w.length++] = U & O, W = 10; W < v.length; W++) {
        var M = v.words[W] | 0;
        v.words[W - 10] = (M & O) << 4 | U >>> 22, U = M;
      }
      U >>>= 22, v.words[W - 10] = U, U === 0 && v.length > 10 ? v.length -= 10 : v.length -= 9;
    }, C.prototype.imulK = function(v) {
      v.words[v.length] = 0, v.words[v.length + 1] = 0, v.length += 2;
      for (var w = 0, O = 0; O < v.length; O++) {
        var G = v.words[O] | 0;
        w += G * 977, v.words[O] = w & 67108863, w = G * 64 + (w / 67108864 | 0);
      }
      return v.words[v.length - 1] === 0 && (v.length--, v.words[v.length - 1] === 0 && v.length--), v;
    };
    function I() {
      N.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    c(I, N);
    function D() {
      N.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    c(D, N);
    function j() {
      N.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    c(j, N), j.prototype.imulK = function(v) {
      for (var w = 0, O = 0; O < v.length; O++) {
        var G = (v.words[O] | 0) * 19 + w, W = G & 67108863;
        G >>>= 26, v.words[O] = W, w = G;
      }
      return w !== 0 && (v.words[v.length++] = w), v;
    }, u._prime = function(v) {
      if (R[v])
        return R[v];
      var w;
      if (v === "k256")
        w = new C();
      else if (v === "p224")
        w = new I();
      else if (v === "p192")
        w = new D();
      else if (v === "p25519")
        w = new j();
      else
        throw new Error("Unknown prime " + v);
      return R[v] = w, w;
    };
    function F(T) {
      if (typeof T == "string") {
        var v = u._prime(T);
        this.m = v.p, this.prime = v;
      } else
        a(T.gtn(1), "modulus must be greater than 1"), this.m = T, this.prime = null;
    }
    F.prototype._verify1 = function(v) {
      a(v.negative === 0, "red works only with positives"), a(v.red, "red works only with red numbers");
    }, F.prototype._verify2 = function(v, w) {
      a((v.negative | w.negative) === 0, "red works only with positives"), a(
        v.red && v.red === w.red,
        "red works only with red numbers"
      );
    }, F.prototype.imod = function(v) {
      return this.prime ? this.prime.ireduce(v)._forceRed(this) : (d(v, v.umod(this.m)._forceRed(this)), v);
    }, F.prototype.neg = function(v) {
      return v.isZero() ? v.clone() : this.m.sub(v)._forceRed(this);
    }, F.prototype.add = function(v, w) {
      this._verify2(v, w);
      var O = v.add(w);
      return O.cmp(this.m) >= 0 && O.isub(this.m), O._forceRed(this);
    }, F.prototype.iadd = function(v, w) {
      this._verify2(v, w);
      var O = v.iadd(w);
      return O.cmp(this.m) >= 0 && O.isub(this.m), O;
    }, F.prototype.sub = function(v, w) {
      this._verify2(v, w);
      var O = v.sub(w);
      return O.cmpn(0) < 0 && O.iadd(this.m), O._forceRed(this);
    }, F.prototype.isub = function(v, w) {
      this._verify2(v, w);
      var O = v.isub(w);
      return O.cmpn(0) < 0 && O.iadd(this.m), O;
    }, F.prototype.shl = function(v, w) {
      return this._verify1(v), this.imod(v.ushln(w));
    }, F.prototype.imul = function(v, w) {
      return this._verify2(v, w), this.imod(v.imul(w));
    }, F.prototype.mul = function(v, w) {
      return this._verify2(v, w), this.imod(v.mul(w));
    }, F.prototype.isqr = function(v) {
      return this.imul(v, v.clone());
    }, F.prototype.sqr = function(v) {
      return this.mul(v, v);
    }, F.prototype.sqrt = function(v) {
      if (v.isZero())
        return v.clone();
      var w = this.m.andln(3);
      if (a(w % 2 === 1), w === 3) {
        var O = this.m.add(new u(1)).iushrn(2);
        return this.pow(v, O);
      }
      for (var G = this.m.subn(1), W = 0; !G.isZero() && G.andln(1) === 0; )
        W++, G.iushrn(1);
      a(!G.isZero());
      var U = new u(1).toRed(this), M = U.redNeg(), B = this.m.subn(1).iushrn(1), k = this.m.bitLength();
      for (k = new u(2 * k * k).toRed(this); this.pow(k, B).cmp(M) !== 0; )
        k.redIAdd(M);
      for (var K = this.pow(k, G), te = this.pow(v, G.addn(1).iushrn(1)), z = this.pow(v, G), q = W; z.cmp(U) !== 0; ) {
        for (var $ = z, Y = 0; $.cmp(U) !== 0; Y++)
          $ = $.redSqr();
        a(Y < q);
        var H = this.pow(K, new u(1).iushln(q - Y - 1));
        te = te.redMul(H), K = H.redSqr(), z = z.redMul(K), q = Y;
      }
      return te;
    }, F.prototype.invm = function(v) {
      var w = v._invmp(this.m);
      return w.negative !== 0 ? (w.negative = 0, this.imod(w).redNeg()) : this.imod(w);
    }, F.prototype.pow = function(v, w) {
      if (w.isZero())
        return new u(1).toRed(this);
      if (w.cmpn(1) === 0)
        return v.clone();
      var O = 4, G = new Array(1 << O);
      G[0] = new u(1).toRed(this), G[1] = v;
      for (var W = 2; W < G.length; W++)
        G[W] = this.mul(G[W - 1], v);
      var U = G[0], M = 0, B = 0, k = w.bitLength() % 26;
      for (k === 0 && (k = 26), W = w.length - 1; W >= 0; W--) {
        for (var K = w.words[W], te = k - 1; te >= 0; te--) {
          var z = K >> te & 1;
          if (U !== G[0] && (U = this.sqr(U)), z === 0 && M === 0) {
            B = 0;
            continue;
          }
          M <<= 1, M |= z, B++, !(B !== O && (W !== 0 || te !== 0)) && (U = this.mul(U, G[M]), B = 0, M = 0);
        }
        k = 26;
      }
      return U;
    }, F.prototype.convertTo = function(v) {
      var w = v.umod(this.m);
      return w === v ? w.clone() : w;
    }, F.prototype.convertFrom = function(v) {
      var w = v.clone();
      return w.red = null, w;
    }, u.mont = function(v) {
      return new _(v);
    };
    function _(T) {
      F.call(this, T), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new u(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    c(_, F), _.prototype.convertTo = function(v) {
      return this.imod(v.ushln(this.shift));
    }, _.prototype.convertFrom = function(v) {
      var w = this.imod(v.mul(this.rinv));
      return w.red = null, w;
    }, _.prototype.imul = function(v, w) {
      if (v.isZero() || w.isZero())
        return v.words[0] = 0, v.length = 1, v;
      var O = v.imul(w), G = O.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), W = O.isub(G).iushrn(this.shift), U = W;
      return W.cmp(this.m) >= 0 ? U = W.isub(this.m) : W.cmpn(0) < 0 && (U = W.iadd(this.m)), U._forceRed(this);
    }, _.prototype.mul = function(v, w) {
      if (v.isZero() || w.isZero())
        return new u(0)._forceRed(this);
      var O = v.mul(w), G = O.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), W = O.isub(G).iushrn(this.shift), U = W;
      return W.cmp(this.m) >= 0 ? U = W.isub(this.m) : W.cmpn(0) < 0 && (U = W.iadd(this.m)), U._forceRed(this);
    }, _.prototype.invm = function(v) {
      var w = this.imod(v._invmp(this.m).mul(this.r2));
      return w._forceRed(this);
    };
  })(t, Bt);
})(By);
var $y = By.exports, Io = $y, uj = nl;
function cj(t) {
  var e = GA(t), n = e.toRed(Io.mont(t.modulus)).redPow(new Io(t.publicExponent)).fromRed();
  return { blinder: n, unblinder: e.invm(t.modulus) };
}
function GA(t) {
  var e = t.modulus.byteLength(), n;
  do
    n = new Io(uj(e));
  while (n.cmp(t.modulus) >= 0 || !n.umod(t.prime1) || !n.umod(t.prime2));
  return n;
}
function zA(t, e) {
  var n = cj(e), a = e.modulus.byteLength(), c = new Io(t).mul(n.blinder).umod(e.modulus), u = c.toRed(Io.mont(e.prime1)), r = c.toRed(Io.mont(e.prime2)), l = e.coefficient, i = e.prime1, f = e.prime2, d = u.redPow(e.exponent1).fromRed(), s = r.redPow(e.exponent2).fromRed(), o = d.isub(s).imul(l).umod(i).imul(f);
  return s.iadd(o).imul(n.unblinder).umod(e.modulus).toArrayLike(Ve.Buffer, "be", a);
}
zA.getr = GA;
var Uy = zA, Qh = {};
const fj = "elliptic", dj = "6.5.4", pj = "EC cryptography", hj = "lib/elliptic.js", mj = [
  "lib"
], yj = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, bj = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, gj = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], vj = "Fedor Indutny <fedor@indutny.com>", Ej = "MIT", _j = {
  url: "https://github.com/indutny/elliptic/issues"
}, Sj = "https://github.com/indutny/elliptic", wj = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, Tj = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, Aj = {
  name: fj,
  version: dj,
  description: pj,
  main: hj,
  files: mj,
  scripts: yj,
  repository: bj,
  keywords: gj,
  author: vj,
  license: Ej,
  bugs: _j,
  homepage: Sj,
  devDependencies: wj,
  dependencies: Tj
};
var ti = {}, Vy = {};
(function(t) {
  var e = t;
  function n(u, r) {
    if (Array.isArray(u))
      return u.slice();
    if (!u)
      return [];
    var l = [];
    if (typeof u != "string") {
      for (var i = 0; i < u.length; i++)
        l[i] = u[i] | 0;
      return l;
    }
    if (r === "hex") {
      u = u.replace(/[^a-z0-9]+/ig, ""), u.length % 2 !== 0 && (u = "0" + u);
      for (var i = 0; i < u.length; i += 2)
        l.push(parseInt(u[i] + u[i + 1], 16));
    } else
      for (var i = 0; i < u.length; i++) {
        var f = u.charCodeAt(i), d = f >> 8, s = f & 255;
        d ? l.push(d, s) : l.push(s);
      }
    return l;
  }
  e.toArray = n;
  function a(u) {
    return u.length === 1 ? "0" + u : u;
  }
  e.zero2 = a;
  function c(u) {
    for (var r = "", l = 0; l < u.length; l++)
      r += a(u[l].toString(16));
    return r;
  }
  e.toHex = c, e.encode = function(r, l) {
    return l === "hex" ? c(r) : r;
  };
})(Vy);
(function(t) {
  var e = t, n = pn, a = wi, c = Vy;
  e.assert = a, e.toArray = c.toArray, e.zero2 = c.zero2, e.toHex = c.toHex, e.encode = c.encode;
  function u(d, s, o) {
    var m = new Array(Math.max(d.bitLength(), o) + 1);
    m.fill(0);
    for (var h = 1 << s + 1, y = d.clone(), b = 0; b < m.length; b++) {
      var E, S = y.andln(h - 1);
      y.isOdd() ? (S > (h >> 1) - 1 ? E = (h >> 1) - S : E = S, y.isubn(E)) : E = 0, m[b] = E, y.iushrn(1);
    }
    return m;
  }
  e.getNAF = u;
  function r(d, s) {
    var o = [
      [],
      []
    ];
    d = d.clone(), s = s.clone();
    for (var m = 0, h = 0, y; d.cmpn(-m) > 0 || s.cmpn(-h) > 0; ) {
      var b = d.andln(3) + m & 3, E = s.andln(3) + h & 3;
      b === 3 && (b = -1), E === 3 && (E = -1);
      var S;
      b & 1 ? (y = d.andln(7) + m & 7, (y === 3 || y === 5) && E === 2 ? S = -b : S = b) : S = 0, o[0].push(S);
      var g;
      E & 1 ? (y = s.andln(7) + h & 7, (y === 3 || y === 5) && b === 2 ? g = -E : g = E) : g = 0, o[1].push(g), 2 * m === S + 1 && (m = 1 - m), 2 * h === g + 1 && (h = 1 - h), d.iushrn(1), s.iushrn(1);
    }
    return o;
  }
  e.getJSF = r;
  function l(d, s, o) {
    var m = "_" + s;
    d.prototype[s] = function() {
      return this[m] !== void 0 ? this[m] : this[m] = o.call(this);
    };
  }
  e.cachedProperty = l;
  function i(d) {
    return typeof d == "string" ? e.toArray(d, "hex") : d;
  }
  e.parseBytes = i;
  function f(d) {
    return new n(d, "hex", "le");
  }
  e.intFromLE = f;
})(ti);
var Wy = {}, xa = pn, qu = ti, Ff = qu.getNAF, xj = qu.getJSF, Bf = qu.assert;
function ya(t, e) {
  this.type = t, this.p = new xa(e.p, 16), this.red = e.prime ? xa.red(e.prime) : xa.mont(this.p), this.zero = new xa(0).toRed(this.red), this.one = new xa(1).toRed(this.red), this.two = new xa(2).toRed(this.red), this.n = e.n && new xa(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var n = this.n && this.p.div(this.n);
  !n || n.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var Xd = ya;
ya.prototype.point = function() {
  throw new Error("Not implemented");
};
ya.prototype.validate = function() {
  throw new Error("Not implemented");
};
ya.prototype._fixedNafMul = function(e, n) {
  Bf(e.precomputed);
  var a = e._getDoubles(), c = Ff(n, 1, this._bitLength), u = (1 << a.step + 1) - (a.step % 2 === 0 ? 2 : 1);
  u /= 3;
  var r = [], l, i;
  for (l = 0; l < c.length; l += a.step) {
    i = 0;
    for (var f = l + a.step - 1; f >= l; f--)
      i = (i << 1) + c[f];
    r.push(i);
  }
  for (var d = this.jpoint(null, null, null), s = this.jpoint(null, null, null), o = u; o > 0; o--) {
    for (l = 0; l < r.length; l++)
      i = r[l], i === o ? s = s.mixedAdd(a.points[l]) : i === -o && (s = s.mixedAdd(a.points[l].neg()));
    d = d.add(s);
  }
  return d.toP();
};
ya.prototype._wnafMul = function(e, n) {
  var a = 4, c = e._getNAFPoints(a);
  a = c.wnd;
  for (var u = c.points, r = Ff(n, a, this._bitLength), l = this.jpoint(null, null, null), i = r.length - 1; i >= 0; i--) {
    for (var f = 0; i >= 0 && r[i] === 0; i--)
      f++;
    if (i >= 0 && f++, l = l.dblp(f), i < 0)
      break;
    var d = r[i];
    Bf(d !== 0), e.type === "affine" ? d > 0 ? l = l.mixedAdd(u[d - 1 >> 1]) : l = l.mixedAdd(u[-d - 1 >> 1].neg()) : d > 0 ? l = l.add(u[d - 1 >> 1]) : l = l.add(u[-d - 1 >> 1].neg());
  }
  return e.type === "affine" ? l.toP() : l;
};
ya.prototype._wnafMulAdd = function(e, n, a, c, u) {
  var r = this._wnafT1, l = this._wnafT2, i = this._wnafT3, f = 0, d, s, o;
  for (d = 0; d < c; d++) {
    o = n[d];
    var m = o._getNAFPoints(e);
    r[d] = m.wnd, l[d] = m.points;
  }
  for (d = c - 1; d >= 1; d -= 2) {
    var h = d - 1, y = d;
    if (r[h] !== 1 || r[y] !== 1) {
      i[h] = Ff(a[h], r[h], this._bitLength), i[y] = Ff(a[y], r[y], this._bitLength), f = Math.max(i[h].length, f), f = Math.max(i[y].length, f);
      continue;
    }
    var b = [
      n[h],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      n[y]
      /* 7 */
    ];
    n[h].y.cmp(n[y].y) === 0 ? (b[1] = n[h].add(n[y]), b[2] = n[h].toJ().mixedAdd(n[y].neg())) : n[h].y.cmp(n[y].y.redNeg()) === 0 ? (b[1] = n[h].toJ().mixedAdd(n[y]), b[2] = n[h].add(n[y].neg())) : (b[1] = n[h].toJ().mixedAdd(n[y]), b[2] = n[h].toJ().mixedAdd(n[y].neg()));
    var E = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], S = xj(a[h], a[y]);
    for (f = Math.max(S[0].length, f), i[h] = new Array(f), i[y] = new Array(f), s = 0; s < f; s++) {
      var g = S[0][s] | 0, P = S[1][s] | 0;
      i[h][s] = E[(g + 1) * 3 + (P + 1)], i[y][s] = 0, l[h] = b;
    }
  }
  var R = this.jpoint(null, null, null), N = this._wnafT4;
  for (d = f; d >= 0; d--) {
    for (var C = 0; d >= 0; ) {
      var I = !0;
      for (s = 0; s < c; s++)
        N[s] = i[s][d] | 0, N[s] !== 0 && (I = !1);
      if (!I)
        break;
      C++, d--;
    }
    if (d >= 0 && C++, R = R.dblp(C), d < 0)
      break;
    for (s = 0; s < c; s++) {
      var D = N[s];
      D !== 0 && (D > 0 ? o = l[s][D - 1 >> 1] : D < 0 && (o = l[s][-D - 1 >> 1].neg()), o.type === "affine" ? R = R.mixedAdd(o) : R = R.add(o));
    }
  }
  for (d = 0; d < c; d++)
    l[d] = null;
  return u ? R : R.toP();
};
function Ai(t, e) {
  this.curve = t, this.type = e, this.precomputed = null;
}
ya.BasePoint = Ai;
Ai.prototype.eq = function() {
  throw new Error("Not implemented");
};
Ai.prototype.validate = function() {
  return this.curve.validate(this);
};
ya.prototype.decodePoint = function(e, n) {
  e = qu.toArray(e, n);
  var a = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * a) {
    e[0] === 6 ? Bf(e[e.length - 1] % 2 === 0) : e[0] === 7 && Bf(e[e.length - 1] % 2 === 1);
    var c = this.point(
      e.slice(1, 1 + a),
      e.slice(1 + a, 1 + 2 * a)
    );
    return c;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === a)
    return this.pointFromX(e.slice(1, 1 + a), e[0] === 3);
  throw new Error("Unknown point format");
};
Ai.prototype.encodeCompressed = function(e) {
  return this.encode(e, !0);
};
Ai.prototype._encode = function(e) {
  var n = this.curve.p.byteLength(), a = this.getX().toArray("be", n);
  return e ? [this.getY().isEven() ? 2 : 3].concat(a) : [4].concat(a, this.getY().toArray("be", n));
};
Ai.prototype.encode = function(e, n) {
  return qu.encode(this._encode(n), e);
};
Ai.prototype.precompute = function(e) {
  if (this.precomputed)
    return this;
  var n = {
    doubles: null,
    naf: null,
    beta: null
  };
  return n.naf = this._getNAFPoints(8), n.doubles = this._getDoubles(4, e), n.beta = this._getBeta(), this.precomputed = n, this;
};
Ai.prototype._hasDoubles = function(e) {
  if (!this.precomputed)
    return !1;
  var n = this.precomputed.doubles;
  return n ? n.points.length >= Math.ceil((e.bitLength() + 1) / n.step) : !1;
};
Ai.prototype._getDoubles = function(e, n) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var a = [this], c = this, u = 0; u < n; u += e) {
    for (var r = 0; r < e; r++)
      c = c.dbl();
    a.push(c);
  }
  return {
    step: e,
    points: a
  };
};
Ai.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var n = [this], a = (1 << e) - 1, c = a === 1 ? null : this.dbl(), u = 1; u < a; u++)
    n[u] = n[u - 1].add(c);
  return {
    wnd: e,
    points: n
  };
};
Ai.prototype._getBeta = function() {
  return null;
};
Ai.prototype.dblp = function(e) {
  for (var n = this, a = 0; a < e; a++)
    n = n.dbl();
  return n;
};
var Pj = ti, Fr = pn, Hy = Zt, al = Xd, Cj = Pj.assert;
function xi(t) {
  al.call(this, "short", t), this.a = new Fr(t.a, 16).toRed(this.red), this.b = new Fr(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
Hy(xi, al);
var Ij = xi;
xi.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var n, a;
    if (e.beta)
      n = new Fr(e.beta, 16).toRed(this.red);
    else {
      var c = this._getEndoRoots(this.p);
      n = c[0].cmp(c[1]) < 0 ? c[0] : c[1], n = n.toRed(this.red);
    }
    if (e.lambda)
      a = new Fr(e.lambda, 16);
    else {
      var u = this._getEndoRoots(this.n);
      this.g.mul(u[0]).x.cmp(this.g.x.redMul(n)) === 0 ? a = u[0] : (a = u[1], Cj(this.g.mul(a).x.cmp(this.g.x.redMul(n)) === 0));
    }
    var r;
    return e.basis ? r = e.basis.map(function(l) {
      return {
        a: new Fr(l.a, 16),
        b: new Fr(l.b, 16)
      };
    }) : r = this._getEndoBasis(a), {
      beta: n,
      lambda: a,
      basis: r
    };
  }
};
xi.prototype._getEndoRoots = function(e) {
  var n = e === this.p ? this.red : Fr.mont(e), a = new Fr(2).toRed(n).redInvm(), c = a.redNeg(), u = new Fr(3).toRed(n).redNeg().redSqrt().redMul(a), r = c.redAdd(u).fromRed(), l = c.redSub(u).fromRed();
  return [r, l];
};
xi.prototype._getEndoBasis = function(e) {
  for (var n = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), a = e, c = this.n.clone(), u = new Fr(1), r = new Fr(0), l = new Fr(0), i = new Fr(1), f, d, s, o, m, h, y, b = 0, E, S; a.cmpn(0) !== 0; ) {
    var g = c.div(a);
    E = c.sub(g.mul(a)), S = l.sub(g.mul(u));
    var P = i.sub(g.mul(r));
    if (!s && E.cmp(n) < 0)
      f = y.neg(), d = u, s = E.neg(), o = S;
    else if (s && ++b === 2)
      break;
    y = E, c = a, a = E, l = u, u = S, i = r, r = P;
  }
  m = E.neg(), h = S;
  var R = s.sqr().add(o.sqr()), N = m.sqr().add(h.sqr());
  return N.cmp(R) >= 0 && (m = f, h = d), s.negative && (s = s.neg(), o = o.neg()), m.negative && (m = m.neg(), h = h.neg()), [
    { a: s, b: o },
    { a: m, b: h }
  ];
};
xi.prototype._endoSplit = function(e) {
  var n = this.endo.basis, a = n[0], c = n[1], u = c.b.mul(e).divRound(this.n), r = a.b.neg().mul(e).divRound(this.n), l = u.mul(a.a), i = r.mul(c.a), f = u.mul(a.b), d = r.mul(c.b), s = e.sub(l).sub(i), o = f.add(d).neg();
  return { k1: s, k2: o };
};
xi.prototype.pointFromX = function(e, n) {
  e = new Fr(e, 16), e.red || (e = e.toRed(this.red));
  var a = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), c = a.redSqrt();
  if (c.redSqr().redSub(a).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var u = c.fromRed().isOdd();
  return (n && !u || !n && u) && (c = c.redNeg()), this.point(e, c);
};
xi.prototype.validate = function(e) {
  if (e.inf)
    return !0;
  var n = e.x, a = e.y, c = this.a.redMul(n), u = n.redSqr().redMul(n).redIAdd(c).redIAdd(this.b);
  return a.redSqr().redISub(u).cmpn(0) === 0;
};
xi.prototype._endoWnafMulAdd = function(e, n, a) {
  for (var c = this._endoWnafT1, u = this._endoWnafT2, r = 0; r < e.length; r++) {
    var l = this._endoSplit(n[r]), i = e[r], f = i._getBeta();
    l.k1.negative && (l.k1.ineg(), i = i.neg(!0)), l.k2.negative && (l.k2.ineg(), f = f.neg(!0)), c[r * 2] = i, c[r * 2 + 1] = f, u[r * 2] = l.k1, u[r * 2 + 1] = l.k2;
  }
  for (var d = this._wnafMulAdd(1, c, u, r * 2, a), s = 0; s < r * 2; s++)
    c[s] = null, u[s] = null;
  return d;
};
function hn(t, e, n, a) {
  al.BasePoint.call(this, t, "affine"), e === null && n === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new Fr(e, 16), this.y = new Fr(n, 16), a && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
Hy(hn, al.BasePoint);
xi.prototype.point = function(e, n, a) {
  return new hn(this, e, n, a);
};
xi.prototype.pointFromJSON = function(e, n) {
  return hn.fromJSON(this, e, n);
};
hn.prototype._getBeta = function() {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var n = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var a = this.curve, c = function(u) {
        return a.point(u.x.redMul(a.endo.beta), u.y);
      };
      e.beta = n, n.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(c)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(c)
        }
      };
    }
    return n;
  }
};
hn.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
hn.fromJSON = function(e, n, a) {
  typeof n == "string" && (n = JSON.parse(n));
  var c = e.point(n[0], n[1], a);
  if (!n[2])
    return c;
  function u(l) {
    return e.point(l[0], l[1], a);
  }
  var r = n[2];
  return c.precomputed = {
    beta: null,
    doubles: r.doubles && {
      step: r.doubles.step,
      points: [c].concat(r.doubles.points.map(u))
    },
    naf: r.naf && {
      wnd: r.naf.wnd,
      points: [c].concat(r.naf.points.map(u))
    }
  }, c;
};
hn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
hn.prototype.isInfinity = function() {
  return this.inf;
};
hn.prototype.add = function(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var n = this.y.redSub(e.y);
  n.cmpn(0) !== 0 && (n = n.redMul(this.x.redSub(e.x).redInvm()));
  var a = n.redSqr().redISub(this.x).redISub(e.x), c = n.redMul(this.x.redSub(a)).redISub(this.y);
  return this.curve.point(a, c);
};
hn.prototype.dbl = function() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var n = this.curve.a, a = this.x.redSqr(), c = e.redInvm(), u = a.redAdd(a).redIAdd(a).redIAdd(n).redMul(c), r = u.redSqr().redISub(this.x.redAdd(this.x)), l = u.redMul(this.x.redSub(r)).redISub(this.y);
  return this.curve.point(r, l);
};
hn.prototype.getX = function() {
  return this.x.fromRed();
};
hn.prototype.getY = function() {
  return this.y.fromRed();
};
hn.prototype.mul = function(e) {
  return e = new Fr(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
hn.prototype.mulAdd = function(e, n, a) {
  var c = [this, n], u = [e, a];
  return this.curve.endo ? this.curve._endoWnafMulAdd(c, u) : this.curve._wnafMulAdd(1, c, u, 2);
};
hn.prototype.jmulAdd = function(e, n, a) {
  var c = [this, n], u = [e, a];
  return this.curve.endo ? this.curve._endoWnafMulAdd(c, u, !0) : this.curve._wnafMulAdd(1, c, u, 2, !0);
};
hn.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
hn.prototype.neg = function(e) {
  if (this.inf)
    return this;
  var n = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var a = this.precomputed, c = function(u) {
      return u.neg();
    };
    n.precomputed = {
      naf: a.naf && {
        wnd: a.naf.wnd,
        points: a.naf.points.map(c)
      },
      doubles: a.doubles && {
        step: a.doubles.step,
        points: a.doubles.points.map(c)
      }
    };
  }
  return n;
};
hn.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function vn(t, e, n, a) {
  al.BasePoint.call(this, t, "jacobian"), e === null && n === null && a === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new Fr(0)) : (this.x = new Fr(e, 16), this.y = new Fr(n, 16), this.z = new Fr(a, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
Hy(vn, al.BasePoint);
xi.prototype.jpoint = function(e, n, a) {
  return new vn(this, e, n, a);
};
vn.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), n = e.redSqr(), a = this.x.redMul(n), c = this.y.redMul(n).redMul(e);
  return this.curve.point(a, c);
};
vn.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
vn.prototype.add = function(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var n = e.z.redSqr(), a = this.z.redSqr(), c = this.x.redMul(n), u = e.x.redMul(a), r = this.y.redMul(n.redMul(e.z)), l = e.y.redMul(a.redMul(this.z)), i = c.redSub(u), f = r.redSub(l);
  if (i.cmpn(0) === 0)
    return f.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var d = i.redSqr(), s = d.redMul(i), o = c.redMul(d), m = f.redSqr().redIAdd(s).redISub(o).redISub(o), h = f.redMul(o.redISub(m)).redISub(r.redMul(s)), y = this.z.redMul(e.z).redMul(i);
  return this.curve.jpoint(m, h, y);
};
vn.prototype.mixedAdd = function(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var n = this.z.redSqr(), a = this.x, c = e.x.redMul(n), u = this.y, r = e.y.redMul(n).redMul(this.z), l = a.redSub(c), i = u.redSub(r);
  if (l.cmpn(0) === 0)
    return i.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var f = l.redSqr(), d = f.redMul(l), s = a.redMul(f), o = i.redSqr().redIAdd(d).redISub(s).redISub(s), m = i.redMul(s.redISub(o)).redISub(u.redMul(d)), h = this.z.redMul(l);
  return this.curve.jpoint(o, m, h);
};
vn.prototype.dblp = function(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var n;
  if (this.curve.zeroA || this.curve.threeA) {
    var a = this;
    for (n = 0; n < e; n++)
      a = a.dbl();
    return a;
  }
  var c = this.curve.a, u = this.curve.tinv, r = this.x, l = this.y, i = this.z, f = i.redSqr().redSqr(), d = l.redAdd(l);
  for (n = 0; n < e; n++) {
    var s = r.redSqr(), o = d.redSqr(), m = o.redSqr(), h = s.redAdd(s).redIAdd(s).redIAdd(c.redMul(f)), y = r.redMul(o), b = h.redSqr().redISub(y.redAdd(y)), E = y.redISub(b), S = h.redMul(E);
    S = S.redIAdd(S).redISub(m);
    var g = d.redMul(i);
    n + 1 < e && (f = f.redMul(m)), r = b, i = g, d = S;
  }
  return this.curve.jpoint(r, d.redMul(u), i);
};
vn.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
vn.prototype._zeroDbl = function() {
  var e, n, a;
  if (this.zOne) {
    var c = this.x.redSqr(), u = this.y.redSqr(), r = u.redSqr(), l = this.x.redAdd(u).redSqr().redISub(c).redISub(r);
    l = l.redIAdd(l);
    var i = c.redAdd(c).redIAdd(c), f = i.redSqr().redISub(l).redISub(l), d = r.redIAdd(r);
    d = d.redIAdd(d), d = d.redIAdd(d), e = f, n = i.redMul(l.redISub(f)).redISub(d), a = this.y.redAdd(this.y);
  } else {
    var s = this.x.redSqr(), o = this.y.redSqr(), m = o.redSqr(), h = this.x.redAdd(o).redSqr().redISub(s).redISub(m);
    h = h.redIAdd(h);
    var y = s.redAdd(s).redIAdd(s), b = y.redSqr(), E = m.redIAdd(m);
    E = E.redIAdd(E), E = E.redIAdd(E), e = b.redISub(h).redISub(h), n = y.redMul(h.redISub(e)).redISub(E), a = this.y.redMul(this.z), a = a.redIAdd(a);
  }
  return this.curve.jpoint(e, n, a);
};
vn.prototype._threeDbl = function() {
  var e, n, a;
  if (this.zOne) {
    var c = this.x.redSqr(), u = this.y.redSqr(), r = u.redSqr(), l = this.x.redAdd(u).redSqr().redISub(c).redISub(r);
    l = l.redIAdd(l);
    var i = c.redAdd(c).redIAdd(c).redIAdd(this.curve.a), f = i.redSqr().redISub(l).redISub(l);
    e = f;
    var d = r.redIAdd(r);
    d = d.redIAdd(d), d = d.redIAdd(d), n = i.redMul(l.redISub(f)).redISub(d), a = this.y.redAdd(this.y);
  } else {
    var s = this.z.redSqr(), o = this.y.redSqr(), m = this.x.redMul(o), h = this.x.redSub(s).redMul(this.x.redAdd(s));
    h = h.redAdd(h).redIAdd(h);
    var y = m.redIAdd(m);
    y = y.redIAdd(y);
    var b = y.redAdd(y);
    e = h.redSqr().redISub(b), a = this.y.redAdd(this.z).redSqr().redISub(o).redISub(s);
    var E = o.redSqr();
    E = E.redIAdd(E), E = E.redIAdd(E), E = E.redIAdd(E), n = h.redMul(y.redISub(e)).redISub(E);
  }
  return this.curve.jpoint(e, n, a);
};
vn.prototype._dbl = function() {
  var e = this.curve.a, n = this.x, a = this.y, c = this.z, u = c.redSqr().redSqr(), r = n.redSqr(), l = a.redSqr(), i = r.redAdd(r).redIAdd(r).redIAdd(e.redMul(u)), f = n.redAdd(n);
  f = f.redIAdd(f);
  var d = f.redMul(l), s = i.redSqr().redISub(d.redAdd(d)), o = d.redISub(s), m = l.redSqr();
  m = m.redIAdd(m), m = m.redIAdd(m), m = m.redIAdd(m);
  var h = i.redMul(o).redISub(m), y = a.redAdd(a).redMul(c);
  return this.curve.jpoint(s, h, y);
};
vn.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), n = this.y.redSqr(), a = this.z.redSqr(), c = n.redSqr(), u = e.redAdd(e).redIAdd(e), r = u.redSqr(), l = this.x.redAdd(n).redSqr().redISub(e).redISub(c);
  l = l.redIAdd(l), l = l.redAdd(l).redIAdd(l), l = l.redISub(r);
  var i = l.redSqr(), f = c.redIAdd(c);
  f = f.redIAdd(f), f = f.redIAdd(f), f = f.redIAdd(f);
  var d = u.redIAdd(l).redSqr().redISub(r).redISub(i).redISub(f), s = n.redMul(d);
  s = s.redIAdd(s), s = s.redIAdd(s);
  var o = this.x.redMul(i).redISub(s);
  o = o.redIAdd(o), o = o.redIAdd(o);
  var m = this.y.redMul(d.redMul(f.redISub(d)).redISub(l.redMul(i)));
  m = m.redIAdd(m), m = m.redIAdd(m), m = m.redIAdd(m);
  var h = this.z.redAdd(l).redSqr().redISub(a).redISub(i);
  return this.curve.jpoint(o, m, h);
};
vn.prototype.mul = function(e, n) {
  return e = new Fr(e, n), this.curve._wnafMul(this, e);
};
vn.prototype.eq = function(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var n = this.z.redSqr(), a = e.z.redSqr();
  if (this.x.redMul(a).redISub(e.x.redMul(n)).cmpn(0) !== 0)
    return !1;
  var c = n.redMul(this.z), u = a.redMul(e.z);
  return this.y.redMul(u).redISub(e.y.redMul(c)).cmpn(0) === 0;
};
vn.prototype.eqXToP = function(e) {
  var n = this.z.redSqr(), a = e.toRed(this.curve.red).redMul(n);
  if (this.x.cmp(a) === 0)
    return !0;
  for (var c = e.clone(), u = this.curve.redN.redMul(n); ; ) {
    if (c.iadd(this.curve.n), c.cmp(this.curve.p) >= 0)
      return !1;
    if (a.redIAdd(u), this.x.cmp(a) === 0)
      return !0;
  }
};
vn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
vn.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var _o = pn, KA = Zt, Jd = Xd, Oj = ti;
function ol(t) {
  Jd.call(this, "mont", t), this.a = new _o(t.a, 16).toRed(this.red), this.b = new _o(t.b, 16).toRed(this.red), this.i4 = new _o(4).toRed(this.red).redInvm(), this.two = new _o(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
KA(ol, Jd);
var kj = ol;
ol.prototype.validate = function(e) {
  var n = e.normalize().x, a = n.redSqr(), c = a.redMul(n).redAdd(a.redMul(this.a)).redAdd(n), u = c.redSqrt();
  return u.redSqr().cmp(c) === 0;
};
function cn(t, e, n) {
  Jd.BasePoint.call(this, t, "projective"), e === null && n === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new _o(e, 16), this.z = new _o(n, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
KA(cn, Jd.BasePoint);
ol.prototype.decodePoint = function(e, n) {
  return this.point(Oj.toArray(e, n), 1);
};
ol.prototype.point = function(e, n) {
  return new cn(this, e, n);
};
ol.prototype.pointFromJSON = function(e) {
  return cn.fromJSON(this, e);
};
cn.prototype.precompute = function() {
};
cn.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
cn.fromJSON = function(e, n) {
  return new cn(e, n[0], n[1] || e.one);
};
cn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
cn.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
cn.prototype.dbl = function() {
  var e = this.x.redAdd(this.z), n = e.redSqr(), a = this.x.redSub(this.z), c = a.redSqr(), u = n.redSub(c), r = n.redMul(c), l = u.redMul(c.redAdd(this.curve.a24.redMul(u)));
  return this.curve.point(r, l);
};
cn.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
cn.prototype.diffAdd = function(e, n) {
  var a = this.x.redAdd(this.z), c = this.x.redSub(this.z), u = e.x.redAdd(e.z), r = e.x.redSub(e.z), l = r.redMul(a), i = u.redMul(c), f = n.z.redMul(l.redAdd(i).redSqr()), d = n.x.redMul(l.redISub(i).redSqr());
  return this.curve.point(f, d);
};
cn.prototype.mul = function(e) {
  for (var n = e.clone(), a = this, c = this.curve.point(null, null), u = this, r = []; n.cmpn(0) !== 0; n.iushrn(1))
    r.push(n.andln(1));
  for (var l = r.length - 1; l >= 0; l--)
    r[l] === 0 ? (a = a.diffAdd(c, u), c = c.dbl()) : (c = a.diffAdd(c, u), a = a.dbl());
  return c;
};
cn.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
cn.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
cn.prototype.eq = function(e) {
  return this.getX().cmp(e.getX()) === 0;
};
cn.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
cn.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var Dj = ti, Rs = pn, YA = Zt, Qd = Xd, Nj = Dj.assert;
function Ss(t) {
  this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, Qd.call(this, "edwards", t), this.a = new Rs(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new Rs(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new Rs(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), Nj(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
}
YA(Ss, Qd);
var Rj = Ss;
Ss.prototype._mulA = function(e) {
  return this.mOneA ? e.redNeg() : this.a.redMul(e);
};
Ss.prototype._mulC = function(e) {
  return this.oneC ? e : this.c.redMul(e);
};
Ss.prototype.jpoint = function(e, n, a, c) {
  return this.point(e, n, a, c);
};
Ss.prototype.pointFromX = function(e, n) {
  e = new Rs(e, 16), e.red || (e = e.toRed(this.red));
  var a = e.redSqr(), c = this.c2.redSub(this.a.redMul(a)), u = this.one.redSub(this.c2.redMul(this.d).redMul(a)), r = c.redMul(u.redInvm()), l = r.redSqrt();
  if (l.redSqr().redSub(r).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var i = l.fromRed().isOdd();
  return (n && !i || !n && i) && (l = l.redNeg()), this.point(e, l);
};
Ss.prototype.pointFromY = function(e, n) {
  e = new Rs(e, 16), e.red || (e = e.toRed(this.red));
  var a = e.redSqr(), c = a.redSub(this.c2), u = a.redMul(this.d).redMul(this.c2).redSub(this.a), r = c.redMul(u.redInvm());
  if (r.cmp(this.zero) === 0) {
    if (n)
      throw new Error("invalid point");
    return this.point(this.zero, e);
  }
  var l = r.redSqrt();
  if (l.redSqr().redSub(r).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return l.fromRed().isOdd() !== n && (l = l.redNeg()), this.point(l, e);
};
Ss.prototype.validate = function(e) {
  if (e.isInfinity())
    return !0;
  e.normalize();
  var n = e.x.redSqr(), a = e.y.redSqr(), c = n.redMul(this.a).redAdd(a), u = this.c2.redMul(this.one.redAdd(this.d.redMul(n).redMul(a)));
  return c.cmp(u) === 0;
};
function wr(t, e, n, a, c) {
  Qd.BasePoint.call(this, t, "projective"), e === null && n === null && a === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new Rs(e, 16), this.y = new Rs(n, 16), this.z = a ? new Rs(a, 16) : this.curve.one, this.t = c && new Rs(c, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
YA(wr, Qd.BasePoint);
Ss.prototype.pointFromJSON = function(e) {
  return wr.fromJSON(this, e);
};
Ss.prototype.point = function(e, n, a, c) {
  return new wr(this, e, n, a, c);
};
wr.fromJSON = function(e, n) {
  return new wr(e, n[0], n[1], n[2]);
};
wr.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
wr.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
wr.prototype._extDbl = function() {
  var e = this.x.redSqr(), n = this.y.redSqr(), a = this.z.redSqr();
  a = a.redIAdd(a);
  var c = this.curve._mulA(e), u = this.x.redAdd(this.y).redSqr().redISub(e).redISub(n), r = c.redAdd(n), l = r.redSub(a), i = c.redSub(n), f = u.redMul(l), d = r.redMul(i), s = u.redMul(i), o = l.redMul(r);
  return this.curve.point(f, d, o, s);
};
wr.prototype._projDbl = function() {
  var e = this.x.redAdd(this.y).redSqr(), n = this.x.redSqr(), a = this.y.redSqr(), c, u, r, l, i, f;
  if (this.curve.twisted) {
    l = this.curve._mulA(n);
    var d = l.redAdd(a);
    this.zOne ? (c = e.redSub(n).redSub(a).redMul(d.redSub(this.curve.two)), u = d.redMul(l.redSub(a)), r = d.redSqr().redSub(d).redSub(d)) : (i = this.z.redSqr(), f = d.redSub(i).redISub(i), c = e.redSub(n).redISub(a).redMul(f), u = d.redMul(l.redSub(a)), r = d.redMul(f));
  } else
    l = n.redAdd(a), i = this.curve._mulC(this.z).redSqr(), f = l.redSub(i).redSub(i), c = this.curve._mulC(e.redISub(l)).redMul(f), u = this.curve._mulC(l).redMul(n.redISub(a)), r = l.redMul(f);
  return this.curve.point(c, u, r);
};
wr.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
wr.prototype._extAdd = function(e) {
  var n = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), a = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), c = this.t.redMul(this.curve.dd).redMul(e.t), u = this.z.redMul(e.z.redAdd(e.z)), r = a.redSub(n), l = u.redSub(c), i = u.redAdd(c), f = a.redAdd(n), d = r.redMul(l), s = i.redMul(f), o = r.redMul(f), m = l.redMul(i);
  return this.curve.point(d, s, m, o);
};
wr.prototype._projAdd = function(e) {
  var n = this.z.redMul(e.z), a = n.redSqr(), c = this.x.redMul(e.x), u = this.y.redMul(e.y), r = this.curve.d.redMul(c).redMul(u), l = a.redSub(r), i = a.redAdd(r), f = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(c).redISub(u), d = n.redMul(l).redMul(f), s, o;
  return this.curve.twisted ? (s = n.redMul(i).redMul(u.redSub(this.curve._mulA(c))), o = l.redMul(i)) : (s = n.redMul(i).redMul(u.redSub(c)), o = this.curve._mulC(l).redMul(i)), this.curve.point(d, s, o);
};
wr.prototype.add = function(e) {
  return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
};
wr.prototype.mul = function(e) {
  return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
};
wr.prototype.mulAdd = function(e, n, a) {
  return this.curve._wnafMulAdd(1, [this, n], [e, a], 2, !1);
};
wr.prototype.jmulAdd = function(e, n, a) {
  return this.curve._wnafMulAdd(1, [this, n], [e, a], 2, !0);
};
wr.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var e = this.z.redInvm();
  return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this;
};
wr.prototype.neg = function() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
wr.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
wr.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
wr.prototype.eq = function(e) {
  return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
};
wr.prototype.eqXToP = function(e) {
  var n = e.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(n) === 0)
    return !0;
  for (var a = e.clone(), c = this.curve.redN.redMul(this.z); ; ) {
    if (a.iadd(this.curve.n), a.cmp(this.curve.p) >= 0)
      return !1;
    if (n.redIAdd(c), this.x.cmp(n) === 0)
      return !0;
  }
};
wr.prototype.toP = wr.prototype.normalize;
wr.prototype.mixedAdd = wr.prototype.add;
(function(t) {
  var e = t;
  e.base = Xd, e.short = Ij, e.mont = kj, e.edwards = Rj;
})(Wy);
var Zd = {}, ep = {}, sr = {}, Mj = wi, Lj = Zt;
sr.inherits = Lj;
function jj(t, e) {
  return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? !1 : (t.charCodeAt(e + 1) & 64512) === 56320;
}
function Fj(t, e) {
  if (Array.isArray(t))
    return t.slice();
  if (!t)
    return [];
  var n = [];
  if (typeof t == "string")
    if (e) {
      if (e === "hex")
        for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), c = 0; c < t.length; c += 2)
          n.push(parseInt(t[c] + t[c + 1], 16));
    } else
      for (var a = 0, c = 0; c < t.length; c++) {
        var u = t.charCodeAt(c);
        u < 128 ? n[a++] = u : u < 2048 ? (n[a++] = u >> 6 | 192, n[a++] = u & 63 | 128) : jj(t, c) ? (u = 65536 + ((u & 1023) << 10) + (t.charCodeAt(++c) & 1023), n[a++] = u >> 18 | 240, n[a++] = u >> 12 & 63 | 128, n[a++] = u >> 6 & 63 | 128, n[a++] = u & 63 | 128) : (n[a++] = u >> 12 | 224, n[a++] = u >> 6 & 63 | 128, n[a++] = u & 63 | 128);
      }
  else
    for (c = 0; c < t.length; c++)
      n[c] = t[c] | 0;
  return n;
}
sr.toArray = Fj;
function Bj(t) {
  for (var e = "", n = 0; n < t.length; n++)
    e += JA(t[n].toString(16));
  return e;
}
sr.toHex = Bj;
function XA(t) {
  var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
  return e >>> 0;
}
sr.htonl = XA;
function $j(t, e) {
  for (var n = "", a = 0; a < t.length; a++) {
    var c = t[a];
    e === "little" && (c = XA(c)), n += QA(c.toString(16));
  }
  return n;
}
sr.toHex32 = $j;
function JA(t) {
  return t.length === 1 ? "0" + t : t;
}
sr.zero2 = JA;
function QA(t) {
  return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
}
sr.zero8 = QA;
function Uj(t, e, n, a) {
  var c = n - e;
  Mj(c % 4 === 0);
  for (var u = new Array(c / 4), r = 0, l = e; r < u.length; r++, l += 4) {
    var i;
    a === "big" ? i = t[l] << 24 | t[l + 1] << 16 | t[l + 2] << 8 | t[l + 3] : i = t[l + 3] << 24 | t[l + 2] << 16 | t[l + 1] << 8 | t[l], u[r] = i >>> 0;
  }
  return u;
}
sr.join32 = Uj;
function Vj(t, e) {
  for (var n = new Array(t.length * 4), a = 0, c = 0; a < t.length; a++, c += 4) {
    var u = t[a];
    e === "big" ? (n[c] = u >>> 24, n[c + 1] = u >>> 16 & 255, n[c + 2] = u >>> 8 & 255, n[c + 3] = u & 255) : (n[c + 3] = u >>> 24, n[c + 2] = u >>> 16 & 255, n[c + 1] = u >>> 8 & 255, n[c] = u & 255);
  }
  return n;
}
sr.split32 = Vj;
function Wj(t, e) {
  return t >>> e | t << 32 - e;
}
sr.rotr32 = Wj;
function Hj(t, e) {
  return t << e | t >>> 32 - e;
}
sr.rotl32 = Hj;
function qj(t, e) {
  return t + e >>> 0;
}
sr.sum32 = qj;
function Gj(t, e, n) {
  return t + e + n >>> 0;
}
sr.sum32_3 = Gj;
function zj(t, e, n, a) {
  return t + e + n + a >>> 0;
}
sr.sum32_4 = zj;
function Kj(t, e, n, a, c) {
  return t + e + n + a + c >>> 0;
}
sr.sum32_5 = Kj;
function Yj(t, e, n, a) {
  var c = t[e], u = t[e + 1], r = a + u >>> 0, l = (r < a ? 1 : 0) + n + c;
  t[e] = l >>> 0, t[e + 1] = r;
}
sr.sum64 = Yj;
function Xj(t, e, n, a) {
  var c = e + a >>> 0, u = (c < e ? 1 : 0) + t + n;
  return u >>> 0;
}
sr.sum64_hi = Xj;
function Jj(t, e, n, a) {
  var c = e + a;
  return c >>> 0;
}
sr.sum64_lo = Jj;
function Qj(t, e, n, a, c, u, r, l) {
  var i = 0, f = e;
  f = f + a >>> 0, i += f < e ? 1 : 0, f = f + u >>> 0, i += f < u ? 1 : 0, f = f + l >>> 0, i += f < l ? 1 : 0;
  var d = t + n + c + r + i;
  return d >>> 0;
}
sr.sum64_4_hi = Qj;
function Zj(t, e, n, a, c, u, r, l) {
  var i = e + a + u + l;
  return i >>> 0;
}
sr.sum64_4_lo = Zj;
function eF(t, e, n, a, c, u, r, l, i, f) {
  var d = 0, s = e;
  s = s + a >>> 0, d += s < e ? 1 : 0, s = s + u >>> 0, d += s < u ? 1 : 0, s = s + l >>> 0, d += s < l ? 1 : 0, s = s + f >>> 0, d += s < f ? 1 : 0;
  var o = t + n + c + r + i + d;
  return o >>> 0;
}
sr.sum64_5_hi = eF;
function tF(t, e, n, a, c, u, r, l, i, f) {
  var d = e + a + u + l + f;
  return d >>> 0;
}
sr.sum64_5_lo = tF;
function rF(t, e, n) {
  var a = e << 32 - n | t >>> n;
  return a >>> 0;
}
sr.rotr64_hi = rF;
function nF(t, e, n) {
  var a = t << 32 - n | e >>> n;
  return a >>> 0;
}
sr.rotr64_lo = nF;
function iF(t, e, n) {
  return t >>> n;
}
sr.shr64_hi = iF;
function sF(t, e, n) {
  var a = t << 32 - n | e >>> n;
  return a >>> 0;
}
sr.shr64_lo = sF;
var ll = {}, GE = sr, aF = wi;
function tp() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
ll.BlockHash = tp;
tp.prototype.update = function(e, n) {
  if (e = GE.toArray(e, n), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
    e = this.pending;
    var a = e.length % this._delta8;
    this.pending = e.slice(e.length - a, e.length), this.pending.length === 0 && (this.pending = null), e = GE.join32(e, 0, e.length - a, this.endian);
    for (var c = 0; c < e.length; c += this._delta32)
      this._update(e, c, c + this._delta32);
  }
  return this;
};
tp.prototype.digest = function(e) {
  return this.update(this._pad()), aF(this.pending === null), this._digest(e);
};
tp.prototype._pad = function() {
  var e = this.pendingTotal, n = this._delta8, a = n - (e + this.padLength) % n, c = new Array(a + this.padLength);
  c[0] = 128;
  for (var u = 1; u < a; u++)
    c[u] = 0;
  if (e <<= 3, this.endian === "big") {
    for (var r = 8; r < this.padLength; r++)
      c[u++] = 0;
    c[u++] = 0, c[u++] = 0, c[u++] = 0, c[u++] = 0, c[u++] = e >>> 24 & 255, c[u++] = e >>> 16 & 255, c[u++] = e >>> 8 & 255, c[u++] = e & 255;
  } else
    for (c[u++] = e & 255, c[u++] = e >>> 8 & 255, c[u++] = e >>> 16 & 255, c[u++] = e >>> 24 & 255, c[u++] = 0, c[u++] = 0, c[u++] = 0, c[u++] = 0, r = 8; r < this.padLength; r++)
      c[u++] = 0;
  return c;
};
var ul = {}, ws = {}, oF = sr, as = oF.rotr32;
function lF(t, e, n, a) {
  if (t === 0)
    return ZA(e, n, a);
  if (t === 1 || t === 3)
    return tx(e, n, a);
  if (t === 2)
    return ex(e, n, a);
}
ws.ft_1 = lF;
function ZA(t, e, n) {
  return t & e ^ ~t & n;
}
ws.ch32 = ZA;
function ex(t, e, n) {
  return t & e ^ t & n ^ e & n;
}
ws.maj32 = ex;
function tx(t, e, n) {
  return t ^ e ^ n;
}
ws.p32 = tx;
function uF(t) {
  return as(t, 2) ^ as(t, 13) ^ as(t, 22);
}
ws.s0_256 = uF;
function cF(t) {
  return as(t, 6) ^ as(t, 11) ^ as(t, 25);
}
ws.s1_256 = cF;
function fF(t) {
  return as(t, 7) ^ as(t, 18) ^ t >>> 3;
}
ws.g0_256 = fF;
function dF(t) {
  return as(t, 17) ^ as(t, 19) ^ t >>> 10;
}
ws.g1_256 = dF;
var Uo = sr, pF = ll, hF = ws, Zh = Uo.rotl32, Rl = Uo.sum32, mF = Uo.sum32_5, yF = hF.ft_1, rx = pF.BlockHash, bF = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function ms() {
  if (!(this instanceof ms))
    return new ms();
  rx.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
Uo.inherits(ms, rx);
var gF = ms;
ms.blockSize = 512;
ms.outSize = 160;
ms.hmacStrength = 80;
ms.padLength = 64;
ms.prototype._update = function(e, n) {
  for (var a = this.W, c = 0; c < 16; c++)
    a[c] = e[n + c];
  for (; c < a.length; c++)
    a[c] = Zh(a[c - 3] ^ a[c - 8] ^ a[c - 14] ^ a[c - 16], 1);
  var u = this.h[0], r = this.h[1], l = this.h[2], i = this.h[3], f = this.h[4];
  for (c = 0; c < a.length; c++) {
    var d = ~~(c / 20), s = mF(Zh(u, 5), yF(d, r, l, i), f, a[c], bF[d]);
    f = i, i = l, l = Zh(r, 30), r = u, u = s;
  }
  this.h[0] = Rl(this.h[0], u), this.h[1] = Rl(this.h[1], r), this.h[2] = Rl(this.h[2], l), this.h[3] = Rl(this.h[3], i), this.h[4] = Rl(this.h[4], f);
};
ms.prototype._digest = function(e) {
  return e === "hex" ? Uo.toHex32(this.h, "big") : Uo.split32(this.h, "big");
};
var Vo = sr, vF = ll, cl = ws, EF = wi, Oi = Vo.sum32, _F = Vo.sum32_4, SF = Vo.sum32_5, wF = cl.ch32, TF = cl.maj32, AF = cl.s0_256, xF = cl.s1_256, PF = cl.g0_256, CF = cl.g1_256, nx = vF.BlockHash, IF = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function ys() {
  if (!(this instanceof ys))
    return new ys();
  nx.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = IF, this.W = new Array(64);
}
Vo.inherits(ys, nx);
var ix = ys;
ys.blockSize = 512;
ys.outSize = 256;
ys.hmacStrength = 192;
ys.padLength = 64;
ys.prototype._update = function(e, n) {
  for (var a = this.W, c = 0; c < 16; c++)
    a[c] = e[n + c];
  for (; c < a.length; c++)
    a[c] = _F(CF(a[c - 2]), a[c - 7], PF(a[c - 15]), a[c - 16]);
  var u = this.h[0], r = this.h[1], l = this.h[2], i = this.h[3], f = this.h[4], d = this.h[5], s = this.h[6], o = this.h[7];
  for (EF(this.k.length === a.length), c = 0; c < a.length; c++) {
    var m = SF(o, xF(f), wF(f, d, s), this.k[c], a[c]), h = Oi(AF(u), TF(u, r, l));
    o = s, s = d, d = f, f = Oi(i, m), i = l, l = r, r = u, u = Oi(m, h);
  }
  this.h[0] = Oi(this.h[0], u), this.h[1] = Oi(this.h[1], r), this.h[2] = Oi(this.h[2], l), this.h[3] = Oi(this.h[3], i), this.h[4] = Oi(this.h[4], f), this.h[5] = Oi(this.h[5], d), this.h[6] = Oi(this.h[6], s), this.h[7] = Oi(this.h[7], o);
};
ys.prototype._digest = function(e) {
  return e === "hex" ? Vo.toHex32(this.h, "big") : Vo.split32(this.h, "big");
};
var K1 = sr, sx = ix;
function Bs() {
  if (!(this instanceof Bs))
    return new Bs();
  sx.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
K1.inherits(Bs, sx);
var OF = Bs;
Bs.blockSize = 512;
Bs.outSize = 224;
Bs.hmacStrength = 192;
Bs.padLength = 64;
Bs.prototype._digest = function(e) {
  return e === "hex" ? K1.toHex32(this.h.slice(0, 7), "big") : K1.split32(this.h.slice(0, 7), "big");
};
var Wn = sr, kF = ll, DF = wi, os = Wn.rotr64_hi, ls = Wn.rotr64_lo, ax = Wn.shr64_hi, ox = Wn.shr64_lo, Ks = Wn.sum64, em = Wn.sum64_hi, tm = Wn.sum64_lo, NF = Wn.sum64_4_hi, RF = Wn.sum64_4_lo, MF = Wn.sum64_5_hi, LF = Wn.sum64_5_lo, lx = kF.BlockHash, jF = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function Li() {
  if (!(this instanceof Li))
    return new Li();
  lx.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = jF, this.W = new Array(160);
}
Wn.inherits(Li, lx);
var ux = Li;
Li.blockSize = 1024;
Li.outSize = 512;
Li.hmacStrength = 192;
Li.padLength = 128;
Li.prototype._prepareBlock = function(e, n) {
  for (var a = this.W, c = 0; c < 32; c++)
    a[c] = e[n + c];
  for (; c < a.length; c += 2) {
    var u = KF(a[c - 4], a[c - 3]), r = YF(a[c - 4], a[c - 3]), l = a[c - 14], i = a[c - 13], f = GF(a[c - 30], a[c - 29]), d = zF(a[c - 30], a[c - 29]), s = a[c - 32], o = a[c - 31];
    a[c] = NF(
      u,
      r,
      l,
      i,
      f,
      d,
      s,
      o
    ), a[c + 1] = RF(
      u,
      r,
      l,
      i,
      f,
      d,
      s,
      o
    );
  }
};
Li.prototype._update = function(e, n) {
  this._prepareBlock(e, n);
  var a = this.W, c = this.h[0], u = this.h[1], r = this.h[2], l = this.h[3], i = this.h[4], f = this.h[5], d = this.h[6], s = this.h[7], o = this.h[8], m = this.h[9], h = this.h[10], y = this.h[11], b = this.h[12], E = this.h[13], S = this.h[14], g = this.h[15];
  DF(this.k.length === a.length);
  for (var P = 0; P < a.length; P += 2) {
    var R = S, N = g, C = HF(o, m), I = qF(o, m), D = FF(o, m, h, y, b), j = BF(o, m, h, y, b, E), F = this.k[P], _ = this.k[P + 1], T = a[P], v = a[P + 1], w = MF(
      R,
      N,
      C,
      I,
      D,
      j,
      F,
      _,
      T,
      v
    ), O = LF(
      R,
      N,
      C,
      I,
      D,
      j,
      F,
      _,
      T,
      v
    );
    R = VF(c, u), N = WF(c, u), C = $F(c, u, r, l, i), I = UF(c, u, r, l, i, f);
    var G = em(R, N, C, I), W = tm(R, N, C, I);
    S = b, g = E, b = h, E = y, h = o, y = m, o = em(d, s, w, O), m = tm(s, s, w, O), d = i, s = f, i = r, f = l, r = c, l = u, c = em(w, O, G, W), u = tm(w, O, G, W);
  }
  Ks(this.h, 0, c, u), Ks(this.h, 2, r, l), Ks(this.h, 4, i, f), Ks(this.h, 6, d, s), Ks(this.h, 8, o, m), Ks(this.h, 10, h, y), Ks(this.h, 12, b, E), Ks(this.h, 14, S, g);
};
Li.prototype._digest = function(e) {
  return e === "hex" ? Wn.toHex32(this.h, "big") : Wn.split32(this.h, "big");
};
function FF(t, e, n, a, c) {
  var u = t & n ^ ~t & c;
  return u < 0 && (u += 4294967296), u;
}
function BF(t, e, n, a, c, u) {
  var r = e & a ^ ~e & u;
  return r < 0 && (r += 4294967296), r;
}
function $F(t, e, n, a, c) {
  var u = t & n ^ t & c ^ n & c;
  return u < 0 && (u += 4294967296), u;
}
function UF(t, e, n, a, c, u) {
  var r = e & a ^ e & u ^ a & u;
  return r < 0 && (r += 4294967296), r;
}
function VF(t, e) {
  var n = os(t, e, 28), a = os(e, t, 2), c = os(e, t, 7), u = n ^ a ^ c;
  return u < 0 && (u += 4294967296), u;
}
function WF(t, e) {
  var n = ls(t, e, 28), a = ls(e, t, 2), c = ls(e, t, 7), u = n ^ a ^ c;
  return u < 0 && (u += 4294967296), u;
}
function HF(t, e) {
  var n = os(t, e, 14), a = os(t, e, 18), c = os(e, t, 9), u = n ^ a ^ c;
  return u < 0 && (u += 4294967296), u;
}
function qF(t, e) {
  var n = ls(t, e, 14), a = ls(t, e, 18), c = ls(e, t, 9), u = n ^ a ^ c;
  return u < 0 && (u += 4294967296), u;
}
function GF(t, e) {
  var n = os(t, e, 1), a = os(t, e, 8), c = ax(t, e, 7), u = n ^ a ^ c;
  return u < 0 && (u += 4294967296), u;
}
function zF(t, e) {
  var n = ls(t, e, 1), a = ls(t, e, 8), c = ox(t, e, 7), u = n ^ a ^ c;
  return u < 0 && (u += 4294967296), u;
}
function KF(t, e) {
  var n = os(t, e, 19), a = os(e, t, 29), c = ax(t, e, 6), u = n ^ a ^ c;
  return u < 0 && (u += 4294967296), u;
}
function YF(t, e) {
  var n = ls(t, e, 19), a = ls(e, t, 29), c = ox(t, e, 6), u = n ^ a ^ c;
  return u < 0 && (u += 4294967296), u;
}
var Y1 = sr, cx = ux;
function $s() {
  if (!(this instanceof $s))
    return new $s();
  cx.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
Y1.inherits($s, cx);
var XF = $s;
$s.blockSize = 1024;
$s.outSize = 384;
$s.hmacStrength = 192;
$s.padLength = 128;
$s.prototype._digest = function(e) {
  return e === "hex" ? Y1.toHex32(this.h.slice(0, 12), "big") : Y1.split32(this.h.slice(0, 12), "big");
};
ul.sha1 = gF;
ul.sha224 = OF;
ul.sha256 = ix;
ul.sha384 = XF;
ul.sha512 = ux;
var fx = {}, Wa = sr, JF = ll, Fc = Wa.rotl32, zE = Wa.sum32, Ml = Wa.sum32_3, KE = Wa.sum32_4, dx = JF.BlockHash;
function bs() {
  if (!(this instanceof bs))
    return new bs();
  dx.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
Wa.inherits(bs, dx);
fx.ripemd160 = bs;
bs.blockSize = 512;
bs.outSize = 160;
bs.hmacStrength = 192;
bs.padLength = 64;
bs.prototype._update = function(e, n) {
  for (var a = this.h[0], c = this.h[1], u = this.h[2], r = this.h[3], l = this.h[4], i = a, f = c, d = u, s = r, o = l, m = 0; m < 80; m++) {
    var h = zE(
      Fc(
        KE(a, YE(m, c, u, r), e[e9[m] + n], QF(m)),
        r9[m]
      ),
      l
    );
    a = l, l = r, r = Fc(u, 10), u = c, c = h, h = zE(
      Fc(
        KE(i, YE(79 - m, f, d, s), e[t9[m] + n], ZF(m)),
        n9[m]
      ),
      o
    ), i = o, o = s, s = Fc(d, 10), d = f, f = h;
  }
  h = Ml(this.h[1], u, s), this.h[1] = Ml(this.h[2], r, o), this.h[2] = Ml(this.h[3], l, i), this.h[3] = Ml(this.h[4], a, f), this.h[4] = Ml(this.h[0], c, d), this.h[0] = h;
};
bs.prototype._digest = function(e) {
  return e === "hex" ? Wa.toHex32(this.h, "little") : Wa.split32(this.h, "little");
};
function YE(t, e, n, a) {
  return t <= 15 ? e ^ n ^ a : t <= 31 ? e & n | ~e & a : t <= 47 ? (e | ~n) ^ a : t <= 63 ? e & a | n & ~a : e ^ (n | ~a);
}
function QF(t) {
  return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
}
function ZF(t) {
  return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
}
var e9 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], t9 = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], r9 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], n9 = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], i9 = sr, s9 = wi;
function Wo(t, e, n) {
  if (!(this instanceof Wo))
    return new Wo(t, e, n);
  this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(i9.toArray(e, n));
}
var a9 = Wo;
Wo.prototype._init = function(e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()), s9(e.length <= this.blockSize);
  for (var n = e.length; n < this.blockSize; n++)
    e.push(0);
  for (n = 0; n < e.length; n++)
    e[n] ^= 54;
  for (this.inner = new this.Hash().update(e), n = 0; n < e.length; n++)
    e[n] ^= 106;
  this.outer = new this.Hash().update(e);
};
Wo.prototype.update = function(e, n) {
  return this.inner.update(e, n), this;
};
Wo.prototype.digest = function(e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function(t) {
  var e = t;
  e.utils = sr, e.common = ll, e.sha = ul, e.ripemd = fx, e.hmac = a9, e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160;
})(ep);
var rm, XE;
function o9() {
  return XE || (XE = 1, rm = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), rm;
}
(function(t) {
  var e = t, n = ep, a = Wy, c = ti, u = c.assert;
  function r(f) {
    f.type === "short" ? this.curve = new a.short(f) : f.type === "edwards" ? this.curve = new a.edwards(f) : this.curve = new a.mont(f), this.g = this.curve.g, this.n = this.curve.n, this.hash = f.hash, u(this.g.validate(), "Invalid curve"), u(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  e.PresetCurve = r;
  function l(f, d) {
    Object.defineProperty(e, f, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var s = new r(d);
        return Object.defineProperty(e, f, {
          configurable: !0,
          enumerable: !0,
          value: s
        }), s;
      }
    });
  }
  l("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: n.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), l("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: n.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), l("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: n.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), l("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: n.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), l("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: n.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), l("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: n.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), l("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: n.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var i;
  try {
    i = o9();
  } catch {
    i = void 0;
  }
  l("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: n.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      i
    ]
  });
})(Zd);
var l9 = ep, Ba = Vy, px = wi;
function ua(t) {
  if (!(this instanceof ua))
    return new ua(t);
  this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var e = Ba.toArray(t.entropy, t.entropyEnc || "hex"), n = Ba.toArray(t.nonce, t.nonceEnc || "hex"), a = Ba.toArray(t.pers, t.persEnc || "hex");
  px(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(e, n, a);
}
var u9 = ua;
ua.prototype._init = function(e, n, a) {
  var c = e.concat(n).concat(a);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var u = 0; u < this.V.length; u++)
    this.K[u] = 0, this.V[u] = 1;
  this._update(c), this._reseed = 1, this.reseedInterval = 281474976710656;
};
ua.prototype._hmac = function() {
  return new l9.hmac(this.hash, this.K);
};
ua.prototype._update = function(e) {
  var n = this._hmac().update(this.V).update([0]);
  e && (n = n.update(e)), this.K = n.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
ua.prototype.reseed = function(e, n, a, c) {
  typeof n != "string" && (c = a, a = n, n = null), e = Ba.toArray(e, n), a = Ba.toArray(a, c), px(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(a || [])), this._reseed = 1;
};
ua.prototype.generate = function(e, n, a, c) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof n != "string" && (c = a, a = n, n = null), a && (a = Ba.toArray(a, c || "hex"), this._update(a));
  for (var u = []; u.length < e; )
    this.V = this._hmac().update(this.V).digest(), u = u.concat(this.V);
  var r = u.slice(0, e);
  return this._update(a), this._reseed++, Ba.encode(r, n);
};
var c9 = pn, f9 = ti, X1 = f9.assert;
function Cn(t, e) {
  this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
}
var d9 = Cn;
Cn.fromPublic = function(e, n, a) {
  return n instanceof Cn ? n : new Cn(e, {
    pub: n,
    pubEnc: a
  });
};
Cn.fromPrivate = function(e, n, a) {
  return n instanceof Cn ? n : new Cn(e, {
    priv: n,
    privEnc: a
  });
};
Cn.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
Cn.prototype.getPublic = function(e, n) {
  return typeof e == "string" && (n = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), n ? this.pub.encode(n, e) : this.pub;
};
Cn.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
Cn.prototype._importPrivate = function(e, n) {
  this.priv = new c9(e, n || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
Cn.prototype._importPublic = function(e, n) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? X1(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && X1(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, n);
};
Cn.prototype.derive = function(e) {
  return e.validate() || X1(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
Cn.prototype.sign = function(e, n, a) {
  return this.ec.sign(e, this, n, a);
};
Cn.prototype.verify = function(e, n) {
  return this.ec.verify(e, n, this);
};
Cn.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var $f = pn, qy = ti, p9 = qy.assert;
function rp(t, e) {
  if (t instanceof rp)
    return t;
  this._importDER(t, e) || (p9(t.r && t.s, "Signature without r or s"), this.r = new $f(t.r, 16), this.s = new $f(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
}
var h9 = rp;
function m9() {
  this.place = 0;
}
function nm(t, e) {
  var n = t[e.place++];
  if (!(n & 128))
    return n;
  var a = n & 15;
  if (a === 0 || a > 4)
    return !1;
  for (var c = 0, u = 0, r = e.place; u < a; u++, r++)
    c <<= 8, c |= t[r], c >>>= 0;
  return c <= 127 ? !1 : (e.place = r, c);
}
function JE(t) {
  for (var e = 0, n = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < n; )
    e++;
  return e === 0 ? t : t.slice(e);
}
rp.prototype._importDER = function(e, n) {
  e = qy.toArray(e, n);
  var a = new m9();
  if (e[a.place++] !== 48)
    return !1;
  var c = nm(e, a);
  if (c === !1 || c + a.place !== e.length || e[a.place++] !== 2)
    return !1;
  var u = nm(e, a);
  if (u === !1)
    return !1;
  var r = e.slice(a.place, u + a.place);
  if (a.place += u, e[a.place++] !== 2)
    return !1;
  var l = nm(e, a);
  if (l === !1 || e.length !== l + a.place)
    return !1;
  var i = e.slice(a.place, l + a.place);
  if (r[0] === 0)
    if (r[1] & 128)
      r = r.slice(1);
    else
      return !1;
  if (i[0] === 0)
    if (i[1] & 128)
      i = i.slice(1);
    else
      return !1;
  return this.r = new $f(r), this.s = new $f(i), this.recoveryParam = null, !0;
};
function im(t, e) {
  if (e < 128) {
    t.push(e);
    return;
  }
  var n = 1 + (Math.log(e) / Math.LN2 >>> 3);
  for (t.push(n | 128); --n; )
    t.push(e >>> (n << 3) & 255);
  t.push(e);
}
rp.prototype.toDER = function(e) {
  var n = this.r.toArray(), a = this.s.toArray();
  for (n[0] & 128 && (n = [0].concat(n)), a[0] & 128 && (a = [0].concat(a)), n = JE(n), a = JE(a); !a[0] && !(a[1] & 128); )
    a = a.slice(1);
  var c = [2];
  im(c, n.length), c = c.concat(n), c.push(2), im(c, a.length);
  var u = c.concat(a), r = [48];
  return im(r, u.length), r = r.concat(u), qy.encode(r, e);
};
var sm, QE;
function y9() {
  if (QE)
    return sm;
  QE = 1;
  var t = pn, e = u9, n = ti, a = Zd, c = Fy(), u = n.assert, r = d9, l = h9;
  function i(f) {
    if (!(this instanceof i))
      return new i(f);
    typeof f == "string" && (u(
      Object.prototype.hasOwnProperty.call(a, f),
      "Unknown curve " + f
    ), f = a[f]), f instanceof a.PresetCurve && (f = { curve: f }), this.curve = f.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = f.curve.g, this.g.precompute(f.curve.n.bitLength() + 1), this.hash = f.hash || f.curve.hash;
  }
  return sm = i, i.prototype.keyPair = function(d) {
    return new r(this, d);
  }, i.prototype.keyFromPrivate = function(d, s) {
    return r.fromPrivate(this, d, s);
  }, i.prototype.keyFromPublic = function(d, s) {
    return r.fromPublic(this, d, s);
  }, i.prototype.genKeyPair = function(d) {
    d || (d = {});
    for (var s = new e({
      hash: this.hash,
      pers: d.pers,
      persEnc: d.persEnc || "utf8",
      entropy: d.entropy || c(this.hash.hmacStrength),
      entropyEnc: d.entropy && d.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), o = this.n.byteLength(), m = this.n.sub(new t(2)); ; ) {
      var h = new t(s.generate(o));
      if (!(h.cmp(m) > 0))
        return h.iaddn(1), this.keyFromPrivate(h);
    }
  }, i.prototype._truncateToN = function(d, s) {
    var o = d.byteLength() * 8 - this.n.bitLength();
    return o > 0 && (d = d.ushrn(o)), !s && d.cmp(this.n) >= 0 ? d.sub(this.n) : d;
  }, i.prototype.sign = function(d, s, o, m) {
    typeof o == "object" && (m = o, o = null), m || (m = {}), s = this.keyFromPrivate(s, o), d = this._truncateToN(new t(d, 16));
    for (var h = this.n.byteLength(), y = s.getPrivate().toArray("be", h), b = d.toArray("be", h), E = new e({
      hash: this.hash,
      entropy: y,
      nonce: b,
      pers: m.pers,
      persEnc: m.persEnc || "utf8"
    }), S = this.n.sub(new t(1)), g = 0; ; g++) {
      var P = m.k ? m.k(g) : new t(E.generate(this.n.byteLength()));
      if (P = this._truncateToN(P, !0), !(P.cmpn(1) <= 0 || P.cmp(S) >= 0)) {
        var R = this.g.mul(P);
        if (!R.isInfinity()) {
          var N = R.getX(), C = N.umod(this.n);
          if (C.cmpn(0) !== 0) {
            var I = P.invm(this.n).mul(C.mul(s.getPrivate()).iadd(d));
            if (I = I.umod(this.n), I.cmpn(0) !== 0) {
              var D = (R.getY().isOdd() ? 1 : 0) | (N.cmp(C) !== 0 ? 2 : 0);
              return m.canonical && I.cmp(this.nh) > 0 && (I = this.n.sub(I), D ^= 1), new l({ r: C, s: I, recoveryParam: D });
            }
          }
        }
      }
    }
  }, i.prototype.verify = function(d, s, o, m) {
    d = this._truncateToN(new t(d, 16)), o = this.keyFromPublic(o, m), s = new l(s, "hex");
    var h = s.r, y = s.s;
    if (h.cmpn(1) < 0 || h.cmp(this.n) >= 0 || y.cmpn(1) < 0 || y.cmp(this.n) >= 0)
      return !1;
    var b = y.invm(this.n), E = b.mul(d).umod(this.n), S = b.mul(h).umod(this.n), g;
    return this.curve._maxwellTrick ? (g = this.g.jmulAdd(E, o.getPublic(), S), g.isInfinity() ? !1 : g.eqXToP(h)) : (g = this.g.mulAdd(E, o.getPublic(), S), g.isInfinity() ? !1 : g.getX().umod(this.n).cmp(h) === 0);
  }, i.prototype.recoverPubKey = function(f, d, s, o) {
    u((3 & s) === s, "The recovery param is more than two bits"), d = new l(d, o);
    var m = this.n, h = new t(f), y = d.r, b = d.s, E = s & 1, S = s >> 1;
    if (y.cmp(this.curve.p.umod(this.curve.n)) >= 0 && S)
      throw new Error("Unable to find sencond key candinate");
    S ? y = this.curve.pointFromX(y.add(this.curve.n), E) : y = this.curve.pointFromX(y, E);
    var g = d.r.invm(m), P = m.sub(h).mul(g).umod(m), R = b.mul(g).umod(m);
    return this.g.mulAdd(P, y, R);
  }, i.prototype.getKeyRecoveryParam = function(f, d, s, o) {
    if (d = new l(d, o), d.recoveryParam !== null)
      return d.recoveryParam;
    for (var m = 0; m < 4; m++) {
      var h;
      try {
        h = this.recoverPubKey(f, d, m);
      } catch {
        continue;
      }
      if (h.eq(s))
        return m;
    }
    throw new Error("Unable to find valid recovery factor");
  }, sm;
}
var Gu = ti, hx = Gu.assert, ZE = Gu.parseBytes, fl = Gu.cachedProperty;
function un(t, e) {
  this.eddsa = t, this._secret = ZE(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = ZE(e.pub);
}
un.fromPublic = function(e, n) {
  return n instanceof un ? n : new un(e, { pub: n });
};
un.fromSecret = function(e, n) {
  return n instanceof un ? n : new un(e, { secret: n });
};
un.prototype.secret = function() {
  return this._secret;
};
fl(un, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
fl(un, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
fl(un, "privBytes", function() {
  var e = this.eddsa, n = this.hash(), a = e.encodingLength - 1, c = n.slice(0, e.encodingLength);
  return c[0] &= 248, c[a] &= 127, c[a] |= 64, c;
});
fl(un, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
fl(un, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
fl(un, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
un.prototype.sign = function(e) {
  return hx(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
};
un.prototype.verify = function(e, n) {
  return this.eddsa.verify(e, n, this);
};
un.prototype.getSecret = function(e) {
  return hx(this._secret, "KeyPair is public only"), Gu.encode(this.secret(), e);
};
un.prototype.getPublic = function(e) {
  return Gu.encode(this.pubBytes(), e);
};
var b9 = un, g9 = pn, np = ti, v9 = np.assert, ip = np.cachedProperty, E9 = np.parseBytes;
function eo(t, e) {
  this.eddsa = t, typeof e != "object" && (e = E9(e)), Array.isArray(e) && (e = {
    R: e.slice(0, t.encodingLength),
    S: e.slice(t.encodingLength)
  }), v9(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof g9 && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
}
ip(eo, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
ip(eo, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
ip(eo, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
ip(eo, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
eo.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
eo.prototype.toHex = function() {
  return np.encode(this.toBytes(), "hex").toUpperCase();
};
var _9 = eo, S9 = ep, w9 = Zd, Ho = ti, T9 = Ho.assert, mx = Ho.parseBytes, yx = b9, e_ = _9;
function Hn(t) {
  if (T9(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof Hn))
    return new Hn(t);
  t = w9[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = S9.sha512;
}
var A9 = Hn;
Hn.prototype.sign = function(e, n) {
  e = mx(e);
  var a = this.keyFromSecret(n), c = this.hashInt(a.messagePrefix(), e), u = this.g.mul(c), r = this.encodePoint(u), l = this.hashInt(r, a.pubBytes(), e).mul(a.priv()), i = c.add(l).umod(this.curve.n);
  return this.makeSignature({ R: u, S: i, Rencoded: r });
};
Hn.prototype.verify = function(e, n, a) {
  e = mx(e), n = this.makeSignature(n);
  var c = this.keyFromPublic(a), u = this.hashInt(n.Rencoded(), c.pubBytes(), e), r = this.g.mul(n.S()), l = n.R().add(c.pub().mul(u));
  return l.eq(r);
};
Hn.prototype.hashInt = function() {
  for (var e = this.hash(), n = 0; n < arguments.length; n++)
    e.update(arguments[n]);
  return Ho.intFromLE(e.digest()).umod(this.curve.n);
};
Hn.prototype.keyFromPublic = function(e) {
  return yx.fromPublic(this, e);
};
Hn.prototype.keyFromSecret = function(e) {
  return yx.fromSecret(this, e);
};
Hn.prototype.makeSignature = function(e) {
  return e instanceof e_ ? e : new e_(this, e);
};
Hn.prototype.encodePoint = function(e) {
  var n = e.getY().toArray("le", this.encodingLength);
  return n[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, n;
};
Hn.prototype.decodePoint = function(e) {
  e = Ho.parseBytes(e);
  var n = e.length - 1, a = e.slice(0, n).concat(e[n] & -129), c = (e[n] & 128) !== 0, u = Ho.intFromLE(a);
  return this.curve.pointFromY(u, c);
};
Hn.prototype.encodeInt = function(e) {
  return e.toArray("le", this.encodingLength);
};
Hn.prototype.decodeInt = function(e) {
  return Ho.intFromLE(e);
};
Hn.prototype.isPoint = function(e) {
  return e instanceof this.pointClass;
};
var t_;
function Gy() {
  return t_ || (t_ = 1, function(t) {
    var e = t;
    e.version = Aj.version, e.utils = ti, e.rand = Fy(), e.curve = Wy, e.curves = Zd, e.ec = y9(), e.eddsa = A9;
  }(Qh)), Qh;
}
var Ui = {}, zy = {}, bx = {}, Ky = {}, pf = fa, Oo = pf.Buffer, ui = {}, ci;
for (ci in pf)
  pf.hasOwnProperty(ci) && (ci === "SlowBuffer" || ci === "Buffer" || (ui[ci] = pf[ci]));
var ko = ui.Buffer = {};
for (ci in Oo)
  Oo.hasOwnProperty(ci) && (ci === "allocUnsafe" || ci === "allocUnsafeSlow" || (ko[ci] = Oo[ci]));
ui.Buffer.prototype = Oo.prototype;
(!ko.from || ko.from === Uint8Array.from) && (ko.from = function(t, e, n) {
  if (typeof t == "number")
    throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof t);
  if (t && typeof t.length > "u")
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
  return Oo(t, e, n);
});
ko.alloc || (ko.alloc = function(t, e, n) {
  if (typeof t != "number")
    throw new TypeError('The "size" argument must be of type number. Received type ' + typeof t);
  if (t < 0 || t >= 2 * (1 << 30))
    throw new RangeError('The value "' + t + '" is invalid for option "size"');
  var a = Oo(t);
  return !e || e.length === 0 ? a.fill(0) : typeof n == "string" ? a.fill(e, n) : a.fill(e), a;
});
if (!ui.kStringMaxLength)
  try {
    ui.kStringMaxLength = Ve.process.binding("buffer").kStringMaxLength;
  } catch {
  }
ui.constants || (ui.constants = {
  MAX_LENGTH: ui.kMaxLength
}, ui.kStringMaxLength && (ui.constants.MAX_STRING_LENGTH = ui.kStringMaxLength));
var Yy = ui, sp = {};
const x9 = Zt;
function Pi(t) {
  this._reporterState = {
    obj: null,
    path: [],
    options: t || {},
    errors: []
  };
}
sp.Reporter = Pi;
Pi.prototype.isError = function(e) {
  return e instanceof qo;
};
Pi.prototype.save = function() {
  const e = this._reporterState;
  return { obj: e.obj, pathLen: e.path.length };
};
Pi.prototype.restore = function(e) {
  const n = this._reporterState;
  n.obj = e.obj, n.path = n.path.slice(0, e.pathLen);
};
Pi.prototype.enterKey = function(e) {
  return this._reporterState.path.push(e);
};
Pi.prototype.exitKey = function(e) {
  const n = this._reporterState;
  n.path = n.path.slice(0, e - 1);
};
Pi.prototype.leaveKey = function(e, n, a) {
  const c = this._reporterState;
  this.exitKey(e), c.obj !== null && (c.obj[n] = a);
};
Pi.prototype.path = function() {
  return this._reporterState.path.join("/");
};
Pi.prototype.enterObject = function() {
  const e = this._reporterState, n = e.obj;
  return e.obj = {}, n;
};
Pi.prototype.leaveObject = function(e) {
  const n = this._reporterState, a = n.obj;
  return n.obj = e, a;
};
Pi.prototype.error = function(e) {
  let n;
  const a = this._reporterState, c = e instanceof qo;
  if (c ? n = e : n = new qo(a.path.map(function(u) {
    return "[" + JSON.stringify(u) + "]";
  }).join(""), e.message || e, e.stack), !a.options.partial)
    throw n;
  return c || a.errors.push(n), n;
};
Pi.prototype.wrapResult = function(e) {
  const n = this._reporterState;
  return n.options.partial ? {
    result: this.isError(e) ? null : e,
    errors: n.errors
  } : e;
};
function qo(t, e) {
  this.path = t, this.rethrow(e);
}
x9(qo, Error);
qo.prototype.rethrow = function(e) {
  if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, qo), !this.stack)
    try {
      throw new Error(this.message);
    } catch (n) {
      this.stack = n.stack;
    }
  return this;
};
var Ha = {};
const P9 = Zt, ap = sp.Reporter, Go = Yy.Buffer;
function gi(t, e) {
  if (ap.call(this, e), !Go.isBuffer(t)) {
    this.error("Input not Buffer");
    return;
  }
  this.base = t, this.offset = 0, this.length = t.length;
}
P9(gi, ap);
Ha.DecoderBuffer = gi;
gi.isDecoderBuffer = function(e) {
  return e instanceof gi ? !0 : typeof e == "object" && Go.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function";
};
gi.prototype.save = function() {
  return { offset: this.offset, reporter: ap.prototype.save.call(this) };
};
gi.prototype.restore = function(e) {
  const n = new gi(this.base);
  return n.offset = e.offset, n.length = this.offset, this.offset = e.offset, ap.prototype.restore.call(this, e.reporter), n;
};
gi.prototype.isEmpty = function() {
  return this.offset === this.length;
};
gi.prototype.readUInt8 = function(e) {
  return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(e || "DecoderBuffer overrun");
};
gi.prototype.skip = function(e, n) {
  if (!(this.offset + e <= this.length))
    return this.error(n || "DecoderBuffer overrun");
  const a = new gi(this.base);
  return a._reporterState = this._reporterState, a.offset = this.offset, a.length = this.offset + e, this.offset += e, a;
};
gi.prototype.raw = function(e) {
  return this.base.slice(e ? e.offset : this.offset, this.length);
};
function zo(t, e) {
  if (Array.isArray(t))
    this.length = 0, this.value = t.map(function(n) {
      return zo.isEncoderBuffer(n) || (n = new zo(n, e)), this.length += n.length, n;
    }, this);
  else if (typeof t == "number") {
    if (!(0 <= t && t <= 255))
      return e.error("non-byte EncoderBuffer value");
    this.value = t, this.length = 1;
  } else if (typeof t == "string")
    this.value = t, this.length = Go.byteLength(t);
  else if (Go.isBuffer(t))
    this.value = t, this.length = t.length;
  else
    return e.error("Unsupported type: " + typeof t);
}
Ha.EncoderBuffer = zo;
zo.isEncoderBuffer = function(e) {
  return e instanceof zo ? !0 : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function";
};
zo.prototype.join = function(e, n) {
  return e || (e = Go.alloc(this.length)), n || (n = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(a) {
    a.join(e, n), n += a.length;
  }) : (typeof this.value == "number" ? e[n] = this.value : typeof this.value == "string" ? e.write(this.value, n) : Go.isBuffer(this.value) && this.value.copy(e, n), n += this.length)), e;
};
const C9 = sp.Reporter, I9 = Ha.EncoderBuffer, O9 = Ha.DecoderBuffer, Nn = wi, gx = [
  "seq",
  "seqof",
  "set",
  "setof",
  "objid",
  "bool",
  "gentime",
  "utctime",
  "null_",
  "enum",
  "int",
  "objDesc",
  "bitstr",
  "bmpstr",
  "charstr",
  "genstr",
  "graphstr",
  "ia5str",
  "iso646str",
  "numstr",
  "octstr",
  "printstr",
  "t61str",
  "unistr",
  "utf8str",
  "videostr"
], k9 = [
  "key",
  "obj",
  "use",
  "optional",
  "explicit",
  "implicit",
  "def",
  "choice",
  "any",
  "contains"
].concat(gx), D9 = [
  "_peekTag",
  "_decodeTag",
  "_use",
  "_decodeStr",
  "_decodeObjid",
  "_decodeTime",
  "_decodeNull",
  "_decodeInt",
  "_decodeBool",
  "_decodeList",
  "_encodeComposite",
  "_encodeStr",
  "_encodeObjid",
  "_encodeTime",
  "_encodeNull",
  "_encodeInt",
  "_encodeBool"
];
function vr(t, e, n) {
  const a = {};
  this._baseState = a, a.name = n, a.enc = t, a.parent = e || null, a.children = null, a.tag = null, a.args = null, a.reverseArgs = null, a.choice = null, a.optional = !1, a.any = !1, a.obj = !1, a.use = null, a.useDecoder = null, a.key = null, a.default = null, a.explicit = null, a.implicit = null, a.contains = null, a.parent || (a.children = [], this._wrap());
}
var Xy = vr;
const N9 = [
  "enc",
  "parent",
  "children",
  "tag",
  "args",
  "reverseArgs",
  "choice",
  "optional",
  "any",
  "obj",
  "use",
  "alteredUse",
  "key",
  "default",
  "explicit",
  "implicit",
  "contains"
];
vr.prototype.clone = function() {
  const e = this._baseState, n = {};
  N9.forEach(function(c) {
    n[c] = e[c];
  });
  const a = new this.constructor(n.parent);
  return a._baseState = n, a;
};
vr.prototype._wrap = function() {
  const e = this._baseState;
  k9.forEach(function(n) {
    this[n] = function() {
      const c = new this.constructor(this);
      return e.children.push(c), c[n].apply(c, arguments);
    };
  }, this);
};
vr.prototype._init = function(e) {
  const n = this._baseState;
  Nn(n.parent === null), e.call(this), n.children = n.children.filter(function(a) {
    return a._baseState.parent === this;
  }, this), Nn.equal(n.children.length, 1, "Root node can have only one child");
};
vr.prototype._useArgs = function(e) {
  const n = this._baseState, a = e.filter(function(c) {
    return c instanceof this.constructor;
  }, this);
  e = e.filter(function(c) {
    return !(c instanceof this.constructor);
  }, this), a.length !== 0 && (Nn(n.children === null), n.children = a, a.forEach(function(c) {
    c._baseState.parent = this;
  }, this)), e.length !== 0 && (Nn(n.args === null), n.args = e, n.reverseArgs = e.map(function(c) {
    if (typeof c != "object" || c.constructor !== Object)
      return c;
    const u = {};
    return Object.keys(c).forEach(function(r) {
      r == (r | 0) && (r |= 0);
      const l = c[r];
      u[l] = r;
    }), u;
  }));
};
D9.forEach(function(t) {
  vr.prototype[t] = function() {
    const n = this._baseState;
    throw new Error(t + " not implemented for encoding: " + n.enc);
  };
});
gx.forEach(function(t) {
  vr.prototype[t] = function() {
    const n = this._baseState, a = Array.prototype.slice.call(arguments);
    return Nn(n.tag === null), n.tag = t, this._useArgs(a), this;
  };
});
vr.prototype.use = function(e) {
  Nn(e);
  const n = this._baseState;
  return Nn(n.use === null), n.use = e, this;
};
vr.prototype.optional = function() {
  const e = this._baseState;
  return e.optional = !0, this;
};
vr.prototype.def = function(e) {
  const n = this._baseState;
  return Nn(n.default === null), n.default = e, n.optional = !0, this;
};
vr.prototype.explicit = function(e) {
  const n = this._baseState;
  return Nn(n.explicit === null && n.implicit === null), n.explicit = e, this;
};
vr.prototype.implicit = function(e) {
  const n = this._baseState;
  return Nn(n.explicit === null && n.implicit === null), n.implicit = e, this;
};
vr.prototype.obj = function() {
  const e = this._baseState, n = Array.prototype.slice.call(arguments);
  return e.obj = !0, n.length !== 0 && this._useArgs(n), this;
};
vr.prototype.key = function(e) {
  const n = this._baseState;
  return Nn(n.key === null), n.key = e, this;
};
vr.prototype.any = function() {
  const e = this._baseState;
  return e.any = !0, this;
};
vr.prototype.choice = function(e) {
  const n = this._baseState;
  return Nn(n.choice === null), n.choice = e, this._useArgs(Object.keys(e).map(function(a) {
    return e[a];
  })), this;
};
vr.prototype.contains = function(e) {
  const n = this._baseState;
  return Nn(n.use === null), n.contains = e, this;
};
vr.prototype._decode = function(e, n) {
  const a = this._baseState;
  if (a.parent === null)
    return e.wrapResult(a.children[0]._decode(e, n));
  let c = a.default, u = !0, r = null;
  if (a.key !== null && (r = e.enterKey(a.key)), a.optional) {
    let i = null;
    if (a.explicit !== null ? i = a.explicit : a.implicit !== null ? i = a.implicit : a.tag !== null && (i = a.tag), i === null && !a.any) {
      const f = e.save();
      try {
        a.choice === null ? this._decodeGeneric(a.tag, e, n) : this._decodeChoice(e, n), u = !0;
      } catch {
        u = !1;
      }
      e.restore(f);
    } else if (u = this._peekTag(e, i, a.any), e.isError(u))
      return u;
  }
  let l;
  if (a.obj && u && (l = e.enterObject()), u) {
    if (a.explicit !== null) {
      const f = this._decodeTag(e, a.explicit);
      if (e.isError(f))
        return f;
      e = f;
    }
    const i = e.offset;
    if (a.use === null && a.choice === null) {
      let f;
      a.any && (f = e.save());
      const d = this._decodeTag(
        e,
        a.implicit !== null ? a.implicit : a.tag,
        a.any
      );
      if (e.isError(d))
        return d;
      a.any ? c = e.raw(f) : e = d;
    }
    if (n && n.track && a.tag !== null && n.track(e.path(), i, e.length, "tagged"), n && n.track && a.tag !== null && n.track(e.path(), e.offset, e.length, "content"), a.any || (a.choice === null ? c = this._decodeGeneric(a.tag, e, n) : c = this._decodeChoice(e, n)), e.isError(c))
      return c;
    if (!a.any && a.choice === null && a.children !== null && a.children.forEach(function(d) {
      d._decode(e, n);
    }), a.contains && (a.tag === "octstr" || a.tag === "bitstr")) {
      const f = new O9(c);
      c = this._getUse(a.contains, e._reporterState.obj)._decode(f, n);
    }
  }
  return a.obj && u && (c = e.leaveObject(l)), a.key !== null && (c !== null || u === !0) ? e.leaveKey(r, a.key, c) : r !== null && e.exitKey(r), c;
};
vr.prototype._decodeGeneric = function(e, n, a) {
  const c = this._baseState;
  return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(n, e, c.args[0], a) : /str$/.test(e) ? this._decodeStr(n, e, a) : e === "objid" && c.args ? this._decodeObjid(n, c.args[0], c.args[1], a) : e === "objid" ? this._decodeObjid(n, null, null, a) : e === "gentime" || e === "utctime" ? this._decodeTime(n, e, a) : e === "null_" ? this._decodeNull(n, a) : e === "bool" ? this._decodeBool(n, a) : e === "objDesc" ? this._decodeStr(n, e, a) : e === "int" || e === "enum" ? this._decodeInt(n, c.args && c.args[0], a) : c.use !== null ? this._getUse(c.use, n._reporterState.obj)._decode(n, a) : n.error("unknown tag: " + e);
};
vr.prototype._getUse = function(e, n) {
  const a = this._baseState;
  return a.useDecoder = this._use(e, n), Nn(a.useDecoder._baseState.parent === null), a.useDecoder = a.useDecoder._baseState.children[0], a.implicit !== a.useDecoder._baseState.implicit && (a.useDecoder = a.useDecoder.clone(), a.useDecoder._baseState.implicit = a.implicit), a.useDecoder;
};
vr.prototype._decodeChoice = function(e, n) {
  const a = this._baseState;
  let c = null, u = !1;
  return Object.keys(a.choice).some(function(r) {
    const l = e.save(), i = a.choice[r];
    try {
      const f = i._decode(e, n);
      if (e.isError(f))
        return !1;
      c = { type: r, value: f }, u = !0;
    } catch {
      return e.restore(l), !1;
    }
    return !0;
  }, this), u ? c : e.error("Choice not matched");
};
vr.prototype._createEncoderBuffer = function(e) {
  return new I9(e, this.reporter);
};
vr.prototype._encode = function(e, n, a) {
  const c = this._baseState;
  if (c.default !== null && c.default === e)
    return;
  const u = this._encodeValue(e, n, a);
  if (u !== void 0 && !this._skipDefault(u, n, a))
    return u;
};
vr.prototype._encodeValue = function(e, n, a) {
  const c = this._baseState;
  if (c.parent === null)
    return c.children[0]._encode(e, n || new C9());
  let u = null;
  if (this.reporter = n, c.optional && e === void 0)
    if (c.default !== null)
      e = c.default;
    else
      return;
  let r = null, l = !1;
  if (c.any)
    u = this._createEncoderBuffer(e);
  else if (c.choice)
    u = this._encodeChoice(e, n);
  else if (c.contains)
    r = this._getUse(c.contains, a)._encode(e, n), l = !0;
  else if (c.children)
    r = c.children.map(function(i) {
      if (i._baseState.tag === "null_")
        return i._encode(null, n, e);
      if (i._baseState.key === null)
        return n.error("Child should have a key");
      const f = n.enterKey(i._baseState.key);
      if (typeof e != "object")
        return n.error("Child expected, but input is not object");
      const d = i._encode(e[i._baseState.key], n, e);
      return n.leaveKey(f), d;
    }, this).filter(function(i) {
      return i;
    }), r = this._createEncoderBuffer(r);
  else if (c.tag === "seqof" || c.tag === "setof") {
    if (!(c.args && c.args.length === 1))
      return n.error("Too many args for : " + c.tag);
    if (!Array.isArray(e))
      return n.error("seqof/setof, but data is not Array");
    const i = this.clone();
    i._baseState.implicit = null, r = this._createEncoderBuffer(e.map(function(f) {
      const d = this._baseState;
      return this._getUse(d.args[0], e)._encode(f, n);
    }, i));
  } else
    c.use !== null ? u = this._getUse(c.use, a)._encode(e, n) : (r = this._encodePrimitive(c.tag, e), l = !0);
  if (!c.any && c.choice === null) {
    const i = c.implicit !== null ? c.implicit : c.tag, f = c.implicit === null ? "universal" : "context";
    i === null ? c.use === null && n.error("Tag could be omitted only for .use()") : c.use === null && (u = this._encodeComposite(i, l, f, r));
  }
  return c.explicit !== null && (u = this._encodeComposite(c.explicit, !1, "context", u)), u;
};
vr.prototype._encodeChoice = function(e, n) {
  const a = this._baseState, c = a.choice[e.type];
  return c || Nn(
    !1,
    e.type + " not found in " + JSON.stringify(Object.keys(a.choice))
  ), c._encode(e.value, n);
};
vr.prototype._encodePrimitive = function(e, n) {
  const a = this._baseState;
  if (/str$/.test(e))
    return this._encodeStr(n, e);
  if (e === "objid" && a.args)
    return this._encodeObjid(n, a.reverseArgs[0], a.args[1]);
  if (e === "objid")
    return this._encodeObjid(n, null, null);
  if (e === "gentime" || e === "utctime")
    return this._encodeTime(n, e);
  if (e === "null_")
    return this._encodeNull();
  if (e === "int" || e === "enum")
    return this._encodeInt(n, a.args && a.reverseArgs[0]);
  if (e === "bool")
    return this._encodeBool(n);
  if (e === "objDesc")
    return this._encodeStr(n, e);
  throw new Error("Unsupported tag: " + e);
};
vr.prototype._isNumstr = function(e) {
  return /^[0-9 ]*$/.test(e);
};
vr.prototype._isPrintstr = function(e) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);
};
var op = {};
(function(t) {
  function e(n) {
    const a = {};
    return Object.keys(n).forEach(function(c) {
      (c | 0) == c && (c = c | 0);
      const u = n[c];
      a[u] = c;
    }), a;
  }
  t.tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
  }, t.tagClassByName = e(t.tagClass), t.tag = {
    0: "end",
    1: "bool",
    2: "int",
    3: "bitstr",
    4: "octstr",
    5: "null_",
    6: "objid",
    7: "objDesc",
    8: "external",
    9: "real",
    10: "enum",
    11: "embed",
    12: "utf8str",
    13: "relativeOid",
    16: "seq",
    17: "set",
    18: "numstr",
    19: "printstr",
    20: "t61str",
    21: "videostr",
    22: "ia5str",
    23: "utctime",
    24: "gentime",
    25: "graphstr",
    26: "iso646str",
    27: "genstr",
    28: "unistr",
    29: "charstr",
    30: "bmpstr"
  }, t.tagByName = e(t.tag);
})(op);
const R9 = Zt, ks = Yy.Buffer, vx = Xy, am = op;
function Ex(t) {
  this.enc = "der", this.name = t.name, this.entity = t, this.tree = new Vi(), this.tree._init(t.body);
}
var _x = Ex;
Ex.prototype.encode = function(e, n) {
  return this.tree._encode(e, n).join();
};
function Vi(t) {
  vx.call(this, "der", t);
}
R9(Vi, vx);
Vi.prototype._encodeComposite = function(e, n, a, c) {
  const u = M9(e, n, a, this.reporter);
  if (c.length < 128) {
    const i = ks.alloc(2);
    return i[0] = u, i[1] = c.length, this._createEncoderBuffer([i, c]);
  }
  let r = 1;
  for (let i = c.length; i >= 256; i >>= 8)
    r++;
  const l = ks.alloc(1 + 1 + r);
  l[0] = u, l[1] = 128 | r;
  for (let i = 1 + r, f = c.length; f > 0; i--, f >>= 8)
    l[i] = f & 255;
  return this._createEncoderBuffer([l, c]);
};
Vi.prototype._encodeStr = function(e, n) {
  if (n === "bitstr")
    return this._createEncoderBuffer([e.unused | 0, e.data]);
  if (n === "bmpstr") {
    const a = ks.alloc(e.length * 2);
    for (let c = 0; c < e.length; c++)
      a.writeUInt16BE(e.charCodeAt(c), c * 2);
    return this._createEncoderBuffer(a);
  } else
    return n === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : n === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(n) ? this._createEncoderBuffer(e) : n === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + n + " unsupported");
};
Vi.prototype._encodeObjid = function(e, n, a) {
  if (typeof e == "string") {
    if (!n)
      return this.reporter.error("string objid given, but no values map found");
    if (!n.hasOwnProperty(e))
      return this.reporter.error("objid not found in values map");
    e = n[e].split(/[\s.]+/g);
    for (let l = 0; l < e.length; l++)
      e[l] |= 0;
  } else if (Array.isArray(e)) {
    e = e.slice();
    for (let l = 0; l < e.length; l++)
      e[l] |= 0;
  }
  if (!Array.isArray(e))
    return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
  if (!a) {
    if (e[1] >= 40)
      return this.reporter.error("Second objid identifier OOB");
    e.splice(0, 2, e[0] * 40 + e[1]);
  }
  let c = 0;
  for (let l = 0; l < e.length; l++) {
    let i = e[l];
    for (c++; i >= 128; i >>= 7)
      c++;
  }
  const u = ks.alloc(c);
  let r = u.length - 1;
  for (let l = e.length - 1; l >= 0; l--) {
    let i = e[l];
    for (u[r--] = i & 127; (i >>= 7) > 0; )
      u[r--] = 128 | i & 127;
  }
  return this._createEncoderBuffer(u);
};
function ii(t) {
  return t < 10 ? "0" + t : t;
}
Vi.prototype._encodeTime = function(e, n) {
  let a;
  const c = new Date(e);
  return n === "gentime" ? a = [
    ii(c.getUTCFullYear()),
    ii(c.getUTCMonth() + 1),
    ii(c.getUTCDate()),
    ii(c.getUTCHours()),
    ii(c.getUTCMinutes()),
    ii(c.getUTCSeconds()),
    "Z"
  ].join("") : n === "utctime" ? a = [
    ii(c.getUTCFullYear() % 100),
    ii(c.getUTCMonth() + 1),
    ii(c.getUTCDate()),
    ii(c.getUTCHours()),
    ii(c.getUTCMinutes()),
    ii(c.getUTCSeconds()),
    "Z"
  ].join("") : this.reporter.error("Encoding " + n + " time is not supported yet"), this._encodeStr(a, "octstr");
};
Vi.prototype._encodeNull = function() {
  return this._createEncoderBuffer("");
};
Vi.prototype._encodeInt = function(e, n) {
  if (typeof e == "string") {
    if (!n)
      return this.reporter.error("String int or enum given, but no values map");
    if (!n.hasOwnProperty(e))
      return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
    e = n[e];
  }
  if (typeof e != "number" && !ks.isBuffer(e)) {
    const u = e.toArray();
    !e.sign && u[0] & 128 && u.unshift(0), e = ks.from(u);
  }
  if (ks.isBuffer(e)) {
    let u = e.length;
    e.length === 0 && u++;
    const r = ks.alloc(u);
    return e.copy(r), e.length === 0 && (r[0] = 0), this._createEncoderBuffer(r);
  }
  if (e < 128)
    return this._createEncoderBuffer(e);
  if (e < 256)
    return this._createEncoderBuffer([0, e]);
  let a = 1;
  for (let u = e; u >= 256; u >>= 8)
    a++;
  const c = new Array(a);
  for (let u = c.length - 1; u >= 0; u--)
    c[u] = e & 255, e >>= 8;
  return c[0] & 128 && c.unshift(0), this._createEncoderBuffer(ks.from(c));
};
Vi.prototype._encodeBool = function(e) {
  return this._createEncoderBuffer(e ? 255 : 0);
};
Vi.prototype._use = function(e, n) {
  return typeof e == "function" && (e = e(n)), e._getEncoder("der").tree;
};
Vi.prototype._skipDefault = function(e, n, a) {
  const c = this._baseState;
  let u;
  if (c.default === null)
    return !1;
  const r = e.join();
  if (c.defaultBuffer === void 0 && (c.defaultBuffer = this._encodeValue(c.default, n, a).join()), r.length !== c.defaultBuffer.length)
    return !1;
  for (u = 0; u < r.length; u++)
    if (r[u] !== c.defaultBuffer[u])
      return !1;
  return !0;
};
function M9(t, e, n, a) {
  let c;
  if (t === "seqof" ? t = "seq" : t === "setof" && (t = "set"), am.tagByName.hasOwnProperty(t))
    c = am.tagByName[t];
  else if (typeof t == "number" && (t | 0) === t)
    c = t;
  else
    return a.error("Unknown tag: " + t);
  return c >= 31 ? a.error("Multi-octet tag encoding unsupported") : (e || (c |= 32), c |= am.tagClassByName[n || "universal"] << 6, c);
}
const L9 = Zt, Jy = _x;
function Qy(t) {
  Jy.call(this, t), this.enc = "pem";
}
L9(Qy, Jy);
var j9 = Qy;
Qy.prototype.encode = function(e, n) {
  const c = Jy.prototype.encode.call(this, e).toString("base64"), u = ["-----BEGIN " + n.label + "-----"];
  for (let r = 0; r < c.length; r += 64)
    u.push(c.slice(r, r + 64));
  return u.push("-----END " + n.label + "-----"), u.join(`
`);
};
(function(t) {
  const e = t;
  e.der = _x, e.pem = j9;
})(Ky);
var Zy = {};
const F9 = Zt, B9 = pn, r_ = Ha.DecoderBuffer, Sx = Xy, n_ = op;
function wx(t) {
  this.enc = "der", this.name = t.name, this.entity = t, this.tree = new ri(), this.tree._init(t.body);
}
var Tx = wx;
wx.prototype.decode = function(e, n) {
  return r_.isDecoderBuffer(e) || (e = new r_(e, n)), this.tree._decode(e, n);
};
function ri(t) {
  Sx.call(this, "der", t);
}
F9(ri, Sx);
ri.prototype._peekTag = function(e, n, a) {
  if (e.isEmpty())
    return !1;
  const c = e.save(), u = eb(e, 'Failed to peek tag: "' + n + '"');
  return e.isError(u) ? u : (e.restore(c), u.tag === n || u.tagStr === n || u.tagStr + "of" === n || a);
};
ri.prototype._decodeTag = function(e, n, a) {
  const c = eb(
    e,
    'Failed to decode tag of "' + n + '"'
  );
  if (e.isError(c))
    return c;
  let u = Ax(
    e,
    c.primitive,
    'Failed to get length of "' + n + '"'
  );
  if (e.isError(u))
    return u;
  if (!a && c.tag !== n && c.tagStr !== n && c.tagStr + "of" !== n)
    return e.error('Failed to match tag: "' + n + '"');
  if (c.primitive || u !== null)
    return e.skip(u, 'Failed to match body of: "' + n + '"');
  const r = e.save(), l = this._skipUntilEnd(
    e,
    'Failed to skip indefinite length body: "' + this.tag + '"'
  );
  return e.isError(l) ? l : (u = e.offset - r.offset, e.restore(r), e.skip(u, 'Failed to match body of: "' + n + '"'));
};
ri.prototype._skipUntilEnd = function(e, n) {
  for (; ; ) {
    const a = eb(e, n);
    if (e.isError(a))
      return a;
    const c = Ax(e, a.primitive, n);
    if (e.isError(c))
      return c;
    let u;
    if (a.primitive || c !== null ? u = e.skip(c) : u = this._skipUntilEnd(e, n), e.isError(u))
      return u;
    if (a.tagStr === "end")
      break;
  }
};
ri.prototype._decodeList = function(e, n, a, c) {
  const u = [];
  for (; !e.isEmpty(); ) {
    const r = this._peekTag(e, "end");
    if (e.isError(r))
      return r;
    const l = a.decode(e, "der", c);
    if (e.isError(l) && r)
      break;
    u.push(l);
  }
  return u;
};
ri.prototype._decodeStr = function(e, n) {
  if (n === "bitstr") {
    const a = e.readUInt8();
    return e.isError(a) ? a : { unused: a, data: e.raw() };
  } else if (n === "bmpstr") {
    const a = e.raw();
    if (a.length % 2 === 1)
      return e.error("Decoding of string type: bmpstr length mismatch");
    let c = "";
    for (let u = 0; u < a.length / 2; u++)
      c += String.fromCharCode(a.readUInt16BE(u * 2));
    return c;
  } else if (n === "numstr") {
    const a = e.raw().toString("ascii");
    return this._isNumstr(a) ? a : e.error("Decoding of string type: numstr unsupported characters");
  } else {
    if (n === "octstr")
      return e.raw();
    if (n === "objDesc")
      return e.raw();
    if (n === "printstr") {
      const a = e.raw().toString("ascii");
      return this._isPrintstr(a) ? a : e.error("Decoding of string type: printstr unsupported characters");
    } else
      return /str$/.test(n) ? e.raw().toString() : e.error("Decoding of string type: " + n + " unsupported");
  }
};
ri.prototype._decodeObjid = function(e, n, a) {
  let c;
  const u = [];
  let r = 0, l = 0;
  for (; !e.isEmpty(); )
    l = e.readUInt8(), r <<= 7, r |= l & 127, l & 128 || (u.push(r), r = 0);
  l & 128 && u.push(r);
  const i = u[0] / 40 | 0, f = u[0] % 40;
  if (a ? c = u : c = [i, f].concat(u.slice(1)), n) {
    let d = n[c.join(" ")];
    d === void 0 && (d = n[c.join(".")]), d !== void 0 && (c = d);
  }
  return c;
};
ri.prototype._decodeTime = function(e, n) {
  const a = e.raw().toString();
  let c, u, r, l, i, f;
  if (n === "gentime")
    c = a.slice(0, 4) | 0, u = a.slice(4, 6) | 0, r = a.slice(6, 8) | 0, l = a.slice(8, 10) | 0, i = a.slice(10, 12) | 0, f = a.slice(12, 14) | 0;
  else if (n === "utctime")
    c = a.slice(0, 2) | 0, u = a.slice(2, 4) | 0, r = a.slice(4, 6) | 0, l = a.slice(6, 8) | 0, i = a.slice(8, 10) | 0, f = a.slice(10, 12) | 0, c < 70 ? c = 2e3 + c : c = 1900 + c;
  else
    return e.error("Decoding " + n + " time is not supported yet");
  return Date.UTC(c, u - 1, r, l, i, f, 0);
};
ri.prototype._decodeNull = function() {
  return null;
};
ri.prototype._decodeBool = function(e) {
  const n = e.readUInt8();
  return e.isError(n) ? n : n !== 0;
};
ri.prototype._decodeInt = function(e, n) {
  const a = e.raw();
  let c = new B9(a);
  return n && (c = n[c.toString(10)] || c), c;
};
ri.prototype._use = function(e, n) {
  return typeof e == "function" && (e = e(n)), e._getDecoder("der").tree;
};
function eb(t, e) {
  let n = t.readUInt8(e);
  if (t.isError(n))
    return n;
  const a = n_.tagClass[n >> 6], c = (n & 32) === 0;
  if ((n & 31) === 31) {
    let r = n;
    for (n = 0; (r & 128) === 128; ) {
      if (r = t.readUInt8(e), t.isError(r))
        return r;
      n <<= 7, n |= r & 127;
    }
  } else
    n &= 31;
  const u = n_.tag[n];
  return {
    cls: a,
    primitive: c,
    tag: n,
    tagStr: u
  };
}
function Ax(t, e, n) {
  let a = t.readUInt8(n);
  if (t.isError(a))
    return a;
  if (!e && a === 128)
    return null;
  if (!(a & 128))
    return a;
  const c = a & 127;
  if (c > 4)
    return t.error("length octect is too long");
  a = 0;
  for (let u = 0; u < c; u++) {
    a <<= 8;
    const r = t.readUInt8(n);
    if (t.isError(r))
      return r;
    a |= r;
  }
  return a;
}
const $9 = Zt, U9 = Yy.Buffer, tb = Tx;
function rb(t) {
  tb.call(this, t), this.enc = "pem";
}
$9(rb, tb);
var V9 = rb;
rb.prototype.decode = function(e, n) {
  const a = e.toString().split(/[\r\n]+/g), c = n.label.toUpperCase(), u = /^-----(BEGIN|END) ([^-]+)-----$/;
  let r = -1, l = -1;
  for (let d = 0; d < a.length; d++) {
    const s = a[d].match(u);
    if (s !== null && s[2] === c)
      if (r === -1) {
        if (s[1] !== "BEGIN")
          break;
        r = d;
      } else {
        if (s[1] !== "END")
          break;
        l = d;
        break;
      }
  }
  if (r === -1 || l === -1)
    throw new Error("PEM section not found for: " + c);
  const i = a.slice(r + 1, l).join("");
  i.replace(/[^a-z0-9+/=]+/gi, "");
  const f = U9.from(i, "base64");
  return tb.prototype.decode.call(this, f, n);
};
(function(t) {
  const e = t;
  e.der = Tx, e.pem = V9;
})(Zy);
(function(t) {
  const e = Ky, n = Zy, a = Zt, c = t;
  c.define = function(l, i) {
    return new u(l, i);
  };
  function u(r, l) {
    this.name = r, this.body = l, this.decoders = {}, this.encoders = {};
  }
  u.prototype._createNamed = function(l) {
    const i = this.name;
    function f(d) {
      this._initNamed(d, i);
    }
    return a(f, l), f.prototype._initNamed = function(s, o) {
      l.call(this, s, o);
    }, new f(this);
  }, u.prototype._getDecoder = function(l) {
    return l = l || "der", this.decoders.hasOwnProperty(l) || (this.decoders[l] = this._createNamed(n[l])), this.decoders[l];
  }, u.prototype.decode = function(l, i, f) {
    return this._getDecoder(i).decode(l, f);
  }, u.prototype._getEncoder = function(l) {
    return l = l || "der", this.encoders.hasOwnProperty(l) || (this.encoders[l] = this._createNamed(e[l])), this.encoders[l];
  }, u.prototype.encode = function(l, i, f) {
    return this._getEncoder(i).encode(l, f);
  };
})(bx);
var xx = {};
(function(t) {
  const e = t;
  e.Reporter = sp.Reporter, e.DecoderBuffer = Ha.DecoderBuffer, e.EncoderBuffer = Ha.EncoderBuffer, e.Node = Xy;
})(xx);
var Px = {};
(function(t) {
  const e = t;
  e._reverse = function(a) {
    const c = {};
    return Object.keys(a).forEach(function(u) {
      (u | 0) == u && (u = u | 0);
      const r = a[u];
      c[r] = u;
    }), c;
  }, e.der = op;
})(Px);
(function(t) {
  const e = t;
  e.bignum = pn, e.define = bx.define, e.base = xx, e.constants = Px, e.decoders = Zy, e.encoders = Ky;
})(zy);
var Wi = zy, i_ = Wi.define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
}), W9 = Wi.define("AttributeTypeValue", function() {
  this.seq().obj(
    this.key("type").objid(),
    this.key("value").any()
  );
}), nb = Wi.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("parameters").optional(),
    this.key("curve").objid().optional()
  );
}), H9 = Wi.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(nb),
    this.key("subjectPublicKey").bitstr()
  );
}), q9 = Wi.define("RelativeDistinguishedName", function() {
  this.setof(W9);
}), G9 = Wi.define("RDNSequence", function() {
  this.seqof(q9);
}), s_ = Wi.define("Name", function() {
  this.choice({
    rdnSequence: this.use(G9)
  });
}), z9 = Wi.define("Validity", function() {
  this.seq().obj(
    this.key("notBefore").use(i_),
    this.key("notAfter").use(i_)
  );
}), K9 = Wi.define("Extension", function() {
  this.seq().obj(
    this.key("extnID").objid(),
    this.key("critical").bool().def(!1),
    this.key("extnValue").octstr()
  );
}), Y9 = Wi.define("TBSCertificate", function() {
  this.seq().obj(
    this.key("version").explicit(0).int().optional(),
    this.key("serialNumber").int(),
    this.key("signature").use(nb),
    this.key("issuer").use(s_),
    this.key("validity").use(z9),
    this.key("subject").use(s_),
    this.key("subjectPublicKeyInfo").use(H9),
    this.key("issuerUniqueID").implicit(1).bitstr().optional(),
    this.key("subjectUniqueID").implicit(2).bitstr().optional(),
    this.key("extensions").explicit(3).seqof(K9).optional()
  );
}), X9 = Wi.define("X509Certificate", function() {
  this.seq().obj(
    this.key("tbsCertificate").use(Y9),
    this.key("signatureAlgorithm").use(nb),
    this.key("signatureValue").bitstr()
  );
}), J9 = X9, Hi = zy;
Ui.certificate = J9;
var Q9 = Hi.define("RSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("modulus").int(),
    this.key("publicExponent").int(),
    this.key("privateExponent").int(),
    this.key("prime1").int(),
    this.key("prime2").int(),
    this.key("exponent1").int(),
    this.key("exponent2").int(),
    this.key("coefficient").int()
  );
});
Ui.RSAPrivateKey = Q9;
var Z9 = Hi.define("RSAPublicKey", function() {
  this.seq().obj(
    this.key("modulus").int(),
    this.key("publicExponent").int()
  );
});
Ui.RSAPublicKey = Z9;
var eB = Hi.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(Cx),
    this.key("subjectPublicKey").bitstr()
  );
});
Ui.PublicKey = eB;
var Cx = Hi.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("none").null_().optional(),
    this.key("curve").objid().optional(),
    this.key("params").seq().obj(
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int()
    ).optional()
  );
}), tB = Hi.define("PrivateKeyInfo", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("algorithm").use(Cx),
    this.key("subjectPrivateKey").octstr()
  );
});
Ui.PrivateKey = tB;
var rB = Hi.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").seq().obj(
      this.key("id").objid(),
      this.key("decrypt").seq().obj(
        this.key("kde").seq().obj(
          this.key("id").objid(),
          this.key("kdeparams").seq().obj(
            this.key("salt").octstr(),
            this.key("iters").int()
          )
        ),
        this.key("cipher").seq().obj(
          this.key("algo").objid(),
          this.key("iv").octstr()
        )
      )
    ),
    this.key("subjectPrivateKey").octstr()
  );
});
Ui.EncryptedPrivateKey = rB;
var nB = Hi.define("DSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("p").int(),
    this.key("q").int(),
    this.key("g").int(),
    this.key("pub_key").int(),
    this.key("priv_key").int()
  );
});
Ui.DSAPrivateKey = nB;
Ui.DSAparam = Hi.define("DSAparam", function() {
  this.int();
});
var iB = Hi.define("ECPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("privateKey").octstr(),
    this.key("parameters").optional().explicit(0).use(sB),
    this.key("publicKey").optional().explicit(1).bitstr()
  );
});
Ui.ECPrivateKey = iB;
var sB = Hi.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
});
Ui.signature = Hi.define("signature", function() {
  this.seq().obj(
    this.key("r").int(),
    this.key("s").int()
  );
});
const aB = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var oB = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, lB = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, uB = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, cB = zd, fB = Qn, Bc = er.Buffer, dB = function(t, e) {
  var n = t.toString(), a = n.match(oB), c;
  if (a) {
    var r = "aes" + a[1], l = Bc.from(a[2], "hex"), i = Bc.from(a[3].replace(/[\r\n]/g, ""), "base64"), f = cB(e, l.slice(0, 8), parseInt(a[1], 10)).key, d = [], s = fB.createDecipheriv(r, f, l);
    d.push(s.update(i)), d.push(s.final()), c = Bc.concat(d);
  } else {
    var u = n.match(uB);
    c = Bc.from(u[2].replace(/[\r\n]/g, ""), "base64");
  }
  var o = n.match(lB)[1];
  return {
    tag: o,
    data: c
  };
}, $n = Ui, pB = aB, hB = dB, mB = Qn, yB = Hd, J1 = er.Buffer, lp = Ix;
function Ix(t) {
  var e;
  typeof t == "object" && !J1.isBuffer(t) && (e = t.passphrase, t = t.key), typeof t == "string" && (t = J1.from(t));
  var n = hB(t, e), a = n.tag, c = n.data, u, r;
  switch (a) {
    case "CERTIFICATE":
      r = $n.certificate.decode(c, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      switch (r || (r = $n.PublicKey.decode(c, "der")), u = r.algorithm.algorithm.join("."), u) {
        case "1.2.840.113549.1.1.1":
          return $n.RSAPublicKey.decode(r.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          return r.subjectPrivateKey = r.subjectPublicKey, {
            type: "ec",
            data: r
          };
        case "1.2.840.10040.4.1":
          return r.algorithm.params.pub_key = $n.DSAparam.decode(r.subjectPublicKey.data, "der"), {
            type: "dsa",
            data: r.algorithm.params
          };
        default:
          throw new Error("unknown key id " + u);
      }
    case "ENCRYPTED PRIVATE KEY":
      c = $n.EncryptedPrivateKey.decode(c, "der"), c = bB(c, e);
    case "PRIVATE KEY":
      switch (r = $n.PrivateKey.decode(c, "der"), u = r.algorithm.algorithm.join("."), u) {
        case "1.2.840.113549.1.1.1":
          return $n.RSAPrivateKey.decode(r.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: r.algorithm.curve,
            privateKey: $n.ECPrivateKey.decode(r.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          return r.algorithm.params.priv_key = $n.DSAparam.decode(r.subjectPrivateKey, "der"), {
            type: "dsa",
            params: r.algorithm.params
          };
        default:
          throw new Error("unknown key id " + u);
      }
    case "RSA PUBLIC KEY":
      return $n.RSAPublicKey.decode(c, "der");
    case "RSA PRIVATE KEY":
      return $n.RSAPrivateKey.decode(c, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: $n.DSAPrivateKey.decode(c, "der")
      };
    case "EC PRIVATE KEY":
      return c = $n.ECPrivateKey.decode(c, "der"), {
        curve: c.parameters.value,
        privateKey: c.privateKey
      };
    default:
      throw new Error("unknown key type " + a);
  }
}
Ix.signature = $n.signature;
function bB(t, e) {
  var n = t.algorithm.decrypt.kde.kdeparams.salt, a = parseInt(t.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), c = pB[t.algorithm.decrypt.cipher.algo.join(".")], u = t.algorithm.decrypt.cipher.iv, r = t.subjectPrivateKey, l = parseInt(c.split("-")[1], 10) / 8, i = yB.pbkdf2Sync(e, n, a, l, "sha1"), f = mB.createDecipheriv(c, i, u), d = [];
  return d.push(f.update(r)), d.push(f.final()), J1.concat(d);
}
const Ox = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var a_;
function gB() {
  if (a_)
    return Nl.exports;
  a_ = 1;
  var t = er.Buffer, e = tA, n = Uy, a = Gy().ec, c = $y, u = lp, r = Ox, l = 1;
  function i(E, S, g, P, R) {
    var N = u(S);
    if (N.curve) {
      if (P !== "ecdsa" && P !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return f(E, N);
    } else if (N.type === "dsa") {
      if (P !== "dsa")
        throw new Error("wrong private key type");
      return d(E, N, g);
    }
    if (P !== "rsa" && P !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (S.padding !== void 0 && S.padding !== l)
      throw new Error("illegal or unsupported padding mode");
    E = t.concat([R, E]);
    for (var C = N.modulus.byteLength(), I = [0, 1]; E.length + I.length + 1 < C; )
      I.push(255);
    I.push(0);
    for (var D = -1; ++D < E.length; )
      I.push(E[D]);
    var j = n(I, N);
    return j;
  }
  function f(E, S) {
    var g = r[S.curve.join(".")];
    if (!g)
      throw new Error("unknown curve " + S.curve.join("."));
    var P = new a(g), R = P.keyFromPrivate(S.privateKey), N = R.sign(E);
    return t.from(N.toDER());
  }
  function d(E, S, g) {
    for (var P = S.params.priv_key, R = S.params.p, N = S.params.q, C = S.params.g, I = new c(0), D, j = m(E, N).mod(N), F = !1, _ = o(P, N, E, g); F === !1; )
      D = y(N, _, g), I = b(C, D, R, N), F = D.invm(N).imul(j.add(P.mul(I))).mod(N), F.cmpn(0) === 0 && (F = !1, I = new c(0));
    return s(I, F);
  }
  function s(E, S) {
    E = E.toArray(), S = S.toArray(), E[0] & 128 && (E = [0].concat(E)), S[0] & 128 && (S = [0].concat(S));
    var g = E.length + S.length + 4, P = [
      48,
      g,
      2,
      E.length
    ];
    return P = P.concat(E, [2, S.length], S), t.from(P);
  }
  function o(E, S, g, P) {
    if (E = t.from(E.toArray()), E.length < S.byteLength()) {
      var R = t.alloc(S.byteLength() - E.length);
      E = t.concat([R, E]);
    }
    var N = g.length, C = h(g, S), I = t.alloc(N);
    I.fill(1);
    var D = t.alloc(N);
    return D = e(P, D).update(I).update(t.from([0])).update(E).update(C).digest(), I = e(P, D).update(I).digest(), D = e(P, D).update(I).update(t.from([1])).update(E).update(C).digest(), I = e(P, D).update(I).digest(), { k: D, v: I };
  }
  function m(E, S) {
    var g = new c(E), P = (E.length << 3) - S.bitLength();
    return P > 0 && g.ishrn(P), g;
  }
  function h(E, S) {
    E = m(E, S), E = E.mod(S);
    var g = t.from(E.toArray());
    if (g.length < S.byteLength()) {
      var P = t.alloc(S.byteLength() - g.length);
      g = t.concat([P, g]);
    }
    return g;
  }
  function y(E, S, g) {
    var P, R;
    do {
      for (P = t.alloc(0); P.length * 8 < E.bitLength(); )
        S.v = e(g, S.k).update(S.v).digest(), P = t.concat([P, S.v]);
      R = m(P, E), S.k = e(g, S.k).update(S.v).update(t.from([0])).digest(), S.v = e(g, S.k).update(S.v).digest();
    } while (R.cmp(E) !== -1);
    return R;
  }
  function b(E, S, g, P) {
    return E.toRed(c.mont(g)).redPow(S).fromRed().mod(P);
  }
  return Nl.exports = i, Nl.exports.getKey = o, Nl.exports.makeKey = y, Nl.exports;
}
var om, o_;
function vB() {
  if (o_)
    return om;
  o_ = 1;
  var t = er.Buffer, e = $y, n = Gy().ec, a = lp, c = Ox;
  function u(f, d, s, o, m) {
    var h = a(s);
    if (h.type === "ec") {
      if (o !== "ecdsa" && o !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return r(f, d, h);
    } else if (h.type === "dsa") {
      if (o !== "dsa")
        throw new Error("wrong public key type");
      return l(f, d, h);
    }
    if (o !== "rsa" && o !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    d = t.concat([m, d]);
    for (var y = h.modulus.byteLength(), b = [1], E = 0; d.length + b.length + 2 < y; )
      b.push(255), E += 1;
    b.push(0);
    for (var S = -1; ++S < d.length; )
      b.push(d[S]);
    b = t.from(b);
    var g = e.mont(h.modulus);
    f = new e(f).toRed(g), f = f.redPow(new e(h.publicExponent)), f = t.from(f.fromRed().toArray());
    var P = E < 8 ? 1 : 0;
    for (y = Math.min(f.length, b.length), f.length !== b.length && (P = 1), S = -1; ++S < y; )
      P |= f[S] ^ b[S];
    return P === 0;
  }
  function r(f, d, s) {
    var o = c[s.data.algorithm.curve.join(".")];
    if (!o)
      throw new Error("unknown curve " + s.data.algorithm.curve.join("."));
    var m = new n(o), h = s.data.subjectPrivateKey.data;
    return m.verify(d, f, h);
  }
  function l(f, d, s) {
    var o = s.data.p, m = s.data.q, h = s.data.g, y = s.data.pub_key, b = a.signature.decode(f, "der"), E = b.s, S = b.r;
    i(E, m), i(S, m);
    var g = e.mont(o), P = E.invm(m), R = h.toRed(g).redPow(new e(d).mul(P).mod(m)).fromRed().mul(y.toRed(g).redPow(S.mul(P).mod(m)).fromRed()).mod(o).mod(m);
    return R.cmp(S) === 0;
  }
  function i(f, d) {
    if (f.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (f.cmp(d) >= 0)
      throw new Error("invalid sig");
  }
  return om = u, om;
}
var lm, l_;
function EB() {
  if (l_)
    return lm;
  l_ = 1;
  var t = er.Buffer, e = Bu, n = LT, a = Zt, c = gB(), u = vB(), r = rA;
  Object.keys(r).forEach(function(s) {
    r[s].id = t.from(r[s].id, "hex"), r[s.toLowerCase()] = r[s];
  });
  function l(s) {
    n.Writable.call(this);
    var o = r[s];
    if (!o)
      throw new Error("Unknown message digest");
    this._hashType = o.hash, this._hash = e(o.hash), this._tag = o.id, this._signType = o.sign;
  }
  a(l, n.Writable), l.prototype._write = function(o, m, h) {
    this._hash.update(o), h();
  }, l.prototype.update = function(o, m) {
    return this._hash.update(typeof o == "string" ? t.from(o, m) : o), this;
  }, l.prototype.sign = function(o, m) {
    this.end();
    var h = this._hash.digest(), y = c(h, o, this._hashType, this._signType, this._tag);
    return m ? y.toString(m) : y;
  };
  function i(s) {
    n.Writable.call(this);
    var o = r[s];
    if (!o)
      throw new Error("Unknown message digest");
    this._hash = e(o.hash), this._tag = o.id, this._signType = o.sign;
  }
  a(i, n.Writable), i.prototype._write = function(o, m, h) {
    this._hash.update(o), h();
  }, i.prototype.update = function(o, m) {
    return this._hash.update(typeof o == "string" ? t.from(o, m) : o), this;
  }, i.prototype.verify = function(o, m, h) {
    var y = typeof m == "string" ? t.from(m, h) : m;
    this.end();
    var b = this._hash.digest();
    return u(y, b, o, this._signType, this._tag);
  };
  function f(s) {
    return new l(s);
  }
  function d(s) {
    return new i(s);
  }
  return lm = {
    Sign: f,
    Verify: d,
    createSign: f,
    createVerify: d
  }, lm;
}
var um, u_;
function _B() {
  if (u_)
    return um;
  u_ = 1;
  var t = Gy(), e = pn;
  um = function(r) {
    return new a(r);
  };
  var n = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  n.p224 = n.secp224r1, n.p256 = n.secp256r1 = n.prime256v1, n.p192 = n.secp192r1 = n.prime192v1, n.p384 = n.secp384r1, n.p521 = n.secp521r1;
  function a(u) {
    this.curveType = n[u], this.curveType || (this.curveType = {
      name: u
    }), this.curve = new t.ec(this.curveType.name), this.keys = void 0;
  }
  a.prototype.generateKeys = function(u, r) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(u, r);
  }, a.prototype.computeSecret = function(u, r, l) {
    r = r || "utf8", Ve.Buffer.isBuffer(u) || (u = new Ve.Buffer(u, r));
    var i = this.curve.keyFromPublic(u).getPublic(), f = i.mul(this.keys.getPrivate()).getX();
    return c(f, l, this.curveType.byteLength);
  }, a.prototype.getPublicKey = function(u, r) {
    var l = this.keys.getPublic(r === "compressed", !0);
    return r === "hybrid" && (l[l.length - 1] % 2 ? l[0] = 7 : l[0] = 6), c(l, u);
  }, a.prototype.getPrivateKey = function(u) {
    return c(this.keys.getPrivate(), u);
  }, a.prototype.setPublicKey = function(u, r) {
    return r = r || "utf8", Ve.Buffer.isBuffer(u) || (u = new Ve.Buffer(u, r)), this.keys._importPublic(u), this;
  }, a.prototype.setPrivateKey = function(u, r) {
    r = r || "utf8", Ve.Buffer.isBuffer(u) || (u = new Ve.Buffer(u, r));
    var l = new e(u);
    return l = l.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(l), this;
  };
  function c(u, r, l) {
    Array.isArray(u) || (u = u.toArray());
    var i = new Ve.Buffer(u);
    if (l && i.length < l) {
      var f = new Ve.Buffer(l - i.length);
      f.fill(0), i = Ve.Buffer.concat([f, i]);
    }
    return r ? i.toString(r) : i;
  }
  return um;
}
var kx = {}, SB = Bu, Q1 = er.Buffer, Dx = function(t, e) {
  for (var n = Q1.alloc(0), a = 0, c; n.length < e; )
    c = wB(a++), n = Q1.concat([n, SB("sha1").update(t).update(c).digest()]);
  return n.slice(0, e);
};
function wB(t) {
  var e = Q1.allocUnsafe(4);
  return e.writeUInt32BE(t, 0), e;
}
var Nx = function(e, n) {
  for (var a = e.length, c = -1; ++c < a; )
    e[c] ^= n[c];
  return e;
}, c_ = pn, TB = er.Buffer;
function AB(t, e) {
  return TB.from(t.toRed(c_.mont(e.modulus)).redPow(new c_(e.publicExponent)).fromRed().toArray());
}
var Rx = AB, xB = lp, Z1 = nl, PB = Bu, f_ = Dx, d_ = Nx, ib = pn, CB = Rx, IB = Uy, Ni = er.Buffer, OB = function(e, n, a) {
  var c;
  e.padding ? c = e.padding : a ? c = 1 : c = 4;
  var u = xB(e), r;
  if (c === 4)
    r = kB(u, n);
  else if (c === 1)
    r = DB(u, n, a);
  else if (c === 3) {
    if (r = new ib(n), r.cmp(u.modulus) >= 0)
      throw new Error("data too long for modulus");
  } else
    throw new Error("unknown padding");
  return a ? IB(r, u) : CB(r, u);
};
function kB(t, e) {
  var n = t.modulus.byteLength(), a = e.length, c = PB("sha1").update(Ni.alloc(0)).digest(), u = c.length, r = 2 * u;
  if (a > n - r - 2)
    throw new Error("message too long");
  var l = Ni.alloc(n - a - r - 2), i = n - u - 1, f = Z1(u), d = d_(Ni.concat([c, l, Ni.alloc(1, 1), e], i), f_(f, i)), s = d_(f, f_(d, u));
  return new ib(Ni.concat([Ni.alloc(1), s, d], n));
}
function DB(t, e, n) {
  var a = e.length, c = t.modulus.byteLength();
  if (a > c - 11)
    throw new Error("message too long");
  var u;
  return n ? u = Ni.alloc(c - a - 3, 255) : u = NB(c - a - 3), new ib(Ni.concat([Ni.from([0, n ? 1 : 2]), u, Ni.alloc(1), e], c));
}
function NB(t) {
  for (var e = Ni.allocUnsafe(t), n = 0, a = Z1(t * 2), c = 0, u; n < t; )
    c === a.length && (a = Z1(t * 2), c = 0), u = a[c++], u && (e[n++] = u);
  return e;
}
var RB = lp, p_ = Dx, h_ = Nx, m_ = pn, MB = Uy, LB = Bu, jB = Rx, du = er.Buffer, FB = function(e, n, a) {
  var c;
  e.padding ? c = e.padding : a ? c = 1 : c = 4;
  var u = RB(e), r = u.modulus.byteLength();
  if (n.length > r || new m_(n).cmp(u.modulus) >= 0)
    throw new Error("decryption error");
  var l;
  a ? l = jB(new m_(n), u) : l = MB(n, u);
  var i = du.alloc(r - l.length);
  if (l = du.concat([i, l], r), c === 4)
    return BB(u, l);
  if (c === 1)
    return $B(u, l, a);
  if (c === 3)
    return l;
  throw new Error("unknown padding");
};
function BB(t, e) {
  var n = t.modulus.byteLength(), a = LB("sha1").update(du.alloc(0)).digest(), c = a.length;
  if (e[0] !== 0)
    throw new Error("decryption error");
  var u = e.slice(1, c + 1), r = e.slice(c + 1), l = h_(u, p_(r, c)), i = h_(r, p_(l, n - c - 1));
  if (UB(a, i.slice(0, c)))
    throw new Error("decryption error");
  for (var f = c; i[f] === 0; )
    f++;
  if (i[f++] !== 1)
    throw new Error("decryption error");
  return i.slice(f);
}
function $B(t, e, n) {
  for (var a = e.slice(0, 2), c = 2, u = 0; e[c++] !== 0; )
    if (c >= e.length) {
      u++;
      break;
    }
  var r = e.slice(2, c - 1);
  if ((a.toString("hex") !== "0002" && !n || a.toString("hex") !== "0001" && n) && u++, r.length < 8 && u++, u)
    throw new Error("decryption error");
  return e.slice(c);
}
function UB(t, e) {
  t = du.from(t), e = du.from(e);
  var n = 0, a = t.length;
  t.length !== e.length && (n++, a = Math.min(t.length, e.length));
  for (var c = -1; ++c < a; )
    n += t[c] ^ e[c];
  return n;
}
(function(t) {
  t.publicEncrypt = OB, t.privateDecrypt = FB, t.privateEncrypt = function(n, a) {
    return t.publicEncrypt(n, a, !0);
  }, t.publicDecrypt = function(n, a) {
    return t.privateDecrypt(n, a, !0);
  };
})(kx);
var Wl = {};
function y_() {
  throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
}
var Mx = er, b_ = nl, Lx = Mx.Buffer, jx = Mx.kMaxLength, e0 = Bt.crypto || Bt.msCrypto, Fx = Math.pow(2, 32) - 1;
function Bx(t, e) {
  if (typeof t != "number" || t !== t)
    throw new TypeError("offset must be a number");
  if (t > Fx || t < 0)
    throw new TypeError("offset must be a uint32");
  if (t > jx || t > e)
    throw new RangeError("offset out of range");
}
function $x(t, e, n) {
  if (typeof t != "number" || t !== t)
    throw new TypeError("size must be a number");
  if (t > Fx || t < 0)
    throw new TypeError("size must be a uint32");
  if (t + e > n || t > jx)
    throw new RangeError("buffer too small");
}
e0 && e0.getRandomValues || !Ve.process.browser ? (Wl.randomFill = VB, Wl.randomFillSync = WB) : (Wl.randomFill = y_, Wl.randomFillSync = y_);
function VB(t, e, n, a) {
  if (!Lx.isBuffer(t) && !(t instanceof Bt.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  if (typeof e == "function")
    a = e, e = 0, n = t.length;
  else if (typeof n == "function")
    a = n, n = t.length - e;
  else if (typeof a != "function")
    throw new TypeError('"cb" argument must be a function');
  return Bx(e, t.length), $x(n, e, t.length), Ux(t, e, n, a);
}
function Ux(t, e, n, a) {
  if (Ve.process.browser) {
    var c = t.buffer, u = new Uint8Array(c, e, n);
    if (e0.getRandomValues(u), a) {
      Ve.process.nextTick(function() {
        a(null, t);
      });
      return;
    }
    return t;
  }
  if (a) {
    b_(n, function(l, i) {
      if (l)
        return a(l);
      i.copy(t, e), a(null, t);
    });
    return;
  }
  var r = b_(n);
  return r.copy(t, e), t;
}
function WB(t, e, n) {
  if (typeof e > "u" && (e = 0), !Lx.isBuffer(t) && !(t instanceof Bt.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  return Bx(e, t.length), n === void 0 && (n = t.length - e), $x(n, e, t.length), Ux(t, e, n);
}
var g_;
function sb() {
  if (g_)
    return Yt;
  g_ = 1, Yt.randomBytes = Yt.rng = Yt.pseudoRandomBytes = Yt.prng = nl, Yt.createHash = Yt.Hash = Bu, Yt.createHmac = Yt.Hmac = tA;
  var t = OM, e = Object.keys(t), n = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(e);
  Yt.getHashes = function() {
    return n;
  };
  var a = Hd;
  Yt.pbkdf2 = a.pbkdf2, Yt.pbkdf2Sync = a.pbkdf2Sync;
  var c = Mi;
  Yt.Cipher = c.Cipher, Yt.createCipher = c.createCipher, Yt.Cipheriv = c.Cipheriv, Yt.createCipheriv = c.createCipheriv, Yt.Decipher = c.Decipher, Yt.createDecipher = c.createDecipher, Yt.Decipheriv = c.Decipheriv, Yt.createDecipheriv = c.createDecipheriv, Yt.getCiphers = c.getCiphers, Yt.listCiphers = c.listCiphers;
  var u = lj();
  Yt.DiffieHellmanGroup = u.DiffieHellmanGroup, Yt.createDiffieHellmanGroup = u.createDiffieHellmanGroup, Yt.getDiffieHellman = u.getDiffieHellman, Yt.createDiffieHellman = u.createDiffieHellman, Yt.DiffieHellman = u.DiffieHellman;
  var r = EB();
  Yt.createSign = r.createSign, Yt.Sign = r.Sign, Yt.createVerify = r.createVerify, Yt.Verify = r.Verify, Yt.createECDH = _B();
  var l = kx;
  Yt.publicEncrypt = l.publicEncrypt, Yt.privateEncrypt = l.privateEncrypt, Yt.publicDecrypt = l.publicDecrypt, Yt.privateDecrypt = l.privateDecrypt;
  var i = Wl;
  return Yt.randomFill = i.randomFill, Yt.randomFillSync = i.randomFillSync, Yt.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, Yt.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, Yt;
}
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "hasContentChanged", {
    enumerable: !0,
    get: function() {
      return l;
    }
  });
  const e = /* @__PURE__ */ a(sb()), n = /* @__PURE__ */ u(Xa);
  function a(i) {
    return i && i.__esModule ? i : {
      default: i
    };
  }
  function c(i) {
    if (typeof WeakMap != "function")
      return null;
    var f = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakMap();
    return (c = function(s) {
      return s ? d : f;
    })(i);
  }
  function u(i, f) {
    if (!f && i && i.__esModule)
      return i;
    if (i === null || typeof i != "object" && typeof i != "function")
      return {
        default: i
      };
    var d = c(f);
    if (d && d.has(i))
      return d.get(i);
    var s = {}, o = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var m in i)
      if (m !== "default" && Object.prototype.hasOwnProperty.call(i, m)) {
        var h = o ? Object.getOwnPropertyDescriptor(i, m) : null;
        h && (h.get || h.set) ? Object.defineProperty(s, m, h) : s[m] = i[m];
      }
    return s.default = i, d && d.set(i, s), s;
  }
  function r(i) {
    try {
      return e.default.createHash("md5").update(i, "utf-8").digest("binary");
    } catch {
      return "";
    }
  }
  function l(i, f) {
    let d = f.toString();
    if (!d.includes("@tailwind"))
      return !1;
    let s = n.sourceHashMap.get(i), o = r(d), m = s !== o;
    return n.sourceHashMap.set(i, o), m;
  }
})(AT);
var Vx = {}, Wx = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(n) {
    return (n > 0n) - (n < 0n);
  }
})(Wx);
var Hx = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "remapBitfield", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(n, a) {
    let c = 0n, u = 0n;
    for (let [r, l] of a)
      n & r && (c = c | r, u = u | l);
    return n & ~c | u;
  }
})(Hx);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "Offsets", {
    enumerable: !0,
    get: function() {
      return c;
    }
  });
  const e = /* @__PURE__ */ a(Wx), n = Hx;
  function a(l) {
    return l && l.__esModule ? l : {
      default: l
    };
  }
  class c {
    constructor() {
      this.offsets = {
        defaults: 0n,
        base: 0n,
        components: 0n,
        utilities: 0n,
        variants: 0n,
        user: 0n
      }, this.layerPositions = {
        defaults: 0n,
        base: 1n,
        components: 2n,
        utilities: 3n,
        // There isn't technically a "user" layer, but we need to give it a position
        // Because it's used for ordering user-css from @apply
        user: 4n,
        variants: 5n
      }, this.reservedVariantBits = 0n, this.variantOffsets = /* @__PURE__ */ new Map();
    }
    /**
    * @param {Layer} layer
    * @returns {RuleOffset}
    */
    create(i) {
      return {
        layer: i,
        parentLayer: i,
        arbitrary: 0n,
        variants: 0n,
        parallelIndex: 0n,
        index: this.offsets[i]++,
        options: []
      };
    }
    /**
    * @returns {RuleOffset}
    */
    arbitraryProperty() {
      return {
        ...this.create("utilities"),
        arbitrary: 1n
      };
    }
    /**
    * Get the offset for a variant
    *
    * @param {string} variant
    * @param {number} index
    * @returns {RuleOffset}
    */
    forVariant(i, f = 0) {
      let d = this.variantOffsets.get(i);
      if (d === void 0)
        throw new Error(`Cannot find offset for unknown variant ${i}`);
      return {
        ...this.create("variants"),
        variants: d << BigInt(f)
      };
    }
    /**
    * @param {RuleOffset} rule
    * @param {RuleOffset} variant
    * @param {VariantOption} options
    * @returns {RuleOffset}
    */
    applyVariantOffset(i, f, d) {
      return d.variant = f.variants, {
        ...i,
        layer: "variants",
        parentLayer: i.layer === "variants" ? i.parentLayer : i.layer,
        variants: i.variants | f.variants,
        options: d.sort ? [].concat(d, i.options) : i.options,
        // TODO: Technically this is wrong. We should be handling parallel index on a per variant basis.
        // We'll take the max of all the parallel indexes for now.
        // @ts-ignore
        parallelIndex: u([
          i.parallelIndex,
          f.parallelIndex
        ])
      };
    }
    /**
    * @param {RuleOffset} offset
    * @param {number} parallelIndex
    * @returns {RuleOffset}
    */
    applyParallelOffset(i, f) {
      return {
        ...i,
        parallelIndex: BigInt(f)
      };
    }
    /**
    * Each variant gets 1 bit per function / rule registered.
    * This is because multiple variants can be applied to a single rule and we need to know which ones are present and which ones are not.
    * Additionally, every unique group of variants is grouped together in the stylesheet.
    *
    * This grouping is order-independent. For instance, we do not differentiate between `hover:focus` and `focus:hover`.
    *
    * @param {string[]} variants
    * @param {(name: string) => number} getLength
    */
    recordVariants(i, f) {
      for (let d of i)
        this.recordVariant(d, f(d));
    }
    /**
    * The same as `recordVariants` but for a single arbitrary variant at runtime.
    * @param {string} variant
    * @param {number} fnCount
    *
    * @returns {RuleOffset} The highest offset for this variant
    */
    recordVariant(i, f = 1) {
      return this.variantOffsets.set(i, 1n << this.reservedVariantBits), this.reservedVariantBits += BigInt(f), {
        ...this.create("variants"),
        variants: this.variantOffsets.get(i)
      };
    }
    /**
    * @param {RuleOffset} a
    * @param {RuleOffset} b
    * @returns {bigint}
    */
    compare(i, f) {
      if (i.layer !== f.layer)
        return this.layerPositions[i.layer] - this.layerPositions[f.layer];
      if (i.parentLayer !== f.parentLayer)
        return this.layerPositions[i.parentLayer] - this.layerPositions[f.parentLayer];
      for (let s of i.options)
        for (let o of f.options) {
          if (s.id !== o.id || !s.sort || !o.sort)
            continue;
          var d;
          let m = (d = u([
            s.variant,
            o.variant
          ])) !== null && d !== void 0 ? d : 0n, h = ~(m | m - 1n), y = i.variants & h, b = f.variants & h;
          if (y !== b)
            continue;
          let E = s.sort({
            value: s.value,
            modifier: s.modifier
          }, {
            value: o.value,
            modifier: o.modifier
          });
          if (E !== 0)
            return E;
        }
      return i.variants !== f.variants ? i.variants - f.variants : i.parallelIndex !== f.parallelIndex ? i.parallelIndex - f.parallelIndex : i.arbitrary !== f.arbitrary ? i.arbitrary - f.arbitrary : i.index - f.index;
    }
    /**
    * Arbitrary variants are recorded in the order they're encountered.
    * This means that the order is not stable between environments and sets of content files.
    *
    * In order to make the order stable, we need to remap the arbitrary variant offsets to
    * be in alphabetical order starting from the offset of the first arbitrary variant.
    */
    recalculateVariantOffsets() {
      let i = Array.from(this.variantOffsets.entries()).filter(([s]) => s.startsWith("[")).sort(([s], [o]) => r(s, o)), f = i.map(([, s]) => s).sort((s, o) => (0, e.default)(s - o));
      return i.map(([, s], o) => [
        s,
        f[o]
      ]).filter(([s, o]) => s !== o);
    }
    /**
    * @template T
    * @param {[RuleOffset, T][]} list
    * @returns {[RuleOffset, T][]}
    */
    remapArbitraryVariantOffsets(i) {
      let f = this.recalculateVariantOffsets();
      return f.length === 0 ? i : i.map((d) => {
        let [s, o] = d;
        return s = {
          ...s,
          variants: (0, n.remapBitfield)(s.variants, f)
        }, [
          s,
          o
        ];
      });
    }
    /**
    * @template T
    * @param {[RuleOffset, T][]} list
    * @returns {[RuleOffset, T][]}
    */
    sort(i) {
      return i = this.remapArbitraryVariantOffsets(i), i.sort(([f], [d]) => (0, e.default)(this.compare(f, d)));
    }
  }
  function u(l) {
    let i = null;
    for (const f of l)
      i = i ?? f, i = i > f ? i : f;
    return i;
  }
  function r(l, i) {
    let f = l.length, d = i.length, s = f < d ? f : d;
    for (let o = 0; o < s; o++) {
      let m = l.charCodeAt(o) - i.charCodeAt(o);
      if (m !== 0)
        return m;
    }
    return f - d;
  }
})(Vx);
var v_;
function ab() {
  return v_ || (v_ = 1, function(t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    });
    function e(le, ue) {
      for (var ie in ue)
        Object.defineProperty(le, ie, {
          enumerable: !0,
          get: ue[ie]
        });
    }
    e(t, {
      isValidVariantFormatString: function() {
        return k;
      },
      parseVariant: function() {
        return K;
      },
      getFileModifiedMap: function() {
        return q;
      },
      createContext: function() {
        return ve;
      },
      getContext: function() {
        return ae;
      }
    });
    const n = /* @__PURE__ */ D(Dn), a = /* @__PURE__ */ D(ds), c = /* @__PURE__ */ D(vi), u = /* @__PURE__ */ D(z2), r = /* @__PURE__ */ D(Ws), l = /* @__PURE__ */ D(Nu), i = /* @__PURE__ */ D(py), f = /* @__PURE__ */ D(Od), d = /* @__PURE__ */ D(tl), s = /* @__PURE__ */ D(rl), o = /* @__PURE__ */ F(vy), m = Pu, h = vT, y = /* @__PURE__ */ F(Xa), b = Sd, E = /* @__PURE__ */ D(Bi), S = /* @__PURE__ */ D(_d), g = /* @__PURE__ */ D(Ey), P = wy(), R = AT, N = Vx, C = _s, I = _y;
    function D(le) {
      return le && le.__esModule ? le : {
        default: le
      };
    }
    function j(le) {
      if (typeof WeakMap != "function")
        return null;
      var ue = /* @__PURE__ */ new WeakMap(), ie = /* @__PURE__ */ new WeakMap();
      return (j = function(we) {
        return we ? ie : ue;
      })(le);
    }
    function F(le, ue) {
      if (!ue && le && le.__esModule)
        return le;
      if (le === null || typeof le != "object" && typeof le != "function")
        return {
          default: le
        };
      var ie = j(ue);
      if (ie && ie.has(le))
        return ie.get(le);
      var we = {}, De = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var Ee in le)
        if (Ee !== "default" && Object.prototype.hasOwnProperty.call(le, Ee)) {
          var Ae = De ? Object.getOwnPropertyDescriptor(le, Ee) : null;
          Ae && (Ae.get || Ae.set) ? Object.defineProperty(we, Ee, Ae) : we[Ee] = le[Ee];
        }
      return we.default = le, ie && ie.set(le, we), we;
    }
    const _ = {
      AddVariant: Symbol.for("ADD_VARIANT"),
      MatchVariant: Symbol.for("MATCH_VARIANT")
    }, T = {
      Base: 1,
      Dynamic: 2
    };
    function v(le, ue) {
      let ie = le.tailwindConfig.prefix;
      return typeof ie == "function" ? ie(ue) : ie + ue;
    }
    function w({ type: le = "any", ...ue }) {
      let ie = [].concat(le);
      return {
        ...ue,
        types: ie.map((we) => Array.isArray(we) ? {
          type: we[0],
          ...we[1]
        } : {
          type: we,
          preferOnConflict: !1
        })
      };
    }
    function O(le) {
      let ue = [], ie = "", we = 0;
      for (let De = 0; De < le.length; De++) {
        let Ee = le[De];
        if (Ee === "\\")
          ie += "\\" + le[++De];
        else if (Ee === "{")
          ++we, ue.push(ie.trim()), ie = "";
        else if (Ee === "}") {
          if (--we < 0)
            throw new Error("Your { and } are unbalanced.");
          ue.push(ie.trim()), ie = "";
        } else
          ie += Ee;
      }
      return ie.length > 0 && ue.push(ie.trim()), ue = ue.filter((De) => De !== ""), ue;
    }
    function G(le, ue, { before: ie = [] } = {}) {
      if (ie = [].concat(ie), ie.length <= 0) {
        le.push(ue);
        return;
      }
      let we = le.length - 1;
      for (let De of ie) {
        let Ee = le.indexOf(De);
        Ee !== -1 && (we = Math.min(we, Ee));
      }
      le.splice(we, 0, ue);
    }
    function W(le) {
      return Array.isArray(le) ? le.flatMap((ue) => !Array.isArray(ue) && !(0, d.default)(ue) ? ue : (0, i.default)(ue)) : W([
        le
      ]);
    }
    function U(le, ue) {
      return (0, r.default)((we) => {
        let De = [];
        return ue && ue(we), we.walkClasses((Ee) => {
          De.push(Ee.value);
        }), De;
      }).transformSync(le);
    }
    function M(le, ue = {
      containsNonOnDemandable: !1
    }, ie = 0) {
      let we = [];
      if (le.type === "rule") {
        let De = function(Ee) {
          Ee.walkPseudos((Ae) => {
            Ae.value === ":not" && Ae.remove();
          });
        };
        for (let Ee of le.selectors) {
          let Ae = U(Ee, De);
          Ae.length === 0 && (ue.containsNonOnDemandable = !0);
          for (let Me of Ae)
            we.push(Me);
        }
      } else
        le.type === "atrule" && le.walkRules((De) => {
          for (let Ee of De.selectors.flatMap((Ae) => U(Ae)))
            we.push(Ee);
        });
      return ie === 0 ? [
        ue.containsNonOnDemandable || we.length === 0,
        we
      ] : we;
    }
    function B(le) {
      return W(le).flatMap((ue) => {
        let ie = /* @__PURE__ */ new Map(), [we, De] = M(ue);
        return we && De.unshift(y.NOT_ON_DEMAND), De.map((Ee) => (ie.has(ue) || ie.set(ue, ue), [
          Ee,
          ie.get(ue)
        ]));
      });
    }
    function k(le) {
      return le.startsWith("@") || le.includes("&");
    }
    function K(le) {
      le = le.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
      let ue = O(le).map((ie) => {
        if (!ie.startsWith("@"))
          return ({ format: Ee }) => Ee(ie);
        let [, we, De] = /@(.*?)( .+|[({].*)/g.exec(ie);
        return ({ wrap: Ee }) => Ee(c.default.atRule({
          name: we,
          params: De.trim()
        }));
      }).reverse();
      return (ie) => {
        for (let we of ue)
          we(ie);
      };
    }
    function te(le, ue, { variantList: ie, variantMap: we, offsets: De, classList: Ee }) {
      function Ae(be, _e) {
        return be ? (0, u.default)(le, be, _e) : le;
      }
      function Me(be) {
        return (0, f.default)(le.prefix, be);
      }
      function me(be, _e) {
        return be === y.NOT_ON_DEMAND ? y.NOT_ON_DEMAND : _e.respectPrefix ? ue.tailwindConfig.prefix + be : be;
      }
      function se(be, _e, Ie = {}) {
        let We = (0, b.toPath)(be), tt = Ae([
          "theme",
          ...We
        ], _e);
        return (0, l.default)(We[0])(tt, Ie);
      }
      let Z = 0, pe = {
        postcss: c.default,
        prefix: Me,
        e: s.default,
        config: Ae,
        theme: se,
        corePlugins: (be) => Array.isArray(le.corePlugins) ? le.corePlugins.includes(be) : Ae([
          "corePlugins",
          be
        ], !0),
        variants: () => [],
        addBase(be) {
          for (let [_e, Ie] of B(be)) {
            let We = me(_e, {}), tt = De.create("base");
            ue.candidateRuleMap.has(We) || ue.candidateRuleMap.set(We, []), ue.candidateRuleMap.get(We).push([
              {
                sort: tt,
                layer: "base"
              },
              Ie
            ]);
          }
        },
        /**
        * @param {string} group
        * @param {Record<string, string | string[]>} declarations
        */
        addDefaults(be, _e) {
          const Ie = {
            [`@defaults ${be}`]: _e
          };
          for (let [We, tt] of B(Ie)) {
            let Ye = me(We, {});
            ue.candidateRuleMap.has(Ye) || ue.candidateRuleMap.set(Ye, []), ue.candidateRuleMap.get(Ye).push([
              {
                sort: De.create("defaults"),
                layer: "defaults"
              },
              tt
            ]);
          }
        },
        addComponents(be, _e) {
          _e = Object.assign({}, {
            preserveSource: !1,
            respectPrefix: !0,
            respectImportant: !1
          }, Array.isArray(_e) ? {} : _e);
          for (let [We, tt] of B(be)) {
            let Ye = me(We, _e);
            Ee.add(Ye), ue.candidateRuleMap.has(Ye) || ue.candidateRuleMap.set(Ye, []), ue.candidateRuleMap.get(Ye).push([
              {
                sort: De.create("components"),
                layer: "components",
                options: _e
              },
              tt
            ]);
          }
        },
        addUtilities(be, _e) {
          _e = Object.assign({}, {
            preserveSource: !1,
            respectPrefix: !0,
            respectImportant: !0
          }, Array.isArray(_e) ? {} : _e);
          for (let [We, tt] of B(be)) {
            let Ye = me(We, _e);
            Ee.add(Ye), ue.candidateRuleMap.has(Ye) || ue.candidateRuleMap.set(Ye, []), ue.candidateRuleMap.get(Ye).push([
              {
                sort: De.create("utilities"),
                layer: "utilities",
                options: _e
              },
              tt
            ]);
          }
        },
        matchUtilities: function(be, _e) {
          _e = w({
            ...{
              respectPrefix: !0,
              respectImportant: !0,
              modifiers: !1
            },
            ..._e
          });
          let We = De.create("utilities");
          for (let tt in be) {
            let ct = function(Xe, { isOnlyPlugin: Ke }) {
              let [Ce, xe, He] = (0, m.coerceValue)(_e.types, Xe, _e, le);
              if (Ce === void 0)
                return [];
              if (!_e.types.some(({ type: $e }) => $e === xe))
                if (Ke)
                  E.default.warn([
                    `Unnecessary typehint \`${xe}\` in \`${tt}-${Xe}\`.`,
                    `You can safely update it to \`${tt}-${Xe.replace(xe + ":", "")}\`.`
                  ]);
                else
                  return [];
              if (!(0, g.default)(Ce))
                return [];
              let Be = {
                get modifier() {
                  return _e.modifiers || E.default.warn(`modifier-used-without-options-for-${tt}`, [
                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                  ]), He;
                }
              }, Ze = (0, C.flagEnabled)(le, "generalizedModifiers");
              return [].concat(Ze ? ht(Ce, Be) : ht(Ce)).filter(Boolean).map(($e) => ({
                [(0, o.default)(tt, Xe)]: $e
              }));
            }, Ye = me(tt, _e), ht = be[tt];
            Ee.add([
              Ye,
              _e
            ]);
            let st = [
              {
                sort: We,
                layer: "utilities",
                options: _e
              },
              ct
            ];
            ue.candidateRuleMap.has(Ye) || ue.candidateRuleMap.set(Ye, []), ue.candidateRuleMap.get(Ye).push(st);
          }
        },
        matchComponents: function(be, _e) {
          _e = w({
            ...{
              respectPrefix: !0,
              respectImportant: !1,
              modifiers: !1
            },
            ..._e
          });
          let We = De.create("components");
          for (let tt in be) {
            let ct = function(Xe, { isOnlyPlugin: Ke }) {
              let [Ce, xe, He] = (0, m.coerceValue)(_e.types, Xe, _e, le);
              if (Ce === void 0)
                return [];
              if (!_e.types.some(({ type: $e }) => $e === xe))
                if (Ke)
                  E.default.warn([
                    `Unnecessary typehint \`${xe}\` in \`${tt}-${Xe}\`.`,
                    `You can safely update it to \`${tt}-${Xe.replace(xe + ":", "")}\`.`
                  ]);
                else
                  return [];
              if (!(0, g.default)(Ce))
                return [];
              let Be = {
                get modifier() {
                  return _e.modifiers || E.default.warn(`modifier-used-without-options-for-${tt}`, [
                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                  ]), He;
                }
              }, Ze = (0, C.flagEnabled)(le, "generalizedModifiers");
              return [].concat(Ze ? ht(Ce, Be) : ht(Ce)).filter(Boolean).map(($e) => ({
                [(0, o.default)(tt, Xe)]: $e
              }));
            }, Ye = me(tt, _e), ht = be[tt];
            Ee.add([
              Ye,
              _e
            ]);
            let st = [
              {
                sort: We,
                layer: "components",
                options: _e
              },
              ct
            ];
            ue.candidateRuleMap.has(Ye) || ue.candidateRuleMap.set(Ye, []), ue.candidateRuleMap.get(Ye).push(st);
          }
        },
        addVariant(be, _e, Ie = {}) {
          _e = [].concat(_e).map((We) => {
            if (typeof We != "string")
              return (tt = {}) => {
                let { args: Ye, modifySelectors: ht, container: ct, separator: st, wrap: Xe, format: Ke } = tt, Ce = We(Object.assign({
                  modifySelectors: ht,
                  container: ct,
                  separator: st
                }, Ie.type === _.MatchVariant && {
                  args: Ye,
                  wrap: Xe,
                  format: Ke
                }));
                if (typeof Ce == "string" && !k(Ce))
                  throw new Error(`Your custom variant \`${be}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
                return Array.isArray(Ce) ? Ce.filter((xe) => typeof xe == "string").map((xe) => K(xe)) : Ce && typeof Ce == "string" && K(Ce)(tt);
              };
            if (!k(We))
              throw new Error(`Your custom variant \`${be}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
            return K(We);
          }), G(ie, be, Ie), we.set(be, _e), ue.variantOptions.set(be, Ie);
        },
        matchVariant(be, _e, Ie) {
          var We;
          let tt = (We = Ie == null ? void 0 : Ie.id) !== null && We !== void 0 ? We : ++Z, Ye = be === "@", ht = (0, C.flagEnabled)(le, "generalizedModifiers");
          var ct;
          for (let [Ke, Ce] of Object.entries((ct = Ie == null ? void 0 : Ie.values) !== null && ct !== void 0 ? ct : {}))
            Ke !== "DEFAULT" && pe.addVariant(Ye ? `${be}${Ke}` : `${be}-${Ke}`, ({ args: xe, container: He }) => _e(Ce, ht ? {
              modifier: xe == null ? void 0 : xe.modifier,
              container: He
            } : {
              container: He
            }), {
              ...Ie,
              value: Ce,
              id: tt,
              type: _.MatchVariant,
              variantInfo: T.Base
            });
          var st;
          let Xe = "DEFAULT" in ((st = Ie == null ? void 0 : Ie.values) !== null && st !== void 0 ? st : {});
          pe.addVariant(be, ({ args: Ke, container: Ce }) => {
            if ((Ke == null ? void 0 : Ke.value) === y.NONE && !Xe)
              return null;
            var xe;
            return _e((Ke == null ? void 0 : Ke.value) === y.NONE ? Ie.values.DEFAULT : (xe = Ke == null ? void 0 : Ke.value) !== null && xe !== void 0 ? xe : typeof Ke == "string" ? Ke : "", ht ? {
              modifier: Ke == null ? void 0 : Ke.modifier,
              container: Ce
            } : {
              container: Ce
            });
          }, {
            ...Ie,
            id: tt,
            type: _.MatchVariant,
            variantInfo: T.Dynamic
          });
        }
      };
      return pe;
    }
    let z = /* @__PURE__ */ new WeakMap();
    function q(le) {
      return z.has(le) || z.set(le, /* @__PURE__ */ new Map()), z.get(le);
    }
    function $(le, ue) {
      let ie = !1, we = /* @__PURE__ */ new Map();
      for (let Ee of le) {
        var De;
        if (!Ee)
          continue;
        let Ae = a.default.parse(Ee), Me = Ae.hash ? Ae.href.replace(Ae.hash, "") : Ae.href;
        Me = Ae.search ? Me.replace(Ae.search, "") : Me;
        let me = (De = n.default.statSync(decodeURIComponent(Me), {
          throwIfNoEntry: !1
        })) === null || De === void 0 ? void 0 : De.mtimeMs;
        me && ((!ue.has(Ee) || me > ue.get(Ee)) && (ie = !0), we.set(Ee, me));
      }
      return [
        ie,
        we
      ];
    }
    function Y(le) {
      le.walkAtRules((ue) => {
        [
          "responsive",
          "variants"
        ].includes(ue.name) && (Y(ue), ue.before(ue.nodes), ue.remove());
      });
    }
    function H(le) {
      let ue = [];
      return le.each((ie) => {
        ie.type === "atrule" && [
          "responsive",
          "variants"
        ].includes(ie.name) && (ie.name = "layer", ie.params = "utilities");
      }), le.walkAtRules("layer", (ie) => {
        if (Y(ie), ie.params === "base") {
          for (let we of ie.nodes)
            ue.push(function({ addBase: De }) {
              De(we, {
                respectPrefix: !1
              });
            });
          ie.remove();
        } else if (ie.params === "components") {
          for (let we of ie.nodes)
            ue.push(function({ addComponents: De }) {
              De(we, {
                respectPrefix: !1,
                preserveSource: !0
              });
            });
          ie.remove();
        } else if (ie.params === "utilities") {
          for (let we of ie.nodes)
            ue.push(function({ addUtilities: De }) {
              De(we, {
                respectPrefix: !1,
                preserveSource: !0
              });
            });
          ie.remove();
        }
      }), ue;
    }
    function Q(le, ue) {
      let ie = Object.entries({
        ...h.variantPlugins,
        ...h.corePlugins
      }).map(([Me, me]) => le.tailwindConfig.corePlugins.includes(Me) ? me : null).filter(Boolean), we = le.tailwindConfig.plugins.map((Me) => (Me.__isOptionsFunction && (Me = Me()), typeof Me == "function" ? Me : Me.handler)), De = H(ue), Ee = [
        h.variantPlugins.pseudoElementVariants,
        h.variantPlugins.pseudoClassVariants,
        h.variantPlugins.ariaVariants,
        h.variantPlugins.dataVariants
      ], Ae = [
        h.variantPlugins.supportsVariants,
        h.variantPlugins.directionVariants,
        h.variantPlugins.reducedMotionVariants,
        h.variantPlugins.prefersContrastVariants,
        h.variantPlugins.darkVariants,
        h.variantPlugins.printVariant,
        h.variantPlugins.screenVariants,
        h.variantPlugins.orientationVariants
      ];
      return [
        ...ie,
        ...Ee,
        ...we,
        ...Ae,
        ...De
      ];
    }
    function X(le, ue) {
      let ie = [], we = /* @__PURE__ */ new Map();
      ue.variantMap = we;
      let De = new N.Offsets();
      ue.offsets = De;
      let Ee = /* @__PURE__ */ new Set(), Ae = te(ue.tailwindConfig, ue, {
        variantList: ie,
        variantMap: we,
        offsets: De,
        classList: Ee
      });
      for (let _e of le)
        if (Array.isArray(_e))
          for (let Ie of _e)
            Ie(Ae);
        else
          _e == null || _e(Ae);
      De.recordVariants(ie, (_e) => we.get(_e).length);
      for (let [_e, Ie] of we.entries())
        ue.variantMap.set(_e, Ie.map((We, tt) => [
          De.forVariant(_e, tt),
          We
        ]));
      var Me;
      let me = ((Me = ue.tailwindConfig.safelist) !== null && Me !== void 0 ? Me : []).filter(Boolean);
      if (me.length > 0) {
        let _e = [];
        for (let Ie of me) {
          if (typeof Ie == "string") {
            ue.changedContent.push({
              content: Ie,
              extension: "html"
            });
            continue;
          }
          if (Ie instanceof RegExp) {
            E.default.warn("root-regex", [
              "Regular expressions in `safelist` work differently in Tailwind CSS v3.0.",
              "Update your `safelist` configuration to eliminate this warning.",
              "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
            ]);
            continue;
          }
          _e.push(Ie);
        }
        if (_e.length > 0) {
          let Ie = /* @__PURE__ */ new Map(), We = ue.tailwindConfig.prefix.length, tt = _e.some((Ye) => Ye.pattern.source.includes("!"));
          for (let Ye of Ee) {
            let ht = Array.isArray(Ye) ? (() => {
              let [ct, st] = Ye;
              var Xe;
              let Ce = Object.keys((Xe = st == null ? void 0 : st.values) !== null && Xe !== void 0 ? Xe : {}).map((xe) => (0, o.formatClass)(ct, xe));
              return st != null && st.supportsNegativeValues && (Ce = [
                ...Ce,
                ...Ce.map((xe) => "-" + xe)
              ], Ce = [
                ...Ce,
                ...Ce.map((xe) => xe.slice(0, We) + "-" + xe.slice(We))
              ]), st.types.some(({ type: xe }) => xe === "color") && (Ce = [
                ...Ce,
                ...Ce.flatMap((xe) => Object.keys(ue.tailwindConfig.theme.opacity).map((He) => `${xe}/${He}`))
              ]), tt && (st != null && st.respectImportant) && (Ce = [
                ...Ce,
                ...Ce.map((xe) => "!" + xe)
              ]), Ce;
            })() : [
              Ye
            ];
            for (let ct of ht)
              for (let { pattern: st, variants: Xe = [] } of _e)
                if (st.lastIndex = 0, Ie.has(st) || Ie.set(st, 0), !!st.test(ct)) {
                  Ie.set(st, Ie.get(st) + 1), ue.changedContent.push({
                    content: ct,
                    extension: "html"
                  });
                  for (let Ke of Xe)
                    ue.changedContent.push({
                      content: Ke + ue.tailwindConfig.separator + ct,
                      extension: "html"
                    });
                }
          }
          for (let [Ye, ht] of Ie.entries())
            ht === 0 && E.default.warn([
              `The safelist pattern \`${Ye}\` doesn't match any Tailwind CSS classes.`,
              "Fix this pattern or remove it from your `safelist` configuration.",
              "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
            ]);
        }
      }
      var se, Z;
      let pe = (Z = [].concat((se = ue.tailwindConfig.darkMode) !== null && se !== void 0 ? se : "media")[1]) !== null && Z !== void 0 ? Z : "dark", be = [
        v(ue, pe),
        v(ue, "group"),
        v(ue, "peer")
      ];
      ue.getClassOrder = function(Ie) {
        let We = [
          ...Ie
        ].sort((ct, st) => ct === st ? 0 : ct < st ? -1 : 1), tt = new Map(We.map((ct) => [
          ct,
          null
        ])), Ye = (0, P.generateRules)(new Set(We), ue);
        Ye = ue.offsets.sort(Ye);
        let ht = BigInt(be.length);
        for (const [, ct] of Ye)
          tt.set(ct.raws.tailwind.candidate, ht++);
        return Ie.map((ct) => {
          var st;
          let Xe = (st = tt.get(ct)) !== null && st !== void 0 ? st : null, Ke = be.indexOf(ct);
          return Xe === null && Ke !== -1 && (Xe = BigInt(Ke)), [
            ct,
            Xe
          ];
        });
      }, ue.getClassList = function(Ie = {}) {
        let We = [];
        for (let st of Ee)
          if (Array.isArray(st)) {
            var tt;
            let [Xe, Ke] = st, Ce = [];
            var Ye;
            let xe = Object.keys((Ye = Ke == null ? void 0 : Ke.modifiers) !== null && Ye !== void 0 ? Ye : {});
            if (!(Ke == null || (tt = Ke.types) === null || tt === void 0) && tt.some(({ type: Ze }) => Ze === "color")) {
              var ht;
              xe.push(...Object.keys((ht = ue.tailwindConfig.theme.opacity) !== null && ht !== void 0 ? ht : {}));
            }
            let He = {
              modifiers: xe
            }, Be = Ie.includeMetadata && xe.length > 0;
            var ct;
            for (let [Ze, nt] of Object.entries((ct = Ke == null ? void 0 : Ke.values) !== null && ct !== void 0 ? ct : {})) {
              if (nt == null)
                continue;
              let $e = (0, o.formatClass)(Xe, Ze);
              if (We.push(Be ? [
                $e,
                He
              ] : $e), Ke != null && Ke.supportsNegativeValues && (0, S.default)(nt)) {
                let ut = (0, o.formatClass)(Xe, `-${Ze}`);
                Ce.push(Be ? [
                  ut,
                  He
                ] : ut);
              }
            }
            We.push(...Ce);
          } else
            We.push(st);
        return We;
      }, ue.getVariants = function() {
        let Ie = [];
        for (let [tt, Ye] of ue.variantOptions.entries())
          if (Ye.variantInfo !== T.Base) {
            var We;
            Ie.push({
              name: tt,
              isArbitrary: Ye.type === Symbol.for("MATCH_VARIANT"),
              values: Object.keys((We = Ye.values) !== null && We !== void 0 ? We : {}),
              hasDash: tt !== "@",
              selectors({ modifier: ht, value: ct } = {}) {
                let st = "__TAILWIND_PLACEHOLDER__", Xe = c.default.rule({
                  selector: `.${st}`
                }), Ke = c.default.root({
                  nodes: [
                    Xe.clone()
                  ]
                }), Ce = Ke.toString();
                var xe;
                let He = ((xe = ue.variantMap.get(tt)) !== null && xe !== void 0 ? xe : []).flatMap(([lt, Et]) => Et), Be = [];
                for (let lt of He) {
                  var Ze;
                  let Et = [];
                  var nt;
                  let wt = {
                    args: {
                      modifier: ht,
                      value: (nt = (Ze = Ye.values) === null || Ze === void 0 ? void 0 : Ze[ct]) !== null && nt !== void 0 ? nt : ct
                    },
                    separator: ue.tailwindConfig.separator,
                    modifySelectors(Je) {
                      return Ke.each((ft) => {
                        ft.type === "rule" && (ft.selectors = ft.selectors.map((rt) => Je({
                          get className() {
                            return (0, P.getClassNameFromSelector)(rt);
                          },
                          selector: rt
                        })));
                      }), Ke;
                    },
                    format(Je) {
                      Et.push(Je);
                    },
                    wrap(Je) {
                      Et.push(`@${Je.name} ${Je.params} { & }`);
                    },
                    container: Ke
                  }, Ne = lt(wt);
                  if (Et.length > 0 && Be.push(Et), Array.isArray(Ne))
                    for (let Je of Ne)
                      Et = [], Je(wt), Be.push(Et);
                }
                let $e = [], ut = Ke.toString();
                Ce !== ut && (Ke.walkRules((lt) => {
                  let Et = lt.selector, wt = (0, r.default)((Ne) => {
                    Ne.walkClasses((Je) => {
                      Je.value = `${tt}${ue.tailwindConfig.separator}${Je.value}`;
                    });
                  }).processSync(Et);
                  $e.push(Et.replace(wt, "&").replace(st, "&"));
                }), Ke.walkAtRules((lt) => {
                  $e.push(`@${lt.name} (${lt.params}) { & }`);
                }));
                var vt;
                let yt = !(ct in ((vt = Ye.values) !== null && vt !== void 0 ? vt : {}));
                Be = Be.map((lt) => lt.map((Et) => ({
                  format: Et,
                  isArbitraryVariant: yt
                }))), $e = $e.map((lt) => ({
                  format: lt,
                  isArbitraryVariant: yt
                }));
                let et = {
                  candidate: st,
                  context: ue
                }, bt = Be.map((lt) => (0, I.finalizeSelector)(`.${st}`, (0, I.formatVariantSelector)(lt, et), et).replace(`.${st}`, "&").replace("{ & }", "").trim());
                return $e.length > 0 && bt.push((0, I.formatVariantSelector)($e, et).toString().replace(`.${st}`, "&")), bt;
              }
            });
          }
        return Ie;
      };
    }
    function ne(le, ue) {
      le.classCache.has(ue) && (le.notClassCache.add(ue), le.classCache.delete(ue), le.applyClassCache.delete(ue), le.candidateRuleMap.delete(ue), le.candidateRuleCache.delete(ue), le.stylesheetCache = null);
    }
    function ye(le, ue) {
      let ie = ue.raws.tailwind.candidate;
      if (ie) {
        for (const we of le.ruleCache)
          we[1].raws.tailwind.candidate === ie && le.ruleCache.delete(we);
        ne(le, ie);
      }
    }
    function ve(le, ue = [], ie = c.default.root()) {
      var we;
      let De = {
        disposables: [],
        ruleCache: /* @__PURE__ */ new Set(),
        candidateRuleCache: /* @__PURE__ */ new Map(),
        classCache: /* @__PURE__ */ new Map(),
        applyClassCache: /* @__PURE__ */ new Map(),
        // Seed the not class cache with the blocklist (which is only strings)
        notClassCache: new Set((we = le.blocklist) !== null && we !== void 0 ? we : []),
        postCssNodeCache: /* @__PURE__ */ new Map(),
        candidateRuleMap: /* @__PURE__ */ new Map(),
        tailwindConfig: le,
        changedContent: ue,
        variantMap: /* @__PURE__ */ new Map(),
        stylesheetCache: null,
        variantOptions: /* @__PURE__ */ new Map(),
        markInvalidUtilityCandidate: (Ae) => ne(De, Ae),
        markInvalidUtilityNode: (Ae) => ye(De, Ae)
      }, Ee = Q(De, ie);
      return X(Ee, De), De;
    }
    let de = y.contextMap, oe = y.configContextMap, re = y.contextSourcesMap;
    function ae(le, ue, ie, we, De, Ee) {
      let Ae = ue.opts.from, Me = we !== null;
      y.env.DEBUG && console.log("Source path:", Ae);
      let me;
      if (Me && de.has(Ae))
        me = de.get(Ae);
      else if (oe.has(De)) {
        let be = oe.get(De);
        re.get(be).add(Ae), de.set(Ae, be), me = be;
      }
      let se = (0, R.hasContentChanged)(Ae, le);
      if (me) {
        let [be, _e] = $([
          ...Ee
        ], q(me));
        if (!be && !se)
          return [
            me,
            !1,
            _e
          ];
      }
      if (de.has(Ae)) {
        let be = de.get(Ae);
        if (re.has(be) && (re.get(be).delete(Ae), re.get(be).size === 0)) {
          re.delete(be);
          for (let [_e, Ie] of oe)
            Ie === be && oe.delete(_e);
          for (let _e of be.disposables.splice(0))
            _e(be);
        }
      }
      y.env.DEBUG && console.log("Setting up new context...");
      let Z = ve(ie, [], le);
      Object.assign(Z, {
        userConfigPath: we
      });
      let [, pe] = $([
        ...Ee
      ], q(Z));
      return oe.set(De, Z), de.set(Ae, Z), re.has(Z) || re.set(Z, /* @__PURE__ */ new Set()), re.get(Z).add(Ae), [
        Z,
        !0,
        pe
      ];
    }
  }(Th)), Th;
}
var qx = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(n) {
    return n.ignore ? [] : n.glob ? Ve.process.env.ROLLUP_WATCH === "true" ? [
      {
        type: "dependency",
        file: n.base
      }
    ] : [
      {
        type: "dir-dependency",
        dir: n.base,
        glob: n.glob
      }
    ] : [
      {
        type: "dependency",
        file: n.base
      }
    ];
  }
})(qx);
var Gx = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "validateConfig", {
    enumerable: !0,
    get: function() {
      return a;
    }
  });
  const e = /* @__PURE__ */ n(Bi);
  function n(c) {
    return c && c.__esModule ? c : {
      default: c
    };
  }
  function a(c) {
    return c.content.files.length === 0 && e.default.warn("content-problems", [
      "The `content` option in your Tailwind CSS configuration is missing or empty.",
      "Configure your content sources or your generated CSS will be missing styles.",
      "https://tailwindcss.com/docs/content-configuration"
    ]), c;
  }
})(Gx);
var zx = {};
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var HB = function(e) {
  if (typeof e != "string" || e === "")
    return !1;
  for (var n; n = /(\\).|([@?!+*]\(.*\))/g.exec(e); ) {
    if (n[2])
      return !0;
    e = e.slice(n.index + n[0].length);
  }
  return !1;
};
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var qB = HB, Kx = { "{": "}", "(": ")", "[": "]" }, GB = function(t) {
  if (t[0] === "!")
    return !0;
  for (var e = 0, n = -2, a = -2, c = -2, u = -2, r = -2; e < t.length; ) {
    if (t[e] === "*" || t[e + 1] === "?" && /[\].+)]/.test(t[e]) || a !== -1 && t[e] === "[" && t[e + 1] !== "]" && (a < e && (a = t.indexOf("]", e)), a > e && (r === -1 || r > a || (r = t.indexOf("\\", e), r === -1 || r > a))) || c !== -1 && t[e] === "{" && t[e + 1] !== "}" && (c = t.indexOf("}", e), c > e && (r = t.indexOf("\\", e), r === -1 || r > c)) || u !== -1 && t[e] === "(" && t[e + 1] === "?" && /[:!=]/.test(t[e + 2]) && t[e + 3] !== ")" && (u = t.indexOf(")", e), u > e && (r = t.indexOf("\\", e), r === -1 || r > u)) || n !== -1 && t[e] === "(" && t[e + 1] !== "|" && (n < e && (n = t.indexOf("|", e)), n !== -1 && t[n + 1] !== ")" && (u = t.indexOf(")", n), u > n && (r = t.indexOf("\\", n), r === -1 || r > u))))
      return !0;
    if (t[e] === "\\") {
      var l = t[e + 1];
      e += 2;
      var i = Kx[l];
      if (i) {
        var f = t.indexOf(i, e);
        f !== -1 && (e = f + 1);
      }
      if (t[e] === "!")
        return !0;
    } else
      e++;
  }
  return !1;
}, zB = function(t) {
  if (t[0] === "!")
    return !0;
  for (var e = 0; e < t.length; ) {
    if (/[*?{}()[\]]/.test(t[e]))
      return !0;
    if (t[e] === "\\") {
      var n = t[e + 1];
      e += 2;
      var a = Kx[n];
      if (a) {
        var c = t.indexOf(a, e);
        c !== -1 && (e = c + 1);
      }
      if (t[e] === "!")
        return !0;
    } else
      e++;
  }
  return !1;
}, ob = function(e, n) {
  if (typeof e != "string" || e === "")
    return !1;
  if (qB(e))
    return !0;
  var a = GB;
  return n && n.strict === !1 && (a = zB), a(e);
}, Pn = {}, Mr = {}, Ko = {};
Object.defineProperty(Ko, "__esModule", { value: !0 });
Ko.splitWhen = Ko.flatten = void 0;
function KB(t) {
  return t.reduce((e, n) => [].concat(e, n), []);
}
Ko.flatten = KB;
function YB(t, e) {
  const n = [[]];
  let a = 0;
  for (const c of t)
    e(c) ? (a++, n[a] = []) : n[a].push(c);
  return n;
}
Ko.splitWhen = YB;
var up = {};
Object.defineProperty(up, "__esModule", { value: !0 });
up.isEnoentCodeError = void 0;
function XB(t) {
  return t.code === "ENOENT";
}
up.isEnoentCodeError = XB;
var cp = {};
Object.defineProperty(cp, "__esModule", { value: !0 });
cp.createDirentFromStats = void 0;
let JB = class {
  constructor(e, n) {
    this.name = e, this.isBlockDevice = n.isBlockDevice.bind(n), this.isCharacterDevice = n.isCharacterDevice.bind(n), this.isDirectory = n.isDirectory.bind(n), this.isFIFO = n.isFIFO.bind(n), this.isFile = n.isFile.bind(n), this.isSocket = n.isSocket.bind(n), this.isSymbolicLink = n.isSymbolicLink.bind(n);
  }
};
function QB(t, e) {
  return new JB(t, e);
}
cp.createDirentFromStats = QB;
var Xr = {}, jr = {};
jr.endianness = function() {
  return "LE";
};
jr.hostname = function() {
  return typeof location < "u" ? location.hostname : "";
};
jr.loadavg = function() {
  return [];
};
jr.uptime = function() {
  return 0;
};
jr.freemem = function() {
  return Number.MAX_VALUE;
};
jr.totalmem = function() {
  return Number.MAX_VALUE;
};
jr.cpus = function() {
  return [];
};
jr.type = function() {
  return "Browser";
};
jr.release = function() {
  return typeof navigator < "u" ? navigator.appVersion : "";
};
jr.networkInterfaces = jr.getNetworkInterfaces = function() {
  return {};
};
jr.arch = function() {
  return "javascript";
};
jr.platform = function() {
  return "browser";
};
jr.tmpdir = jr.tmpDir = function() {
  return "/tmp";
};
jr.EOL = `
`;
jr.homedir = function() {
  return "/";
};
Object.defineProperty(Xr, "__esModule", { value: !0 });
Xr.convertPosixPathToPattern = Xr.convertWindowsPathToPattern = Xr.convertPathToPattern = Xr.escapePosixPath = Xr.escapeWindowsPath = Xr.escape = Xr.removeLeadingDotSegment = Xr.makeAbsolute = Xr.unixify = void 0;
const ZB = jr, e$ = Lr, Yx = ZB.platform() === "win32", t$ = 2, r$ = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g, n$ = /(\\?)([()[\]{}]|^!|[!+@](?=\())/g, i$ = /^\\\\([.?])/, s$ = /\\(?![!()+@[\]{}])/g;
function a$(t) {
  return t.replace(/\\/g, "/");
}
Xr.unixify = a$;
function o$(t, e) {
  return e$.resolve(t, e);
}
Xr.makeAbsolute = o$;
function l$(t) {
  if (t.charAt(0) === ".") {
    const e = t.charAt(1);
    if (e === "/" || e === "\\")
      return t.slice(t$);
  }
  return t;
}
Xr.removeLeadingDotSegment = l$;
Xr.escape = Yx ? lb : ub;
function lb(t) {
  return t.replace(n$, "\\$2");
}
Xr.escapeWindowsPath = lb;
function ub(t) {
  return t.replace(r$, "\\$2");
}
Xr.escapePosixPath = ub;
Xr.convertPathToPattern = Yx ? Xx : Jx;
function Xx(t) {
  return lb(t).replace(i$, "//$1").replace(s$, "/");
}
Xr.convertWindowsPathToPattern = Xx;
function Jx(t) {
  return ub(t);
}
Xr.convertPosixPathToPattern = Jx;
var Ht = {}, u$ = ob, c$ = Lr.posix.dirname, f$ = jr.platform() === "win32", cm = "/", d$ = /\\/g, p$ = /[\{\[].*[\}\]]$/, h$ = /(^|[^\\])([\{\[]|\([^\)]+$)/, m$ = /\\([\!\*\?\|\[\]\(\)\{\}])/g, y$ = function(e, n) {
  var a = Object.assign({ flipBackslashes: !0 }, n);
  a.flipBackslashes && f$ && e.indexOf(cm) < 0 && (e = e.replace(d$, cm)), p$.test(e) && (e += cm), e += "a";
  do
    e = c$(e);
  while (u$(e) || h$.test(e));
  return e.replace(m$, "$1");
}, fp = {};
(function(t) {
  t.isInteger = (e) => typeof e == "number" ? Number.isInteger(e) : typeof e == "string" && e.trim() !== "" ? Number.isInteger(Number(e)) : !1, t.find = (e, n) => e.nodes.find((a) => a.type === n), t.exceedsLimit = (e, n, a = 1, c) => c === !1 || !t.isInteger(e) || !t.isInteger(n) ? !1 : (Number(n) - Number(e)) / Number(a) >= c, t.escapeNode = (e, n = 0, a) => {
    let c = e.nodes[n];
    c && (a && c.type === a || c.type === "open" || c.type === "close") && c.escaped !== !0 && (c.value = "\\" + c.value, c.escaped = !0);
  }, t.encloseBrace = (e) => e.type !== "brace" || e.commas >> 0 + e.ranges >> 0 ? !1 : (e.invalid = !0, !0), t.isInvalidBrace = (e) => e.type !== "brace" ? !1 : e.invalid === !0 || e.dollar ? !0 : !(e.commas >> 0 + e.ranges >> 0) || e.open !== !0 || e.close !== !0 ? (e.invalid = !0, !0) : !1, t.isOpenOrClose = (e) => e.type === "open" || e.type === "close" ? !0 : e.open === !0 || e.close === !0, t.reduce = (e) => e.reduce((n, a) => (a.type === "text" && n.push(a.value), a.type === "range" && (a.type = "text"), n), []), t.flatten = (...e) => {
    const n = [], a = (c) => {
      for (let u = 0; u < c.length; u++) {
        let r = c[u];
        Array.isArray(r) ? a(r) : r !== void 0 && n.push(r);
      }
      return n;
    };
    return a(e), n;
  };
})(fp);
const E_ = fp;
var cb = (t, e = {}) => {
  let n = (a, c = {}) => {
    let u = e.escapeInvalid && E_.isInvalidBrace(c), r = a.invalid === !0 && e.escapeInvalid === !0, l = "";
    if (a.value)
      return (u || r) && E_.isOpenOrClose(a) ? "\\" + a.value : a.value;
    if (a.value)
      return a.value;
    if (a.nodes)
      for (let i of a.nodes)
        l += n(i);
    return l;
  };
  return n(t);
};
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
var b$ = function(t) {
  return typeof t == "number" ? t - t === 0 : typeof t == "string" && t.trim() !== "" ? Number.isFinite ? Number.isFinite(+t) : isFinite(+t) : !1;
};
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
const __ = b$, $a = (t, e, n) => {
  if (__(t) === !1)
    throw new TypeError("toRegexRange: expected the first argument to be a number");
  if (e === void 0 || t === e)
    return String(t);
  if (__(e) === !1)
    throw new TypeError("toRegexRange: expected the second argument to be a number.");
  let a = { relaxZeros: !0, ...n };
  typeof a.strictZeros == "boolean" && (a.relaxZeros = a.strictZeros === !1);
  let c = String(a.relaxZeros), u = String(a.shorthand), r = String(a.capture), l = String(a.wrap), i = t + ":" + e + "=" + c + u + r + l;
  if ($a.cache.hasOwnProperty(i))
    return $a.cache[i].result;
  let f = Math.min(t, e), d = Math.max(t, e);
  if (Math.abs(f - d) === 1) {
    let y = t + "|" + e;
    return a.capture ? `(${y})` : a.wrap === !1 ? y : `(?:${y})`;
  }
  let s = P_(t) || P_(e), o = { min: t, max: e, a: f, b: d }, m = [], h = [];
  if (s && (o.isPadded = s, o.maxLen = String(o.max).length), f < 0) {
    let y = d < 0 ? Math.abs(d) : 1;
    h = S_(y, Math.abs(f), o, a), f = o.a = 0;
  }
  return d >= 0 && (m = S_(f, d, o, a)), o.negatives = h, o.positives = m, o.result = g$(h, m), a.capture === !0 ? o.result = `(${o.result})` : a.wrap !== !1 && m.length + h.length > 1 && (o.result = `(?:${o.result})`), $a.cache[i] = o, o.result;
};
function g$(t, e, n) {
  let a = fm(t, e, "-", !1) || [], c = fm(e, t, "", !1) || [], u = fm(t, e, "-?", !0) || [];
  return a.concat(u).concat(c).join("|");
}
function v$(t, e) {
  let n = 1, a = 1, c = T_(t, n), u = /* @__PURE__ */ new Set([e]);
  for (; t <= c && c <= e; )
    u.add(c), n += 1, c = T_(t, n);
  for (c = A_(e + 1, a) - 1; t < c && c <= e; )
    u.add(c), a += 1, c = A_(e + 1, a) - 1;
  return u = [...u], u.sort(S$), u;
}
function E$(t, e, n) {
  if (t === e)
    return { pattern: t, count: [], digits: 0 };
  let a = _$(t, e), c = a.length, u = "", r = 0;
  for (let l = 0; l < c; l++) {
    let [i, f] = a[l];
    i === f ? u += i : i !== "0" || f !== "9" ? u += w$(i, f) : r++;
  }
  return r && (u += n.shorthand === !0 ? "\\d" : "[0-9]"), { pattern: u, count: [r], digits: c };
}
function S_(t, e, n, a) {
  let c = v$(t, e), u = [], r = t, l;
  for (let i = 0; i < c.length; i++) {
    let f = c[i], d = E$(String(r), String(f), a), s = "";
    if (!n.isPadded && l && l.pattern === d.pattern) {
      l.count.length > 1 && l.count.pop(), l.count.push(d.count[0]), l.string = l.pattern + x_(l.count), r = f + 1;
      continue;
    }
    n.isPadded && (s = T$(f, n, a)), d.string = s + d.pattern + x_(d.count), u.push(d), r = f + 1, l = d;
  }
  return u;
}
function fm(t, e, n, a, c) {
  let u = [];
  for (let r of t) {
    let { string: l } = r;
    !a && !w_(e, "string", l) && u.push(n + l), a && w_(e, "string", l) && u.push(n + l);
  }
  return u;
}
function _$(t, e) {
  let n = [];
  for (let a = 0; a < t.length; a++)
    n.push([t[a], e[a]]);
  return n;
}
function S$(t, e) {
  return t > e ? 1 : e > t ? -1 : 0;
}
function w_(t, e, n) {
  return t.some((a) => a[e] === n);
}
function T_(t, e) {
  return Number(String(t).slice(0, -e) + "9".repeat(e));
}
function A_(t, e) {
  return t - t % Math.pow(10, e);
}
function x_(t) {
  let [e = 0, n = ""] = t;
  return n || e > 1 ? `{${e + (n ? "," + n : "")}}` : "";
}
function w$(t, e, n) {
  return `[${t}${e - t === 1 ? "" : "-"}${e}]`;
}
function P_(t) {
  return /^-?(0+)\d/.test(t);
}
function T$(t, e, n) {
  if (!e.isPadded)
    return t;
  let a = Math.abs(e.maxLen - String(t).length), c = n.relaxZeros !== !1;
  switch (a) {
    case 0:
      return "";
    case 1:
      return c ? "0?" : "0";
    case 2:
      return c ? "0{0,2}" : "00";
    default:
      return c ? `0{0,${a}}` : `0{${a}}`;
  }
}
$a.cache = {};
$a.clearCache = () => $a.cache = {};
var A$ = $a;
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
const x$ = mi, Qx = A$, C_ = (t) => t !== null && typeof t == "object" && !Array.isArray(t), P$ = (t) => (e) => t === !0 ? Number(e) : String(e), dm = (t) => typeof t == "number" || typeof t == "string" && t !== "", Zl = (t) => Number.isInteger(+t), pm = (t) => {
  let e = `${t}`, n = -1;
  if (e[0] === "-" && (e = e.slice(1)), e === "0")
    return !1;
  for (; e[++n] === "0"; )
    ;
  return n > 0;
}, C$ = (t, e, n) => typeof t == "string" || typeof e == "string" ? !0 : n.stringify === !0, I$ = (t, e, n) => {
  if (e > 0) {
    let a = t[0] === "-" ? "-" : "";
    a && (t = t.slice(1)), t = a + t.padStart(a ? e - 1 : e, "0");
  }
  return n === !1 ? String(t) : t;
}, I_ = (t, e) => {
  let n = t[0] === "-" ? "-" : "";
  for (n && (t = t.slice(1), e--); t.length < e; )
    t = "0" + t;
  return n ? "-" + t : t;
}, O$ = (t, e) => {
  t.negatives.sort((r, l) => r < l ? -1 : r > l ? 1 : 0), t.positives.sort((r, l) => r < l ? -1 : r > l ? 1 : 0);
  let n = e.capture ? "" : "?:", a = "", c = "", u;
  return t.positives.length && (a = t.positives.join("|")), t.negatives.length && (c = `-(${n}${t.negatives.join("|")})`), a && c ? u = `${a}|${c}` : u = a || c, e.wrap ? `(${n}${u})` : u;
}, Zx = (t, e, n, a) => {
  if (n)
    return Qx(t, e, { wrap: !1, ...a });
  let c = String.fromCharCode(t);
  if (t === e)
    return c;
  let u = String.fromCharCode(e);
  return `[${c}-${u}]`;
}, eP = (t, e, n) => {
  if (Array.isArray(t)) {
    let a = n.wrap === !0, c = n.capture ? "" : "?:";
    return a ? `(${c}${t.join("|")})` : t.join("|");
  }
  return Qx(t, e, n);
}, tP = (...t) => new RangeError("Invalid range arguments: " + x$.inspect(...t)), rP = (t, e, n) => {
  if (n.strictRanges === !0)
    throw tP([t, e]);
  return [];
}, k$ = (t, e) => {
  if (e.strictRanges === !0)
    throw new TypeError(`Expected step "${t}" to be a number`);
  return [];
}, D$ = (t, e, n = 1, a = {}) => {
  let c = Number(t), u = Number(e);
  if (!Number.isInteger(c) || !Number.isInteger(u)) {
    if (a.strictRanges === !0)
      throw tP([t, e]);
    return [];
  }
  c === 0 && (c = 0), u === 0 && (u = 0);
  let r = c > u, l = String(t), i = String(e), f = String(n);
  n = Math.max(Math.abs(n), 1);
  let d = pm(l) || pm(i) || pm(f), s = d ? Math.max(l.length, i.length, f.length) : 0, o = d === !1 && C$(t, e, a) === !1, m = a.transform || P$(o);
  if (a.toRegex && n === 1)
    return Zx(I_(t, s), I_(e, s), !0, a);
  let h = { negatives: [], positives: [] }, y = (S) => h[S < 0 ? "negatives" : "positives"].push(Math.abs(S)), b = [], E = 0;
  for (; r ? c >= u : c <= u; )
    a.toRegex === !0 && n > 1 ? y(c) : b.push(I$(m(c, E), s, o)), c = r ? c - n : c + n, E++;
  return a.toRegex === !0 ? n > 1 ? O$(h, a) : eP(b, null, { wrap: !1, ...a }) : b;
}, N$ = (t, e, n = 1, a = {}) => {
  if (!Zl(t) && t.length > 1 || !Zl(e) && e.length > 1)
    return rP(t, e, a);
  let c = a.transform || ((o) => String.fromCharCode(o)), u = `${t}`.charCodeAt(0), r = `${e}`.charCodeAt(0), l = u > r, i = Math.min(u, r), f = Math.max(u, r);
  if (a.toRegex && n === 1)
    return Zx(i, f, !1, a);
  let d = [], s = 0;
  for (; l ? u >= r : u <= r; )
    d.push(c(u, s)), u = l ? u - n : u + n, s++;
  return a.toRegex === !0 ? eP(d, null, { wrap: !1, options: a }) : d;
}, hf = (t, e, n, a = {}) => {
  if (e == null && dm(t))
    return [t];
  if (!dm(t) || !dm(e))
    return rP(t, e, a);
  if (typeof n == "function")
    return hf(t, e, 1, { transform: n });
  if (C_(n))
    return hf(t, e, 0, n);
  let c = { ...a };
  return c.capture === !0 && (c.wrap = !0), n = n || c.step || 1, Zl(n) ? Zl(t) && Zl(e) ? D$(t, e, n, c) : N$(t, e, Math.max(Math.abs(n), 1), c) : n != null && !C_(n) ? k$(n, c) : hf(t, e, 1, n);
};
var nP = hf;
const R$ = nP, O_ = fp, M$ = (t, e = {}) => {
  let n = (a, c = {}) => {
    let u = O_.isInvalidBrace(c), r = a.invalid === !0 && e.escapeInvalid === !0, l = u === !0 || r === !0, i = e.escapeInvalid === !0 ? "\\" : "", f = "";
    if (a.isOpen === !0 || a.isClose === !0)
      return i + a.value;
    if (a.type === "open")
      return l ? i + a.value : "(";
    if (a.type === "close")
      return l ? i + a.value : ")";
    if (a.type === "comma")
      return a.prev.type === "comma" ? "" : l ? a.value : "|";
    if (a.value)
      return a.value;
    if (a.nodes && a.ranges > 0) {
      let d = O_.reduce(a.nodes), s = R$(...d, { ...e, wrap: !1, toRegex: !0 });
      if (s.length !== 0)
        return d.length > 1 && s.length > 1 ? `(${s})` : s;
    }
    if (a.nodes)
      for (let d of a.nodes)
        f += n(d, a);
    return f;
  };
  return n(t);
};
var L$ = M$;
const j$ = nP, k_ = cb, So = fp, Oa = (t = "", e = "", n = !1) => {
  let a = [];
  if (t = [].concat(t), e = [].concat(e), !e.length)
    return t;
  if (!t.length)
    return n ? So.flatten(e).map((c) => `{${c}}`) : e;
  for (let c of t)
    if (Array.isArray(c))
      for (let u of c)
        a.push(Oa(u, e, n));
    else
      for (let u of e)
        n === !0 && typeof u == "string" && (u = `{${u}}`), a.push(Array.isArray(u) ? Oa(c, u, n) : c + u);
  return So.flatten(a);
}, F$ = (t, e = {}) => {
  let n = e.rangeLimit === void 0 ? 1e3 : e.rangeLimit, a = (c, u = {}) => {
    c.queue = [];
    let r = u, l = u.queue;
    for (; r.type !== "brace" && r.type !== "root" && r.parent; )
      r = r.parent, l = r.queue;
    if (c.invalid || c.dollar) {
      l.push(Oa(l.pop(), k_(c, e)));
      return;
    }
    if (c.type === "brace" && c.invalid !== !0 && c.nodes.length === 2) {
      l.push(Oa(l.pop(), ["{}"]));
      return;
    }
    if (c.nodes && c.ranges > 0) {
      let s = So.reduce(c.nodes);
      if (So.exceedsLimit(...s, e.step, n))
        throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
      let o = j$(...s, e);
      o.length === 0 && (o = k_(c, e)), l.push(Oa(l.pop(), o)), c.nodes = [];
      return;
    }
    let i = So.encloseBrace(c), f = c.queue, d = c;
    for (; d.type !== "brace" && d.type !== "root" && d.parent; )
      d = d.parent, f = d.queue;
    for (let s = 0; s < c.nodes.length; s++) {
      let o = c.nodes[s];
      if (o.type === "comma" && c.type === "brace") {
        s === 1 && f.push(""), f.push("");
        continue;
      }
      if (o.type === "close") {
        l.push(Oa(l.pop(), f, i));
        continue;
      }
      if (o.value && o.type !== "open") {
        f.push(Oa(f.pop(), o.value));
        continue;
      }
      o.nodes && a(o, c);
    }
    return f;
  };
  return So.flatten(a(t));
};
var B$ = F$, $$ = {
  MAX_LENGTH: 1024 * 64,
  // Digits
  CHAR_0: "0",
  /* 0 */
  CHAR_9: "9",
  /* 9 */
  // Alphabet chars.
  CHAR_UPPERCASE_A: "A",
  /* A */
  CHAR_LOWERCASE_A: "a",
  /* a */
  CHAR_UPPERCASE_Z: "Z",
  /* Z */
  CHAR_LOWERCASE_Z: "z",
  /* z */
  CHAR_LEFT_PARENTHESES: "(",
  /* ( */
  CHAR_RIGHT_PARENTHESES: ")",
  /* ) */
  CHAR_ASTERISK: "*",
  /* * */
  // Non-alphabetic chars.
  CHAR_AMPERSAND: "&",
  /* & */
  CHAR_AT: "@",
  /* @ */
  CHAR_BACKSLASH: "\\",
  /* \ */
  CHAR_BACKTICK: "`",
  /* ` */
  CHAR_CARRIAGE_RETURN: "\r",
  /* \r */
  CHAR_CIRCUMFLEX_ACCENT: "^",
  /* ^ */
  CHAR_COLON: ":",
  /* : */
  CHAR_COMMA: ",",
  /* , */
  CHAR_DOLLAR: "$",
  /* . */
  CHAR_DOT: ".",
  /* . */
  CHAR_DOUBLE_QUOTE: '"',
  /* " */
  CHAR_EQUAL: "=",
  /* = */
  CHAR_EXCLAMATION_MARK: "!",
  /* ! */
  CHAR_FORM_FEED: "\f",
  /* \f */
  CHAR_FORWARD_SLASH: "/",
  /* / */
  CHAR_HASH: "#",
  /* # */
  CHAR_HYPHEN_MINUS: "-",
  /* - */
  CHAR_LEFT_ANGLE_BRACKET: "<",
  /* < */
  CHAR_LEFT_CURLY_BRACE: "{",
  /* { */
  CHAR_LEFT_SQUARE_BRACKET: "[",
  /* [ */
  CHAR_LINE_FEED: `
`,
  /* \n */
  CHAR_NO_BREAK_SPACE: "",
  /* \u00A0 */
  CHAR_PERCENT: "%",
  /* % */
  CHAR_PLUS: "+",
  /* + */
  CHAR_QUESTION_MARK: "?",
  /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: ">",
  /* > */
  CHAR_RIGHT_CURLY_BRACE: "}",
  /* } */
  CHAR_RIGHT_SQUARE_BRACKET: "]",
  /* ] */
  CHAR_SEMICOLON: ";",
  /* ; */
  CHAR_SINGLE_QUOTE: "'",
  /* ' */
  CHAR_SPACE: " ",
  /*   */
  CHAR_TAB: "	",
  /* \t */
  CHAR_UNDERSCORE: "_",
  /* _ */
  CHAR_VERTICAL_LINE: "|",
  /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
  /* \uFEFF */
};
const U$ = cb, {
  MAX_LENGTH: D_,
  CHAR_BACKSLASH: hm,
  /* \ */
  CHAR_BACKTICK: V$,
  /* ` */
  CHAR_COMMA: W$,
  /* , */
  CHAR_DOT: H$,
  /* . */
  CHAR_LEFT_PARENTHESES: q$,
  /* ( */
  CHAR_RIGHT_PARENTHESES: G$,
  /* ) */
  CHAR_LEFT_CURLY_BRACE: z$,
  /* { */
  CHAR_RIGHT_CURLY_BRACE: K$,
  /* } */
  CHAR_LEFT_SQUARE_BRACKET: N_,
  /* [ */
  CHAR_RIGHT_SQUARE_BRACKET: R_,
  /* ] */
  CHAR_DOUBLE_QUOTE: Y$,
  /* " */
  CHAR_SINGLE_QUOTE: X$,
  /* ' */
  CHAR_NO_BREAK_SPACE: J$,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: Q$
} = $$, Z$ = (t, e = {}) => {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  let n = e || {}, a = typeof n.maxLength == "number" ? Math.min(D_, n.maxLength) : D_;
  if (t.length > a)
    throw new SyntaxError(`Input length (${t.length}), exceeds max characters (${a})`);
  let c = { type: "root", input: t, nodes: [] }, u = [c], r = c, l = c, i = 0, f = t.length, d = 0, s = 0, o;
  const m = () => t[d++], h = (y) => {
    if (y.type === "text" && l.type === "dot" && (l.type = "text"), l && l.type === "text" && y.type === "text") {
      l.value += y.value;
      return;
    }
    return r.nodes.push(y), y.parent = r, y.prev = l, l = y, y;
  };
  for (h({ type: "bos" }); d < f; )
    if (r = u[u.length - 1], o = m(), !(o === Q$ || o === J$)) {
      if (o === hm) {
        h({ type: "text", value: (e.keepEscaping ? o : "") + m() });
        continue;
      }
      if (o === R_) {
        h({ type: "text", value: "\\" + o });
        continue;
      }
      if (o === N_) {
        i++;
        let y;
        for (; d < f && (y = m()); ) {
          if (o += y, y === N_) {
            i++;
            continue;
          }
          if (y === hm) {
            o += m();
            continue;
          }
          if (y === R_ && (i--, i === 0))
            break;
        }
        h({ type: "text", value: o });
        continue;
      }
      if (o === q$) {
        r = h({ type: "paren", nodes: [] }), u.push(r), h({ type: "text", value: o });
        continue;
      }
      if (o === G$) {
        if (r.type !== "paren") {
          h({ type: "text", value: o });
          continue;
        }
        r = u.pop(), h({ type: "text", value: o }), r = u[u.length - 1];
        continue;
      }
      if (o === Y$ || o === X$ || o === V$) {
        let y = o, b;
        for (e.keepQuotes !== !0 && (o = ""); d < f && (b = m()); ) {
          if (b === hm) {
            o += b + m();
            continue;
          }
          if (b === y) {
            e.keepQuotes === !0 && (o += b);
            break;
          }
          o += b;
        }
        h({ type: "text", value: o });
        continue;
      }
      if (o === z$) {
        s++;
        let b = {
          type: "brace",
          open: !0,
          close: !1,
          dollar: l.value && l.value.slice(-1) === "$" || r.dollar === !0,
          depth: s,
          commas: 0,
          ranges: 0,
          nodes: []
        };
        r = h(b), u.push(r), h({ type: "open", value: o });
        continue;
      }
      if (o === K$) {
        if (r.type !== "brace") {
          h({ type: "text", value: o });
          continue;
        }
        let y = "close";
        r = u.pop(), r.close = !0, h({ type: y, value: o }), s--, r = u[u.length - 1];
        continue;
      }
      if (o === W$ && s > 0) {
        if (r.ranges > 0) {
          r.ranges = 0;
          let y = r.nodes.shift();
          r.nodes = [y, { type: "text", value: U$(r) }];
        }
        h({ type: "comma", value: o }), r.commas++;
        continue;
      }
      if (o === H$ && s > 0 && r.commas === 0) {
        let y = r.nodes;
        if (s === 0 || y.length === 0) {
          h({ type: "text", value: o });
          continue;
        }
        if (l.type === "dot") {
          if (r.range = [], l.value += o, l.type = "range", r.nodes.length !== 3 && r.nodes.length !== 5) {
            r.invalid = !0, r.ranges = 0, l.type = "text";
            continue;
          }
          r.ranges++, r.args = [];
          continue;
        }
        if (l.type === "range") {
          y.pop();
          let b = y[y.length - 1];
          b.value += l.value + o, l = b, r.ranges--;
          continue;
        }
        h({ type: "dot", value: o });
        continue;
      }
      h({ type: "text", value: o });
    }
  do
    if (r = u.pop(), r.type !== "root") {
      r.nodes.forEach((E) => {
        E.nodes || (E.type === "open" && (E.isOpen = !0), E.type === "close" && (E.isClose = !0), E.nodes || (E.type = "text"), E.invalid = !0);
      });
      let y = u[u.length - 1], b = y.nodes.indexOf(r);
      y.nodes.splice(b, 1, ...r.nodes);
    }
  while (u.length > 0);
  return h({ type: "eos" }), c;
};
var eU = Z$;
const M_ = cb, tU = L$, rU = B$, nU = eU, Xn = (t, e = {}) => {
  let n = [];
  if (Array.isArray(t))
    for (let a of t) {
      let c = Xn.create(a, e);
      Array.isArray(c) ? n.push(...c) : n.push(c);
    }
  else
    n = [].concat(Xn.create(t, e));
  return e && e.expand === !0 && e.nodupes === !0 && (n = [...new Set(n)]), n;
};
Xn.parse = (t, e = {}) => nU(t, e);
Xn.stringify = (t, e = {}) => M_(typeof t == "string" ? Xn.parse(t, e) : t, e);
Xn.compile = (t, e = {}) => (typeof t == "string" && (t = Xn.parse(t, e)), tU(t, e));
Xn.expand = (t, e = {}) => {
  typeof t == "string" && (t = Xn.parse(t, e));
  let n = rU(t, e);
  return e.noempty === !0 && (n = n.filter(Boolean)), e.nodupes === !0 && (n = [...new Set(n)]), n;
};
Xn.create = (t, e = {}) => t === "" || t.length < 3 ? [t] : e.expand !== !0 ? Xn.compile(t, e) : Xn.expand(t, e);
var iU = Xn, zu = {};
const sU = Lr, es = "\\\\/", L_ = `[^${es}]`, Ds = "\\.", aU = "\\+", oU = "\\?", dp = "\\/", lU = "(?=.)", iP = "[^/]", fb = `(?:${dp}|$)`, sP = `(?:^|${dp})`, db = `${Ds}{1,2}${fb}`, uU = `(?!${Ds})`, cU = `(?!${sP}${db})`, fU = `(?!${Ds}{0,1}${fb})`, dU = `(?!${db})`, pU = `[^.${dp}]`, hU = `${iP}*?`, aP = {
  DOT_LITERAL: Ds,
  PLUS_LITERAL: aU,
  QMARK_LITERAL: oU,
  SLASH_LITERAL: dp,
  ONE_CHAR: lU,
  QMARK: iP,
  END_ANCHOR: fb,
  DOTS_SLASH: db,
  NO_DOT: uU,
  NO_DOTS: cU,
  NO_DOT_SLASH: fU,
  NO_DOTS_SLASH: dU,
  QMARK_NO_DOT: pU,
  STAR: hU,
  START_ANCHOR: sP
}, mU = {
  ...aP,
  SLASH_LITERAL: `[${es}]`,
  QMARK: L_,
  STAR: `${L_}*?`,
  DOTS_SLASH: `${Ds}{1,2}(?:[${es}]|$)`,
  NO_DOT: `(?!${Ds})`,
  NO_DOTS: `(?!(?:^|[${es}])${Ds}{1,2}(?:[${es}]|$))`,
  NO_DOT_SLASH: `(?!${Ds}{0,1}(?:[${es}]|$))`,
  NO_DOTS_SLASH: `(?!${Ds}{1,2}(?:[${es}]|$))`,
  QMARK_NO_DOT: `[^.${es}]`,
  START_ANCHOR: `(?:^|[${es}])`,
  END_ANCHOR: `(?:[${es}]|$)`
}, yU = {
  alnum: "a-zA-Z0-9",
  alpha: "a-zA-Z",
  ascii: "\\x00-\\x7F",
  blank: " \\t",
  cntrl: "\\x00-\\x1F\\x7F",
  digit: "0-9",
  graph: "\\x21-\\x7E",
  lower: "a-z",
  print: "\\x20-\\x7E ",
  punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
  space: " \\t\\r\\n\\v\\f",
  upper: "A-Z",
  word: "A-Za-z0-9_",
  xdigit: "A-Fa-f0-9"
};
var pp = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE: yU,
  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    "***": "*",
    "**/**": "**",
    "**/**/**": "**"
  },
  // Digits
  CHAR_0: 48,
  /* 0 */
  CHAR_9: 57,
  /* 9 */
  // Alphabet chars.
  CHAR_UPPERCASE_A: 65,
  /* A */
  CHAR_LOWERCASE_A: 97,
  /* a */
  CHAR_UPPERCASE_Z: 90,
  /* Z */
  CHAR_LOWERCASE_Z: 122,
  /* z */
  CHAR_LEFT_PARENTHESES: 40,
  /* ( */
  CHAR_RIGHT_PARENTHESES: 41,
  /* ) */
  CHAR_ASTERISK: 42,
  /* * */
  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38,
  /* & */
  CHAR_AT: 64,
  /* @ */
  CHAR_BACKWARD_SLASH: 92,
  /* \ */
  CHAR_CARRIAGE_RETURN: 13,
  /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94,
  /* ^ */
  CHAR_COLON: 58,
  /* : */
  CHAR_COMMA: 44,
  /* , */
  CHAR_DOT: 46,
  /* . */
  CHAR_DOUBLE_QUOTE: 34,
  /* " */
  CHAR_EQUAL: 61,
  /* = */
  CHAR_EXCLAMATION_MARK: 33,
  /* ! */
  CHAR_FORM_FEED: 12,
  /* \f */
  CHAR_FORWARD_SLASH: 47,
  /* / */
  CHAR_GRAVE_ACCENT: 96,
  /* ` */
  CHAR_HASH: 35,
  /* # */
  CHAR_HYPHEN_MINUS: 45,
  /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60,
  /* < */
  CHAR_LEFT_CURLY_BRACE: 123,
  /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91,
  /* [ */
  CHAR_LINE_FEED: 10,
  /* \n */
  CHAR_NO_BREAK_SPACE: 160,
  /* \u00A0 */
  CHAR_PERCENT: 37,
  /* % */
  CHAR_PLUS: 43,
  /* + */
  CHAR_QUESTION_MARK: 63,
  /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62,
  /* > */
  CHAR_RIGHT_CURLY_BRACE: 125,
  /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93,
  /* ] */
  CHAR_SEMICOLON: 59,
  /* ; */
  CHAR_SINGLE_QUOTE: 39,
  /* ' */
  CHAR_SPACE: 32,
  /*   */
  CHAR_TAB: 9,
  /* \t */
  CHAR_UNDERSCORE: 95,
  /* _ */
  CHAR_VERTICAL_LINE: 124,
  /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
  /* \uFEFF */
  SEP: sU.sep,
  /**
   * Create EXTGLOB_CHARS
   */
  extglobChars(t) {
    return {
      "!": { type: "negate", open: "(?:(?!(?:", close: `))${t.STAR})` },
      "?": { type: "qmark", open: "(?:", close: ")?" },
      "+": { type: "plus", open: "(?:", close: ")+" },
      "*": { type: "star", open: "(?:", close: ")*" },
      "@": { type: "at", open: "(?:", close: ")" }
    };
  },
  /**
   * Create GLOB_CHARS
   */
  globChars(t) {
    return t === !0 ? mU : aP;
  }
};
(function(t) {
  const e = Lr, n = Ve.process.platform === "win32", {
    REGEX_BACKSLASH: a,
    REGEX_REMOVE_BACKSLASH: c,
    REGEX_SPECIAL_CHARS: u,
    REGEX_SPECIAL_CHARS_GLOBAL: r
  } = pp;
  t.isObject = (l) => l !== null && typeof l == "object" && !Array.isArray(l), t.hasRegexChars = (l) => u.test(l), t.isRegexChar = (l) => l.length === 1 && t.hasRegexChars(l), t.escapeRegex = (l) => l.replace(r, "\\$1"), t.toPosixSlashes = (l) => l.replace(a, "/"), t.removeBackslashes = (l) => l.replace(c, (i) => i === "\\" ? "" : i), t.supportsLookbehinds = () => {
    const l = Ve.process.version.slice(1).split(".").map(Number);
    return l.length === 3 && l[0] >= 9 || l[0] === 8 && l[1] >= 10;
  }, t.isWindows = (l) => l && typeof l.windows == "boolean" ? l.windows : n === !0 || e.sep === "\\", t.escapeLast = (l, i, f) => {
    const d = l.lastIndexOf(i, f);
    return d === -1 ? l : l[d - 1] === "\\" ? t.escapeLast(l, i, d - 1) : `${l.slice(0, d)}\\${l.slice(d)}`;
  }, t.removePrefix = (l, i = {}) => {
    let f = l;
    return f.startsWith("./") && (f = f.slice(2), i.prefix = "./"), f;
  }, t.wrapOutput = (l, i = {}, f = {}) => {
    const d = f.contains ? "" : "^", s = f.contains ? "" : "$";
    let o = `${d}(?:${l})${s}`;
    return i.negated === !0 && (o = `(?:^(?!${o}).*$)`), o;
  };
})(zu);
const j_ = zu, {
  CHAR_ASTERISK: mm,
  /* * */
  CHAR_AT: bU,
  /* @ */
  CHAR_BACKWARD_SLASH: Hl,
  /* \ */
  CHAR_COMMA: gU,
  /* , */
  CHAR_DOT: ym,
  /* . */
  CHAR_EXCLAMATION_MARK: bm,
  /* ! */
  CHAR_FORWARD_SLASH: oP,
  /* / */
  CHAR_LEFT_CURLY_BRACE: gm,
  /* { */
  CHAR_LEFT_PARENTHESES: vm,
  /* ( */
  CHAR_LEFT_SQUARE_BRACKET: vU,
  /* [ */
  CHAR_PLUS: EU,
  /* + */
  CHAR_QUESTION_MARK: F_,
  /* ? */
  CHAR_RIGHT_CURLY_BRACE: _U,
  /* } */
  CHAR_RIGHT_PARENTHESES: B_,
  /* ) */
  CHAR_RIGHT_SQUARE_BRACKET: SU
  /* ] */
} = pp, $_ = (t) => t === oP || t === Hl, U_ = (t) => {
  t.isPrefix !== !0 && (t.depth = t.isGlobstar ? 1 / 0 : 1);
}, wU = (t, e) => {
  const n = e || {}, a = t.length - 1, c = n.parts === !0 || n.scanToEnd === !0, u = [], r = [], l = [];
  let i = t, f = -1, d = 0, s = 0, o = !1, m = !1, h = !1, y = !1, b = !1, E = !1, S = !1, g = !1, P = !1, R = !1, N = 0, C, I, D = { value: "", depth: 0, isGlob: !1 };
  const j = () => f >= a, F = () => i.charCodeAt(f + 1), _ = () => (C = I, i.charCodeAt(++f));
  for (; f < a; ) {
    I = _();
    let G;
    if (I === Hl) {
      S = D.backslashes = !0, I = _(), I === gm && (E = !0);
      continue;
    }
    if (E === !0 || I === gm) {
      for (N++; j() !== !0 && (I = _()); ) {
        if (I === Hl) {
          S = D.backslashes = !0, _();
          continue;
        }
        if (I === gm) {
          N++;
          continue;
        }
        if (E !== !0 && I === ym && (I = _()) === ym) {
          if (o = D.isBrace = !0, h = D.isGlob = !0, R = !0, c === !0)
            continue;
          break;
        }
        if (E !== !0 && I === gU) {
          if (o = D.isBrace = !0, h = D.isGlob = !0, R = !0, c === !0)
            continue;
          break;
        }
        if (I === _U && (N--, N === 0)) {
          E = !1, o = D.isBrace = !0, R = !0;
          break;
        }
      }
      if (c === !0)
        continue;
      break;
    }
    if (I === oP) {
      if (u.push(f), r.push(D), D = { value: "", depth: 0, isGlob: !1 }, R === !0)
        continue;
      if (C === ym && f === d + 1) {
        d += 2;
        continue;
      }
      s = f + 1;
      continue;
    }
    if (n.noext !== !0 && (I === EU || I === bU || I === mm || I === F_ || I === bm) === !0 && F() === vm) {
      if (h = D.isGlob = !0, y = D.isExtglob = !0, R = !0, I === bm && f === d && (P = !0), c === !0) {
        for (; j() !== !0 && (I = _()); ) {
          if (I === Hl) {
            S = D.backslashes = !0, I = _();
            continue;
          }
          if (I === B_) {
            h = D.isGlob = !0, R = !0;
            break;
          }
        }
        continue;
      }
      break;
    }
    if (I === mm) {
      if (C === mm && (b = D.isGlobstar = !0), h = D.isGlob = !0, R = !0, c === !0)
        continue;
      break;
    }
    if (I === F_) {
      if (h = D.isGlob = !0, R = !0, c === !0)
        continue;
      break;
    }
    if (I === vU) {
      for (; j() !== !0 && (G = _()); ) {
        if (G === Hl) {
          S = D.backslashes = !0, _();
          continue;
        }
        if (G === SU) {
          m = D.isBracket = !0, h = D.isGlob = !0, R = !0;
          break;
        }
      }
      if (c === !0)
        continue;
      break;
    }
    if (n.nonegate !== !0 && I === bm && f === d) {
      g = D.negated = !0, d++;
      continue;
    }
    if (n.noparen !== !0 && I === vm) {
      if (h = D.isGlob = !0, c === !0) {
        for (; j() !== !0 && (I = _()); ) {
          if (I === vm) {
            S = D.backslashes = !0, I = _();
            continue;
          }
          if (I === B_) {
            R = !0;
            break;
          }
        }
        continue;
      }
      break;
    }
    if (h === !0) {
      if (R = !0, c === !0)
        continue;
      break;
    }
  }
  n.noext === !0 && (y = !1, h = !1);
  let T = i, v = "", w = "";
  d > 0 && (v = i.slice(0, d), i = i.slice(d), s -= d), T && h === !0 && s > 0 ? (T = i.slice(0, s), w = i.slice(s)) : h === !0 ? (T = "", w = i) : T = i, T && T !== "" && T !== "/" && T !== i && $_(T.charCodeAt(T.length - 1)) && (T = T.slice(0, -1)), n.unescape === !0 && (w && (w = j_.removeBackslashes(w)), T && S === !0 && (T = j_.removeBackslashes(T)));
  const O = {
    prefix: v,
    input: t,
    start: d,
    base: T,
    glob: w,
    isBrace: o,
    isBracket: m,
    isGlob: h,
    isExtglob: y,
    isGlobstar: b,
    negated: g,
    negatedExtglob: P
  };
  if (n.tokens === !0 && (O.maxDepth = 0, $_(I) || r.push(D), O.tokens = r), n.parts === !0 || n.tokens === !0) {
    let G;
    for (let W = 0; W < u.length; W++) {
      const U = G ? G + 1 : d, M = u[W], B = t.slice(U, M);
      n.tokens && (W === 0 && d !== 0 ? (r[W].isPrefix = !0, r[W].value = v) : r[W].value = B, U_(r[W]), O.maxDepth += r[W].depth), (W !== 0 || B !== "") && l.push(B), G = M;
    }
    if (G && G + 1 < t.length) {
      const W = t.slice(G + 1);
      l.push(W), n.tokens && (r[r.length - 1].value = W, U_(r[r.length - 1]), O.maxDepth += r[r.length - 1].depth);
    }
    O.slashes = u, O.parts = l;
  }
  return O;
};
var TU = wU;
const Uf = pp, zn = zu, {
  MAX_LENGTH: Vf,
  POSIX_REGEX_SOURCE: AU,
  REGEX_NON_SPECIAL_CHARS: xU,
  REGEX_SPECIAL_CHARS_BACKREF: PU,
  REPLACEMENTS: lP
} = Uf, CU = (t, e) => {
  if (typeof e.expandRange == "function")
    return e.expandRange(...t, e);
  t.sort();
  const n = `[${t.join("-")}]`;
  try {
    new RegExp(n);
  } catch {
    return t.map((c) => zn.escapeRegex(c)).join("..");
  }
  return n;
}, mo = (t, e) => `Missing ${t}: "${e}" - use "\\\\${e}" to match literal characters`, pb = (t, e) => {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  t = lP[t] || t;
  const n = { ...e }, a = typeof n.maxLength == "number" ? Math.min(Vf, n.maxLength) : Vf;
  let c = t.length;
  if (c > a)
    throw new SyntaxError(`Input length: ${c}, exceeds maximum allowed length: ${a}`);
  const u = { type: "bos", value: "", output: n.prepend || "" }, r = [u], l = n.capture ? "" : "?:", i = zn.isWindows(e), f = Uf.globChars(i), d = Uf.extglobChars(f), {
    DOT_LITERAL: s,
    PLUS_LITERAL: o,
    SLASH_LITERAL: m,
    ONE_CHAR: h,
    DOTS_SLASH: y,
    NO_DOT: b,
    NO_DOT_SLASH: E,
    NO_DOTS_SLASH: S,
    QMARK: g,
    QMARK_NO_DOT: P,
    STAR: R,
    START_ANCHOR: N
  } = f, C = (H) => `(${l}(?:(?!${N}${H.dot ? y : s}).)*?)`, I = n.dot ? "" : b, D = n.dot ? g : P;
  let j = n.bash === !0 ? C(n) : R;
  n.capture && (j = `(${j})`), typeof n.noext == "boolean" && (n.noextglob = n.noext);
  const F = {
    input: t,
    index: -1,
    start: 0,
    dot: n.dot === !0,
    consumed: "",
    output: "",
    prefix: "",
    backtrack: !1,
    negated: !1,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: !1,
    tokens: r
  };
  t = zn.removePrefix(t, F), c = t.length;
  const _ = [], T = [], v = [];
  let w = u, O;
  const G = () => F.index === c - 1, W = F.peek = (H = 1) => t[F.index + H], U = F.advance = () => t[++F.index] || "", M = () => t.slice(F.index + 1), B = (H = "", Q = 0) => {
    F.consumed += H, F.index += Q;
  }, k = (H) => {
    F.output += H.output != null ? H.output : H.value, B(H.value);
  }, K = () => {
    let H = 1;
    for (; W() === "!" && (W(2) !== "(" || W(3) === "?"); )
      U(), F.start++, H++;
    return H % 2 === 0 ? !1 : (F.negated = !0, F.start++, !0);
  }, te = (H) => {
    F[H]++, v.push(H);
  }, z = (H) => {
    F[H]--, v.pop();
  }, q = (H) => {
    if (w.type === "globstar") {
      const Q = F.braces > 0 && (H.type === "comma" || H.type === "brace"), X = H.extglob === !0 || _.length && (H.type === "pipe" || H.type === "paren");
      H.type !== "slash" && H.type !== "paren" && !Q && !X && (F.output = F.output.slice(0, -w.output.length), w.type = "star", w.value = "*", w.output = j, F.output += w.output);
    }
    if (_.length && H.type !== "paren" && (_[_.length - 1].inner += H.value), (H.value || H.output) && k(H), w && w.type === "text" && H.type === "text") {
      w.value += H.value, w.output = (w.output || "") + H.value;
      return;
    }
    H.prev = w, r.push(H), w = H;
  }, $ = (H, Q) => {
    const X = { ...d[Q], conditions: 1, inner: "" };
    X.prev = w, X.parens = F.parens, X.output = F.output;
    const ne = (n.capture ? "(" : "") + X.open;
    te("parens"), q({ type: H, value: Q, output: F.output ? "" : h }), q({ type: "paren", extglob: !0, value: U(), output: ne }), _.push(X);
  }, Y = (H) => {
    let Q = H.close + (n.capture ? ")" : ""), X;
    if (H.type === "negate") {
      let ne = j;
      if (H.inner && H.inner.length > 1 && H.inner.includes("/") && (ne = C(n)), (ne !== j || G() || /^\)+$/.test(M())) && (Q = H.close = `)$))${ne}`), H.inner.includes("*") && (X = M()) && /^\.[^\\/.]+$/.test(X)) {
        const ye = pb(X, { ...e, fastpaths: !1 }).output;
        Q = H.close = `)${ye})${ne})`;
      }
      H.prev.type === "bos" && (F.negatedExtglob = !0);
    }
    q({ type: "paren", extglob: !0, value: O, output: Q }), z("parens");
  };
  if (n.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(t)) {
    let H = !1, Q = t.replace(PU, (X, ne, ye, ve, de, oe) => ve === "\\" ? (H = !0, X) : ve === "?" ? ne ? ne + ve + (de ? g.repeat(de.length) : "") : oe === 0 ? D + (de ? g.repeat(de.length) : "") : g.repeat(ye.length) : ve === "." ? s.repeat(ye.length) : ve === "*" ? ne ? ne + ve + (de ? j : "") : j : ne ? X : `\\${X}`);
    return H === !0 && (n.unescape === !0 ? Q = Q.replace(/\\/g, "") : Q = Q.replace(/\\+/g, (X) => X.length % 2 === 0 ? "\\\\" : X ? "\\" : "")), Q === t && n.contains === !0 ? (F.output = t, F) : (F.output = zn.wrapOutput(Q, F, e), F);
  }
  for (; !G(); ) {
    if (O = U(), O === "\0")
      continue;
    if (O === "\\") {
      const X = W();
      if (X === "/" && n.bash !== !0 || X === "." || X === ";")
        continue;
      if (!X) {
        O += "\\", q({ type: "text", value: O });
        continue;
      }
      const ne = /^\\+/.exec(M());
      let ye = 0;
      if (ne && ne[0].length > 2 && (ye = ne[0].length, F.index += ye, ye % 2 !== 0 && (O += "\\")), n.unescape === !0 ? O = U() : O += U(), F.brackets === 0) {
        q({ type: "text", value: O });
        continue;
      }
    }
    if (F.brackets > 0 && (O !== "]" || w.value === "[" || w.value === "[^")) {
      if (n.posix !== !1 && O === ":") {
        const X = w.value.slice(1);
        if (X.includes("[") && (w.posix = !0, X.includes(":"))) {
          const ne = w.value.lastIndexOf("["), ye = w.value.slice(0, ne), ve = w.value.slice(ne + 2), de = AU[ve];
          if (de) {
            w.value = ye + de, F.backtrack = !0, U(), !u.output && r.indexOf(w) === 1 && (u.output = h);
            continue;
          }
        }
      }
      (O === "[" && W() !== ":" || O === "-" && W() === "]") && (O = `\\${O}`), O === "]" && (w.value === "[" || w.value === "[^") && (O = `\\${O}`), n.posix === !0 && O === "!" && w.value === "[" && (O = "^"), w.value += O, k({ value: O });
      continue;
    }
    if (F.quotes === 1 && O !== '"') {
      O = zn.escapeRegex(O), w.value += O, k({ value: O });
      continue;
    }
    if (O === '"') {
      F.quotes = F.quotes === 1 ? 0 : 1, n.keepQuotes === !0 && q({ type: "text", value: O });
      continue;
    }
    if (O === "(") {
      te("parens"), q({ type: "paren", value: O });
      continue;
    }
    if (O === ")") {
      if (F.parens === 0 && n.strictBrackets === !0)
        throw new SyntaxError(mo("opening", "("));
      const X = _[_.length - 1];
      if (X && F.parens === X.parens + 1) {
        Y(_.pop());
        continue;
      }
      q({ type: "paren", value: O, output: F.parens ? ")" : "\\)" }), z("parens");
      continue;
    }
    if (O === "[") {
      if (n.nobracket === !0 || !M().includes("]")) {
        if (n.nobracket !== !0 && n.strictBrackets === !0)
          throw new SyntaxError(mo("closing", "]"));
        O = `\\${O}`;
      } else
        te("brackets");
      q({ type: "bracket", value: O });
      continue;
    }
    if (O === "]") {
      if (n.nobracket === !0 || w && w.type === "bracket" && w.value.length === 1) {
        q({ type: "text", value: O, output: `\\${O}` });
        continue;
      }
      if (F.brackets === 0) {
        if (n.strictBrackets === !0)
          throw new SyntaxError(mo("opening", "["));
        q({ type: "text", value: O, output: `\\${O}` });
        continue;
      }
      z("brackets");
      const X = w.value.slice(1);
      if (w.posix !== !0 && X[0] === "^" && !X.includes("/") && (O = `/${O}`), w.value += O, k({ value: O }), n.literalBrackets === !1 || zn.hasRegexChars(X))
        continue;
      const ne = zn.escapeRegex(w.value);
      if (F.output = F.output.slice(0, -w.value.length), n.literalBrackets === !0) {
        F.output += ne, w.value = ne;
        continue;
      }
      w.value = `(${l}${ne}|${w.value})`, F.output += w.value;
      continue;
    }
    if (O === "{" && n.nobrace !== !0) {
      te("braces");
      const X = {
        type: "brace",
        value: O,
        output: "(",
        outputIndex: F.output.length,
        tokensIndex: F.tokens.length
      };
      T.push(X), q(X);
      continue;
    }
    if (O === "}") {
      const X = T[T.length - 1];
      if (n.nobrace === !0 || !X) {
        q({ type: "text", value: O, output: O });
        continue;
      }
      let ne = ")";
      if (X.dots === !0) {
        const ye = r.slice(), ve = [];
        for (let de = ye.length - 1; de >= 0 && (r.pop(), ye[de].type !== "brace"); de--)
          ye[de].type !== "dots" && ve.unshift(ye[de].value);
        ne = CU(ve, n), F.backtrack = !0;
      }
      if (X.comma !== !0 && X.dots !== !0) {
        const ye = F.output.slice(0, X.outputIndex), ve = F.tokens.slice(X.tokensIndex);
        X.value = X.output = "\\{", O = ne = "\\}", F.output = ye;
        for (const de of ve)
          F.output += de.output || de.value;
      }
      q({ type: "brace", value: O, output: ne }), z("braces"), T.pop();
      continue;
    }
    if (O === "|") {
      _.length > 0 && _[_.length - 1].conditions++, q({ type: "text", value: O });
      continue;
    }
    if (O === ",") {
      let X = O;
      const ne = T[T.length - 1];
      ne && v[v.length - 1] === "braces" && (ne.comma = !0, X = "|"), q({ type: "comma", value: O, output: X });
      continue;
    }
    if (O === "/") {
      if (w.type === "dot" && F.index === F.start + 1) {
        F.start = F.index + 1, F.consumed = "", F.output = "", r.pop(), w = u;
        continue;
      }
      q({ type: "slash", value: O, output: m });
      continue;
    }
    if (O === ".") {
      if (F.braces > 0 && w.type === "dot") {
        w.value === "." && (w.output = s);
        const X = T[T.length - 1];
        w.type = "dots", w.output += O, w.value += O, X.dots = !0;
        continue;
      }
      if (F.braces + F.parens === 0 && w.type !== "bos" && w.type !== "slash") {
        q({ type: "text", value: O, output: s });
        continue;
      }
      q({ type: "dot", value: O, output: s });
      continue;
    }
    if (O === "?") {
      if (!(w && w.value === "(") && n.noextglob !== !0 && W() === "(" && W(2) !== "?") {
        $("qmark", O);
        continue;
      }
      if (w && w.type === "paren") {
        const ne = W();
        let ye = O;
        if (ne === "<" && !zn.supportsLookbehinds())
          throw new Error("Node.js v10 or higher is required for regex lookbehinds");
        (w.value === "(" && !/[!=<:]/.test(ne) || ne === "<" && !/<([!=]|\w+>)/.test(M())) && (ye = `\\${O}`), q({ type: "text", value: O, output: ye });
        continue;
      }
      if (n.dot !== !0 && (w.type === "slash" || w.type === "bos")) {
        q({ type: "qmark", value: O, output: P });
        continue;
      }
      q({ type: "qmark", value: O, output: g });
      continue;
    }
    if (O === "!") {
      if (n.noextglob !== !0 && W() === "(" && (W(2) !== "?" || !/[!=<:]/.test(W(3)))) {
        $("negate", O);
        continue;
      }
      if (n.nonegate !== !0 && F.index === 0) {
        K();
        continue;
      }
    }
    if (O === "+") {
      if (n.noextglob !== !0 && W() === "(" && W(2) !== "?") {
        $("plus", O);
        continue;
      }
      if (w && w.value === "(" || n.regex === !1) {
        q({ type: "plus", value: O, output: o });
        continue;
      }
      if (w && (w.type === "bracket" || w.type === "paren" || w.type === "brace") || F.parens > 0) {
        q({ type: "plus", value: O });
        continue;
      }
      q({ type: "plus", value: o });
      continue;
    }
    if (O === "@") {
      if (n.noextglob !== !0 && W() === "(" && W(2) !== "?") {
        q({ type: "at", extglob: !0, value: O, output: "" });
        continue;
      }
      q({ type: "text", value: O });
      continue;
    }
    if (O !== "*") {
      (O === "$" || O === "^") && (O = `\\${O}`);
      const X = xU.exec(M());
      X && (O += X[0], F.index += X[0].length), q({ type: "text", value: O });
      continue;
    }
    if (w && (w.type === "globstar" || w.star === !0)) {
      w.type = "star", w.star = !0, w.value += O, w.output = j, F.backtrack = !0, F.globstar = !0, B(O);
      continue;
    }
    let H = M();
    if (n.noextglob !== !0 && /^\([^?]/.test(H)) {
      $("star", O);
      continue;
    }
    if (w.type === "star") {
      if (n.noglobstar === !0) {
        B(O);
        continue;
      }
      const X = w.prev, ne = X.prev, ye = X.type === "slash" || X.type === "bos", ve = ne && (ne.type === "star" || ne.type === "globstar");
      if (n.bash === !0 && (!ye || H[0] && H[0] !== "/")) {
        q({ type: "star", value: O, output: "" });
        continue;
      }
      const de = F.braces > 0 && (X.type === "comma" || X.type === "brace"), oe = _.length && (X.type === "pipe" || X.type === "paren");
      if (!ye && X.type !== "paren" && !de && !oe) {
        q({ type: "star", value: O, output: "" });
        continue;
      }
      for (; H.slice(0, 3) === "/**"; ) {
        const re = t[F.index + 4];
        if (re && re !== "/")
          break;
        H = H.slice(3), B("/**", 3);
      }
      if (X.type === "bos" && G()) {
        w.type = "globstar", w.value += O, w.output = C(n), F.output = w.output, F.globstar = !0, B(O);
        continue;
      }
      if (X.type === "slash" && X.prev.type !== "bos" && !ve && G()) {
        F.output = F.output.slice(0, -(X.output + w.output).length), X.output = `(?:${X.output}`, w.type = "globstar", w.output = C(n) + (n.strictSlashes ? ")" : "|$)"), w.value += O, F.globstar = !0, F.output += X.output + w.output, B(O);
        continue;
      }
      if (X.type === "slash" && X.prev.type !== "bos" && H[0] === "/") {
        const re = H[1] !== void 0 ? "|$" : "";
        F.output = F.output.slice(0, -(X.output + w.output).length), X.output = `(?:${X.output}`, w.type = "globstar", w.output = `${C(n)}${m}|${m}${re})`, w.value += O, F.output += X.output + w.output, F.globstar = !0, B(O + U()), q({ type: "slash", value: "/", output: "" });
        continue;
      }
      if (X.type === "bos" && H[0] === "/") {
        w.type = "globstar", w.value += O, w.output = `(?:^|${m}|${C(n)}${m})`, F.output = w.output, F.globstar = !0, B(O + U()), q({ type: "slash", value: "/", output: "" });
        continue;
      }
      F.output = F.output.slice(0, -w.output.length), w.type = "globstar", w.output = C(n), w.value += O, F.output += w.output, F.globstar = !0, B(O);
      continue;
    }
    const Q = { type: "star", value: O, output: j };
    if (n.bash === !0) {
      Q.output = ".*?", (w.type === "bos" || w.type === "slash") && (Q.output = I + Q.output), q(Q);
      continue;
    }
    if (w && (w.type === "bracket" || w.type === "paren") && n.regex === !0) {
      Q.output = O, q(Q);
      continue;
    }
    (F.index === F.start || w.type === "slash" || w.type === "dot") && (w.type === "dot" ? (F.output += E, w.output += E) : n.dot === !0 ? (F.output += S, w.output += S) : (F.output += I, w.output += I), W() !== "*" && (F.output += h, w.output += h)), q(Q);
  }
  for (; F.brackets > 0; ) {
    if (n.strictBrackets === !0)
      throw new SyntaxError(mo("closing", "]"));
    F.output = zn.escapeLast(F.output, "["), z("brackets");
  }
  for (; F.parens > 0; ) {
    if (n.strictBrackets === !0)
      throw new SyntaxError(mo("closing", ")"));
    F.output = zn.escapeLast(F.output, "("), z("parens");
  }
  for (; F.braces > 0; ) {
    if (n.strictBrackets === !0)
      throw new SyntaxError(mo("closing", "}"));
    F.output = zn.escapeLast(F.output, "{"), z("braces");
  }
  if (n.strictSlashes !== !0 && (w.type === "star" || w.type === "bracket") && q({ type: "maybe_slash", value: "", output: `${m}?` }), F.backtrack === !0) {
    F.output = "";
    for (const H of F.tokens)
      F.output += H.output != null ? H.output : H.value, H.suffix && (F.output += H.suffix);
  }
  return F;
};
pb.fastpaths = (t, e) => {
  const n = { ...e }, a = typeof n.maxLength == "number" ? Math.min(Vf, n.maxLength) : Vf, c = t.length;
  if (c > a)
    throw new SyntaxError(`Input length: ${c}, exceeds maximum allowed length: ${a}`);
  t = lP[t] || t;
  const u = zn.isWindows(e), {
    DOT_LITERAL: r,
    SLASH_LITERAL: l,
    ONE_CHAR: i,
    DOTS_SLASH: f,
    NO_DOT: d,
    NO_DOTS: s,
    NO_DOTS_SLASH: o,
    STAR: m,
    START_ANCHOR: h
  } = Uf.globChars(u), y = n.dot ? s : d, b = n.dot ? o : d, E = n.capture ? "" : "?:", S = { negated: !1, prefix: "" };
  let g = n.bash === !0 ? ".*?" : m;
  n.capture && (g = `(${g})`);
  const P = (I) => I.noglobstar === !0 ? g : `(${E}(?:(?!${h}${I.dot ? f : r}).)*?)`, R = (I) => {
    switch (I) {
      case "*":
        return `${y}${i}${g}`;
      case ".*":
        return `${r}${i}${g}`;
      case "*.*":
        return `${y}${g}${r}${i}${g}`;
      case "*/*":
        return `${y}${g}${l}${i}${b}${g}`;
      case "**":
        return y + P(n);
      case "**/*":
        return `(?:${y}${P(n)}${l})?${b}${i}${g}`;
      case "**/*.*":
        return `(?:${y}${P(n)}${l})?${b}${g}${r}${i}${g}`;
      case "**/.*":
        return `(?:${y}${P(n)}${l})?${r}${i}${g}`;
      default: {
        const D = /^(.*?)\.(\w+)$/.exec(I);
        if (!D)
          return;
        const j = R(D[1]);
        return j ? j + r + D[2] : void 0;
      }
    }
  }, N = zn.removePrefix(t, S);
  let C = R(N);
  return C && n.strictSlashes !== !0 && (C += `${l}?`), C;
};
var IU = pb;
const OU = Lr, kU = TU, t0 = IU, hb = zu, DU = pp, NU = (t) => t && typeof t == "object" && !Array.isArray(t), Gr = (t, e, n = !1) => {
  if (Array.isArray(t)) {
    const d = t.map((o) => Gr(o, e, n));
    return (o) => {
      for (const m of d) {
        const h = m(o);
        if (h)
          return h;
      }
      return !1;
    };
  }
  const a = NU(t) && t.tokens && t.input;
  if (t === "" || typeof t != "string" && !a)
    throw new TypeError("Expected pattern to be a non-empty string");
  const c = e || {}, u = hb.isWindows(e), r = a ? Gr.compileRe(t, e) : Gr.makeRe(t, e, !1, !0), l = r.state;
  delete r.state;
  let i = () => !1;
  if (c.ignore) {
    const d = { ...e, ignore: null, onMatch: null, onResult: null };
    i = Gr(c.ignore, d, n);
  }
  const f = (d, s = !1) => {
    const { isMatch: o, match: m, output: h } = Gr.test(d, r, e, { glob: t, posix: u }), y = { glob: t, state: l, regex: r, posix: u, input: d, output: h, match: m, isMatch: o };
    return typeof c.onResult == "function" && c.onResult(y), o === !1 ? (y.isMatch = !1, s ? y : !1) : i(d) ? (typeof c.onIgnore == "function" && c.onIgnore(y), y.isMatch = !1, s ? y : !1) : (typeof c.onMatch == "function" && c.onMatch(y), s ? y : !0);
  };
  return n && (f.state = l), f;
};
Gr.test = (t, e, n, { glob: a, posix: c } = {}) => {
  if (typeof t != "string")
    throw new TypeError("Expected input to be a string");
  if (t === "")
    return { isMatch: !1, output: "" };
  const u = n || {}, r = u.format || (c ? hb.toPosixSlashes : null);
  let l = t === a, i = l && r ? r(t) : t;
  return l === !1 && (i = r ? r(t) : t, l = i === a), (l === !1 || u.capture === !0) && (u.matchBase === !0 || u.basename === !0 ? l = Gr.matchBase(t, e, n, c) : l = e.exec(i)), { isMatch: !!l, match: l, output: i };
};
Gr.matchBase = (t, e, n, a = hb.isWindows(n)) => (e instanceof RegExp ? e : Gr.makeRe(e, n)).test(OU.basename(t));
Gr.isMatch = (t, e, n) => Gr(e, n)(t);
Gr.parse = (t, e) => Array.isArray(t) ? t.map((n) => Gr.parse(n, e)) : t0(t, { ...e, fastpaths: !1 });
Gr.scan = (t, e) => kU(t, e);
Gr.compileRe = (t, e, n = !1, a = !1) => {
  if (n === !0)
    return t.output;
  const c = e || {}, u = c.contains ? "" : "^", r = c.contains ? "" : "$";
  let l = `${u}(?:${t.output})${r}`;
  t && t.negated === !0 && (l = `^(?!${l}).*$`);
  const i = Gr.toRegex(l, e);
  return a === !0 && (i.state = t), i;
};
Gr.makeRe = (t, e = {}, n = !1, a = !1) => {
  if (!t || typeof t != "string")
    throw new TypeError("Expected a non-empty string");
  let c = { negated: !1, fastpaths: !0 };
  return e.fastpaths !== !1 && (t[0] === "." || t[0] === "*") && (c.output = t0.fastpaths(t, e)), c.output || (c = t0(t, e)), Gr.compileRe(c, e, n, a);
};
Gr.toRegex = (t, e) => {
  try {
    const n = e || {};
    return new RegExp(t, n.flags || (n.nocase ? "i" : ""));
  } catch (n) {
    if (e && e.debug === !0)
      throw n;
    return /$^/;
  }
};
Gr.constants = DU;
var RU = Gr, MU = RU;
const uP = mi, cP = iU, Ts = MU, r0 = zu, V_ = (t) => t === "" || t === "./", Or = (t, e, n) => {
  e = [].concat(e), t = [].concat(t);
  let a = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new Set(), r = 0, l = (d) => {
    u.add(d.output), n && n.onResult && n.onResult(d);
  };
  for (let d = 0; d < e.length; d++) {
    let s = Ts(String(e[d]), { ...n, onResult: l }, !0), o = s.state.negated || s.state.negatedExtglob;
    o && r++;
    for (let m of t) {
      let h = s(m, !0);
      (o ? !h.isMatch : h.isMatch) && (o ? a.add(h.output) : (a.delete(h.output), c.add(h.output)));
    }
  }
  let f = (r === e.length ? [...u] : [...c]).filter((d) => !a.has(d));
  if (n && f.length === 0) {
    if (n.failglob === !0)
      throw new Error(`No matches found for "${e.join(", ")}"`);
    if (n.nonull === !0 || n.nullglob === !0)
      return n.unescape ? e.map((d) => d.replace(/\\/g, "")) : e;
  }
  return f;
};
Or.match = Or;
Or.matcher = (t, e) => Ts(t, e);
Or.isMatch = (t, e, n) => Ts(e, n)(t);
Or.any = Or.isMatch;
Or.not = (t, e, n = {}) => {
  e = [].concat(e).map(String);
  let a = /* @__PURE__ */ new Set(), c = [], u = (l) => {
    n.onResult && n.onResult(l), c.push(l.output);
  }, r = new Set(Or(t, e, { ...n, onResult: u }));
  for (let l of c)
    r.has(l) || a.add(l);
  return [...a];
};
Or.contains = (t, e, n) => {
  if (typeof t != "string")
    throw new TypeError(`Expected a string: "${uP.inspect(t)}"`);
  if (Array.isArray(e))
    return e.some((a) => Or.contains(t, a, n));
  if (typeof e == "string") {
    if (V_(t) || V_(e))
      return !1;
    if (t.includes(e) || t.startsWith("./") && t.slice(2).includes(e))
      return !0;
  }
  return Or.isMatch(t, e, { ...n, contains: !0 });
};
Or.matchKeys = (t, e, n) => {
  if (!r0.isObject(t))
    throw new TypeError("Expected the first argument to be an object");
  let a = Or(Object.keys(t), e, n), c = {};
  for (let u of a)
    c[u] = t[u];
  return c;
};
Or.some = (t, e, n) => {
  let a = [].concat(t);
  for (let c of [].concat(e)) {
    let u = Ts(String(c), n);
    if (a.some((r) => u(r)))
      return !0;
  }
  return !1;
};
Or.every = (t, e, n) => {
  let a = [].concat(t);
  for (let c of [].concat(e)) {
    let u = Ts(String(c), n);
    if (!a.every((r) => u(r)))
      return !1;
  }
  return !0;
};
Or.all = (t, e, n) => {
  if (typeof t != "string")
    throw new TypeError(`Expected a string: "${uP.inspect(t)}"`);
  return [].concat(e).every((a) => Ts(a, n)(t));
};
Or.capture = (t, e, n) => {
  let a = r0.isWindows(n), u = Ts.makeRe(String(t), { ...n, capture: !0 }).exec(a ? r0.toPosixSlashes(e) : e);
  if (u)
    return u.slice(1).map((r) => r === void 0 ? "" : r);
};
Or.makeRe = (...t) => Ts.makeRe(...t);
Or.scan = (...t) => Ts.scan(...t);
Or.parse = (t, e) => {
  let n = [];
  for (let a of [].concat(t || []))
    for (let c of cP(String(a), e))
      n.push(Ts.parse(c, e));
  return n;
};
Or.braces = (t, e) => {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return e && e.nobrace === !0 || !/\{.*\}/.test(t) ? [t] : cP(t, e);
};
Or.braceExpand = (t, e) => {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return Or.braces(t, { ...e, expand: !0 });
};
var LU = Or;
Object.defineProperty(Ht, "__esModule", { value: !0 });
Ht.removeDuplicateSlashes = Ht.matchAny = Ht.convertPatternsToRe = Ht.makeRe = Ht.getPatternParts = Ht.expandBraceExpansion = Ht.expandPatternsWithBraceExpansion = Ht.isAffectDepthOfReadingPattern = Ht.endsWithSlashGlobStar = Ht.hasGlobStar = Ht.getBaseDirectory = Ht.isPatternRelatedToParentDirectory = Ht.getPatternsOutsideCurrentDirectory = Ht.getPatternsInsideCurrentDirectory = Ht.getPositivePatterns = Ht.getNegativePatterns = Ht.isPositivePattern = Ht.isNegativePattern = Ht.convertToNegativePattern = Ht.convertToPositivePattern = Ht.isDynamicPattern = Ht.isStaticPattern = void 0;
const jU = Lr, FU = y$, mb = LU, fP = "**", BU = "\\", $U = /[*?]|^!/, UU = /\[[^[]*]/, VU = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/, WU = /[!*+?@]\([^(]*\)/, HU = /,|\.\./, qU = /(?!^)\/{2,}/g;
function dP(t, e = {}) {
  return !pP(t, e);
}
Ht.isStaticPattern = dP;
function pP(t, e = {}) {
  return t === "" ? !1 : !!(e.caseSensitiveMatch === !1 || t.includes(BU) || $U.test(t) || UU.test(t) || VU.test(t) || e.extglob !== !1 && WU.test(t) || e.braceExpansion !== !1 && GU(t));
}
Ht.isDynamicPattern = pP;
function GU(t) {
  const e = t.indexOf("{");
  if (e === -1)
    return !1;
  const n = t.indexOf("}", e + 1);
  if (n === -1)
    return !1;
  const a = t.slice(e, n);
  return HU.test(a);
}
function zU(t) {
  return hp(t) ? t.slice(1) : t;
}
Ht.convertToPositivePattern = zU;
function KU(t) {
  return "!" + t;
}
Ht.convertToNegativePattern = KU;
function hp(t) {
  return t.startsWith("!") && t[1] !== "(";
}
Ht.isNegativePattern = hp;
function hP(t) {
  return !hp(t);
}
Ht.isPositivePattern = hP;
function YU(t) {
  return t.filter(hp);
}
Ht.getNegativePatterns = YU;
function XU(t) {
  return t.filter(hP);
}
Ht.getPositivePatterns = XU;
function JU(t) {
  return t.filter((e) => !yb(e));
}
Ht.getPatternsInsideCurrentDirectory = JU;
function QU(t) {
  return t.filter(yb);
}
Ht.getPatternsOutsideCurrentDirectory = QU;
function yb(t) {
  return t.startsWith("..") || t.startsWith("./..");
}
Ht.isPatternRelatedToParentDirectory = yb;
function ZU(t) {
  return FU(t, { flipBackslashes: !1 });
}
Ht.getBaseDirectory = ZU;
function eV(t) {
  return t.includes(fP);
}
Ht.hasGlobStar = eV;
function mP(t) {
  return t.endsWith("/" + fP);
}
Ht.endsWithSlashGlobStar = mP;
function tV(t) {
  const e = jU.basename(t);
  return mP(t) || dP(e);
}
Ht.isAffectDepthOfReadingPattern = tV;
function rV(t) {
  return t.reduce((e, n) => e.concat(yP(n)), []);
}
Ht.expandPatternsWithBraceExpansion = rV;
function yP(t) {
  const e = mb.braces(t, { expand: !0, nodupes: !0, keepEscaping: !0 });
  return e.sort((n, a) => n.length - a.length), e.filter((n) => n !== "");
}
Ht.expandBraceExpansion = yP;
function nV(t, e) {
  let { parts: n } = mb.scan(t, Object.assign(Object.assign({}, e), { parts: !0 }));
  return n.length === 0 && (n = [t]), n[0].startsWith("/") && (n[0] = n[0].slice(1), n.unshift("")), n;
}
Ht.getPatternParts = nV;
function bP(t, e) {
  return mb.makeRe(t, e);
}
Ht.makeRe = bP;
function iV(t, e) {
  return t.map((n) => bP(n, e));
}
Ht.convertPatternsToRe = iV;
function sV(t, e) {
  return e.some((n) => n.test(t));
}
Ht.matchAny = sV;
function aV(t) {
  return t.replace(qU, "/");
}
Ht.removeDuplicateSlashes = aV;
var mp = {};
const oV = xr, gP = oV.PassThrough, lV = Array.prototype.slice;
var uV = cV;
function cV() {
  const t = [], e = lV.call(arguments);
  let n = !1, a = e[e.length - 1];
  a && !Array.isArray(a) && a.pipe == null ? e.pop() : a = {};
  const c = a.end !== !1, u = a.pipeError === !0;
  a.objectMode == null && (a.objectMode = !0), a.highWaterMark == null && (a.highWaterMark = 64 * 1024);
  const r = gP(a);
  function l() {
    for (let d = 0, s = arguments.length; d < s; d++)
      t.push(vP(arguments[d], a));
    return i(), this;
  }
  function i() {
    if (n)
      return;
    n = !0;
    let d = t.shift();
    if (!d) {
      Ve.process.nextTick(f);
      return;
    }
    Array.isArray(d) || (d = [d]);
    let s = d.length + 1;
    function o() {
      --s > 0 || (n = !1, i());
    }
    function m(h) {
      function y() {
        h.removeListener("merge2UnpipeEnd", y), h.removeListener("end", y), u && h.removeListener("error", b), o();
      }
      function b(E) {
        r.emit("error", E);
      }
      if (h._readableState.endEmitted)
        return o();
      h.on("merge2UnpipeEnd", y), h.on("end", y), u && h.on("error", b), h.pipe(r, { end: !1 }), h.resume();
    }
    for (let h = 0; h < d.length; h++)
      m(d[h]);
    o();
  }
  function f() {
    n = !1, r.emit("queueDrain"), c && r.end();
  }
  return r.setMaxListeners(0), r.add = l, r.on("unpipe", function(d) {
    d.emit("merge2UnpipeEnd");
  }), e.length && l.apply(null, e), r;
}
function vP(t, e) {
  if (Array.isArray(t))
    for (let n = 0, a = t.length; n < a; n++)
      t[n] = vP(t[n], e);
  else {
    if (!t._readableState && t.pipe && (t = t.pipe(gP(e))), !t._readableState || !t.pause || !t.pipe)
      throw new Error("Only readable stream can be merged.");
    t.pause();
  }
  return t;
}
Object.defineProperty(mp, "__esModule", { value: !0 });
mp.merge = void 0;
const fV = uV;
function dV(t) {
  const e = fV(t);
  return t.forEach((n) => {
    n.once("error", (a) => e.emit("error", a));
  }), e.once("close", () => W_(t)), e.once("end", () => W_(t)), e;
}
mp.merge = dV;
function W_(t) {
  t.forEach((e) => e.emit("close"));
}
var Yo = {};
Object.defineProperty(Yo, "__esModule", { value: !0 });
Yo.isEmpty = Yo.isString = void 0;
function pV(t) {
  return typeof t == "string";
}
Yo.isString = pV;
function hV(t) {
  return t === "";
}
Yo.isEmpty = hV;
Object.defineProperty(Mr, "__esModule", { value: !0 });
Mr.string = Mr.stream = Mr.pattern = Mr.path = Mr.fs = Mr.errno = Mr.array = void 0;
const mV = Ko;
Mr.array = mV;
const yV = up;
Mr.errno = yV;
const bV = cp;
Mr.fs = bV;
const gV = Xr;
Mr.path = gV;
const vV = Ht;
Mr.pattern = vV;
const EV = mp;
Mr.stream = EV;
const _V = Yo;
Mr.string = _V;
Object.defineProperty(Pn, "__esModule", { value: !0 });
Pn.convertPatternGroupToTask = Pn.convertPatternGroupsToTasks = Pn.groupPatternsByBaseDirectory = Pn.getNegativePatternsAsPositive = Pn.getPositivePatterns = Pn.convertPatternsToTasks = Pn.generate = void 0;
const ji = Mr;
function SV(t, e) {
  const n = H_(t, e), a = H_(e.ignore, e), c = EP(n), u = _P(n, a), r = c.filter((d) => ji.pattern.isStaticPattern(d, e)), l = c.filter((d) => ji.pattern.isDynamicPattern(d, e)), i = n0(
    r,
    u,
    /* dynamic */
    !1
  ), f = n0(
    l,
    u,
    /* dynamic */
    !0
  );
  return i.concat(f);
}
Pn.generate = SV;
function H_(t, e) {
  let n = t;
  return e.braceExpansion && (n = ji.pattern.expandPatternsWithBraceExpansion(n)), e.baseNameMatch && (n = n.map((a) => a.includes("/") ? a : `**/${a}`)), n.map((a) => ji.pattern.removeDuplicateSlashes(a));
}
function n0(t, e, n) {
  const a = [], c = ji.pattern.getPatternsOutsideCurrentDirectory(t), u = ji.pattern.getPatternsInsideCurrentDirectory(t), r = i0(c), l = i0(u);
  return a.push(...s0(r, e, n)), "." in l ? a.push(bb(".", u, e, n)) : a.push(...s0(l, e, n)), a;
}
Pn.convertPatternsToTasks = n0;
function EP(t) {
  return ji.pattern.getPositivePatterns(t);
}
Pn.getPositivePatterns = EP;
function _P(t, e) {
  return ji.pattern.getNegativePatterns(t).concat(e).map(ji.pattern.convertToPositivePattern);
}
Pn.getNegativePatternsAsPositive = _P;
function i0(t) {
  const e = {};
  return t.reduce((n, a) => {
    const c = ji.pattern.getBaseDirectory(a);
    return c in n ? n[c].push(a) : n[c] = [a], n;
  }, e);
}
Pn.groupPatternsByBaseDirectory = i0;
function s0(t, e, n) {
  return Object.keys(t).map((a) => bb(a, t[a], e, n));
}
Pn.convertPatternGroupsToTasks = s0;
function bb(t, e, n, a) {
  return {
    dynamic: a,
    positive: e,
    negative: n,
    base: t,
    patterns: [].concat(e, n.map(ji.pattern.convertToNegativePattern))
  };
}
Pn.convertPatternGroupToTask = bb;
var gb = {}, vb = {}, fi = {}, Eb = {}, yp = {}, us = {}, ra = {}, Jn = {}, bp = {};
Object.defineProperty(bp, "__esModule", { value: !0 });
bp.read = void 0;
function wV(t, e, n) {
  e.fs.lstat(t, (a, c) => {
    if (a !== null) {
      q_(n, a);
      return;
    }
    if (!c.isSymbolicLink() || !e.followSymbolicLink) {
      Em(n, c);
      return;
    }
    e.fs.stat(t, (u, r) => {
      if (u !== null) {
        if (e.throwErrorOnBrokenSymbolicLink) {
          q_(n, u);
          return;
        }
        Em(n, c);
        return;
      }
      e.markSymbolicLink && (r.isSymbolicLink = () => !0), Em(n, r);
    });
  });
}
bp.read = wV;
function q_(t, e) {
  t(e);
}
function Em(t, e) {
  t(null, e);
}
var gp = {};
Object.defineProperty(gp, "__esModule", { value: !0 });
gp.read = void 0;
function TV(t, e) {
  const n = e.fs.lstatSync(t);
  if (!n.isSymbolicLink() || !e.followSymbolicLink)
    return n;
  try {
    const a = e.fs.statSync(t);
    return e.markSymbolicLink && (a.isSymbolicLink = () => !0), a;
  } catch (a) {
    if (!e.throwErrorOnBrokenSymbolicLink)
      return n;
    throw a;
  }
}
gp.read = TV;
var _b = {}, SP = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.createFileSystemAdapter = t.FILE_SYSTEM_ADAPTER = void 0;
  const e = Dn;
  t.FILE_SYSTEM_ADAPTER = {
    lstat: e.lstat,
    stat: e.stat,
    lstatSync: e.lstatSync,
    statSync: e.statSync
  };
  function n(a) {
    return a === void 0 ? t.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, t.FILE_SYSTEM_ADAPTER), a);
  }
  t.createFileSystemAdapter = n;
})(SP);
Object.defineProperty(_b, "__esModule", { value: !0 });
const AV = SP;
let xV = class {
  constructor(e = {}) {
    this._options = e, this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, !0), this.fs = AV.createFileSystemAdapter(this._options.fs), this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !0);
  }
  _getValue(e, n) {
    return e ?? n;
  }
};
_b.default = xV;
Object.defineProperty(Jn, "__esModule", { value: !0 });
Jn.statSync = Jn.stat = Jn.Settings = void 0;
const G_ = bp, PV = gp, a0 = _b;
Jn.Settings = a0.default;
function CV(t, e, n) {
  if (typeof e == "function") {
    G_.read(t, o0(), e);
    return;
  }
  G_.read(t, o0(e), n);
}
Jn.stat = CV;
function IV(t, e) {
  const n = o0(e);
  return PV.read(t, n);
}
Jn.statSync = IV;
function o0(t = {}) {
  return t instanceof a0.default ? t : new a0.default(t);
}
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let z_;
var OV = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window < "u" ? window : Bt) : (t) => (z_ || (z_ = Promise.resolve())).then(t).catch((e) => setTimeout(() => {
  throw e;
}, 0));
/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var kV = NV;
const DV = OV;
function NV(t, e) {
  let n, a, c, u = !0;
  Array.isArray(t) ? (n = [], a = t.length) : (c = Object.keys(t), n = {}, a = c.length);
  function r(i) {
    function f() {
      e && e(i, n), e = null;
    }
    u ? DV(f) : f();
  }
  function l(i, f, d) {
    n[i] = d, (--a === 0 || f) && r(f);
  }
  a ? c ? c.forEach(function(i) {
    t[i](function(f, d) {
      l(i, f, d);
    });
  }) : t.forEach(function(i, f) {
    i(function(d, s) {
      l(f, d, s);
    });
  }) : r(null), u = !1;
}
var Ku = {};
Object.defineProperty(Ku, "__esModule", { value: !0 });
Ku.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
const Wf = Ve.process.versions.node.split(".");
if (Wf[0] === void 0 || Wf[1] === void 0)
  throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${Ve.process.versions.node}`);
const wP = Number.parseInt(Wf[0], 10), RV = Number.parseInt(Wf[1], 10), TP = 10, MV = 10, LV = wP > TP, jV = wP === TP && RV >= MV;
Ku.IS_SUPPORT_READDIR_WITH_FILE_TYPES = LV || jV;
var Yu = {}, vp = {};
Object.defineProperty(vp, "__esModule", { value: !0 });
vp.createDirentFromStats = void 0;
class FV {
  constructor(e, n) {
    this.name = e, this.isBlockDevice = n.isBlockDevice.bind(n), this.isCharacterDevice = n.isCharacterDevice.bind(n), this.isDirectory = n.isDirectory.bind(n), this.isFIFO = n.isFIFO.bind(n), this.isFile = n.isFile.bind(n), this.isSocket = n.isSocket.bind(n), this.isSymbolicLink = n.isSymbolicLink.bind(n);
  }
}
function BV(t, e) {
  return new FV(t, e);
}
vp.createDirentFromStats = BV;
Object.defineProperty(Yu, "__esModule", { value: !0 });
Yu.fs = void 0;
const $V = vp;
Yu.fs = $V;
var Xu = {};
Object.defineProperty(Xu, "__esModule", { value: !0 });
Xu.joinPathSegments = void 0;
function UV(t, e, n) {
  return t.endsWith(n) ? t + e : t + n + e;
}
Xu.joinPathSegments = UV;
Object.defineProperty(ra, "__esModule", { value: !0 });
ra.readdir = ra.readdirWithFileTypes = ra.read = void 0;
const VV = Jn, AP = kV, WV = Ku, xP = Yu, PP = Xu;
function HV(t, e, n) {
  if (!e.stats && WV.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
    CP(t, e, n);
    return;
  }
  IP(t, e, n);
}
ra.read = HV;
function CP(t, e, n) {
  e.fs.readdir(t, { withFileTypes: !0 }, (a, c) => {
    if (a !== null) {
      Hf(n, a);
      return;
    }
    const u = c.map((l) => ({
      dirent: l,
      name: l.name,
      path: PP.joinPathSegments(t, l.name, e.pathSegmentSeparator)
    }));
    if (!e.followSymbolicLinks) {
      l0(n, u);
      return;
    }
    const r = u.map((l) => qV(l, e));
    AP(r, (l, i) => {
      if (l !== null) {
        Hf(n, l);
        return;
      }
      l0(n, i);
    });
  });
}
ra.readdirWithFileTypes = CP;
function qV(t, e) {
  return (n) => {
    if (!t.dirent.isSymbolicLink()) {
      n(null, t);
      return;
    }
    e.fs.stat(t.path, (a, c) => {
      if (a !== null) {
        if (e.throwErrorOnBrokenSymbolicLink) {
          n(a);
          return;
        }
        n(null, t);
        return;
      }
      t.dirent = xP.fs.createDirentFromStats(t.name, c), n(null, t);
    });
  };
}
function IP(t, e, n) {
  e.fs.readdir(t, (a, c) => {
    if (a !== null) {
      Hf(n, a);
      return;
    }
    const u = c.map((r) => {
      const l = PP.joinPathSegments(t, r, e.pathSegmentSeparator);
      return (i) => {
        VV.stat(l, e.fsStatSettings, (f, d) => {
          if (f !== null) {
            i(f);
            return;
          }
          const s = {
            name: r,
            path: l,
            dirent: xP.fs.createDirentFromStats(r, d)
          };
          e.stats && (s.stats = d), i(null, s);
        });
      };
    });
    AP(u, (r, l) => {
      if (r !== null) {
        Hf(n, r);
        return;
      }
      l0(n, l);
    });
  });
}
ra.readdir = IP;
function Hf(t, e) {
  t(e);
}
function l0(t, e) {
  t(null, e);
}
var na = {};
Object.defineProperty(na, "__esModule", { value: !0 });
na.readdir = na.readdirWithFileTypes = na.read = void 0;
const GV = Jn, zV = Ku, OP = Yu, kP = Xu;
function KV(t, e) {
  return !e.stats && zV.IS_SUPPORT_READDIR_WITH_FILE_TYPES ? DP(t, e) : NP(t, e);
}
na.read = KV;
function DP(t, e) {
  return e.fs.readdirSync(t, { withFileTypes: !0 }).map((a) => {
    const c = {
      dirent: a,
      name: a.name,
      path: kP.joinPathSegments(t, a.name, e.pathSegmentSeparator)
    };
    if (c.dirent.isSymbolicLink() && e.followSymbolicLinks)
      try {
        const u = e.fs.statSync(c.path);
        c.dirent = OP.fs.createDirentFromStats(c.name, u);
      } catch (u) {
        if (e.throwErrorOnBrokenSymbolicLink)
          throw u;
      }
    return c;
  });
}
na.readdirWithFileTypes = DP;
function NP(t, e) {
  return e.fs.readdirSync(t).map((a) => {
    const c = kP.joinPathSegments(t, a, e.pathSegmentSeparator), u = GV.statSync(c, e.fsStatSettings), r = {
      name: a,
      path: c,
      dirent: OP.fs.createDirentFromStats(a, u)
    };
    return e.stats && (r.stats = u), r;
  });
}
na.readdir = NP;
var Sb = {}, RP = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.createFileSystemAdapter = t.FILE_SYSTEM_ADAPTER = void 0;
  const e = Dn;
  t.FILE_SYSTEM_ADAPTER = {
    lstat: e.lstat,
    stat: e.stat,
    lstatSync: e.lstatSync,
    statSync: e.statSync,
    readdir: e.readdir,
    readdirSync: e.readdirSync
  };
  function n(a) {
    return a === void 0 ? t.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, t.FILE_SYSTEM_ADAPTER), a);
  }
  t.createFileSystemAdapter = n;
})(RP);
Object.defineProperty(Sb, "__esModule", { value: !0 });
const YV = Lr, XV = Jn, JV = RP;
let QV = class {
  constructor(e = {}) {
    this._options = e, this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, !1), this.fs = JV.createFileSystemAdapter(this._options.fs), this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, YV.sep), this.stats = this._getValue(this._options.stats, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !0), this.fsStatSettings = new XV.Settings({
      followSymbolicLink: this.followSymbolicLinks,
      fs: this.fs,
      throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
    });
  }
  _getValue(e, n) {
    return e ?? n;
  }
};
Sb.default = QV;
Object.defineProperty(us, "__esModule", { value: !0 });
us.Settings = us.scandirSync = us.scandir = void 0;
const K_ = ra, ZV = na, u0 = Sb;
us.Settings = u0.default;
function eW(t, e, n) {
  if (typeof e == "function") {
    K_.read(t, c0(), e);
    return;
  }
  K_.read(t, c0(e), n);
}
us.scandir = eW;
function tW(t, e) {
  const n = c0(e);
  return ZV.read(t, n);
}
us.scandirSync = tW;
function c0(t = {}) {
  return t instanceof u0.default ? t : new u0.default(t);
}
var wb = { exports: {} };
function rW(t) {
  var e = new t(), n = e;
  function a() {
    var u = e;
    return u.next ? e = u.next : (e = new t(), n = e), u.next = null, u;
  }
  function c(u) {
    n.next = u, n = u;
  }
  return {
    get: a,
    release: c
  };
}
var nW = rW, iW = nW;
function MP(t, e, n) {
  if (typeof t == "function" && (n = e, e = t, t = null), n < 1)
    throw new Error("fastqueue concurrency must be greater than 1");
  var a = iW(sW), c = null, u = null, r = 0, l = null, i = {
    push: y,
    drain: li,
    saturated: li,
    pause: d,
    paused: !1,
    concurrency: n,
    running: f,
    resume: m,
    idle: h,
    length: s,
    getQueue: o,
    unshift: b,
    empty: li,
    kill: S,
    killAndDrain: g,
    error: P
  };
  return i;
  function f() {
    return r;
  }
  function d() {
    i.paused = !0;
  }
  function s() {
    for (var R = c, N = 0; R; )
      R = R.next, N++;
    return N;
  }
  function o() {
    for (var R = c, N = []; R; )
      N.push(R.value), R = R.next;
    return N;
  }
  function m() {
    if (i.paused) {
      i.paused = !1;
      for (var R = 0; R < i.concurrency; R++)
        r++, E();
    }
  }
  function h() {
    return r === 0 && i.length() === 0;
  }
  function y(R, N) {
    var C = a.get();
    C.context = t, C.release = E, C.value = R, C.callback = N || li, C.errorHandler = l, r === i.concurrency || i.paused ? u ? (u.next = C, u = C) : (c = C, u = C, i.saturated()) : (r++, e.call(t, C.value, C.worked));
  }
  function b(R, N) {
    var C = a.get();
    C.context = t, C.release = E, C.value = R, C.callback = N || li, r === i.concurrency || i.paused ? c ? (C.next = c, c = C) : (c = C, u = C, i.saturated()) : (r++, e.call(t, C.value, C.worked));
  }
  function E(R) {
    R && a.release(R);
    var N = c;
    N ? i.paused ? r-- : (u === c && (u = null), c = N.next, N.next = null, e.call(t, N.value, N.worked), u === null && i.empty()) : --r === 0 && i.drain();
  }
  function S() {
    c = null, u = null, i.drain = li;
  }
  function g() {
    c = null, u = null, i.drain(), i.drain = li;
  }
  function P(R) {
    l = R;
  }
}
function li() {
}
function sW() {
  this.value = null, this.callback = li, this.next = null, this.release = li, this.context = null, this.errorHandler = null;
  var t = this;
  this.worked = function(n, a) {
    var c = t.callback, u = t.errorHandler, r = t.value;
    t.value = null, t.callback = li, t.errorHandler && u(n, r), c.call(t.context, n, a), t.release(t);
  };
}
function aW(t, e, n) {
  typeof t == "function" && (n = e, e = t, t = null);
  function a(d, s) {
    e.call(this, d).then(function(o) {
      s(null, o);
    }, s);
  }
  var c = MP(t, a, n), u = c.push, r = c.unshift;
  return c.push = l, c.unshift = i, c.drained = f, c;
  function l(d) {
    var s = new Promise(function(o, m) {
      u(d, function(h, y) {
        if (h) {
          m(h);
          return;
        }
        o(y);
      });
    });
    return s.catch(li), s;
  }
  function i(d) {
    var s = new Promise(function(o, m) {
      r(d, function(h, y) {
        if (h) {
          m(h);
          return;
        }
        o(y);
      });
    });
    return s.catch(li), s;
  }
  function f() {
    if (c.idle())
      return new Promise(function(o) {
        o();
      });
    var d = c.drain, s = new Promise(function(o) {
      c.drain = function() {
        d(), o();
      };
    });
    return s;
  }
}
wb.exports = MP;
wb.exports.promise = aW;
var oW = wb.exports, di = {};
Object.defineProperty(di, "__esModule", { value: !0 });
di.joinPathSegments = di.replacePathSegmentSeparator = di.isAppliedFilter = di.isFatalError = void 0;
function lW(t, e) {
  return t.errorFilter === null ? !0 : !t.errorFilter(e);
}
di.isFatalError = lW;
function uW(t, e) {
  return t === null || t(e);
}
di.isAppliedFilter = uW;
function cW(t, e) {
  return t.split(/[/\\]/).join(e);
}
di.replacePathSegmentSeparator = cW;
function fW(t, e, n) {
  return t === "" ? e : t.endsWith(n) ? t + e : t + n + e;
}
di.joinPathSegments = fW;
var Ep = {};
Object.defineProperty(Ep, "__esModule", { value: !0 });
const dW = di;
let pW = class {
  constructor(e, n) {
    this._root = e, this._settings = n, this._root = dW.replacePathSegmentSeparator(e, n.pathSegmentSeparator);
  }
};
Ep.default = pW;
Object.defineProperty(yp, "__esModule", { value: !0 });
const hW = Tu, mW = us, yW = oW, $c = di, bW = Ep;
class gW extends bW.default {
  constructor(e, n) {
    super(e, n), this._settings = n, this._scandir = mW.scandir, this._emitter = new hW.EventEmitter(), this._queue = yW(this._worker.bind(this), this._settings.concurrency), this._isFatalError = !1, this._isDestroyed = !1, this._queue.drain = () => {
      this._isFatalError || this._emitter.emit("end");
    };
  }
  read() {
    return this._isFatalError = !1, this._isDestroyed = !1, setImmediate(() => {
      this._pushToQueue(this._root, this._settings.basePath);
    }), this._emitter;
  }
  get isDestroyed() {
    return this._isDestroyed;
  }
  destroy() {
    if (this._isDestroyed)
      throw new Error("The reader is already destroyed");
    this._isDestroyed = !0, this._queue.killAndDrain();
  }
  onEntry(e) {
    this._emitter.on("entry", e);
  }
  onError(e) {
    this._emitter.once("error", e);
  }
  onEnd(e) {
    this._emitter.once("end", e);
  }
  _pushToQueue(e, n) {
    const a = { directory: e, base: n };
    this._queue.push(a, (c) => {
      c !== null && this._handleError(c);
    });
  }
  _worker(e, n) {
    this._scandir(e.directory, this._settings.fsScandirSettings, (a, c) => {
      if (a !== null) {
        n(a, void 0);
        return;
      }
      for (const u of c)
        this._handleEntry(u, e.base);
      n(null, void 0);
    });
  }
  _handleError(e) {
    this._isDestroyed || !$c.isFatalError(this._settings, e) || (this._isFatalError = !0, this._isDestroyed = !0, this._emitter.emit("error", e));
  }
  _handleEntry(e, n) {
    if (this._isDestroyed || this._isFatalError)
      return;
    const a = e.path;
    n !== void 0 && (e.path = $c.joinPathSegments(n, e.name, this._settings.pathSegmentSeparator)), $c.isAppliedFilter(this._settings.entryFilter, e) && this._emitEntry(e), e.dirent.isDirectory() && $c.isAppliedFilter(this._settings.deepFilter, e) && this._pushToQueue(a, n === void 0 ? void 0 : e.path);
  }
  _emitEntry(e) {
    this._emitter.emit("entry", e);
  }
}
yp.default = gW;
Object.defineProperty(Eb, "__esModule", { value: !0 });
const vW = yp;
class EW {
  constructor(e, n) {
    this._root = e, this._settings = n, this._reader = new vW.default(this._root, this._settings), this._storage = [];
  }
  read(e) {
    this._reader.onError((n) => {
      _W(e, n);
    }), this._reader.onEntry((n) => {
      this._storage.push(n);
    }), this._reader.onEnd(() => {
      SW(e, this._storage);
    }), this._reader.read();
  }
}
Eb.default = EW;
function _W(t, e) {
  t(e);
}
function SW(t, e) {
  t(null, e);
}
var Tb = {};
Object.defineProperty(Tb, "__esModule", { value: !0 });
const wW = xr, TW = yp;
class AW {
  constructor(e, n) {
    this._root = e, this._settings = n, this._reader = new TW.default(this._root, this._settings), this._stream = new wW.Readable({
      objectMode: !0,
      read: () => {
      },
      destroy: () => {
        this._reader.isDestroyed || this._reader.destroy();
      }
    });
  }
  read() {
    return this._reader.onError((e) => {
      this._stream.emit("error", e);
    }), this._reader.onEntry((e) => {
      this._stream.push(e);
    }), this._reader.onEnd(() => {
      this._stream.push(null);
    }), this._reader.read(), this._stream;
  }
}
Tb.default = AW;
var Ab = {}, xb = {};
Object.defineProperty(xb, "__esModule", { value: !0 });
const xW = us, Uc = di, PW = Ep;
class CW extends PW.default {
  constructor() {
    super(...arguments), this._scandir = xW.scandirSync, this._storage = [], this._queue = /* @__PURE__ */ new Set();
  }
  read() {
    return this._pushToQueue(this._root, this._settings.basePath), this._handleQueue(), this._storage;
  }
  _pushToQueue(e, n) {
    this._queue.add({ directory: e, base: n });
  }
  _handleQueue() {
    for (const e of this._queue.values())
      this._handleDirectory(e.directory, e.base);
  }
  _handleDirectory(e, n) {
    try {
      const a = this._scandir(e, this._settings.fsScandirSettings);
      for (const c of a)
        this._handleEntry(c, n);
    } catch (a) {
      this._handleError(a);
    }
  }
  _handleError(e) {
    if (Uc.isFatalError(this._settings, e))
      throw e;
  }
  _handleEntry(e, n) {
    const a = e.path;
    n !== void 0 && (e.path = Uc.joinPathSegments(n, e.name, this._settings.pathSegmentSeparator)), Uc.isAppliedFilter(this._settings.entryFilter, e) && this._pushToStorage(e), e.dirent.isDirectory() && Uc.isAppliedFilter(this._settings.deepFilter, e) && this._pushToQueue(a, n === void 0 ? void 0 : e.path);
  }
  _pushToStorage(e) {
    this._storage.push(e);
  }
}
xb.default = CW;
Object.defineProperty(Ab, "__esModule", { value: !0 });
const IW = xb;
class OW {
  constructor(e, n) {
    this._root = e, this._settings = n, this._reader = new IW.default(this._root, this._settings);
  }
  read() {
    return this._reader.read();
  }
}
Ab.default = OW;
var Pb = {};
Object.defineProperty(Pb, "__esModule", { value: !0 });
const kW = Lr, DW = us;
class NW {
  constructor(e = {}) {
    this._options = e, this.basePath = this._getValue(this._options.basePath, void 0), this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY), this.deepFilter = this._getValue(this._options.deepFilter, null), this.entryFilter = this._getValue(this._options.entryFilter, null), this.errorFilter = this._getValue(this._options.errorFilter, null), this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, kW.sep), this.fsScandirSettings = new DW.Settings({
      followSymbolicLinks: this._options.followSymbolicLinks,
      fs: this._options.fs,
      pathSegmentSeparator: this._options.pathSegmentSeparator,
      stats: this._options.stats,
      throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
    });
  }
  _getValue(e, n) {
    return e ?? n;
  }
}
Pb.default = NW;
Object.defineProperty(fi, "__esModule", { value: !0 });
fi.Settings = fi.walkStream = fi.walkSync = fi.walk = void 0;
const Y_ = Eb, RW = Tb, MW = Ab, f0 = Pb;
fi.Settings = f0.default;
function LW(t, e, n) {
  if (typeof e == "function") {
    new Y_.default(t, qf()).read(e);
    return;
  }
  new Y_.default(t, qf(e)).read(n);
}
fi.walk = LW;
function jW(t, e) {
  const n = qf(e);
  return new MW.default(t, n).read();
}
fi.walkSync = jW;
function FW(t, e) {
  const n = qf(e);
  return new RW.default(t, n).read();
}
fi.walkStream = FW;
function qf(t = {}) {
  return t instanceof f0.default ? t : new f0.default(t);
}
var Ju = {};
Object.defineProperty(Ju, "__esModule", { value: !0 });
const BW = Lr, $W = Jn, X_ = Mr;
class UW {
  constructor(e) {
    this._settings = e, this._fsStatSettings = new $W.Settings({
      followSymbolicLink: this._settings.followSymbolicLinks,
      fs: this._settings.fs,
      throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
    });
  }
  _getFullEntryPath(e) {
    return BW.resolve(this._settings.cwd, e);
  }
  _makeEntry(e, n) {
    const a = {
      name: n,
      path: n,
      dirent: X_.fs.createDirentFromStats(n, e)
    };
    return this._settings.stats && (a.stats = e), a;
  }
  _isFatalError(e) {
    return !X_.errno.isEnoentCodeError(e) && !this._settings.suppressErrors;
  }
}
Ju.default = UW;
var _p = {};
Object.defineProperty(_p, "__esModule", { value: !0 });
const VW = xr, WW = Jn, HW = fi, qW = Ju;
class GW extends qW.default {
  constructor() {
    super(...arguments), this._walkStream = HW.walkStream, this._stat = WW.stat;
  }
  dynamic(e, n) {
    return this._walkStream(e, n);
  }
  static(e, n) {
    const a = e.map(this._getFullEntryPath, this), c = new VW.PassThrough({ objectMode: !0 });
    c._write = (u, r, l) => this._getEntry(a[u], e[u], n).then((i) => {
      i !== null && n.entryFilter(i) && c.push(i), u === a.length - 1 && c.end(), l();
    }).catch(l);
    for (let u = 0; u < a.length; u++)
      c.write(u);
    return c;
  }
  _getEntry(e, n, a) {
    return this._getStat(e).then((c) => this._makeEntry(c, n)).catch((c) => {
      if (a.errorFilter(c))
        return null;
      throw c;
    });
  }
  _getStat(e) {
    return new Promise((n, a) => {
      this._stat(e, this._fsStatSettings, (c, u) => c === null ? n(u) : a(c));
    });
  }
}
_p.default = GW;
Object.defineProperty(vb, "__esModule", { value: !0 });
const zW = fi, KW = Ju, YW = _p;
class XW extends KW.default {
  constructor() {
    super(...arguments), this._walkAsync = zW.walk, this._readerStream = new YW.default(this._settings);
  }
  dynamic(e, n) {
    return new Promise((a, c) => {
      this._walkAsync(e, n, (u, r) => {
        u === null ? a(r) : c(u);
      });
    });
  }
  async static(e, n) {
    const a = [], c = this._readerStream.static(e, n);
    return new Promise((u, r) => {
      c.once("error", r), c.on("data", (l) => a.push(l)), c.once("end", () => u(a));
    });
  }
}
vb.default = XW;
var Qu = {}, Cb = {}, Ib = {}, Ob = {};
Object.defineProperty(Ob, "__esModule", { value: !0 });
const Ll = Mr;
class JW {
  constructor(e, n, a) {
    this._patterns = e, this._settings = n, this._micromatchOptions = a, this._storage = [], this._fillStorage();
  }
  _fillStorage() {
    for (const e of this._patterns) {
      const n = this._getPatternSegments(e), a = this._splitSegmentsIntoSections(n);
      this._storage.push({
        complete: a.length <= 1,
        pattern: e,
        segments: n,
        sections: a
      });
    }
  }
  _getPatternSegments(e) {
    return Ll.pattern.getPatternParts(e, this._micromatchOptions).map((a) => Ll.pattern.isDynamicPattern(a, this._settings) ? {
      dynamic: !0,
      pattern: a,
      patternRe: Ll.pattern.makeRe(a, this._micromatchOptions)
    } : {
      dynamic: !1,
      pattern: a
    });
  }
  _splitSegmentsIntoSections(e) {
    return Ll.array.splitWhen(e, (n) => n.dynamic && Ll.pattern.hasGlobStar(n.pattern));
  }
}
Ob.default = JW;
Object.defineProperty(Ib, "__esModule", { value: !0 });
const QW = Ob;
class ZW extends QW.default {
  match(e) {
    const n = e.split("/"), a = n.length, c = this._storage.filter((u) => !u.complete || u.segments.length > a);
    for (const u of c) {
      const r = u.sections[0];
      if (!u.complete && a > r.length || n.every((i, f) => {
        const d = u.segments[f];
        return !!(d.dynamic && d.patternRe.test(i) || !d.dynamic && d.pattern === i);
      }))
        return !0;
    }
    return !1;
  }
}
Ib.default = ZW;
Object.defineProperty(Cb, "__esModule", { value: !0 });
const Vc = Mr, eH = Ib;
class tH {
  constructor(e, n) {
    this._settings = e, this._micromatchOptions = n;
  }
  getFilter(e, n, a) {
    const c = this._getMatcher(n), u = this._getNegativePatternsRe(a);
    return (r) => this._filter(e, r, c, u);
  }
  _getMatcher(e) {
    return new eH.default(e, this._settings, this._micromatchOptions);
  }
  _getNegativePatternsRe(e) {
    const n = e.filter(Vc.pattern.isAffectDepthOfReadingPattern);
    return Vc.pattern.convertPatternsToRe(n, this._micromatchOptions);
  }
  _filter(e, n, a, c) {
    if (this._isSkippedByDeep(e, n.path) || this._isSkippedSymbolicLink(n))
      return !1;
    const u = Vc.path.removeLeadingDotSegment(n.path);
    return this._isSkippedByPositivePatterns(u, a) ? !1 : this._isSkippedByNegativePatterns(u, c);
  }
  _isSkippedByDeep(e, n) {
    return this._settings.deep === 1 / 0 ? !1 : this._getEntryLevel(e, n) >= this._settings.deep;
  }
  _getEntryLevel(e, n) {
    const a = n.split("/").length;
    if (e === "")
      return a;
    const c = e.split("/").length;
    return a - c;
  }
  _isSkippedSymbolicLink(e) {
    return !this._settings.followSymbolicLinks && e.dirent.isSymbolicLink();
  }
  _isSkippedByPositivePatterns(e, n) {
    return !this._settings.baseNameMatch && !n.match(e);
  }
  _isSkippedByNegativePatterns(e, n) {
    return !Vc.pattern.matchAny(e, n);
  }
}
Cb.default = tH;
var kb = {};
Object.defineProperty(kb, "__esModule", { value: !0 });
const Pa = Mr;
class rH {
  constructor(e, n) {
    this._settings = e, this._micromatchOptions = n, this.index = /* @__PURE__ */ new Map();
  }
  getFilter(e, n) {
    const a = Pa.pattern.convertPatternsToRe(e, this._micromatchOptions), c = Pa.pattern.convertPatternsToRe(n, Object.assign(Object.assign({}, this._micromatchOptions), { dot: !0 }));
    return (u) => this._filter(u, a, c);
  }
  _filter(e, n, a) {
    const c = Pa.path.removeLeadingDotSegment(e.path);
    if (this._settings.unique && this._isDuplicateEntry(c) || this._onlyFileFilter(e) || this._onlyDirectoryFilter(e) || this._isSkippedByAbsoluteNegativePatterns(c, a))
      return !1;
    const u = e.dirent.isDirectory(), r = this._isMatchToPatterns(c, n, u) && !this._isMatchToPatterns(c, a, u);
    return this._settings.unique && r && this._createIndexRecord(c), r;
  }
  _isDuplicateEntry(e) {
    return this.index.has(e);
  }
  _createIndexRecord(e) {
    this.index.set(e, void 0);
  }
  _onlyFileFilter(e) {
    return this._settings.onlyFiles && !e.dirent.isFile();
  }
  _onlyDirectoryFilter(e) {
    return this._settings.onlyDirectories && !e.dirent.isDirectory();
  }
  _isSkippedByAbsoluteNegativePatterns(e, n) {
    if (!this._settings.absolute)
      return !1;
    const a = Pa.path.makeAbsolute(this._settings.cwd, e);
    return Pa.pattern.matchAny(a, n);
  }
  _isMatchToPatterns(e, n, a) {
    const c = Pa.pattern.matchAny(e, n);
    return !c && a ? Pa.pattern.matchAny(e + "/", n) : c;
  }
}
kb.default = rH;
var Db = {};
Object.defineProperty(Db, "__esModule", { value: !0 });
const nH = Mr;
class iH {
  constructor(e) {
    this._settings = e;
  }
  getFilter() {
    return (e) => this._isNonFatalError(e);
  }
  _isNonFatalError(e) {
    return nH.errno.isEnoentCodeError(e) || this._settings.suppressErrors;
  }
}
Db.default = iH;
var Nb = {};
Object.defineProperty(Nb, "__esModule", { value: !0 });
const J_ = Mr;
class sH {
  constructor(e) {
    this._settings = e;
  }
  getTransformer() {
    return (e) => this._transform(e);
  }
  _transform(e) {
    let n = e.path;
    return this._settings.absolute && (n = J_.path.makeAbsolute(this._settings.cwd, n), n = J_.path.unixify(n)), this._settings.markDirectories && e.dirent.isDirectory() && (n += "/"), this._settings.objectMode ? Object.assign(Object.assign({}, e), { path: n }) : n;
  }
}
Nb.default = sH;
Object.defineProperty(Qu, "__esModule", { value: !0 });
const aH = Lr, oH = Cb, lH = kb, uH = Db, cH = Nb;
class fH {
  constructor(e) {
    this._settings = e, this.errorFilter = new uH.default(this._settings), this.entryFilter = new lH.default(this._settings, this._getMicromatchOptions()), this.deepFilter = new oH.default(this._settings, this._getMicromatchOptions()), this.entryTransformer = new cH.default(this._settings);
  }
  _getRootDirectory(e) {
    return aH.resolve(this._settings.cwd, e.base);
  }
  _getReaderOptions(e) {
    const n = e.base === "." ? "" : e.base;
    return {
      basePath: n,
      pathSegmentSeparator: "/",
      concurrency: this._settings.concurrency,
      deepFilter: this.deepFilter.getFilter(n, e.positive, e.negative),
      entryFilter: this.entryFilter.getFilter(e.positive, e.negative),
      errorFilter: this.errorFilter.getFilter(),
      followSymbolicLinks: this._settings.followSymbolicLinks,
      fs: this._settings.fs,
      stats: this._settings.stats,
      throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
      transform: this.entryTransformer.getTransformer()
    };
  }
  _getMicromatchOptions() {
    return {
      dot: this._settings.dot,
      matchBase: this._settings.baseNameMatch,
      nobrace: !this._settings.braceExpansion,
      nocase: !this._settings.caseSensitiveMatch,
      noext: !this._settings.extglob,
      noglobstar: !this._settings.globstar,
      posix: !0,
      strictSlashes: !1
    };
  }
}
Qu.default = fH;
Object.defineProperty(gb, "__esModule", { value: !0 });
const dH = vb, pH = Qu;
class hH extends pH.default {
  constructor() {
    super(...arguments), this._reader = new dH.default(this._settings);
  }
  async read(e) {
    const n = this._getRootDirectory(e), a = this._getReaderOptions(e);
    return (await this.api(n, e, a)).map((u) => a.transform(u));
  }
  api(e, n, a) {
    return n.dynamic ? this._reader.dynamic(e, a) : this._reader.static(n.patterns, a);
  }
}
gb.default = hH;
var Rb = {};
Object.defineProperty(Rb, "__esModule", { value: !0 });
const mH = xr, yH = _p, bH = Qu;
class gH extends bH.default {
  constructor() {
    super(...arguments), this._reader = new yH.default(this._settings);
  }
  read(e) {
    const n = this._getRootDirectory(e), a = this._getReaderOptions(e), c = this.api(n, e, a), u = new mH.Readable({ objectMode: !0, read: () => {
    } });
    return c.once("error", (r) => u.emit("error", r)).on("data", (r) => u.emit("data", a.transform(r))).once("end", () => u.emit("end")), u.once("close", () => c.destroy()), u;
  }
  api(e, n, a) {
    return n.dynamic ? this._reader.dynamic(e, a) : this._reader.static(n.patterns, a);
  }
}
Rb.default = gH;
var Mb = {}, Lb = {};
Object.defineProperty(Lb, "__esModule", { value: !0 });
const vH = Jn, EH = fi, _H = Ju;
class SH extends _H.default {
  constructor() {
    super(...arguments), this._walkSync = EH.walkSync, this._statSync = vH.statSync;
  }
  dynamic(e, n) {
    return this._walkSync(e, n);
  }
  static(e, n) {
    const a = [];
    for (const c of e) {
      const u = this._getFullEntryPath(c), r = this._getEntry(u, c, n);
      r === null || !n.entryFilter(r) || a.push(r);
    }
    return a;
  }
  _getEntry(e, n, a) {
    try {
      const c = this._getStat(e);
      return this._makeEntry(c, n);
    } catch (c) {
      if (a.errorFilter(c))
        return null;
      throw c;
    }
  }
  _getStat(e) {
    return this._statSync(e, this._fsStatSettings);
  }
}
Lb.default = SH;
Object.defineProperty(Mb, "__esModule", { value: !0 });
const wH = Lb, TH = Qu;
class AH extends TH.default {
  constructor() {
    super(...arguments), this._reader = new wH.default(this._settings);
  }
  read(e) {
    const n = this._getRootDirectory(e), a = this._getReaderOptions(e);
    return this.api(n, e, a).map(a.transform);
  }
  api(e, n, a) {
    return n.dynamic ? this._reader.dynamic(e, a) : this._reader.static(n.patterns, a);
  }
}
Mb.default = AH;
var LP = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
  const e = Dn, a = Math.max(jr.cpus().length, 1);
  t.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: e.lstat,
    lstatSync: e.lstatSync,
    stat: e.stat,
    statSync: e.statSync,
    readdir: e.readdir,
    readdirSync: e.readdirSync
  };
  class c {
    constructor(r = {}) {
      this._options = r, this.absolute = this._getValue(this._options.absolute, !1), this.baseNameMatch = this._getValue(this._options.baseNameMatch, !1), this.braceExpansion = this._getValue(this._options.braceExpansion, !0), this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, !0), this.concurrency = this._getValue(this._options.concurrency, a), this.cwd = this._getValue(this._options.cwd, Ve.process.cwd()), this.deep = this._getValue(this._options.deep, 1 / 0), this.dot = this._getValue(this._options.dot, !1), this.extglob = this._getValue(this._options.extglob, !0), this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, !0), this.fs = this._getFileSystemMethods(this._options.fs), this.globstar = this._getValue(this._options.globstar, !0), this.ignore = this._getValue(this._options.ignore, []), this.markDirectories = this._getValue(this._options.markDirectories, !1), this.objectMode = this._getValue(this._options.objectMode, !1), this.onlyDirectories = this._getValue(this._options.onlyDirectories, !1), this.onlyFiles = this._getValue(this._options.onlyFiles, !0), this.stats = this._getValue(this._options.stats, !1), this.suppressErrors = this._getValue(this._options.suppressErrors, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !1), this.unique = this._getValue(this._options.unique, !0), this.onlyDirectories && (this.onlyFiles = !1), this.stats && (this.objectMode = !0), this.ignore = [].concat(this.ignore);
    }
    _getValue(r, l) {
      return r === void 0 ? l : r;
    }
    _getFileSystemMethods(r = {}) {
      return Object.assign(Object.assign({}, t.DEFAULT_FILE_SYSTEM_ADAPTER), r);
    }
  }
  t.default = c;
})(LP);
const jP = Pn, xH = gb, PH = Rb, CH = Mb, d0 = LP, oi = Mr;
async function p0(t, e) {
  Di(t);
  const n = h0(t, xH.default, e), a = await Promise.all(n);
  return oi.array.flatten(a);
}
(function(t) {
  t.glob = t, t.globSync = e, t.globStream = n, t.async = t;
  function e(l, i) {
    Di(l);
    const f = h0(l, CH.default, i);
    return oi.array.flatten(f);
  }
  t.sync = e;
  function n(l, i) {
    Di(l);
    const f = h0(l, PH.default, i);
    return oi.stream.merge(f);
  }
  t.stream = n;
  function a(l, i) {
    Di(l);
    const f = [].concat(l), d = new d0.default(i);
    return jP.generate(f, d);
  }
  t.generateTasks = a;
  function c(l, i) {
    Di(l);
    const f = new d0.default(i);
    return oi.pattern.isDynamicPattern(l, f);
  }
  t.isDynamicPattern = c;
  function u(l) {
    return Di(l), oi.path.escape(l);
  }
  t.escapePath = u;
  function r(l) {
    return Di(l), oi.path.convertPathToPattern(l);
  }
  t.convertPathToPattern = r, function(l) {
    function i(d) {
      return Di(d), oi.path.escapePosixPath(d);
    }
    l.escapePath = i;
    function f(d) {
      return Di(d), oi.path.convertPosixPathToPattern(d);
    }
    l.convertPathToPattern = f;
  }(t.posix || (t.posix = {})), function(l) {
    function i(d) {
      return Di(d), oi.path.escapeWindowsPath(d);
    }
    l.escapePath = i;
    function f(d) {
      return Di(d), oi.path.convertWindowsPathToPattern(d);
    }
    l.convertPathToPattern = f;
  }(t.win32 || (t.win32 = {}));
})(p0 || (p0 = {}));
function h0(t, e, n) {
  const a = [].concat(t), c = new d0.default(n), u = jP.generate(a, c), r = new e(c);
  return u.map(r.read, r);
}
function Di(t) {
  if (![].concat(t).every((a) => oi.string.isString(a) && !oi.string.isEmpty(a)))
    throw new TypeError("Patterns must be a string (non empty) or an array of strings");
}
var IH = p0;
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
var OH = function(t, e) {
  if (typeof t != "string")
    throw new TypeError("expected path to be a string");
  if (t === "\\" || t === "/")
    return "/";
  var n = t.length;
  if (n <= 1)
    return t;
  var a = "";
  if (n > 4 && t[3] === "\\") {
    var c = t[2];
    (c === "?" || c === ".") && t.slice(0, 2) === "\\\\" && (t = t.slice(2), a = "//");
  }
  var u = t.split(/[/\\]+/);
  return e !== !1 && u[u.length - 1] === "" && u.pop(), a + u.join("/");
}, FP = {}, kH = ob, DH = Lr.posix.dirname, NH = jr.platform() === "win32", mf = "/", RH = /\\/g, MH = /\\([!*?|[\](){}])/g, LH = function(e, n) {
  var a = Object.assign({ flipBackslashes: !0 }, n);
  a.flipBackslashes && NH && e.indexOf(mf) < 0 && (e = e.replace(RH, mf)), jH(e) && (e += mf), e += "a";
  do
    e = DH(e);
  while (FH(e));
  return e.replace(MH, "$1");
};
function jH(t) {
  var e = t.slice(-1), n;
  switch (e) {
    case "}":
      n = "{";
      break;
    case "]":
      n = "[";
      break;
    default:
      return !1;
  }
  var a = t.indexOf(n);
  return a < 0 ? !1 : t.slice(a + 1, -1).includes(mf);
}
function FH(t) {
  return /\([^()]+$/.test(t) || t[0] === "{" || t[0] === "[" || /[^\\][{[]/.test(t) ? !0 : kH(t);
}
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "parseGlob", {
    enumerable: !0,
    get: function() {
      return a;
    }
  });
  const e = /* @__PURE__ */ n(LH);
  function n(c) {
    return c && c.__esModule ? c : {
      default: c
    };
  }
  function a(c) {
    let u = c, r = (0, e.default)(c);
    return r !== "." && (u = c.substr(r.length), u.charAt(0) === "/" && (u = u.substr(1))), u.substr(0, 2) === "./" && (u = u.substr(2)), u.charAt(0) === "/" && (u = u.substr(1)), {
      base: r,
      glob: u
    };
  }
})(FP);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(E, S) {
    for (var g in S)
      Object.defineProperty(E, g, {
        enumerable: !0,
        get: S[g]
      });
  }
  e(t, {
    parseCandidateFiles: function() {
      return d;
    },
    resolvedChangedContent: function() {
      return y;
    }
  });
  const n = /* @__PURE__ */ f(Dn), a = /* @__PURE__ */ f(Lr), c = /* @__PURE__ */ f(ob), u = /* @__PURE__ */ f(IH), r = /* @__PURE__ */ f(OH), l = FP, i = Xa;
  function f(E) {
    return E && E.__esModule ? E : {
      default: E
    };
  }
  function d(E, S) {
    let g = S.content.files;
    g = g.filter((I) => typeof I == "string"), g = g.map(r.default);
    let P = u.default.generateTasks(g), R = [], N = [];
    for (const I of P)
      R.push(...I.positive.map((D) => s(D, !1))), N.push(...I.negative.map((D) => s(D, !0)));
    let C = [
      ...R,
      ...N
    ];
    return C = m(E, C), C = C.flatMap(h), C = C.map(o), C;
  }
  function s(E, S) {
    let g = {
      original: E,
      base: E,
      ignore: S,
      pattern: E,
      glob: null
    };
    return (0, c.default)(E) && Object.assign(g, (0, l.parseGlob)(E)), g;
  }
  function o(E) {
    let S = (0, r.default)(E.base);
    return S = u.default.escapePath(S), E.pattern = E.glob ? `${S}/${E.glob}` : S, E.pattern = E.ignore ? `!${E.pattern}` : E.pattern, E;
  }
  function m(E, S) {
    let g = [];
    return E.userConfigPath && E.tailwindConfig.content.relative && (g = [
      a.default.dirname(E.userConfigPath)
    ]), S.map((P) => (P.base = a.default.resolve(...g, P.base), P));
  }
  function h(E) {
    let S = [
      E
    ];
    try {
      let g = n.default.realpathSync(E.base);
      g !== E.base && S.push({
        ...E,
        base: g
      });
    } catch {
    }
    return S;
  }
  function y(E, S, g) {
    let P = E.tailwindConfig.content.files.filter((C) => typeof C.raw == "string").map(({ raw: C, extension: I = "html" }) => ({
      content: C,
      extension: I
    })), [R, N] = b(S, g);
    for (let C of R) {
      let I = a.default.extname(C).slice(1);
      P.push({
        file: C,
        extension: I
      });
    }
    return [
      P,
      N
    ];
  }
  function b(E, S) {
    let g = E.map((C) => C.pattern), P = /* @__PURE__ */ new Map(), R = /* @__PURE__ */ new Set();
    i.env.DEBUG && console.time("Finding changed files");
    let N = u.default.sync(g, {
      absolute: !0
    });
    for (let C of N) {
      let I = S.get(C) || -1 / 0, D = n.default.statSync(C).mtimeMs;
      D > I && (R.add(C), P.set(C, D));
    }
    return i.env.DEBUG && console.timeEnd("Finding changed files"), [
      R,
      P
    ];
  }
})(zx);
var BP = {}, _m = { exports: {} }, Q_;
function BH() {
  return Q_ || (Q_ = 1, function(t) {
    (() => {
      var e = { "./node_modules/.pnpm/create-require@1.1.1/node_modules/create-require/create-require.js": (u, r, l) => {
        const i = l("module"), f = l("path"), d = l("fs");
        u.exports = function(s) {
          return s || (s = Ve.process.cwd()), function(o) {
            try {
              return d.lstatSync(o).isDirectory();
            } catch {
              return !1;
            }
          }(s) && (s = f.join(s, "index.js")), i.createRequire ? i.createRequire(s) : i.createRequireFromPath ? i.createRequireFromPath(s) : function(o) {
            const m = new i.Module(o, null);
            return m.filename = o, m.paths = i.Module._nodeModulePaths(f.dirname(o)), m._compile("module.exports = require;", o), m.exports;
          }(s);
        };
      }, "./node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js"), f = Symbol("max"), d = Symbol("length"), s = Symbol("lengthCalculator"), o = Symbol("allowStale"), m = Symbol("maxAge"), h = Symbol("dispose"), y = Symbol("noDisposeOnSet"), b = Symbol("lruList"), E = Symbol("cache"), S = Symbol("updateAgeOnGet"), g = () => 1, P = (j, F, _) => {
          const T = j[E].get(F);
          if (T) {
            const v = T.value;
            if (R(j, v)) {
              if (C(j, T), !j[o])
                return;
            } else
              _ && (j[S] && (T.value.now = Date.now()), j[b].unshiftNode(T));
            return v.value;
          }
        }, R = (j, F) => {
          if (!F || !F.maxAge && !j[m])
            return !1;
          const _ = Date.now() - F.now;
          return F.maxAge ? _ > F.maxAge : j[m] && _ > j[m];
        }, N = (j) => {
          if (j[d] > j[f])
            for (let F = j[b].tail; j[d] > j[f] && F !== null; ) {
              const _ = F.prev;
              C(j, F), F = _;
            }
        }, C = (j, F) => {
          if (F) {
            const _ = F.value;
            j[h] && j[h](_.key, _.value), j[d] -= _.length, j[E].delete(_.key), j[b].removeNode(F);
          }
        };
        class I {
          constructor(F, _, T, v, w) {
            this.key = F, this.value = _, this.length = T, this.now = v, this.maxAge = w || 0;
          }
        }
        const D = (j, F, _, T) => {
          let v = _.value;
          R(j, v) && (C(j, _), j[o] || (v = void 0)), v && F.call(T, v.value, v.key, j);
        };
        u.exports = class {
          constructor(j) {
            if (typeof j == "number" && (j = { max: j }), j || (j = {}), j.max && (typeof j.max != "number" || j.max < 0))
              throw new TypeError("max must be a non-negative number");
            this[f] = j.max || 1 / 0;
            const F = j.length || g;
            if (this[s] = typeof F != "function" ? g : F, this[o] = j.stale || !1, j.maxAge && typeof j.maxAge != "number")
              throw new TypeError("maxAge must be a number");
            this[m] = j.maxAge || 0, this[h] = j.dispose, this[y] = j.noDisposeOnSet || !1, this[S] = j.updateAgeOnGet || !1, this.reset();
          }
          set max(j) {
            if (typeof j != "number" || j < 0)
              throw new TypeError("max must be a non-negative number");
            this[f] = j || 1 / 0, N(this);
          }
          get max() {
            return this[f];
          }
          set allowStale(j) {
            this[o] = !!j;
          }
          get allowStale() {
            return this[o];
          }
          set maxAge(j) {
            if (typeof j != "number")
              throw new TypeError("maxAge must be a non-negative number");
            this[m] = j, N(this);
          }
          get maxAge() {
            return this[m];
          }
          set lengthCalculator(j) {
            typeof j != "function" && (j = g), j !== this[s] && (this[s] = j, this[d] = 0, this[b].forEach((F) => {
              F.length = this[s](F.value, F.key), this[d] += F.length;
            })), N(this);
          }
          get lengthCalculator() {
            return this[s];
          }
          get length() {
            return this[d];
          }
          get itemCount() {
            return this[b].length;
          }
          rforEach(j, F) {
            F = F || this;
            for (let _ = this[b].tail; _ !== null; ) {
              const T = _.prev;
              D(this, j, _, F), _ = T;
            }
          }
          forEach(j, F) {
            F = F || this;
            for (let _ = this[b].head; _ !== null; ) {
              const T = _.next;
              D(this, j, _, F), _ = T;
            }
          }
          keys() {
            return this[b].toArray().map((j) => j.key);
          }
          values() {
            return this[b].toArray().map((j) => j.value);
          }
          reset() {
            this[h] && this[b] && this[b].length && this[b].forEach((j) => this[h](j.key, j.value)), this[E] = /* @__PURE__ */ new Map(), this[b] = new i(), this[d] = 0;
          }
          dump() {
            return this[b].map((j) => !R(this, j) && { k: j.key, v: j.value, e: j.now + (j.maxAge || 0) }).toArray().filter((j) => j);
          }
          dumpLru() {
            return this[b];
          }
          set(j, F, _) {
            if ((_ = _ || this[m]) && typeof _ != "number")
              throw new TypeError("maxAge must be a number");
            const T = _ ? Date.now() : 0, v = this[s](F, j);
            if (this[E].has(j)) {
              if (v > this[f])
                return C(this, this[E].get(j)), !1;
              const O = this[E].get(j).value;
              return this[h] && (this[y] || this[h](j, O.value)), O.now = T, O.maxAge = _, O.value = F, this[d] += v - O.length, O.length = v, this.get(j), N(this), !0;
            }
            const w = new I(j, F, v, T, _);
            return w.length > this[f] ? (this[h] && this[h](j, F), !1) : (this[d] += w.length, this[b].unshift(w), this[E].set(j, this[b].head), N(this), !0);
          }
          has(j) {
            if (!this[E].has(j))
              return !1;
            const F = this[E].get(j).value;
            return !R(this, F);
          }
          get(j) {
            return P(this, j, !0);
          }
          peek(j) {
            return P(this, j, !1);
          }
          pop() {
            const j = this[b].tail;
            return j ? (C(this, j), j.value) : null;
          }
          del(j) {
            C(this, this[E].get(j));
          }
          load(j) {
            this.reset();
            const F = Date.now();
            for (let _ = j.length - 1; _ >= 0; _--) {
              const T = j[_], v = T.e || 0;
              if (v === 0)
                this.set(T.k, T.v);
              else {
                const w = v - F;
                w > 0 && this.set(T.k, T.v, w);
              }
            }
          }
          prune() {
            this[E].forEach((j, F) => P(this, F, !1));
          }
        };
      }, "./node_modules/.pnpm/mlly@1.4.2/node_modules/mlly/dist lazy recursive": (u) => {
        function r(l) {
          return Promise.resolve().then(() => {
            var i = new Error("Cannot find module '" + l + "'");
            throw i.code = "MODULE_NOT_FOUND", i;
          });
        }
        r.keys = () => [], r.resolve = r, r.id = "./node_modules/.pnpm/mlly@1.4.2/node_modules/mlly/dist lazy recursive", u.exports = r;
      }, "./node_modules/.pnpm/object-hash@3.0.0/node_modules/object-hash/index.js": (u, r, l) => {
        var i = l("crypto");
        function f(b, E) {
          return function(S, g) {
            var P;
            P = g.algorithm !== "passthrough" ? i.createHash(g.algorithm) : new y(), P.write === void 0 && (P.write = P.update, P.end = P.update);
            var R = h(g, P);
            if (R.dispatch(S), P.update || P.end(""), P.digest)
              return P.digest(g.encoding === "buffer" ? void 0 : g.encoding);
            var N = P.read();
            return g.encoding === "buffer" ? N : N.toString(g.encoding);
          }(b, E = o(b, E));
        }
        (r = u.exports = f).sha1 = function(b) {
          return f(b);
        }, r.keys = function(b) {
          return f(b, { excludeValues: !0, algorithm: "sha1", encoding: "hex" });
        }, r.MD5 = function(b) {
          return f(b, { algorithm: "md5", encoding: "hex" });
        }, r.keysMD5 = function(b) {
          return f(b, { algorithm: "md5", encoding: "hex", excludeValues: !0 });
        };
        var d = i.getHashes ? i.getHashes().slice() : ["sha1", "md5"];
        d.push("passthrough");
        var s = ["buffer", "hex", "binary", "base64"];
        function o(b, E) {
          E = E || {};
          var S = {};
          if (S.algorithm = E.algorithm || "sha1", S.encoding = E.encoding || "hex", S.excludeValues = !!E.excludeValues, S.algorithm = S.algorithm.toLowerCase(), S.encoding = S.encoding.toLowerCase(), S.ignoreUnknown = E.ignoreUnknown === !0, S.respectType = E.respectType !== !1, S.respectFunctionNames = E.respectFunctionNames !== !1, S.respectFunctionProperties = E.respectFunctionProperties !== !1, S.unorderedArrays = E.unorderedArrays === !0, S.unorderedSets = E.unorderedSets !== !1, S.unorderedObjects = E.unorderedObjects !== !1, S.replacer = E.replacer || void 0, S.excludeKeys = E.excludeKeys || void 0, b === void 0)
            throw new Error("Object argument required.");
          for (var g = 0; g < d.length; ++g)
            d[g].toLowerCase() === S.algorithm.toLowerCase() && (S.algorithm = d[g]);
          if (d.indexOf(S.algorithm) === -1)
            throw new Error('Algorithm "' + S.algorithm + '"  not supported. supported values: ' + d.join(", "));
          if (s.indexOf(S.encoding) === -1 && S.algorithm !== "passthrough")
            throw new Error('Encoding "' + S.encoding + '"  not supported. supported values: ' + s.join(", "));
          return S;
        }
        function m(b) {
          return typeof b != "function" ? !1 : /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(b)) != null;
        }
        function h(b, E, S) {
          S = S || [];
          var g = function(P) {
            return E.update ? E.update(P, "utf8") : E.write(P, "utf8");
          };
          return { dispatch: function(P) {
            b.replacer && (P = b.replacer(P));
            var R = typeof P;
            return P === null && (R = "null"), this["_" + R](P);
          }, _object: function(P) {
            var R = Object.prototype.toString.call(P), N = /\[object (.*)\]/i.exec(R);
            N = (N = N ? N[1] : "unknown:[" + R + "]").toLowerCase();
            var C;
            if ((C = S.indexOf(P)) >= 0)
              return this.dispatch("[CIRCULAR:" + C + "]");
            if (S.push(P), typeof Ve.Buffer < "u" && Ve.Buffer.isBuffer && Ve.Buffer.isBuffer(P))
              return g("buffer:"), g(P);
            if (N === "object" || N === "function" || N === "asyncfunction") {
              var I = Object.keys(P);
              b.unorderedObjects && (I = I.sort()), b.respectType === !1 || m(P) || I.splice(0, 0, "prototype", "__proto__", "constructor"), b.excludeKeys && (I = I.filter(function(j) {
                return !b.excludeKeys(j);
              })), g("object:" + I.length + ":");
              var D = this;
              return I.forEach(function(j) {
                D.dispatch(j), g(":"), b.excludeValues || D.dispatch(P[j]), g(",");
              });
            }
            if (!this["_" + N]) {
              if (b.ignoreUnknown)
                return g("[" + N + "]");
              throw new Error('Unknown object type "' + N + '"');
            }
            this["_" + N](P);
          }, _array: function(P, R) {
            R = R !== void 0 ? R : b.unorderedArrays !== !1;
            var N = this;
            if (g("array:" + P.length + ":"), !R || P.length <= 1)
              return P.forEach(function(D) {
                return N.dispatch(D);
              });
            var C = [], I = P.map(function(D) {
              var j = new y(), F = S.slice();
              return h(b, j, F).dispatch(D), C = C.concat(F.slice(S.length)), j.read().toString();
            });
            return S = S.concat(C), I.sort(), this._array(I, !1);
          }, _date: function(P) {
            return g("date:" + P.toJSON());
          }, _symbol: function(P) {
            return g("symbol:" + P.toString());
          }, _error: function(P) {
            return g("error:" + P.toString());
          }, _boolean: function(P) {
            return g("bool:" + P.toString());
          }, _string: function(P) {
            g("string:" + P.length + ":"), g(P.toString());
          }, _function: function(P) {
            g("fn:"), m(P) ? this.dispatch("[native]") : this.dispatch(P.toString()), b.respectFunctionNames !== !1 && this.dispatch("function-name:" + String(P.name)), b.respectFunctionProperties && this._object(P);
          }, _number: function(P) {
            return g("number:" + P.toString());
          }, _xml: function(P) {
            return g("xml:" + P.toString());
          }, _null: function() {
            return g("Null");
          }, _undefined: function() {
            return g("Undefined");
          }, _regexp: function(P) {
            return g("regex:" + P.toString());
          }, _uint8array: function(P) {
            return g("uint8array:"), this.dispatch(Array.prototype.slice.call(P));
          }, _uint8clampedarray: function(P) {
            return g("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(P));
          }, _int8array: function(P) {
            return g("int8array:"), this.dispatch(Array.prototype.slice.call(P));
          }, _uint16array: function(P) {
            return g("uint16array:"), this.dispatch(Array.prototype.slice.call(P));
          }, _int16array: function(P) {
            return g("int16array:"), this.dispatch(Array.prototype.slice.call(P));
          }, _uint32array: function(P) {
            return g("uint32array:"), this.dispatch(Array.prototype.slice.call(P));
          }, _int32array: function(P) {
            return g("int32array:"), this.dispatch(Array.prototype.slice.call(P));
          }, _float32array: function(P) {
            return g("float32array:"), this.dispatch(Array.prototype.slice.call(P));
          }, _float64array: function(P) {
            return g("float64array:"), this.dispatch(Array.prototype.slice.call(P));
          }, _arraybuffer: function(P) {
            return g("arraybuffer:"), this.dispatch(new Uint8Array(P));
          }, _url: function(P) {
            return g("url:" + P.toString());
          }, _map: function(P) {
            g("map:");
            var R = Array.from(P);
            return this._array(R, b.unorderedSets !== !1);
          }, _set: function(P) {
            g("set:");
            var R = Array.from(P);
            return this._array(R, b.unorderedSets !== !1);
          }, _file: function(P) {
            return g("file:"), this.dispatch([P.name, P.size, P.type, P.lastModfied]);
          }, _blob: function() {
            if (b.ignoreUnknown)
              return g("[blob]");
            throw Error(`Hashing Blob objects is currently not supported
(see https://github.com/puleos/object-hash/issues/26)
Use "options.replacer" or "options.ignoreUnknown"
`);
          }, _domwindow: function() {
            return g("domwindow");
          }, _bigint: function(P) {
            return g("bigint:" + P.toString());
          }, _process: function() {
            return g("process");
          }, _timer: function() {
            return g("timer");
          }, _pipe: function() {
            return g("pipe");
          }, _tcp: function() {
            return g("tcp");
          }, _udp: function() {
            return g("udp");
          }, _tty: function() {
            return g("tty");
          }, _statwatcher: function() {
            return g("statwatcher");
          }, _securecontext: function() {
            return g("securecontext");
          }, _connection: function() {
            return g("connection");
          }, _zlib: function() {
            return g("zlib");
          }, _context: function() {
            return g("context");
          }, _nodescript: function() {
            return g("nodescript");
          }, _httpparser: function() {
            return g("httpparser");
          }, _dataview: function() {
            return g("dataview");
          }, _signal: function() {
            return g("signal");
          }, _fsevent: function() {
            return g("fsevent");
          }, _tlswrap: function() {
            return g("tlswrap");
          } };
        }
        function y() {
          return { buf: "", write: function(b) {
            this.buf += b;
          }, end: function(b) {
            this.buf += b;
          }, read: function() {
            return this.buf;
          } };
        }
        r.writeToStream = function(b, E, S) {
          return S === void 0 && (S = E, E = {}), h(E = o(b, E), S).dispatch(b);
        };
      }, "./node_modules/.pnpm/pirates@4.0.6/node_modules/pirates/lib/index.js": (u, r, l) => {
        u = l.nmd(u), Object.defineProperty(r, "__esModule", { value: !0 }), r.addHook = function(h, y = {}) {
          let b = !1;
          const E = [], S = [];
          let g;
          const P = o._extensions[".js"], R = y.matcher || null, N = y.ignoreNodeModules !== !1;
          return g = y.extensions || y.exts || y.extension || y.ext || [".js"], Array.isArray(g) || (g = [g]), g.forEach((C) => {
            if (typeof C != "string")
              throw new TypeError(`Invalid Extension: ${C}`);
            const I = o._extensions[C] || P;
            S[C] = o._extensions[C], E[C] = o._extensions[C] = function(D, j) {
              let F;
              b || function(_, T, v, w) {
                if (typeof _ != "string" || T.indexOf(f.default.extname(_)) === -1)
                  return !1;
                const O = f.default.resolve(_);
                return w && s.test(O) ? !1 : v && typeof v == "function" ? !!v(O) : !0;
              }(j, g, R, N) && (F = D._compile, D._compile = function(_) {
                D._compile = F;
                const T = h(_, j);
                if (typeof T != "string")
                  throw new Error(m);
                return D._compile(T, j);
              }), I(D, j);
            };
          }), function() {
            b || (b = !0, g.forEach((C) => {
              o._extensions[C] === E[C] && (S[C] ? o._extensions[C] = S[C] : delete o._extensions[C]);
            }));
          };
        };
        var i = d(l("module")), f = d(l("path"));
        function d(h) {
          return h && h.__esModule ? h : { default: h };
        }
        const s = /^(?:.*[\\/])?node_modules(?:[\\/].*)?$/, o = u.constructor.length > 1 ? u.constructor : i.default, m = `[Pirates] A hook returned a non-string, or nothing at all! This is a violation of intergalactic law!
--------------------
If you have no idea what this means or what Pirates is, let me explain: Pirates is a module that makes is easy to implement require hooks. One of the require hooks you're using uses it. One of these require hooks didn't return anything from it's handler, so we don't know what to do. You might want to debug this.`;
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/comparator.js": (u, r, l) => {
        const i = Symbol("SemVer ANY");
        class f {
          static get ANY() {
            return i;
          }
          constructor(S, g) {
            if (g = d(g), S instanceof f) {
              if (S.loose === !!g.loose)
                return S;
              S = S.value;
            }
            S = S.trim().split(/\s+/).join(" "), h("comparator", S, g), this.options = g, this.loose = !!g.loose, this.parse(S), this.semver === i ? this.value = "" : this.value = this.operator + this.semver.version, h("comp", this);
          }
          parse(S) {
            const g = this.options.loose ? s[o.COMPARATORLOOSE] : s[o.COMPARATOR], P = S.match(g);
            if (!P)
              throw new TypeError(`Invalid comparator: ${S}`);
            this.operator = P[1] !== void 0 ? P[1] : "", this.operator === "=" && (this.operator = ""), P[2] ? this.semver = new y(P[2], this.options.loose) : this.semver = i;
          }
          toString() {
            return this.value;
          }
          test(S) {
            if (h("Comparator.test", S, this.options.loose), this.semver === i || S === i)
              return !0;
            if (typeof S == "string")
              try {
                S = new y(S, this.options);
              } catch {
                return !1;
              }
            return m(S, this.operator, this.semver, this.options);
          }
          intersects(S, g) {
            if (!(S instanceof f))
              throw new TypeError("a Comparator is required");
            return this.operator === "" ? this.value === "" || new b(S.value, g).test(this.value) : S.operator === "" ? S.value === "" || new b(this.value, g).test(S.semver) : (!(g = d(g)).includePrerelease || this.value !== "<0.0.0-0" && S.value !== "<0.0.0-0") && !(!g.includePrerelease && (this.value.startsWith("<0.0.0") || S.value.startsWith("<0.0.0"))) && (!(!this.operator.startsWith(">") || !S.operator.startsWith(">")) || !(!this.operator.startsWith("<") || !S.operator.startsWith("<")) || !(this.semver.version !== S.semver.version || !this.operator.includes("=") || !S.operator.includes("=")) || !!(m(this.semver, "<", S.semver, g) && this.operator.startsWith(">") && S.operator.startsWith("<")) || !!(m(this.semver, ">", S.semver, g) && this.operator.startsWith("<") && S.operator.startsWith(">")));
          }
        }
        u.exports = f;
        const d = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/parse-options.js"), { safeRe: s, t: o } = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/re.js"), m = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/cmp.js"), h = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/debug.js"), y = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/semver.js"), b = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/range.js");
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/range.js": (u, r, l) => {
        class i {
          constructor(B, k) {
            if (k = d(k), B instanceof i)
              return B.loose === !!k.loose && B.includePrerelease === !!k.includePrerelease ? B : new i(B.raw, k);
            if (B instanceof s)
              return this.raw = B.value, this.set = [[B]], this.format(), this;
            if (this.options = k, this.loose = !!k.loose, this.includePrerelease = !!k.includePrerelease, this.raw = B.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((K) => this.parseRange(K.trim())).filter((K) => K.length), !this.set.length)
              throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
            if (this.set.length > 1) {
              const K = this.set[0];
              if (this.set = this.set.filter((te) => !R(te[0])), this.set.length === 0)
                this.set = [K];
              else if (this.set.length > 1) {
                for (const te of this.set)
                  if (te.length === 1 && N(te[0])) {
                    this.set = [te];
                    break;
                  }
              }
            }
            this.format();
          }
          format() {
            return this.range = this.set.map((B) => B.join(" ").trim()).join("||").trim(), this.range;
          }
          toString() {
            return this.range;
          }
          parseRange(B) {
            const k = ((this.options.includePrerelease && g) | (this.options.loose && P)) + ":" + B, K = f.get(k);
            if (K)
              return K;
            const te = this.options.loose, z = te ? h[y.HYPHENRANGELOOSE] : h[y.HYPHENRANGE];
            B = B.replace(z, W(this.options.includePrerelease)), o("hyphen replace", B), B = B.replace(h[y.COMPARATORTRIM], b), o("comparator trim", B), B = B.replace(h[y.TILDETRIM], E), o("tilde trim", B), B = B.replace(h[y.CARETTRIM], S), o("caret trim", B);
            let q = B.split(" ").map((Q) => I(Q, this.options)).join(" ").split(/\s+/).map((Q) => G(Q, this.options));
            te && (q = q.filter((Q) => (o("loose invalid filter", Q, this.options), !!Q.match(h[y.COMPARATORLOOSE])))), o("range list", q);
            const $ = /* @__PURE__ */ new Map(), Y = q.map((Q) => new s(Q, this.options));
            for (const Q of Y) {
              if (R(Q))
                return [Q];
              $.set(Q.value, Q);
            }
            $.size > 1 && $.has("") && $.delete("");
            const H = [...$.values()];
            return f.set(k, H), H;
          }
          intersects(B, k) {
            if (!(B instanceof i))
              throw new TypeError("a Range is required");
            return this.set.some((K) => C(K, k) && B.set.some((te) => C(te, k) && K.every((z) => te.every((q) => z.intersects(q, k)))));
          }
          test(B) {
            if (!B)
              return !1;
            if (typeof B == "string")
              try {
                B = new m(B, this.options);
              } catch {
                return !1;
              }
            for (let k = 0; k < this.set.length; k++)
              if (U(this.set[k], B, this.options))
                return !0;
            return !1;
          }
        }
        u.exports = i;
        const f = new (l("./node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js"))({ max: 1e3 }), d = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/parse-options.js"), s = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/comparator.js"), o = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/debug.js"), m = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/semver.js"), { safeRe: h, t: y, comparatorTrimReplace: b, tildeTrimReplace: E, caretTrimReplace: S } = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/re.js"), { FLAG_INCLUDE_PRERELEASE: g, FLAG_LOOSE: P } = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/constants.js"), R = (M) => M.value === "<0.0.0-0", N = (M) => M.value === "", C = (M, B) => {
          let k = !0;
          const K = M.slice();
          let te = K.pop();
          for (; k && K.length; )
            k = K.every((z) => te.intersects(z, B)), te = K.pop();
          return k;
        }, I = (M, B) => (o("comp", M, B), M = _(M, B), o("caret", M), M = j(M, B), o("tildes", M), M = v(M, B), o("xrange", M), M = O(M, B), o("stars", M), M), D = (M) => !M || M.toLowerCase() === "x" || M === "*", j = (M, B) => M.trim().split(/\s+/).map((k) => F(k, B)).join(" "), F = (M, B) => {
          const k = B.loose ? h[y.TILDELOOSE] : h[y.TILDE];
          return M.replace(k, (K, te, z, q, $) => {
            let Y;
            return o("tilde", M, K, te, z, q, $), D(te) ? Y = "" : D(z) ? Y = `>=${te}.0.0 <${+te + 1}.0.0-0` : D(q) ? Y = `>=${te}.${z}.0 <${te}.${+z + 1}.0-0` : $ ? (o("replaceTilde pr", $), Y = `>=${te}.${z}.${q}-${$} <${te}.${+z + 1}.0-0`) : Y = `>=${te}.${z}.${q} <${te}.${+z + 1}.0-0`, o("tilde return", Y), Y;
          });
        }, _ = (M, B) => M.trim().split(/\s+/).map((k) => T(k, B)).join(" "), T = (M, B) => {
          o("caret", M, B);
          const k = B.loose ? h[y.CARETLOOSE] : h[y.CARET], K = B.includePrerelease ? "-0" : "";
          return M.replace(k, (te, z, q, $, Y) => {
            let H;
            return o("caret", M, te, z, q, $, Y), D(z) ? H = "" : D(q) ? H = `>=${z}.0.0${K} <${+z + 1}.0.0-0` : D($) ? H = z === "0" ? `>=${z}.${q}.0${K} <${z}.${+q + 1}.0-0` : `>=${z}.${q}.0${K} <${+z + 1}.0.0-0` : Y ? (o("replaceCaret pr", Y), H = z === "0" ? q === "0" ? `>=${z}.${q}.${$}-${Y} <${z}.${q}.${+$ + 1}-0` : `>=${z}.${q}.${$}-${Y} <${z}.${+q + 1}.0-0` : `>=${z}.${q}.${$}-${Y} <${+z + 1}.0.0-0`) : (o("no pr"), H = z === "0" ? q === "0" ? `>=${z}.${q}.${$}${K} <${z}.${q}.${+$ + 1}-0` : `>=${z}.${q}.${$}${K} <${z}.${+q + 1}.0-0` : `>=${z}.${q}.${$} <${+z + 1}.0.0-0`), o("caret return", H), H;
          });
        }, v = (M, B) => (o("replaceXRanges", M, B), M.split(/\s+/).map((k) => w(k, B)).join(" ")), w = (M, B) => {
          M = M.trim();
          const k = B.loose ? h[y.XRANGELOOSE] : h[y.XRANGE];
          return M.replace(k, (K, te, z, q, $, Y) => {
            o("xRange", M, K, te, z, q, $, Y);
            const H = D(z), Q = H || D(q), X = Q || D($), ne = X;
            return te === "=" && ne && (te = ""), Y = B.includePrerelease ? "-0" : "", H ? K = te === ">" || te === "<" ? "<0.0.0-0" : "*" : te && ne ? (Q && (q = 0), $ = 0, te === ">" ? (te = ">=", Q ? (z = +z + 1, q = 0, $ = 0) : (q = +q + 1, $ = 0)) : te === "<=" && (te = "<", Q ? z = +z + 1 : q = +q + 1), te === "<" && (Y = "-0"), K = `${te + z}.${q}.${$}${Y}`) : Q ? K = `>=${z}.0.0${Y} <${+z + 1}.0.0-0` : X && (K = `>=${z}.${q}.0${Y} <${z}.${+q + 1}.0-0`), o("xRange return", K), K;
          });
        }, O = (M, B) => (o("replaceStars", M, B), M.trim().replace(h[y.STAR], "")), G = (M, B) => (o("replaceGTE0", M, B), M.trim().replace(h[B.includePrerelease ? y.GTE0PRE : y.GTE0], "")), W = (M) => (B, k, K, te, z, q, $, Y, H, Q, X, ne, ye) => `${k = D(K) ? "" : D(te) ? `>=${K}.0.0${M ? "-0" : ""}` : D(z) ? `>=${K}.${te}.0${M ? "-0" : ""}` : q ? `>=${k}` : `>=${k}${M ? "-0" : ""}`} ${Y = D(H) ? "" : D(Q) ? `<${+H + 1}.0.0-0` : D(X) ? `<${H}.${+Q + 1}.0-0` : ne ? `<=${H}.${Q}.${X}-${ne}` : M ? `<${H}.${Q}.${+X + 1}-0` : `<=${Y}`}`.trim(), U = (M, B, k) => {
          for (let K = 0; K < M.length; K++)
            if (!M[K].test(B))
              return !1;
          if (B.prerelease.length && !k.includePrerelease) {
            for (let K = 0; K < M.length; K++)
              if (o(M[K].semver), M[K].semver !== s.ANY && M[K].semver.prerelease.length > 0) {
                const te = M[K].semver;
                if (te.major === B.major && te.minor === B.minor && te.patch === B.patch)
                  return !0;
              }
            return !1;
          }
          return !0;
        };
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/semver.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/debug.js"), { MAX_LENGTH: f, MAX_SAFE_INTEGER: d } = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/constants.js"), { safeRe: s, t: o } = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/re.js"), m = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/parse-options.js"), { compareIdentifiers: h } = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/identifiers.js");
        class y {
          constructor(E, S) {
            if (S = m(S), E instanceof y) {
              if (E.loose === !!S.loose && E.includePrerelease === !!S.includePrerelease)
                return E;
              E = E.version;
            } else if (typeof E != "string")
              throw new TypeError(`Invalid version. Must be a string. Got type "${typeof E}".`);
            if (E.length > f)
              throw new TypeError(`version is longer than ${f} characters`);
            i("SemVer", E, S), this.options = S, this.loose = !!S.loose, this.includePrerelease = !!S.includePrerelease;
            const g = E.trim().match(S.loose ? s[o.LOOSE] : s[o.FULL]);
            if (!g)
              throw new TypeError(`Invalid Version: ${E}`);
            if (this.raw = E, this.major = +g[1], this.minor = +g[2], this.patch = +g[3], this.major > d || this.major < 0)
              throw new TypeError("Invalid major version");
            if (this.minor > d || this.minor < 0)
              throw new TypeError("Invalid minor version");
            if (this.patch > d || this.patch < 0)
              throw new TypeError("Invalid patch version");
            g[4] ? this.prerelease = g[4].split(".").map((P) => {
              if (/^[0-9]+$/.test(P)) {
                const R = +P;
                if (R >= 0 && R < d)
                  return R;
              }
              return P;
            }) : this.prerelease = [], this.build = g[5] ? g[5].split(".") : [], this.format();
          }
          format() {
            return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
          }
          toString() {
            return this.version;
          }
          compare(E) {
            if (i("SemVer.compare", this.version, this.options, E), !(E instanceof y)) {
              if (typeof E == "string" && E === this.version)
                return 0;
              E = new y(E, this.options);
            }
            return E.version === this.version ? 0 : this.compareMain(E) || this.comparePre(E);
          }
          compareMain(E) {
            return E instanceof y || (E = new y(E, this.options)), h(this.major, E.major) || h(this.minor, E.minor) || h(this.patch, E.patch);
          }
          comparePre(E) {
            if (E instanceof y || (E = new y(E, this.options)), this.prerelease.length && !E.prerelease.length)
              return -1;
            if (!this.prerelease.length && E.prerelease.length)
              return 1;
            if (!this.prerelease.length && !E.prerelease.length)
              return 0;
            let S = 0;
            do {
              const g = this.prerelease[S], P = E.prerelease[S];
              if (i("prerelease compare", S, g, P), g === void 0 && P === void 0)
                return 0;
              if (P === void 0)
                return 1;
              if (g === void 0)
                return -1;
              if (g !== P)
                return h(g, P);
            } while (++S);
          }
          compareBuild(E) {
            E instanceof y || (E = new y(E, this.options));
            let S = 0;
            do {
              const g = this.build[S], P = E.build[S];
              if (i("prerelease compare", S, g, P), g === void 0 && P === void 0)
                return 0;
              if (P === void 0)
                return 1;
              if (g === void 0)
                return -1;
              if (g !== P)
                return h(g, P);
            } while (++S);
          }
          inc(E, S, g) {
            switch (E) {
              case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", S, g);
                break;
              case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", S, g);
                break;
              case "prepatch":
                this.prerelease.length = 0, this.inc("patch", S, g), this.inc("pre", S, g);
                break;
              case "prerelease":
                this.prerelease.length === 0 && this.inc("patch", S, g), this.inc("pre", S, g);
                break;
              case "major":
                this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
              case "minor":
                this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
                break;
              case "patch":
                this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                break;
              case "pre": {
                const P = Number(g) ? 1 : 0;
                if (!S && g === !1)
                  throw new Error("invalid increment argument: identifier is empty");
                if (this.prerelease.length === 0)
                  this.prerelease = [P];
                else {
                  let R = this.prerelease.length;
                  for (; --R >= 0; )
                    typeof this.prerelease[R] == "number" && (this.prerelease[R]++, R = -2);
                  if (R === -1) {
                    if (S === this.prerelease.join(".") && g === !1)
                      throw new Error("invalid increment argument: identifier already exists");
                    this.prerelease.push(P);
                  }
                }
                if (S) {
                  let R = [S, P];
                  g === !1 && (R = [S]), h(this.prerelease[0], S) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = R) : this.prerelease = R;
                }
                break;
              }
              default:
                throw new Error(`invalid increment argument: ${E}`);
            }
            return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
          }
        }
        u.exports = y;
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/clean.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/parse.js");
        u.exports = (f, d) => {
          const s = i(f.trim().replace(/^[=v]+/, ""), d);
          return s ? s.version : null;
        };
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/cmp.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/eq.js"), f = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/neq.js"), d = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/gt.js"), s = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/gte.js"), o = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/lt.js"), m = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/lte.js");
        u.exports = (h, y, b, E) => {
          switch (y) {
            case "===":
              return typeof h == "object" && (h = h.version), typeof b == "object" && (b = b.version), h === b;
            case "!==":
              return typeof h == "object" && (h = h.version), typeof b == "object" && (b = b.version), h !== b;
            case "":
            case "=":
            case "==":
              return i(h, b, E);
            case "!=":
              return f(h, b, E);
            case ">":
              return d(h, b, E);
            case ">=":
              return s(h, b, E);
            case "<":
              return o(h, b, E);
            case "<=":
              return m(h, b, E);
            default:
              throw new TypeError(`Invalid operator: ${y}`);
          }
        };
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/coerce.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/semver.js"), f = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/parse.js"), { safeRe: d, t: s } = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/re.js");
        u.exports = (o, m) => {
          if (o instanceof i)
            return o;
          if (typeof o == "number" && (o = String(o)), typeof o != "string")
            return null;
          let h = null;
          if ((m = m || {}).rtl) {
            let y;
            for (; (y = d[s.COERCERTL].exec(o)) && (!h || h.index + h[0].length !== o.length); )
              h && y.index + y[0].length === h.index + h[0].length || (h = y), d[s.COERCERTL].lastIndex = y.index + y[1].length + y[2].length;
            d[s.COERCERTL].lastIndex = -1;
          } else
            h = o.match(d[s.COERCE]);
          return h === null ? null : f(`${h[2]}.${h[3] || "0"}.${h[4] || "0"}`, m);
        };
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare-build.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/semver.js");
        u.exports = (f, d, s) => {
          const o = new i(f, s), m = new i(d, s);
          return o.compare(m) || o.compareBuild(m);
        };
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare-loose.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare.js");
        u.exports = (f, d) => i(f, d, !0);
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/semver.js");
        u.exports = (f, d, s) => new i(f, s).compare(new i(d, s));
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/diff.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/parse.js");
        u.exports = (f, d) => {
          const s = i(f, null, !0), o = i(d, null, !0), m = s.compare(o);
          if (m === 0)
            return null;
          const h = m > 0, y = h ? s : o, b = h ? o : s, E = !!y.prerelease.length;
          if (b.prerelease.length && !E)
            return b.patch || b.minor ? y.patch ? "patch" : y.minor ? "minor" : "major" : "major";
          const S = E ? "pre" : "";
          return s.major !== o.major ? S + "major" : s.minor !== o.minor ? S + "minor" : s.patch !== o.patch ? S + "patch" : "prerelease";
        };
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/eq.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare.js");
        u.exports = (f, d, s) => i(f, d, s) === 0;
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/gt.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare.js");
        u.exports = (f, d, s) => i(f, d, s) > 0;
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/gte.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare.js");
        u.exports = (f, d, s) => i(f, d, s) >= 0;
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/inc.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/semver.js");
        u.exports = (f, d, s, o, m) => {
          typeof s == "string" && (m = o, o = s, s = void 0);
          try {
            return new i(f instanceof i ? f.version : f, s).inc(d, o, m).version;
          } catch {
            return null;
          }
        };
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/lt.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare.js");
        u.exports = (f, d, s) => i(f, d, s) < 0;
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/lte.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare.js");
        u.exports = (f, d, s) => i(f, d, s) <= 0;
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/major.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/semver.js");
        u.exports = (f, d) => new i(f, d).major;
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/minor.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/semver.js");
        u.exports = (f, d) => new i(f, d).minor;
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/neq.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare.js");
        u.exports = (f, d, s) => i(f, d, s) !== 0;
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/parse.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/semver.js");
        u.exports = (f, d, s = !1) => {
          if (f instanceof i)
            return f;
          try {
            return new i(f, d);
          } catch (o) {
            if (!s)
              return null;
            throw o;
          }
        };
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/patch.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/semver.js");
        u.exports = (f, d) => new i(f, d).patch;
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/prerelease.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/parse.js");
        u.exports = (f, d) => {
          const s = i(f, d);
          return s && s.prerelease.length ? s.prerelease : null;
        };
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/rcompare.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare.js");
        u.exports = (f, d, s) => i(d, f, s);
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/rsort.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare-build.js");
        u.exports = (f, d) => f.sort((s, o) => i(o, s, d));
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/satisfies.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/range.js");
        u.exports = (f, d, s) => {
          try {
            d = new i(d, s);
          } catch {
            return !1;
          }
          return d.test(f);
        };
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/sort.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare-build.js");
        u.exports = (f, d) => f.sort((s, o) => i(s, o, d));
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/valid.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/parse.js");
        u.exports = (f, d) => {
          const s = i(f, d);
          return s ? s.version : null;
        };
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/index.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/re.js"), f = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/constants.js"), d = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/semver.js"), s = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/identifiers.js"), o = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/parse.js"), m = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/valid.js"), h = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/clean.js"), y = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/inc.js"), b = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/diff.js"), E = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/major.js"), S = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/minor.js"), g = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/patch.js"), P = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/prerelease.js"), R = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare.js"), N = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/rcompare.js"), C = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare-loose.js"), I = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare-build.js"), D = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/sort.js"), j = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/rsort.js"), F = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/gt.js"), _ = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/lt.js"), T = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/eq.js"), v = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/neq.js"), w = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/gte.js"), O = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/lte.js"), G = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/cmp.js"), W = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/coerce.js"), U = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/comparator.js"), M = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/range.js"), B = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/satisfies.js"), k = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/to-comparators.js"), K = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/max-satisfying.js"), te = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/min-satisfying.js"), z = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/min-version.js"), q = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/valid.js"), $ = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/outside.js"), Y = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/gtr.js"), H = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/ltr.js"), Q = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/intersects.js"), X = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/simplify.js"), ne = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/subset.js");
        u.exports = { parse: o, valid: m, clean: h, inc: y, diff: b, major: E, minor: S, patch: g, prerelease: P, compare: R, rcompare: N, compareLoose: C, compareBuild: I, sort: D, rsort: j, gt: F, lt: _, eq: T, neq: v, gte: w, lte: O, cmp: G, coerce: W, Comparator: U, Range: M, satisfies: B, toComparators: k, maxSatisfying: K, minSatisfying: te, minVersion: z, validRange: q, outside: $, gtr: Y, ltr: H, intersects: Q, simplifyRange: X, subset: ne, SemVer: d, re: i.re, src: i.src, tokens: i.t, SEMVER_SPEC_VERSION: f.SEMVER_SPEC_VERSION, RELEASE_TYPES: f.RELEASE_TYPES, compareIdentifiers: s.compareIdentifiers, rcompareIdentifiers: s.rcompareIdentifiers };
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/constants.js": (u) => {
        const r = Number.MAX_SAFE_INTEGER || 9007199254740991;
        u.exports = { MAX_LENGTH: 256, MAX_SAFE_COMPONENT_LENGTH: 16, MAX_SAFE_BUILD_LENGTH: 250, MAX_SAFE_INTEGER: r, RELEASE_TYPES: ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"], SEMVER_SPEC_VERSION: "2.0.0", FLAG_INCLUDE_PRERELEASE: 1, FLAG_LOOSE: 2 };
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/debug.js": (u) => {
        const r = typeof Ve.process == "object" && Ve.process.env && Ve.process.env.NODE_DEBUG && /\bsemver\b/i.test(Ve.process.env.NODE_DEBUG) ? (...l) => console.error("SEMVER", ...l) : () => {
        };
        u.exports = r;
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/identifiers.js": (u) => {
        const r = /^[0-9]+$/, l = (i, f) => {
          const d = r.test(i), s = r.test(f);
          return d && s && (i = +i, f = +f), i === f ? 0 : d && !s ? -1 : s && !d ? 1 : i < f ? -1 : 1;
        };
        u.exports = { compareIdentifiers: l, rcompareIdentifiers: (i, f) => l(f, i) };
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/parse-options.js": (u) => {
        const r = Object.freeze({ loose: !0 }), l = Object.freeze({});
        u.exports = (i) => i ? typeof i != "object" ? r : i : l;
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/re.js": (u, r, l) => {
        const { MAX_SAFE_COMPONENT_LENGTH: i, MAX_SAFE_BUILD_LENGTH: f, MAX_LENGTH: d } = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/constants.js"), s = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/debug.js"), o = (r = u.exports = {}).re = [], m = r.safeRe = [], h = r.src = [], y = r.t = {};
        let b = 0;
        const E = [["\\s", 1], ["\\d", d], ["[a-zA-Z0-9-]", f]], S = (g, P, R) => {
          const N = ((I) => {
            for (const [D, j] of E)
              I = I.split(`${D}*`).join(`${D}{0,${j}}`).split(`${D}+`).join(`${D}{1,${j}}`);
            return I;
          })(P), C = b++;
          s(g, C, P), y[g] = C, h[C] = P, o[C] = new RegExp(P, R ? "g" : void 0), m[C] = new RegExp(N, R ? "g" : void 0);
        };
        S("NUMERICIDENTIFIER", "0|[1-9]\\d*"), S("NUMERICIDENTIFIERLOOSE", "\\d+"), S("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), S("MAINVERSION", `(${h[y.NUMERICIDENTIFIER]})\\.(${h[y.NUMERICIDENTIFIER]})\\.(${h[y.NUMERICIDENTIFIER]})`), S("MAINVERSIONLOOSE", `(${h[y.NUMERICIDENTIFIERLOOSE]})\\.(${h[y.NUMERICIDENTIFIERLOOSE]})\\.(${h[y.NUMERICIDENTIFIERLOOSE]})`), S("PRERELEASEIDENTIFIER", `(?:${h[y.NUMERICIDENTIFIER]}|${h[y.NONNUMERICIDENTIFIER]})`), S("PRERELEASEIDENTIFIERLOOSE", `(?:${h[y.NUMERICIDENTIFIERLOOSE]}|${h[y.NONNUMERICIDENTIFIER]})`), S("PRERELEASE", `(?:-(${h[y.PRERELEASEIDENTIFIER]}(?:\\.${h[y.PRERELEASEIDENTIFIER]})*))`), S("PRERELEASELOOSE", `(?:-?(${h[y.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${h[y.PRERELEASEIDENTIFIERLOOSE]})*))`), S("BUILDIDENTIFIER", "[a-zA-Z0-9-]+"), S("BUILD", `(?:\\+(${h[y.BUILDIDENTIFIER]}(?:\\.${h[y.BUILDIDENTIFIER]})*))`), S("FULLPLAIN", `v?${h[y.MAINVERSION]}${h[y.PRERELEASE]}?${h[y.BUILD]}?`), S("FULL", `^${h[y.FULLPLAIN]}$`), S("LOOSEPLAIN", `[v=\\s]*${h[y.MAINVERSIONLOOSE]}${h[y.PRERELEASELOOSE]}?${h[y.BUILD]}?`), S("LOOSE", `^${h[y.LOOSEPLAIN]}$`), S("GTLT", "((?:<|>)?=?)"), S("XRANGEIDENTIFIERLOOSE", `${h[y.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), S("XRANGEIDENTIFIER", `${h[y.NUMERICIDENTIFIER]}|x|X|\\*`), S("XRANGEPLAIN", `[v=\\s]*(${h[y.XRANGEIDENTIFIER]})(?:\\.(${h[y.XRANGEIDENTIFIER]})(?:\\.(${h[y.XRANGEIDENTIFIER]})(?:${h[y.PRERELEASE]})?${h[y.BUILD]}?)?)?`), S("XRANGEPLAINLOOSE", `[v=\\s]*(${h[y.XRANGEIDENTIFIERLOOSE]})(?:\\.(${h[y.XRANGEIDENTIFIERLOOSE]})(?:\\.(${h[y.XRANGEIDENTIFIERLOOSE]})(?:${h[y.PRERELEASELOOSE]})?${h[y.BUILD]}?)?)?`), S("XRANGE", `^${h[y.GTLT]}\\s*${h[y.XRANGEPLAIN]}$`), S("XRANGELOOSE", `^${h[y.GTLT]}\\s*${h[y.XRANGEPLAINLOOSE]}$`), S("COERCE", `(^|[^\\d])(\\d{1,${i}})(?:\\.(\\d{1,${i}}))?(?:\\.(\\d{1,${i}}))?(?:$|[^\\d])`), S("COERCERTL", h[y.COERCE], !0), S("LONETILDE", "(?:~>?)"), S("TILDETRIM", `(\\s*)${h[y.LONETILDE]}\\s+`, !0), r.tildeTrimReplace = "$1~", S("TILDE", `^${h[y.LONETILDE]}${h[y.XRANGEPLAIN]}$`), S("TILDELOOSE", `^${h[y.LONETILDE]}${h[y.XRANGEPLAINLOOSE]}$`), S("LONECARET", "(?:\\^)"), S("CARETTRIM", `(\\s*)${h[y.LONECARET]}\\s+`, !0), r.caretTrimReplace = "$1^", S("CARET", `^${h[y.LONECARET]}${h[y.XRANGEPLAIN]}$`), S("CARETLOOSE", `^${h[y.LONECARET]}${h[y.XRANGEPLAINLOOSE]}$`), S("COMPARATORLOOSE", `^${h[y.GTLT]}\\s*(${h[y.LOOSEPLAIN]})$|^$`), S("COMPARATOR", `^${h[y.GTLT]}\\s*(${h[y.FULLPLAIN]})$|^$`), S("COMPARATORTRIM", `(\\s*)${h[y.GTLT]}\\s*(${h[y.LOOSEPLAIN]}|${h[y.XRANGEPLAIN]})`, !0), r.comparatorTrimReplace = "$1$2$3", S("HYPHENRANGE", `^\\s*(${h[y.XRANGEPLAIN]})\\s+-\\s+(${h[y.XRANGEPLAIN]})\\s*$`), S("HYPHENRANGELOOSE", `^\\s*(${h[y.XRANGEPLAINLOOSE]})\\s+-\\s+(${h[y.XRANGEPLAINLOOSE]})\\s*$`), S("STAR", "(<|>)?=?\\s*\\*"), S("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), S("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/gtr.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/outside.js");
        u.exports = (f, d, s) => i(f, d, ">", s);
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/intersects.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/range.js");
        u.exports = (f, d, s) => (f = new i(f, s), d = new i(d, s), f.intersects(d, s));
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/ltr.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/outside.js");
        u.exports = (f, d, s) => i(f, d, "<", s);
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/max-satisfying.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/semver.js"), f = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/range.js");
        u.exports = (d, s, o) => {
          let m = null, h = null, y = null;
          try {
            y = new f(s, o);
          } catch {
            return null;
          }
          return d.forEach((b) => {
            y.test(b) && (m && h.compare(b) !== -1 || (m = b, h = new i(m, o)));
          }), m;
        };
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/min-satisfying.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/semver.js"), f = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/range.js");
        u.exports = (d, s, o) => {
          let m = null, h = null, y = null;
          try {
            y = new f(s, o);
          } catch {
            return null;
          }
          return d.forEach((b) => {
            y.test(b) && (m && h.compare(b) !== 1 || (m = b, h = new i(m, o)));
          }), m;
        };
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/min-version.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/semver.js"), f = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/range.js"), d = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/gt.js");
        u.exports = (s, o) => {
          s = new f(s, o);
          let m = new i("0.0.0");
          if (s.test(m) || (m = new i("0.0.0-0"), s.test(m)))
            return m;
          m = null;
          for (let h = 0; h < s.set.length; ++h) {
            const y = s.set[h];
            let b = null;
            y.forEach((E) => {
              const S = new i(E.semver.version);
              switch (E.operator) {
                case ">":
                  S.prerelease.length === 0 ? S.patch++ : S.prerelease.push(0), S.raw = S.format();
                case "":
                case ">=":
                  b && !d(S, b) || (b = S);
                  break;
                case "<":
                case "<=":
                  break;
                default:
                  throw new Error(`Unexpected operation: ${E.operator}`);
              }
            }), !b || m && !d(m, b) || (m = b);
          }
          return m && s.test(m) ? m : null;
        };
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/outside.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/semver.js"), f = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/comparator.js"), { ANY: d } = f, s = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/range.js"), o = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/satisfies.js"), m = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/gt.js"), h = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/lt.js"), y = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/lte.js"), b = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/gte.js");
        u.exports = (E, S, g, P) => {
          let R, N, C, I, D;
          switch (E = new i(E, P), S = new s(S, P), g) {
            case ">":
              R = m, N = y, C = h, I = ">", D = ">=";
              break;
            case "<":
              R = h, N = b, C = m, I = "<", D = "<=";
              break;
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"');
          }
          if (o(E, S, P))
            return !1;
          for (let j = 0; j < S.set.length; ++j) {
            const F = S.set[j];
            let _ = null, T = null;
            if (F.forEach((v) => {
              v.semver === d && (v = new f(">=0.0.0")), _ = _ || v, T = T || v, R(v.semver, _.semver, P) ? _ = v : C(v.semver, T.semver, P) && (T = v);
            }), _.operator === I || _.operator === D || (!T.operator || T.operator === I) && N(E, T.semver) || T.operator === D && C(E, T.semver))
              return !1;
          }
          return !0;
        };
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/simplify.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/satisfies.js"), f = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare.js");
        u.exports = (d, s, o) => {
          const m = [];
          let h = null, y = null;
          const b = d.sort((P, R) => f(P, R, o));
          for (const P of b)
            i(P, s, o) ? (y = P, h || (h = P)) : (y && m.push([h, y]), y = null, h = null);
          h && m.push([h, null]);
          const E = [];
          for (const [P, R] of m)
            P === R ? E.push(P) : R || P !== b[0] ? R ? P === b[0] ? E.push(`<=${R}`) : E.push(`${P} - ${R}`) : E.push(`>=${P}`) : E.push("*");
          const S = E.join(" || "), g = typeof s.raw == "string" ? s.raw : String(s);
          return S.length < g.length ? S : s;
        };
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/subset.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/range.js"), f = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/comparator.js"), { ANY: d } = f, s = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/satisfies.js"), o = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare.js"), m = [new f(">=0.0.0-0")], h = [new f(">=0.0.0")], y = (S, g, P) => {
          if (S === g)
            return !0;
          if (S.length === 1 && S[0].semver === d) {
            if (g.length === 1 && g[0].semver === d)
              return !0;
            S = P.includePrerelease ? m : h;
          }
          if (g.length === 1 && g[0].semver === d) {
            if (P.includePrerelease)
              return !0;
            g = h;
          }
          const R = /* @__PURE__ */ new Set();
          let N, C, I, D, j, F, _;
          for (const w of S)
            w.operator === ">" || w.operator === ">=" ? N = b(N, w, P) : w.operator === "<" || w.operator === "<=" ? C = E(C, w, P) : R.add(w.semver);
          if (R.size > 1 || N && C && (I = o(N.semver, C.semver, P), I > 0 || I === 0 && (N.operator !== ">=" || C.operator !== "<=")))
            return null;
          for (const w of R) {
            if (N && !s(w, String(N), P) || C && !s(w, String(C), P))
              return null;
            for (const O of g)
              if (!s(w, String(O), P))
                return !1;
            return !0;
          }
          let T = !(!C || P.includePrerelease || !C.semver.prerelease.length) && C.semver, v = !(!N || P.includePrerelease || !N.semver.prerelease.length) && N.semver;
          T && T.prerelease.length === 1 && C.operator === "<" && T.prerelease[0] === 0 && (T = !1);
          for (const w of g) {
            if (_ = _ || w.operator === ">" || w.operator === ">=", F = F || w.operator === "<" || w.operator === "<=", N) {
              if (v && w.semver.prerelease && w.semver.prerelease.length && w.semver.major === v.major && w.semver.minor === v.minor && w.semver.patch === v.patch && (v = !1), w.operator === ">" || w.operator === ">=") {
                if (D = b(N, w, P), D === w && D !== N)
                  return !1;
              } else if (N.operator === ">=" && !s(N.semver, String(w), P))
                return !1;
            }
            if (C) {
              if (T && w.semver.prerelease && w.semver.prerelease.length && w.semver.major === T.major && w.semver.minor === T.minor && w.semver.patch === T.patch && (T = !1), w.operator === "<" || w.operator === "<=") {
                if (j = E(C, w, P), j === w && j !== C)
                  return !1;
              } else if (C.operator === "<=" && !s(C.semver, String(w), P))
                return !1;
            }
            if (!w.operator && (C || N) && I !== 0)
              return !1;
          }
          return !(N && F && !C && I !== 0) && !(C && _ && !N && I !== 0) && !v && !T;
        }, b = (S, g, P) => {
          if (!S)
            return g;
          const R = o(S.semver, g.semver, P);
          return R > 0 ? S : R < 0 || g.operator === ">" && S.operator === ">=" ? g : S;
        }, E = (S, g, P) => {
          if (!S)
            return g;
          const R = o(S.semver, g.semver, P);
          return R < 0 ? S : R > 0 || g.operator === "<" && S.operator === "<=" ? g : S;
        };
        u.exports = (S, g, P = {}) => {
          if (S === g)
            return !0;
          S = new i(S, P), g = new i(g, P);
          let R = !1;
          e:
            for (const N of S.set) {
              for (const C of g.set) {
                const I = y(N, C, P);
                if (R = R || I !== null, I)
                  continue e;
              }
              if (R)
                return !1;
            }
          return !0;
        };
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/to-comparators.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/range.js");
        u.exports = (f, d) => new i(f, d).set.map((s) => s.map((o) => o.value).join(" ").trim().split(" "));
      }, "./node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/valid.js": (u, r, l) => {
        const i = l("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/range.js");
        u.exports = (f, d) => {
          try {
            return new i(f, d).range || "*";
          } catch {
            return null;
          }
        };
      }, "./node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js": (u) => {
        u.exports = function(r) {
          r.prototype[Symbol.iterator] = function* () {
            for (let l = this.head; l; l = l.next)
              yield l.value;
          };
        };
      }, "./node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js": (u, r, l) => {
        function i(m) {
          var h = this;
          if (h instanceof i || (h = new i()), h.tail = null, h.head = null, h.length = 0, m && typeof m.forEach == "function")
            m.forEach(function(E) {
              h.push(E);
            });
          else if (arguments.length > 0)
            for (var y = 0, b = arguments.length; y < b; y++)
              h.push(arguments[y]);
          return h;
        }
        function f(m, h, y) {
          var b = h === m.head ? new o(y, null, h, m) : new o(y, h, h.next, m);
          return b.next === null && (m.tail = b), b.prev === null && (m.head = b), m.length++, b;
        }
        function d(m, h) {
          m.tail = new o(h, m.tail, null, m), m.head || (m.head = m.tail), m.length++;
        }
        function s(m, h) {
          m.head = new o(h, null, m.head, m), m.tail || (m.tail = m.head), m.length++;
        }
        function o(m, h, y, b) {
          if (!(this instanceof o))
            return new o(m, h, y, b);
          this.list = b, this.value = m, h ? (h.next = this, this.prev = h) : this.prev = null, y ? (y.prev = this, this.next = y) : this.next = null;
        }
        u.exports = i, i.Node = o, i.create = i, i.prototype.removeNode = function(m) {
          if (m.list !== this)
            throw new Error("removing node which does not belong to this list");
          var h = m.next, y = m.prev;
          return h && (h.prev = y), y && (y.next = h), m === this.head && (this.head = h), m === this.tail && (this.tail = y), m.list.length--, m.next = null, m.prev = null, m.list = null, h;
        }, i.prototype.unshiftNode = function(m) {
          if (m !== this.head) {
            m.list && m.list.removeNode(m);
            var h = this.head;
            m.list = this, m.next = h, h && (h.prev = m), this.head = m, this.tail || (this.tail = m), this.length++;
          }
        }, i.prototype.pushNode = function(m) {
          if (m !== this.tail) {
            m.list && m.list.removeNode(m);
            var h = this.tail;
            m.list = this, m.prev = h, h && (h.next = m), this.tail = m, this.head || (this.head = m), this.length++;
          }
        }, i.prototype.push = function() {
          for (var m = 0, h = arguments.length; m < h; m++)
            d(this, arguments[m]);
          return this.length;
        }, i.prototype.unshift = function() {
          for (var m = 0, h = arguments.length; m < h; m++)
            s(this, arguments[m]);
          return this.length;
        }, i.prototype.pop = function() {
          if (this.tail) {
            var m = this.tail.value;
            return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, m;
          }
        }, i.prototype.shift = function() {
          if (this.head) {
            var m = this.head.value;
            return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, m;
          }
        }, i.prototype.forEach = function(m, h) {
          h = h || this;
          for (var y = this.head, b = 0; y !== null; b++)
            m.call(h, y.value, b, this), y = y.next;
        }, i.prototype.forEachReverse = function(m, h) {
          h = h || this;
          for (var y = this.tail, b = this.length - 1; y !== null; b--)
            m.call(h, y.value, b, this), y = y.prev;
        }, i.prototype.get = function(m) {
          for (var h = 0, y = this.head; y !== null && h < m; h++)
            y = y.next;
          if (h === m && y !== null)
            return y.value;
        }, i.prototype.getReverse = function(m) {
          for (var h = 0, y = this.tail; y !== null && h < m; h++)
            y = y.prev;
          if (h === m && y !== null)
            return y.value;
        }, i.prototype.map = function(m, h) {
          h = h || this;
          for (var y = new i(), b = this.head; b !== null; )
            y.push(m.call(h, b.value, this)), b = b.next;
          return y;
        }, i.prototype.mapReverse = function(m, h) {
          h = h || this;
          for (var y = new i(), b = this.tail; b !== null; )
            y.push(m.call(h, b.value, this)), b = b.prev;
          return y;
        }, i.prototype.reduce = function(m, h) {
          var y, b = this.head;
          if (arguments.length > 1)
            y = h;
          else {
            if (!this.head)
              throw new TypeError("Reduce of empty list with no initial value");
            b = this.head.next, y = this.head.value;
          }
          for (var E = 0; b !== null; E++)
            y = m(y, b.value, E), b = b.next;
          return y;
        }, i.prototype.reduceReverse = function(m, h) {
          var y, b = this.tail;
          if (arguments.length > 1)
            y = h;
          else {
            if (!this.tail)
              throw new TypeError("Reduce of empty list with no initial value");
            b = this.tail.prev, y = this.tail.value;
          }
          for (var E = this.length - 1; b !== null; E--)
            y = m(y, b.value, E), b = b.prev;
          return y;
        }, i.prototype.toArray = function() {
          for (var m = new Array(this.length), h = 0, y = this.head; y !== null; h++)
            m[h] = y.value, y = y.next;
          return m;
        }, i.prototype.toArrayReverse = function() {
          for (var m = new Array(this.length), h = 0, y = this.tail; y !== null; h++)
            m[h] = y.value, y = y.prev;
          return m;
        }, i.prototype.slice = function(m, h) {
          (h = h || this.length) < 0 && (h += this.length), (m = m || 0) < 0 && (m += this.length);
          var y = new i();
          if (h < m || h < 0)
            return y;
          m < 0 && (m = 0), h > this.length && (h = this.length);
          for (var b = 0, E = this.head; E !== null && b < m; b++)
            E = E.next;
          for (; E !== null && b < h; b++, E = E.next)
            y.push(E.value);
          return y;
        }, i.prototype.sliceReverse = function(m, h) {
          (h = h || this.length) < 0 && (h += this.length), (m = m || 0) < 0 && (m += this.length);
          var y = new i();
          if (h < m || h < 0)
            return y;
          m < 0 && (m = 0), h > this.length && (h = this.length);
          for (var b = this.length, E = this.tail; E !== null && b > h; b--)
            E = E.prev;
          for (; E !== null && b > m; b--, E = E.prev)
            y.push(E.value);
          return y;
        }, i.prototype.splice = function(m, h, ...y) {
          m > this.length && (m = this.length - 1), m < 0 && (m = this.length + m);
          for (var b = 0, E = this.head; E !== null && b < m; b++)
            E = E.next;
          var S = [];
          for (b = 0; E && b < h; b++)
            S.push(E.value), E = this.removeNode(E);
          for (E === null && (E = this.tail), E !== this.head && E !== this.tail && (E = E.prev), b = 0; b < y.length; b++)
            E = f(this, E, y[b]);
          return S;
        }, i.prototype.reverse = function() {
          for (var m = this.head, h = this.tail, y = m; y !== null; y = y.prev) {
            var b = y.prev;
            y.prev = y.next, y.next = b;
          }
          return this.head = h, this.tail = m, this;
        };
        try {
          l("./node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js")(i);
        } catch {
        }
      }, crypto: (u) => {
        u.exports = sb();
      }, fs: (u) => {
        u.exports = Dn;
      }, module: (u) => {
        u.exports = xr;
      }, path: (u) => {
        u.exports = Lr;
      } }, n = {};
      function a(u) {
        var r = n[u];
        if (r !== void 0)
          return r.exports;
        var l = n[u] = { id: u, loaded: !1, exports: {} };
        return e[u](l, l.exports, a), l.loaded = !0, l.exports;
      }
      a.n = (u) => {
        var r = u && u.__esModule ? () => u.default : () => u;
        return a.d(r, { a: r }), r;
      }, a.d = (u, r) => {
        for (var l in r)
          a.o(r, l) && !a.o(u, l) && Object.defineProperty(u, l, { enumerable: !0, get: r[l] });
      }, a.o = (u, r) => Object.prototype.hasOwnProperty.call(u, r), a.nmd = (u) => (u.paths = [], u.children || (u.children = []), u);
      var c = {};
      (() => {
        a.d(c, { default: () => Ig });
        var u = a("fs"), r = a("module");
        const l = xr, i = jr, f = xr;
        var d = a.n(f);
        const s = ds;
        function o(x = "") {
          return x && x.includes("\\") ? x.replace(/\\/g, "/") : x;
        }
        const m = /^[/\\]{2}/, h = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/, y = /^[A-Za-z]:$/, b = function(x) {
          if (x.length === 0)
            return ".";
          const J = (x = o(x)).match(m), he = g(x), ge = x[x.length - 1] === "/";
          return (x = S(x, !he)).length === 0 ? he ? "/" : ge ? "./" : "." : (ge && (x += "/"), y.test(x) && (x += "/"), J ? he ? `//${x}` : `//./${x}` : he && !g(x) ? `/${x}` : x);
        }, E = function(...x) {
          if (x.length === 0)
            return ".";
          let J;
          for (const he of x)
            he && he.length > 0 && (J === void 0 ? J = he : J += `/${he}`);
          return J === void 0 ? "." : b(J.replace(/\/\/+/g, "/"));
        };
        function S(x, J) {
          let he = "", ge = 0, Oe = -1, Le = 0, Ue = null;
          for (let qe = 0; qe <= x.length; ++qe) {
            if (qe < x.length)
              Ue = x[qe];
            else {
              if (Ue === "/")
                break;
              Ue = "/";
            }
            if (Ue === "/") {
              if (!(Oe === qe - 1 || Le === 1))
                if (Le === 2) {
                  if (he.length < 2 || ge !== 2 || he[he.length - 1] !== "." || he[he.length - 2] !== ".") {
                    if (he.length > 2) {
                      const at = he.lastIndexOf("/");
                      at === -1 ? (he = "", ge = 0) : (he = he.slice(0, at), ge = he.length - 1 - he.lastIndexOf("/")), Oe = qe, Le = 0;
                      continue;
                    }
                    if (he.length > 0) {
                      he = "", ge = 0, Oe = qe, Le = 0;
                      continue;
                    }
                  }
                  J && (he += he.length > 0 ? "/.." : "..", ge = 2);
                } else
                  he.length > 0 ? he += `/${x.slice(Oe + 1, qe)}` : he = x.slice(Oe + 1, qe), ge = qe - Oe - 1;
              Oe = qe, Le = 0;
            } else
              Ue === "." && Le !== -1 ? ++Le : Le = -1;
          }
          return he;
        }
        const g = function(x) {
          return h.test(x);
        }, P = /.(\.[^./]+)$/, R = function(x) {
          const J = P.exec(o(x));
          return J && J[1] || "";
        }, N = function(x) {
          const J = o(x).replace(/\/$/, "").split("/").slice(0, -1);
          return J.length === 1 && y.test(J[0]) && (J[0] += "/"), J.join("/") || (g(x) ? "/" : ".");
        }, C = function(x, J) {
          const he = o(x).split("/").pop();
          return J && he.endsWith(J) ? he.slice(0, -J.length) : he;
        }, I = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, D = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, j = /^\s*["[{]|^\s*-?\d[\d.]{0,14}\s*$/;
        function F(x, J) {
          if (!(x === "__proto__" || x === "constructor" && J && typeof J == "object" && "prototype" in J))
            return J;
          (function(he) {
            console.warn(`[destr] Dropping "${he}" key to prevent prototype pollution.`);
          })(x);
        }
        function _(x, J = {}) {
          if (typeof x != "string")
            return x;
          const he = x.trim();
          if (x[0] === '"' && x[x.length - 1] === '"')
            return he.slice(1, -1);
          if (he.length <= 9) {
            const ge = he.toLowerCase();
            if (ge === "true")
              return !0;
            if (ge === "false")
              return !1;
            if (ge === "undefined")
              return;
            if (ge === "null")
              return null;
            if (ge === "nan")
              return Number.NaN;
            if (ge === "infinity")
              return Number.POSITIVE_INFINITY;
            if (ge === "-infinity")
              return Number.NEGATIVE_INFINITY;
          }
          if (!j.test(x)) {
            if (J.strict)
              throw new SyntaxError("[destr] Invalid JSON");
            return x;
          }
          try {
            if (I.test(x) || D.test(x)) {
              if (J.strict)
                throw new Error("[destr] Possible prototype pollution");
              return JSON.parse(x, F);
            }
            return JSON.parse(x);
          } catch (ge) {
            if (J.strict)
              throw ge;
            return x;
          }
        }
        function T(x) {
          if (typeof x != "string")
            throw new TypeError("Expected a string");
          return x.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        }
        var v = a("./node_modules/.pnpm/create-require@1.1.1/node_modules/create-require/create-require.js"), w = a.n(v), O = a("./node_modules/.pnpm/semver@7.5.4/node_modules/semver/index.js");
        const G = /* @__PURE__ */ new Set(["/", "\\", void 0]), W = Symbol.for("pathe:normalizedAlias");
        function U(x) {
          if (x[W])
            return x;
          const J = Object.fromEntries(Object.entries(x).sort(([he], [ge]) => function(Oe, Le) {
            return Le.split("/").length - Oe.split("/").length;
          }(he, ge)));
          for (const he in J)
            for (const ge in J)
              ge === he || he.startsWith(ge) || J[he].startsWith(ge) && G.has(J[he][ge.length]) && (J[he] = J[ge] + J[he].slice(ge.length));
          return Object.defineProperty(J, W, { value: !0, enumerable: !1 }), J;
        }
        var M = a("./node_modules/.pnpm/pirates@4.0.6/node_modules/pirates/lib/index.js"), B = a("./node_modules/.pnpm/object-hash@3.0.0/node_modules/object-hash/index.js"), k = a.n(B), K = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], te = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191], z = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", q = { 3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile", 5: "class enum extends super const export import", 6: "enum", strict: "implements interface let package private protected public static yield", strictBind: "eval arguments" }, $ = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", Y = { 5: $, "5module": $ + " export import", 6: $ + " const class extends export import super" }, H = /^in(stanceof)?$/, Q = new RegExp("[" + z + "]"), X = new RegExp("[" + z + "-----------------------------------------------------------------------------------------------------------------------------------------------------]");
        function ne(x, J) {
          for (var he = 65536, ge = 0; ge < J.length; ge += 2) {
            if ((he += J[ge]) > x)
              return !1;
            if ((he += J[ge + 1]) >= x)
              return !0;
          }
          return !1;
        }
        function ye(x, J) {
          return x < 65 ? x === 36 : x < 91 || (x < 97 ? x === 95 : x < 123 || (x <= 65535 ? x >= 170 && Q.test(String.fromCharCode(x)) : J !== !1 && ne(x, te)));
        }
        function ve(x, J) {
          return x < 48 ? x === 36 : x < 58 || !(x < 65) && (x < 91 || (x < 97 ? x === 95 : x < 123 || (x <= 65535 ? x >= 170 && X.test(String.fromCharCode(x)) : J !== !1 && (ne(x, te) || ne(x, K)))));
        }
        var de = function(x, J) {
          J === void 0 && (J = {}), this.label = x, this.keyword = J.keyword, this.beforeExpr = !!J.beforeExpr, this.startsExpr = !!J.startsExpr, this.isLoop = !!J.isLoop, this.isAssign = !!J.isAssign, this.prefix = !!J.prefix, this.postfix = !!J.postfix, this.binop = J.binop || null, this.updateContext = null;
        };
        function oe(x, J) {
          return new de(x, { beforeExpr: !0, binop: J });
        }
        var re = { beforeExpr: !0 }, ae = { startsExpr: !0 }, le = {};
        function ue(x, J) {
          return J === void 0 && (J = {}), J.keyword = x, le[x] = new de(x, J);
        }
        var ie = { num: new de("num", ae), regexp: new de("regexp", ae), string: new de("string", ae), name: new de("name", ae), privateId: new de("privateId", ae), eof: new de("eof"), bracketL: new de("[", { beforeExpr: !0, startsExpr: !0 }), bracketR: new de("]"), braceL: new de("{", { beforeExpr: !0, startsExpr: !0 }), braceR: new de("}"), parenL: new de("(", { beforeExpr: !0, startsExpr: !0 }), parenR: new de(")"), comma: new de(",", re), semi: new de(";", re), colon: new de(":", re), dot: new de("."), question: new de("?", re), questionDot: new de("?."), arrow: new de("=>", re), template: new de("template"), invalidTemplate: new de("invalidTemplate"), ellipsis: new de("...", re), backQuote: new de("`", ae), dollarBraceL: new de("${", { beforeExpr: !0, startsExpr: !0 }), eq: new de("=", { beforeExpr: !0, isAssign: !0 }), assign: new de("_=", { beforeExpr: !0, isAssign: !0 }), incDec: new de("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }), prefix: new de("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), logicalOR: oe("||", 1), logicalAND: oe("&&", 2), bitwiseOR: oe("|", 3), bitwiseXOR: oe("^", 4), bitwiseAND: oe("&", 5), equality: oe("==/!=/===/!==", 6), relational: oe("</>/<=/>=", 7), bitShift: oe("<</>>/>>>", 8), plusMin: new de("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }), modulo: oe("%", 10), star: oe("*", 10), slash: oe("/", 10), starstar: new de("**", { beforeExpr: !0 }), coalesce: oe("??", 1), _break: ue("break"), _case: ue("case", re), _catch: ue("catch"), _continue: ue("continue"), _debugger: ue("debugger"), _default: ue("default", re), _do: ue("do", { isLoop: !0, beforeExpr: !0 }), _else: ue("else", re), _finally: ue("finally"), _for: ue("for", { isLoop: !0 }), _function: ue("function", ae), _if: ue("if"), _return: ue("return", re), _switch: ue("switch"), _throw: ue("throw", re), _try: ue("try"), _var: ue("var"), _const: ue("const"), _while: ue("while", { isLoop: !0 }), _with: ue("with"), _new: ue("new", { beforeExpr: !0, startsExpr: !0 }), _this: ue("this", ae), _super: ue("super", ae), _class: ue("class", ae), _extends: ue("extends", re), _export: ue("export"), _import: ue("import", ae), _null: ue("null", ae), _true: ue("true", ae), _false: ue("false", ae), _in: ue("in", { beforeExpr: !0, binop: 7 }), _instanceof: ue("instanceof", { beforeExpr: !0, binop: 7 }), _typeof: ue("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _void: ue("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _delete: ue("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 }) }, we = /\r\n?|\n|\u2028|\u2029/, De = new RegExp(we.source, "g");
        function Ee(x) {
          return x === 10 || x === 13 || x === 8232 || x === 8233;
        }
        function Ae(x, J, he) {
          he === void 0 && (he = x.length);
          for (var ge = J; ge < he; ge++) {
            var Oe = x.charCodeAt(ge);
            if (Ee(Oe))
              return ge < he - 1 && Oe === 13 && x.charCodeAt(ge + 1) === 10 ? ge + 2 : ge + 1;
          }
          return -1;
        }
        var Me = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, me = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, se = Object.prototype, Z = se.hasOwnProperty, pe = se.toString, be = Object.hasOwn || function(x, J) {
          return Z.call(x, J);
        }, _e = Array.isArray || function(x) {
          return pe.call(x) === "[object Array]";
        };
        function Ie(x) {
          return new RegExp("^(?:" + x.replace(/ /g, "|") + ")$");
        }
        function We(x) {
          return x <= 65535 ? String.fromCharCode(x) : (x -= 65536, String.fromCharCode(55296 + (x >> 10), 56320 + (1023 & x)));
        }
        var tt = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, Ye = function(x, J) {
          this.line = x, this.column = J;
        };
        Ye.prototype.offset = function(x) {
          return new Ye(this.line, this.column + x);
        };
        var ht = function(x, J, he) {
          this.start = J, this.end = he, x.sourceFile !== null && (this.source = x.sourceFile);
        };
        function ct(x, J) {
          for (var he = 1, ge = 0; ; ) {
            var Oe = Ae(x, ge, J);
            if (Oe < 0)
              return new Ye(he, J - ge);
            ++he, ge = Oe;
          }
        }
        var st = { ecmaVersion: null, sourceType: "script", onInsertedSemicolon: null, onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: !1, allowImportExportEverywhere: !1, allowAwaitOutsideFunction: null, allowSuperOutsideMethod: null, allowHashBang: !1, checkPrivateFields: !0, locations: !1, onToken: null, onComment: null, ranges: !1, program: null, sourceFile: null, directSourceFile: null, preserveParens: !1 }, Xe = !1;
        function Ke(x) {
          var J = {};
          for (var he in st)
            J[he] = x && be(x, he) ? x[he] : st[he];
          if (J.ecmaVersion === "latest" ? J.ecmaVersion = 1e8 : J.ecmaVersion == null ? (!Xe && typeof console == "object" && console.warn && (Xe = !0, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), J.ecmaVersion = 11) : J.ecmaVersion >= 2015 && (J.ecmaVersion -= 2009), J.allowReserved == null && (J.allowReserved = J.ecmaVersion < 5), x && x.allowHashBang != null || (J.allowHashBang = J.ecmaVersion >= 14), _e(J.onToken)) {
            var ge = J.onToken;
            J.onToken = function(Oe) {
              return ge.push(Oe);
            };
          }
          return _e(J.onComment) && (J.onComment = function(Oe, Le) {
            return function(Ue, qe, at, gt, ot, Lt) {
              var Ft = { type: Ue ? "Block" : "Line", value: qe, start: at, end: gt };
              Oe.locations && (Ft.loc = new ht(this, ot, Lt)), Oe.ranges && (Ft.range = [at, gt]), Le.push(Ft);
            };
          }(J, J.onComment)), J;
        }
        function Ce(x, J) {
          return 2 | (x ? 4 : 0) | (J ? 8 : 0);
        }
        var xe = function(x, J, he) {
          this.options = x = Ke(x), this.sourceFile = x.sourceFile, this.keywords = Ie(Y[x.ecmaVersion >= 6 ? 6 : x.sourceType === "module" ? "5module" : 5]);
          var ge = "";
          x.allowReserved !== !0 && (ge = q[x.ecmaVersion >= 6 ? 6 : x.ecmaVersion === 5 ? 5 : 3], x.sourceType === "module" && (ge += " await")), this.reservedWords = Ie(ge);
          var Oe = (ge ? ge + " " : "") + q.strict;
          this.reservedWordsStrict = Ie(Oe), this.reservedWordsStrictBind = Ie(Oe + " " + q.strictBind), this.input = String(J), this.containsEsc = !1, he ? (this.pos = he, this.lineStart = this.input.lastIndexOf(`
`, he - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(we).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = ie.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = x.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.create(null), this.pos === 0 && x.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(1), this.regexpState = null, this.privateNameStack = [];
        }, He = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, canAwait: { configurable: !0 }, allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 }, allowNewDotTarget: { configurable: !0 }, inClassStaticBlock: { configurable: !0 } };
        xe.prototype.parse = function() {
          var x = this.options.program || this.startNode();
          return this.nextToken(), this.parseTopLevel(x);
        }, He.inFunction.get = function() {
          return (2 & this.currentVarScope().flags) > 0;
        }, He.inGenerator.get = function() {
          return (8 & this.currentVarScope().flags) > 0 && !this.currentVarScope().inClassFieldInit;
        }, He.inAsync.get = function() {
          return (4 & this.currentVarScope().flags) > 0 && !this.currentVarScope().inClassFieldInit;
        }, He.canAwait.get = function() {
          for (var x = this.scopeStack.length - 1; x >= 0; x--) {
            var J = this.scopeStack[x];
            if (J.inClassFieldInit || 256 & J.flags)
              return !1;
            if (2 & J.flags)
              return (4 & J.flags) > 0;
          }
          return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
        }, He.allowSuper.get = function() {
          var x = this.currentThisScope(), J = x.flags, he = x.inClassFieldInit;
          return (64 & J) > 0 || he || this.options.allowSuperOutsideMethod;
        }, He.allowDirectSuper.get = function() {
          return (128 & this.currentThisScope().flags) > 0;
        }, He.treatFunctionsAsVar.get = function() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }, He.allowNewDotTarget.get = function() {
          var x = this.currentThisScope(), J = x.flags, he = x.inClassFieldInit;
          return (258 & J) > 0 || he;
        }, He.inClassStaticBlock.get = function() {
          return (256 & this.currentVarScope().flags) > 0;
        }, xe.extend = function() {
          for (var x = [], J = arguments.length; J--; )
            x[J] = arguments[J];
          for (var he = this, ge = 0; ge < x.length; ge++)
            he = x[ge](he);
          return he;
        }, xe.parse = function(x, J) {
          return new this(J, x).parse();
        }, xe.parseExpressionAt = function(x, J, he) {
          var ge = new this(he, x, J);
          return ge.nextToken(), ge.parseExpression();
        }, xe.tokenizer = function(x, J) {
          return new this(J, x);
        }, Object.defineProperties(xe.prototype, He);
        var Be = xe.prototype, Ze = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
        Be.strictDirective = function(x) {
          if (this.options.ecmaVersion < 5)
            return !1;
          for (; ; ) {
            me.lastIndex = x, x += me.exec(this.input)[0].length;
            var J = Ze.exec(this.input.slice(x));
            if (!J)
              return !1;
            if ((J[1] || J[2]) === "use strict") {
              me.lastIndex = x + J[0].length;
              var he = me.exec(this.input), ge = he.index + he[0].length, Oe = this.input.charAt(ge);
              return Oe === ";" || Oe === "}" || we.test(he[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(Oe) || Oe === "!" && this.input.charAt(ge + 1) === "=");
            }
            x += J[0].length, me.lastIndex = x, x += me.exec(this.input)[0].length, this.input[x] === ";" && x++;
          }
        }, Be.eat = function(x) {
          return this.type === x && (this.next(), !0);
        }, Be.isContextual = function(x) {
          return this.type === ie.name && this.value === x && !this.containsEsc;
        }, Be.eatContextual = function(x) {
          return !!this.isContextual(x) && (this.next(), !0);
        }, Be.expectContextual = function(x) {
          this.eatContextual(x) || this.unexpected();
        }, Be.canInsertSemicolon = function() {
          return this.type === ie.eof || this.type === ie.braceR || we.test(this.input.slice(this.lastTokEnd, this.start));
        }, Be.insertSemicolon = function() {
          if (this.canInsertSemicolon())
            return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
        }, Be.semicolon = function() {
          this.eat(ie.semi) || this.insertSemicolon() || this.unexpected();
        }, Be.afterTrailingComma = function(x, J) {
          if (this.type === x)
            return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), J || this.next(), !0;
        }, Be.expect = function(x) {
          this.eat(x) || this.unexpected();
        }, Be.unexpected = function(x) {
          this.raise(x ?? this.start, "Unexpected token");
        };
        var nt = function() {
          this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
        };
        Be.checkPatternErrors = function(x, J) {
          if (x) {
            x.trailingComma > -1 && this.raiseRecoverable(x.trailingComma, "Comma is not permitted after the rest element");
            var he = J ? x.parenthesizedAssign : x.parenthesizedBind;
            he > -1 && this.raiseRecoverable(he, J ? "Assigning to rvalue" : "Parenthesized pattern");
          }
        }, Be.checkExpressionErrors = function(x, J) {
          if (!x)
            return !1;
          var he = x.shorthandAssign, ge = x.doubleProto;
          if (!J)
            return he >= 0 || ge >= 0;
          he >= 0 && this.raise(he, "Shorthand property assignments are valid only in destructuring patterns"), ge >= 0 && this.raiseRecoverable(ge, "Redefinition of __proto__ property");
        }, Be.checkYieldAwaitInDefaultParams = function() {
          this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
        }, Be.isSimpleAssignTarget = function(x) {
          return x.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(x.expression) : x.type === "Identifier" || x.type === "MemberExpression";
        };
        var $e = xe.prototype;
        $e.parseTopLevel = function(x) {
          var J = /* @__PURE__ */ Object.create(null);
          for (x.body || (x.body = []); this.type !== ie.eof; ) {
            var he = this.parseStatement(null, !0, J);
            x.body.push(he);
          }
          if (this.inModule)
            for (var ge = 0, Oe = Object.keys(this.undefinedExports); ge < Oe.length; ge += 1) {
              var Le = Oe[ge];
              this.raiseRecoverable(this.undefinedExports[Le].start, "Export '" + Le + "' is not defined");
            }
          return this.adaptDirectivePrologue(x.body), this.next(), x.sourceType = this.options.sourceType, this.finishNode(x, "Program");
        };
        var ut = { kind: "loop" }, vt = { kind: "switch" };
        $e.isLet = function(x) {
          if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
            return !1;
          me.lastIndex = this.pos;
          var J = me.exec(this.input), he = this.pos + J[0].length, ge = this.input.charCodeAt(he);
          if (ge === 91 || ge === 92)
            return !0;
          if (x)
            return !1;
          if (ge === 123 || ge > 55295 && ge < 56320)
            return !0;
          if (ye(ge, !0)) {
            for (var Oe = he + 1; ve(ge = this.input.charCodeAt(Oe), !0); )
              ++Oe;
            if (ge === 92 || ge > 55295 && ge < 56320)
              return !0;
            var Le = this.input.slice(he, Oe);
            if (!H.test(Le))
              return !0;
          }
          return !1;
        }, $e.isAsyncFunction = function() {
          if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
            return !1;
          me.lastIndex = this.pos;
          var x, J = me.exec(this.input), he = this.pos + J[0].length;
          return !(we.test(this.input.slice(this.pos, he)) || this.input.slice(he, he + 8) !== "function" || he + 8 !== this.input.length && (ve(x = this.input.charCodeAt(he + 8)) || x > 55295 && x < 56320));
        }, $e.parseStatement = function(x, J, he) {
          var ge, Oe = this.type, Le = this.startNode();
          switch (this.isLet(x) && (Oe = ie._var, ge = "let"), Oe) {
            case ie._break:
            case ie._continue:
              return this.parseBreakContinueStatement(Le, Oe.keyword);
            case ie._debugger:
              return this.parseDebuggerStatement(Le);
            case ie._do:
              return this.parseDoStatement(Le);
            case ie._for:
              return this.parseForStatement(Le);
            case ie._function:
              return x && (this.strict || x !== "if" && x !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(Le, !1, !x);
            case ie._class:
              return x && this.unexpected(), this.parseClass(Le, !0);
            case ie._if:
              return this.parseIfStatement(Le);
            case ie._return:
              return this.parseReturnStatement(Le);
            case ie._switch:
              return this.parseSwitchStatement(Le);
            case ie._throw:
              return this.parseThrowStatement(Le);
            case ie._try:
              return this.parseTryStatement(Le);
            case ie._const:
            case ie._var:
              return ge = ge || this.value, x && ge !== "var" && this.unexpected(), this.parseVarStatement(Le, ge);
            case ie._while:
              return this.parseWhileStatement(Le);
            case ie._with:
              return this.parseWithStatement(Le);
            case ie.braceL:
              return this.parseBlock(!0, Le);
            case ie.semi:
              return this.parseEmptyStatement(Le);
            case ie._export:
            case ie._import:
              if (this.options.ecmaVersion > 10 && Oe === ie._import) {
                me.lastIndex = this.pos;
                var Ue = me.exec(this.input), qe = this.pos + Ue[0].length, at = this.input.charCodeAt(qe);
                if (at === 40 || at === 46)
                  return this.parseExpressionStatement(Le, this.parseExpression());
              }
              return this.options.allowImportExportEverywhere || (J || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), Oe === ie._import ? this.parseImport(Le) : this.parseExport(Le, he);
            default:
              if (this.isAsyncFunction())
                return x && this.unexpected(), this.next(), this.parseFunctionStatement(Le, !0, !x);
              var gt = this.value, ot = this.parseExpression();
              return Oe === ie.name && ot.type === "Identifier" && this.eat(ie.colon) ? this.parseLabeledStatement(Le, gt, ot, x) : this.parseExpressionStatement(Le, ot);
          }
        }, $e.parseBreakContinueStatement = function(x, J) {
          var he = J === "break";
          this.next(), this.eat(ie.semi) || this.insertSemicolon() ? x.label = null : this.type !== ie.name ? this.unexpected() : (x.label = this.parseIdent(), this.semicolon());
          for (var ge = 0; ge < this.labels.length; ++ge) {
            var Oe = this.labels[ge];
            if ((x.label == null || Oe.name === x.label.name) && (Oe.kind != null && (he || Oe.kind === "loop") || x.label && he))
              break;
          }
          return ge === this.labels.length && this.raise(x.start, "Unsyntactic " + J), this.finishNode(x, he ? "BreakStatement" : "ContinueStatement");
        }, $e.parseDebuggerStatement = function(x) {
          return this.next(), this.semicolon(), this.finishNode(x, "DebuggerStatement");
        }, $e.parseDoStatement = function(x) {
          return this.next(), this.labels.push(ut), x.body = this.parseStatement("do"), this.labels.pop(), this.expect(ie._while), x.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(ie.semi) : this.semicolon(), this.finishNode(x, "DoWhileStatement");
        }, $e.parseForStatement = function(x) {
          this.next();
          var J = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
          if (this.labels.push(ut), this.enterScope(0), this.expect(ie.parenL), this.type === ie.semi)
            return J > -1 && this.unexpected(J), this.parseFor(x, null);
          var he = this.isLet();
          if (this.type === ie._var || this.type === ie._const || he) {
            var ge = this.startNode(), Oe = he ? "let" : this.value;
            return this.next(), this.parseVar(ge, !0, Oe), this.finishNode(ge, "VariableDeclaration"), (this.type === ie._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && ge.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === ie._in ? J > -1 && this.unexpected(J) : x.await = J > -1), this.parseForIn(x, ge)) : (J > -1 && this.unexpected(J), this.parseFor(x, ge));
          }
          var Le = this.isContextual("let"), Ue = !1, qe = new nt(), at = this.parseExpression(!(J > -1) || "await", qe);
          return this.type === ie._in || (Ue = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (this.options.ecmaVersion >= 9 && (this.type === ie._in ? J > -1 && this.unexpected(J) : x.await = J > -1), Le && Ue && this.raise(at.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(at, !1, qe), this.checkLValPattern(at), this.parseForIn(x, at)) : (this.checkExpressionErrors(qe, !0), J > -1 && this.unexpected(J), this.parseFor(x, at));
        }, $e.parseFunctionStatement = function(x, J, he) {
          return this.next(), this.parseFunction(x, et | (he ? 0 : bt), !1, J);
        }, $e.parseIfStatement = function(x) {
          return this.next(), x.test = this.parseParenExpression(), x.consequent = this.parseStatement("if"), x.alternate = this.eat(ie._else) ? this.parseStatement("if") : null, this.finishNode(x, "IfStatement");
        }, $e.parseReturnStatement = function(x) {
          return this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function"), this.next(), this.eat(ie.semi) || this.insertSemicolon() ? x.argument = null : (x.argument = this.parseExpression(), this.semicolon()), this.finishNode(x, "ReturnStatement");
        }, $e.parseSwitchStatement = function(x) {
          var J;
          this.next(), x.discriminant = this.parseParenExpression(), x.cases = [], this.expect(ie.braceL), this.labels.push(vt), this.enterScope(0);
          for (var he = !1; this.type !== ie.braceR; )
            if (this.type === ie._case || this.type === ie._default) {
              var ge = this.type === ie._case;
              J && this.finishNode(J, "SwitchCase"), x.cases.push(J = this.startNode()), J.consequent = [], this.next(), ge ? J.test = this.parseExpression() : (he && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), he = !0, J.test = null), this.expect(ie.colon);
            } else
              J || this.unexpected(), J.consequent.push(this.parseStatement(null));
          return this.exitScope(), J && this.finishNode(J, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(x, "SwitchStatement");
        }, $e.parseThrowStatement = function(x) {
          return this.next(), we.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), x.argument = this.parseExpression(), this.semicolon(), this.finishNode(x, "ThrowStatement");
        };
        var yt = [];
        $e.parseCatchClauseParam = function() {
          var x = this.parseBindingAtom(), J = x.type === "Identifier";
          return this.enterScope(J ? 32 : 0), this.checkLValPattern(x, J ? 4 : 2), this.expect(ie.parenR), x;
        }, $e.parseTryStatement = function(x) {
          if (this.next(), x.block = this.parseBlock(), x.handler = null, this.type === ie._catch) {
            var J = this.startNode();
            this.next(), this.eat(ie.parenL) ? J.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), J.param = null, this.enterScope(0)), J.body = this.parseBlock(!1), this.exitScope(), x.handler = this.finishNode(J, "CatchClause");
          }
          return x.finalizer = this.eat(ie._finally) ? this.parseBlock() : null, x.handler || x.finalizer || this.raise(x.start, "Missing catch or finally clause"), this.finishNode(x, "TryStatement");
        }, $e.parseVarStatement = function(x, J, he) {
          return this.next(), this.parseVar(x, !1, J, he), this.semicolon(), this.finishNode(x, "VariableDeclaration");
        }, $e.parseWhileStatement = function(x) {
          return this.next(), x.test = this.parseParenExpression(), this.labels.push(ut), x.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(x, "WhileStatement");
        }, $e.parseWithStatement = function(x) {
          return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), x.object = this.parseParenExpression(), x.body = this.parseStatement("with"), this.finishNode(x, "WithStatement");
        }, $e.parseEmptyStatement = function(x) {
          return this.next(), this.finishNode(x, "EmptyStatement");
        }, $e.parseLabeledStatement = function(x, J, he, ge) {
          for (var Oe = 0, Le = this.labels; Oe < Le.length; Oe += 1)
            Le[Oe].name === J && this.raise(he.start, "Label '" + J + "' is already declared");
          for (var Ue = this.type.isLoop ? "loop" : this.type === ie._switch ? "switch" : null, qe = this.labels.length - 1; qe >= 0; qe--) {
            var at = this.labels[qe];
            if (at.statementStart !== x.start)
              break;
            at.statementStart = this.start, at.kind = Ue;
          }
          return this.labels.push({ name: J, kind: Ue, statementStart: this.start }), x.body = this.parseStatement(ge ? ge.indexOf("label") === -1 ? ge + "label" : ge : "label"), this.labels.pop(), x.label = he, this.finishNode(x, "LabeledStatement");
        }, $e.parseExpressionStatement = function(x, J) {
          return x.expression = J, this.semicolon(), this.finishNode(x, "ExpressionStatement");
        }, $e.parseBlock = function(x, J, he) {
          for (x === void 0 && (x = !0), J === void 0 && (J = this.startNode()), J.body = [], this.expect(ie.braceL), x && this.enterScope(0); this.type !== ie.braceR; ) {
            var ge = this.parseStatement(null);
            J.body.push(ge);
          }
          return he && (this.strict = !1), this.next(), x && this.exitScope(), this.finishNode(J, "BlockStatement");
        }, $e.parseFor = function(x, J) {
          return x.init = J, this.expect(ie.semi), x.test = this.type === ie.semi ? null : this.parseExpression(), this.expect(ie.semi), x.update = this.type === ie.parenR ? null : this.parseExpression(), this.expect(ie.parenR), x.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(x, "ForStatement");
        }, $e.parseForIn = function(x, J) {
          var he = this.type === ie._in;
          return this.next(), J.type === "VariableDeclaration" && J.declarations[0].init != null && (!he || this.options.ecmaVersion < 8 || this.strict || J.kind !== "var" || J.declarations[0].id.type !== "Identifier") && this.raise(J.start, (he ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"), x.left = J, x.right = he ? this.parseExpression() : this.parseMaybeAssign(), this.expect(ie.parenR), x.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(x, he ? "ForInStatement" : "ForOfStatement");
        }, $e.parseVar = function(x, J, he, ge) {
          for (x.declarations = [], x.kind = he; ; ) {
            var Oe = this.startNode();
            if (this.parseVarId(Oe, he), this.eat(ie.eq) ? Oe.init = this.parseMaybeAssign(J) : ge || he !== "const" || this.type === ie._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? ge || Oe.id.type === "Identifier" || J && (this.type === ie._in || this.isContextual("of")) ? Oe.init = null : this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : this.unexpected(), x.declarations.push(this.finishNode(Oe, "VariableDeclarator")), !this.eat(ie.comma))
              break;
          }
          return x;
        }, $e.parseVarId = function(x, J) {
          x.id = this.parseBindingAtom(), this.checkLValPattern(x.id, J === "var" ? 1 : 2, !1);
        };
        var et = 1, bt = 2;
        function lt(x, J) {
          var he = J.key.name, ge = x[he], Oe = "true";
          return J.type !== "MethodDefinition" || J.kind !== "get" && J.kind !== "set" || (Oe = (J.static ? "s" : "i") + J.kind), ge === "iget" && Oe === "iset" || ge === "iset" && Oe === "iget" || ge === "sget" && Oe === "sset" || ge === "sset" && Oe === "sget" ? (x[he] = "true", !1) : !!ge || (x[he] = Oe, !1);
        }
        function Et(x, J) {
          var he = x.computed, ge = x.key;
          return !he && (ge.type === "Identifier" && ge.name === J || ge.type === "Literal" && ge.value === J);
        }
        $e.parseFunction = function(x, J, he, ge, Oe) {
          this.initFunction(x), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !ge) && (this.type === ie.star && J & bt && this.unexpected(), x.generator = this.eat(ie.star)), this.options.ecmaVersion >= 8 && (x.async = !!ge), J & et && (x.id = 4 & J && this.type !== ie.name ? null : this.parseIdent(), !x.id || J & bt || this.checkLValSimple(x.id, this.strict || x.generator || x.async ? this.treatFunctionsAsVar ? 1 : 2 : 3));
          var Le = this.yieldPos, Ue = this.awaitPos, qe = this.awaitIdentPos;
          return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(Ce(x.async, x.generator)), J & et || (x.id = this.type === ie.name ? this.parseIdent() : null), this.parseFunctionParams(x), this.parseFunctionBody(x, he, !1, Oe), this.yieldPos = Le, this.awaitPos = Ue, this.awaitIdentPos = qe, this.finishNode(x, J & et ? "FunctionDeclaration" : "FunctionExpression");
        }, $e.parseFunctionParams = function(x) {
          this.expect(ie.parenL), x.params = this.parseBindingList(ie.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
        }, $e.parseClass = function(x, J) {
          this.next();
          var he = this.strict;
          this.strict = !0, this.parseClassId(x, J), this.parseClassSuper(x);
          var ge = this.enterClassBody(), Oe = this.startNode(), Le = !1;
          for (Oe.body = [], this.expect(ie.braceL); this.type !== ie.braceR; ) {
            var Ue = this.parseClassElement(x.superClass !== null);
            Ue && (Oe.body.push(Ue), Ue.type === "MethodDefinition" && Ue.kind === "constructor" ? (Le && this.raiseRecoverable(Ue.start, "Duplicate constructor in the same class"), Le = !0) : Ue.key && Ue.key.type === "PrivateIdentifier" && lt(ge, Ue) && this.raiseRecoverable(Ue.key.start, "Identifier '#" + Ue.key.name + "' has already been declared"));
          }
          return this.strict = he, this.next(), x.body = this.finishNode(Oe, "ClassBody"), this.exitClassBody(), this.finishNode(x, J ? "ClassDeclaration" : "ClassExpression");
        }, $e.parseClassElement = function(x) {
          if (this.eat(ie.semi))
            return null;
          var J = this.options.ecmaVersion, he = this.startNode(), ge = "", Oe = !1, Le = !1, Ue = "method", qe = !1;
          if (this.eatContextual("static")) {
            if (J >= 13 && this.eat(ie.braceL))
              return this.parseClassStaticBlock(he), he;
            this.isClassElementNameStart() || this.type === ie.star ? qe = !0 : ge = "static";
          }
          if (he.static = qe, !ge && J >= 8 && this.eatContextual("async") && (!this.isClassElementNameStart() && this.type !== ie.star || this.canInsertSemicolon() ? ge = "async" : Le = !0), !ge && (J >= 9 || !Le) && this.eat(ie.star) && (Oe = !0), !ge && !Le && !Oe) {
            var at = this.value;
            (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? Ue = at : ge = at);
          }
          if (ge ? (he.computed = !1, he.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), he.key.name = ge, this.finishNode(he.key, "Identifier")) : this.parseClassElementName(he), J < 13 || this.type === ie.parenL || Ue !== "method" || Oe || Le) {
            var gt = !he.static && Et(he, "constructor"), ot = gt && x;
            gt && Ue !== "method" && this.raise(he.key.start, "Constructor can't have get/set modifier"), he.kind = gt ? "constructor" : Ue, this.parseClassMethod(he, Oe, Le, ot);
          } else
            this.parseClassField(he);
          return he;
        }, $e.isClassElementNameStart = function() {
          return this.type === ie.name || this.type === ie.privateId || this.type === ie.num || this.type === ie.string || this.type === ie.bracketL || this.type.keyword;
        }, $e.parseClassElementName = function(x) {
          this.type === ie.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), x.computed = !1, x.key = this.parsePrivateIdent()) : this.parsePropertyName(x);
        }, $e.parseClassMethod = function(x, J, he, ge) {
          var Oe = x.key;
          x.kind === "constructor" ? (J && this.raise(Oe.start, "Constructor can't be a generator"), he && this.raise(Oe.start, "Constructor can't be an async method")) : x.static && Et(x, "prototype") && this.raise(Oe.start, "Classes may not have a static property named prototype");
          var Le = x.value = this.parseMethod(J, he, ge);
          return x.kind === "get" && Le.params.length !== 0 && this.raiseRecoverable(Le.start, "getter should have no params"), x.kind === "set" && Le.params.length !== 1 && this.raiseRecoverable(Le.start, "setter should have exactly one param"), x.kind === "set" && Le.params[0].type === "RestElement" && this.raiseRecoverable(Le.params[0].start, "Setter cannot use rest params"), this.finishNode(x, "MethodDefinition");
        }, $e.parseClassField = function(x) {
          if (Et(x, "constructor") ? this.raise(x.key.start, "Classes can't have a field named 'constructor'") : x.static && Et(x, "prototype") && this.raise(x.key.start, "Classes can't have a static field named 'prototype'"), this.eat(ie.eq)) {
            var J = this.currentThisScope(), he = J.inClassFieldInit;
            J.inClassFieldInit = !0, x.value = this.parseMaybeAssign(), J.inClassFieldInit = he;
          } else
            x.value = null;
          return this.semicolon(), this.finishNode(x, "PropertyDefinition");
        }, $e.parseClassStaticBlock = function(x) {
          x.body = [];
          var J = this.labels;
          for (this.labels = [], this.enterScope(320); this.type !== ie.braceR; ) {
            var he = this.parseStatement(null);
            x.body.push(he);
          }
          return this.next(), this.exitScope(), this.labels = J, this.finishNode(x, "StaticBlock");
        }, $e.parseClassId = function(x, J) {
          this.type === ie.name ? (x.id = this.parseIdent(), J && this.checkLValSimple(x.id, 2, !1)) : (J === !0 && this.unexpected(), x.id = null);
        }, $e.parseClassSuper = function(x) {
          x.superClass = this.eat(ie._extends) ? this.parseExprSubscripts(null, !1) : null;
        }, $e.enterClassBody = function() {
          var x = { declared: /* @__PURE__ */ Object.create(null), used: [] };
          return this.privateNameStack.push(x), x.declared;
        }, $e.exitClassBody = function() {
          var x = this.privateNameStack.pop(), J = x.declared, he = x.used;
          if (this.options.checkPrivateFields)
            for (var ge = this.privateNameStack.length, Oe = ge === 0 ? null : this.privateNameStack[ge - 1], Le = 0; Le < he.length; ++Le) {
              var Ue = he[Le];
              be(J, Ue.name) || (Oe ? Oe.used.push(Ue) : this.raiseRecoverable(Ue.start, "Private field '#" + Ue.name + "' must be declared in an enclosing class"));
            }
        }, $e.parseExportAllDeclaration = function(x, J) {
          return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (x.exported = this.parseModuleExportName(), this.checkExport(J, x.exported, this.lastTokStart)) : x.exported = null), this.expectContextual("from"), this.type !== ie.string && this.unexpected(), x.source = this.parseExprAtom(), this.semicolon(), this.finishNode(x, "ExportAllDeclaration");
        }, $e.parseExport = function(x, J) {
          if (this.next(), this.eat(ie.star))
            return this.parseExportAllDeclaration(x, J);
          if (this.eat(ie._default))
            return this.checkExport(J, "default", this.lastTokStart), x.declaration = this.parseExportDefaultDeclaration(), this.finishNode(x, "ExportDefaultDeclaration");
          if (this.shouldParseExportStatement())
            x.declaration = this.parseExportDeclaration(x), x.declaration.type === "VariableDeclaration" ? this.checkVariableExport(J, x.declaration.declarations) : this.checkExport(J, x.declaration.id, x.declaration.id.start), x.specifiers = [], x.source = null;
          else {
            if (x.declaration = null, x.specifiers = this.parseExportSpecifiers(J), this.eatContextual("from"))
              this.type !== ie.string && this.unexpected(), x.source = this.parseExprAtom();
            else {
              for (var he = 0, ge = x.specifiers; he < ge.length; he += 1) {
                var Oe = ge[he];
                this.checkUnreserved(Oe.local), this.checkLocalExport(Oe.local), Oe.local.type === "Literal" && this.raise(Oe.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
              x.source = null;
            }
            this.semicolon();
          }
          return this.finishNode(x, "ExportNamedDeclaration");
        }, $e.parseExportDeclaration = function(x) {
          return this.parseStatement(null);
        }, $e.parseExportDefaultDeclaration = function() {
          var x;
          if (this.type === ie._function || (x = this.isAsyncFunction())) {
            var J = this.startNode();
            return this.next(), x && this.next(), this.parseFunction(J, 4 | et, !1, x);
          }
          if (this.type === ie._class) {
            var he = this.startNode();
            return this.parseClass(he, "nullableID");
          }
          var ge = this.parseMaybeAssign();
          return this.semicolon(), ge;
        }, $e.checkExport = function(x, J, he) {
          x && (typeof J != "string" && (J = J.type === "Identifier" ? J.name : J.value), be(x, J) && this.raiseRecoverable(he, "Duplicate export '" + J + "'"), x[J] = !0);
        }, $e.checkPatternExport = function(x, J) {
          var he = J.type;
          if (he === "Identifier")
            this.checkExport(x, J, J.start);
          else if (he === "ObjectPattern")
            for (var ge = 0, Oe = J.properties; ge < Oe.length; ge += 1) {
              var Le = Oe[ge];
              this.checkPatternExport(x, Le);
            }
          else if (he === "ArrayPattern")
            for (var Ue = 0, qe = J.elements; Ue < qe.length; Ue += 1) {
              var at = qe[Ue];
              at && this.checkPatternExport(x, at);
            }
          else
            he === "Property" ? this.checkPatternExport(x, J.value) : he === "AssignmentPattern" ? this.checkPatternExport(x, J.left) : he === "RestElement" ? this.checkPatternExport(x, J.argument) : he === "ParenthesizedExpression" && this.checkPatternExport(x, J.expression);
        }, $e.checkVariableExport = function(x, J) {
          if (x)
            for (var he = 0, ge = J; he < ge.length; he += 1) {
              var Oe = ge[he];
              this.checkPatternExport(x, Oe.id);
            }
        }, $e.shouldParseExportStatement = function() {
          return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
        }, $e.parseExportSpecifier = function(x) {
          var J = this.startNode();
          return J.local = this.parseModuleExportName(), J.exported = this.eatContextual("as") ? this.parseModuleExportName() : J.local, this.checkExport(x, J.exported, J.exported.start), this.finishNode(J, "ExportSpecifier");
        }, $e.parseExportSpecifiers = function(x) {
          var J = [], he = !0;
          for (this.expect(ie.braceL); !this.eat(ie.braceR); ) {
            if (he)
              he = !1;
            else if (this.expect(ie.comma), this.afterTrailingComma(ie.braceR))
              break;
            J.push(this.parseExportSpecifier(x));
          }
          return J;
        }, $e.parseImport = function(x) {
          return this.next(), this.type === ie.string ? (x.specifiers = yt, x.source = this.parseExprAtom()) : (x.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), x.source = this.type === ie.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(x, "ImportDeclaration");
        }, $e.parseImportSpecifier = function() {
          var x = this.startNode();
          return x.imported = this.parseModuleExportName(), this.eatContextual("as") ? x.local = this.parseIdent() : (this.checkUnreserved(x.imported), x.local = x.imported), this.checkLValSimple(x.local, 2), this.finishNode(x, "ImportSpecifier");
        }, $e.parseImportDefaultSpecifier = function() {
          var x = this.startNode();
          return x.local = this.parseIdent(), this.checkLValSimple(x.local, 2), this.finishNode(x, "ImportDefaultSpecifier");
        }, $e.parseImportNamespaceSpecifier = function() {
          var x = this.startNode();
          return this.next(), this.expectContextual("as"), x.local = this.parseIdent(), this.checkLValSimple(x.local, 2), this.finishNode(x, "ImportNamespaceSpecifier");
        }, $e.parseImportSpecifiers = function() {
          var x = [], J = !0;
          if (this.type === ie.name && (x.push(this.parseImportDefaultSpecifier()), !this.eat(ie.comma)))
            return x;
          if (this.type === ie.star)
            return x.push(this.parseImportNamespaceSpecifier()), x;
          for (this.expect(ie.braceL); !this.eat(ie.braceR); ) {
            if (J)
              J = !1;
            else if (this.expect(ie.comma), this.afterTrailingComma(ie.braceR))
              break;
            x.push(this.parseImportSpecifier());
          }
          return x;
        }, $e.parseModuleExportName = function() {
          if (this.options.ecmaVersion >= 13 && this.type === ie.string) {
            var x = this.parseLiteral(this.value);
            return tt.test(x.value) && this.raise(x.start, "An export name cannot include a lone surrogate."), x;
          }
          return this.parseIdent(!0);
        }, $e.adaptDirectivePrologue = function(x) {
          for (var J = 0; J < x.length && this.isDirectiveCandidate(x[J]); ++J)
            x[J].directive = x[J].expression.raw.slice(1, -1);
        }, $e.isDirectiveCandidate = function(x) {
          return this.options.ecmaVersion >= 5 && x.type === "ExpressionStatement" && x.expression.type === "Literal" && typeof x.expression.value == "string" && (this.input[x.start] === '"' || this.input[x.start] === "'");
        };
        var wt = xe.prototype;
        wt.toAssignable = function(x, J, he) {
          if (this.options.ecmaVersion >= 6 && x)
            switch (x.type) {
              case "Identifier":
                this.inAsync && x.name === "await" && this.raise(x.start, "Cannot use 'await' as identifier inside an async function");
                break;
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                break;
              case "ObjectExpression":
                x.type = "ObjectPattern", he && this.checkPatternErrors(he, !0);
                for (var ge = 0, Oe = x.properties; ge < Oe.length; ge += 1) {
                  var Le = Oe[ge];
                  this.toAssignable(Le, J), Le.type !== "RestElement" || Le.argument.type !== "ArrayPattern" && Le.argument.type !== "ObjectPattern" || this.raise(Le.argument.start, "Unexpected token");
                }
                break;
              case "Property":
                x.kind !== "init" && this.raise(x.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(x.value, J);
                break;
              case "ArrayExpression":
                x.type = "ArrayPattern", he && this.checkPatternErrors(he, !0), this.toAssignableList(x.elements, J);
                break;
              case "SpreadElement":
                x.type = "RestElement", this.toAssignable(x.argument, J), x.argument.type === "AssignmentPattern" && this.raise(x.argument.start, "Rest elements cannot have a default value");
                break;
              case "AssignmentExpression":
                x.operator !== "=" && this.raise(x.left.end, "Only '=' operator can be used for specifying default value."), x.type = "AssignmentPattern", delete x.operator, this.toAssignable(x.left, J);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(x.expression, J, he);
                break;
              case "ChainExpression":
                this.raiseRecoverable(x.start, "Optional chaining cannot appear in left-hand side");
                break;
              case "MemberExpression":
                if (!J)
                  break;
              default:
                this.raise(x.start, "Assigning to rvalue");
            }
          else
            he && this.checkPatternErrors(he, !0);
          return x;
        }, wt.toAssignableList = function(x, J) {
          for (var he = x.length, ge = 0; ge < he; ge++) {
            var Oe = x[ge];
            Oe && this.toAssignable(Oe, J);
          }
          if (he) {
            var Le = x[he - 1];
            this.options.ecmaVersion === 6 && J && Le && Le.type === "RestElement" && Le.argument.type !== "Identifier" && this.unexpected(Le.argument.start);
          }
          return x;
        }, wt.parseSpread = function(x) {
          var J = this.startNode();
          return this.next(), J.argument = this.parseMaybeAssign(!1, x), this.finishNode(J, "SpreadElement");
        }, wt.parseRestBinding = function() {
          var x = this.startNode();
          return this.next(), this.options.ecmaVersion === 6 && this.type !== ie.name && this.unexpected(), x.argument = this.parseBindingAtom(), this.finishNode(x, "RestElement");
        }, wt.parseBindingAtom = function() {
          if (this.options.ecmaVersion >= 6)
            switch (this.type) {
              case ie.bracketL:
                var x = this.startNode();
                return this.next(), x.elements = this.parseBindingList(ie.bracketR, !0, !0), this.finishNode(x, "ArrayPattern");
              case ie.braceL:
                return this.parseObj(!0);
            }
          return this.parseIdent();
        }, wt.parseBindingList = function(x, J, he, ge) {
          for (var Oe = [], Le = !0; !this.eat(x); )
            if (Le ? Le = !1 : this.expect(ie.comma), J && this.type === ie.comma)
              Oe.push(null);
            else {
              if (he && this.afterTrailingComma(x))
                break;
              if (this.type === ie.ellipsis) {
                var Ue = this.parseRestBinding();
                this.parseBindingListItem(Ue), Oe.push(Ue), this.type === ie.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(x);
                break;
              }
              Oe.push(this.parseAssignableListItem(ge));
            }
          return Oe;
        }, wt.parseAssignableListItem = function(x) {
          var J = this.parseMaybeDefault(this.start, this.startLoc);
          return this.parseBindingListItem(J), J;
        }, wt.parseBindingListItem = function(x) {
          return x;
        }, wt.parseMaybeDefault = function(x, J, he) {
          if (he = he || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(ie.eq))
            return he;
          var ge = this.startNodeAt(x, J);
          return ge.left = he, ge.right = this.parseMaybeAssign(), this.finishNode(ge, "AssignmentPattern");
        }, wt.checkLValSimple = function(x, J, he) {
          J === void 0 && (J = 0);
          var ge = J !== 0;
          switch (x.type) {
            case "Identifier":
              this.strict && this.reservedWordsStrictBind.test(x.name) && this.raiseRecoverable(x.start, (ge ? "Binding " : "Assigning to ") + x.name + " in strict mode"), ge && (J === 2 && x.name === "let" && this.raiseRecoverable(x.start, "let is disallowed as a lexically bound name"), he && (be(he, x.name) && this.raiseRecoverable(x.start, "Argument name clash"), he[x.name] = !0), J !== 5 && this.declareName(x.name, J, x.start));
              break;
            case "ChainExpression":
              this.raiseRecoverable(x.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              ge && this.raiseRecoverable(x.start, "Binding member expression");
              break;
            case "ParenthesizedExpression":
              return ge && this.raiseRecoverable(x.start, "Binding parenthesized expression"), this.checkLValSimple(x.expression, J, he);
            default:
              this.raise(x.start, (ge ? "Binding" : "Assigning to") + " rvalue");
          }
        }, wt.checkLValPattern = function(x, J, he) {
          switch (J === void 0 && (J = 0), x.type) {
            case "ObjectPattern":
              for (var ge = 0, Oe = x.properties; ge < Oe.length; ge += 1) {
                var Le = Oe[ge];
                this.checkLValInnerPattern(Le, J, he);
              }
              break;
            case "ArrayPattern":
              for (var Ue = 0, qe = x.elements; Ue < qe.length; Ue += 1) {
                var at = qe[Ue];
                at && this.checkLValInnerPattern(at, J, he);
              }
              break;
            default:
              this.checkLValSimple(x, J, he);
          }
        }, wt.checkLValInnerPattern = function(x, J, he) {
          switch (J === void 0 && (J = 0), x.type) {
            case "Property":
              this.checkLValInnerPattern(x.value, J, he);
              break;
            case "AssignmentPattern":
              this.checkLValPattern(x.left, J, he);
              break;
            case "RestElement":
              this.checkLValPattern(x.argument, J, he);
              break;
            default:
              this.checkLValPattern(x, J, he);
          }
        };
        var Ne = function(x, J, he, ge, Oe) {
          this.token = x, this.isExpr = !!J, this.preserveSpace = !!he, this.override = ge, this.generator = !!Oe;
        }, Je = { b_stat: new Ne("{", !1), b_expr: new Ne("{", !0), b_tmpl: new Ne("${", !1), p_stat: new Ne("(", !1), p_expr: new Ne("(", !0), q_tmpl: new Ne("`", !0, !0, function(x) {
          return x.tryReadTemplateToken();
        }), f_stat: new Ne("function", !1), f_expr: new Ne("function", !0), f_expr_gen: new Ne("function", !0, !1, null, !0), f_gen: new Ne("function", !1, !1, null, !0) }, ft = xe.prototype;
        ft.initialContext = function() {
          return [Je.b_stat];
        }, ft.curContext = function() {
          return this.context[this.context.length - 1];
        }, ft.braceIsBlock = function(x) {
          var J = this.curContext();
          return J === Je.f_expr || J === Je.f_stat || (x !== ie.colon || J !== Je.b_stat && J !== Je.b_expr ? x === ie._return || x === ie.name && this.exprAllowed ? we.test(this.input.slice(this.lastTokEnd, this.start)) : x === ie._else || x === ie.semi || x === ie.eof || x === ie.parenR || x === ie.arrow || (x === ie.braceL ? J === Je.b_stat : x !== ie._var && x !== ie._const && x !== ie.name && !this.exprAllowed) : !J.isExpr);
        }, ft.inGeneratorContext = function() {
          for (var x = this.context.length - 1; x >= 1; x--) {
            var J = this.context[x];
            if (J.token === "function")
              return J.generator;
          }
          return !1;
        }, ft.updateContext = function(x) {
          var J, he = this.type;
          he.keyword && x === ie.dot ? this.exprAllowed = !1 : (J = he.updateContext) ? J.call(this, x) : this.exprAllowed = he.beforeExpr;
        }, ft.overrideContext = function(x) {
          this.curContext() !== x && (this.context[this.context.length - 1] = x);
        }, ie.parenR.updateContext = ie.braceR.updateContext = function() {
          if (this.context.length !== 1) {
            var x = this.context.pop();
            x === Je.b_stat && this.curContext().token === "function" && (x = this.context.pop()), this.exprAllowed = !x.isExpr;
          } else
            this.exprAllowed = !0;
        }, ie.braceL.updateContext = function(x) {
          this.context.push(this.braceIsBlock(x) ? Je.b_stat : Je.b_expr), this.exprAllowed = !0;
        }, ie.dollarBraceL.updateContext = function() {
          this.context.push(Je.b_tmpl), this.exprAllowed = !0;
        }, ie.parenL.updateContext = function(x) {
          var J = x === ie._if || x === ie._for || x === ie._with || x === ie._while;
          this.context.push(J ? Je.p_stat : Je.p_expr), this.exprAllowed = !0;
        }, ie.incDec.updateContext = function() {
        }, ie._function.updateContext = ie._class.updateContext = function(x) {
          !x.beforeExpr || x === ie._else || x === ie.semi && this.curContext() !== Je.p_stat || x === ie._return && we.test(this.input.slice(this.lastTokEnd, this.start)) || (x === ie.colon || x === ie.braceL) && this.curContext() === Je.b_stat ? this.context.push(Je.f_stat) : this.context.push(Je.f_expr), this.exprAllowed = !1;
        }, ie.backQuote.updateContext = function() {
          this.curContext() === Je.q_tmpl ? this.context.pop() : this.context.push(Je.q_tmpl), this.exprAllowed = !1;
        }, ie.star.updateContext = function(x) {
          if (x === ie._function) {
            var J = this.context.length - 1;
            this.context[J] === Je.f_expr ? this.context[J] = Je.f_expr_gen : this.context[J] = Je.f_gen;
          }
          this.exprAllowed = !0;
        }, ie.name.updateContext = function(x) {
          var J = !1;
          this.options.ecmaVersion >= 6 && x !== ie.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (J = !0), this.exprAllowed = J;
        };
        var rt = xe.prototype;
        function At(x) {
          return x.type === "MemberExpression" && x.property.type === "PrivateIdentifier" || x.type === "ChainExpression" && At(x.expression);
        }
        rt.checkPropClash = function(x, J, he) {
          if (!(this.options.ecmaVersion >= 9 && x.type === "SpreadElement" || this.options.ecmaVersion >= 6 && (x.computed || x.method || x.shorthand))) {
            var ge, Oe = x.key;
            switch (Oe.type) {
              case "Identifier":
                ge = Oe.name;
                break;
              case "Literal":
                ge = String(Oe.value);
                break;
              default:
                return;
            }
            var Le = x.kind;
            if (this.options.ecmaVersion >= 6)
              ge === "__proto__" && Le === "init" && (J.proto && (he ? he.doubleProto < 0 && (he.doubleProto = Oe.start) : this.raiseRecoverable(Oe.start, "Redefinition of __proto__ property")), J.proto = !0);
            else {
              var Ue = J[ge = "$" + ge];
              Ue ? (Le === "init" ? this.strict && Ue.init || Ue.get || Ue.set : Ue.init || Ue[Le]) && this.raiseRecoverable(Oe.start, "Redefinition of property") : Ue = J[ge] = { init: !1, get: !1, set: !1 }, Ue[Le] = !0;
            }
          }
        }, rt.parseExpression = function(x, J) {
          var he = this.start, ge = this.startLoc, Oe = this.parseMaybeAssign(x, J);
          if (this.type === ie.comma) {
            var Le = this.startNodeAt(he, ge);
            for (Le.expressions = [Oe]; this.eat(ie.comma); )
              Le.expressions.push(this.parseMaybeAssign(x, J));
            return this.finishNode(Le, "SequenceExpression");
          }
          return Oe;
        }, rt.parseMaybeAssign = function(x, J, he) {
          if (this.isContextual("yield")) {
            if (this.inGenerator)
              return this.parseYield(x);
            this.exprAllowed = !1;
          }
          var ge = !1, Oe = -1, Le = -1, Ue = -1;
          J ? (Oe = J.parenthesizedAssign, Le = J.trailingComma, Ue = J.doubleProto, J.parenthesizedAssign = J.trailingComma = -1) : (J = new nt(), ge = !0);
          var qe = this.start, at = this.startLoc;
          this.type !== ie.parenL && this.type !== ie.name || (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = x === "await");
          var gt = this.parseMaybeConditional(x, J);
          if (he && (gt = he.call(this, gt, qe, at)), this.type.isAssign) {
            var ot = this.startNodeAt(qe, at);
            return ot.operator = this.value, this.type === ie.eq && (gt = this.toAssignable(gt, !1, J)), ge || (J.parenthesizedAssign = J.trailingComma = J.doubleProto = -1), J.shorthandAssign >= gt.start && (J.shorthandAssign = -1), this.type === ie.eq ? this.checkLValPattern(gt) : this.checkLValSimple(gt), ot.left = gt, this.next(), ot.right = this.parseMaybeAssign(x), Ue > -1 && (J.doubleProto = Ue), this.finishNode(ot, "AssignmentExpression");
          }
          return ge && this.checkExpressionErrors(J, !0), Oe > -1 && (J.parenthesizedAssign = Oe), Le > -1 && (J.trailingComma = Le), gt;
        }, rt.parseMaybeConditional = function(x, J) {
          var he = this.start, ge = this.startLoc, Oe = this.parseExprOps(x, J);
          if (this.checkExpressionErrors(J))
            return Oe;
          if (this.eat(ie.question)) {
            var Le = this.startNodeAt(he, ge);
            return Le.test = Oe, Le.consequent = this.parseMaybeAssign(), this.expect(ie.colon), Le.alternate = this.parseMaybeAssign(x), this.finishNode(Le, "ConditionalExpression");
          }
          return Oe;
        }, rt.parseExprOps = function(x, J) {
          var he = this.start, ge = this.startLoc, Oe = this.parseMaybeUnary(J, !1, !1, x);
          return this.checkExpressionErrors(J) || Oe.start === he && Oe.type === "ArrowFunctionExpression" ? Oe : this.parseExprOp(Oe, he, ge, -1, x);
        }, rt.parseExprOp = function(x, J, he, ge, Oe) {
          var Le = this.type.binop;
          if (Le != null && (!Oe || this.type !== ie._in) && Le > ge) {
            var Ue = this.type === ie.logicalOR || this.type === ie.logicalAND, qe = this.type === ie.coalesce;
            qe && (Le = ie.logicalAND.binop);
            var at = this.value;
            this.next();
            var gt = this.start, ot = this.startLoc, Lt = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, Oe), gt, ot, Le, Oe), Ft = this.buildBinary(J, he, x, Lt, at, Ue || qe);
            return (Ue && this.type === ie.coalesce || qe && (this.type === ie.logicalOR || this.type === ie.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(Ft, J, he, ge, Oe);
          }
          return x;
        }, rt.buildBinary = function(x, J, he, ge, Oe, Le) {
          ge.type === "PrivateIdentifier" && this.raise(ge.start, "Private identifier can only be left side of binary expression");
          var Ue = this.startNodeAt(x, J);
          return Ue.left = he, Ue.operator = Oe, Ue.right = ge, this.finishNode(Ue, Le ? "LogicalExpression" : "BinaryExpression");
        }, rt.parseMaybeUnary = function(x, J, he, ge) {
          var Oe, Le = this.start, Ue = this.startLoc;
          if (this.isContextual("await") && this.canAwait)
            Oe = this.parseAwait(ge), J = !0;
          else if (this.type.prefix) {
            var qe = this.startNode(), at = this.type === ie.incDec;
            qe.operator = this.value, qe.prefix = !0, this.next(), qe.argument = this.parseMaybeUnary(null, !0, at, ge), this.checkExpressionErrors(x, !0), at ? this.checkLValSimple(qe.argument) : this.strict && qe.operator === "delete" && qe.argument.type === "Identifier" ? this.raiseRecoverable(qe.start, "Deleting local variable in strict mode") : qe.operator === "delete" && At(qe.argument) ? this.raiseRecoverable(qe.start, "Private fields can not be deleted") : J = !0, Oe = this.finishNode(qe, at ? "UpdateExpression" : "UnaryExpression");
          } else if (J || this.type !== ie.privateId) {
            if (Oe = this.parseExprSubscripts(x, ge), this.checkExpressionErrors(x))
              return Oe;
            for (; this.type.postfix && !this.canInsertSemicolon(); ) {
              var gt = this.startNodeAt(Le, Ue);
              gt.operator = this.value, gt.prefix = !1, gt.argument = Oe, this.checkLValSimple(Oe), this.next(), Oe = this.finishNode(gt, "UpdateExpression");
            }
          } else
            (ge || this.privateNameStack.length === 0) && this.options.checkPrivateFields && this.unexpected(), Oe = this.parsePrivateIdent(), this.type !== ie._in && this.unexpected();
          return he || !this.eat(ie.starstar) ? Oe : J ? void this.unexpected(this.lastTokStart) : this.buildBinary(Le, Ue, Oe, this.parseMaybeUnary(null, !1, !1, ge), "**", !1);
        }, rt.parseExprSubscripts = function(x, J) {
          var he = this.start, ge = this.startLoc, Oe = this.parseExprAtom(x, J);
          if (Oe.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
            return Oe;
          var Le = this.parseSubscripts(Oe, he, ge, !1, J);
          return x && Le.type === "MemberExpression" && (x.parenthesizedAssign >= Le.start && (x.parenthesizedAssign = -1), x.parenthesizedBind >= Le.start && (x.parenthesizedBind = -1), x.trailingComma >= Le.start && (x.trailingComma = -1)), Le;
        }, rt.parseSubscripts = function(x, J, he, ge, Oe) {
          for (var Le = this.options.ecmaVersion >= 8 && x.type === "Identifier" && x.name === "async" && this.lastTokEnd === x.end && !this.canInsertSemicolon() && x.end - x.start == 5 && this.potentialArrowAt === x.start, Ue = !1; ; ) {
            var qe = this.parseSubscript(x, J, he, ge, Le, Ue, Oe);
            if (qe.optional && (Ue = !0), qe === x || qe.type === "ArrowFunctionExpression") {
              if (Ue) {
                var at = this.startNodeAt(J, he);
                at.expression = qe, qe = this.finishNode(at, "ChainExpression");
              }
              return qe;
            }
            x = qe;
          }
        }, rt.shouldParseAsyncArrow = function() {
          return !this.canInsertSemicolon() && this.eat(ie.arrow);
        }, rt.parseSubscriptAsyncArrow = function(x, J, he, ge) {
          return this.parseArrowExpression(this.startNodeAt(x, J), he, !0, ge);
        }, rt.parseSubscript = function(x, J, he, ge, Oe, Le, Ue) {
          var qe = this.options.ecmaVersion >= 11, at = qe && this.eat(ie.questionDot);
          ge && at && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
          var gt = this.eat(ie.bracketL);
          if (gt || at && this.type !== ie.parenL && this.type !== ie.backQuote || this.eat(ie.dot)) {
            var ot = this.startNodeAt(J, he);
            ot.object = x, gt ? (ot.property = this.parseExpression(), this.expect(ie.bracketR)) : this.type === ie.privateId && x.type !== "Super" ? ot.property = this.parsePrivateIdent() : ot.property = this.parseIdent(this.options.allowReserved !== "never"), ot.computed = !!gt, qe && (ot.optional = at), x = this.finishNode(ot, "MemberExpression");
          } else if (!ge && this.eat(ie.parenL)) {
            var Lt = new nt(), Ft = this.yieldPos, ar = this.awaitPos, Er = this.awaitIdentPos;
            this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
            var Qr = this.parseExprList(ie.parenR, this.options.ecmaVersion >= 8, !1, Lt);
            if (Oe && !at && this.shouldParseAsyncArrow())
              return this.checkPatternErrors(Lt, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = Ft, this.awaitPos = ar, this.awaitIdentPos = Er, this.parseSubscriptAsyncArrow(J, he, Qr, Ue);
            this.checkExpressionErrors(Lt, !0), this.yieldPos = Ft || this.yieldPos, this.awaitPos = ar || this.awaitPos, this.awaitIdentPos = Er || this.awaitIdentPos;
            var gn = this.startNodeAt(J, he);
            gn.callee = x, gn.arguments = Qr, qe && (gn.optional = at), x = this.finishNode(gn, "CallExpression");
          } else if (this.type === ie.backQuote) {
            (at || Le) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
            var Nr = this.startNodeAt(J, he);
            Nr.tag = x, Nr.quasi = this.parseTemplate({ isTagged: !0 }), x = this.finishNode(Nr, "TaggedTemplateExpression");
          }
          return x;
        }, rt.parseExprAtom = function(x, J, he) {
          this.type === ie.slash && this.readRegexp();
          var ge, Oe = this.potentialArrowAt === this.start;
          switch (this.type) {
            case ie._super:
              return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), ge = this.startNode(), this.next(), this.type !== ie.parenL || this.allowDirectSuper || this.raise(ge.start, "super() call outside constructor of a subclass"), this.type !== ie.dot && this.type !== ie.bracketL && this.type !== ie.parenL && this.unexpected(), this.finishNode(ge, "Super");
            case ie._this:
              return ge = this.startNode(), this.next(), this.finishNode(ge, "ThisExpression");
            case ie.name:
              var Le = this.start, Ue = this.startLoc, qe = this.containsEsc, at = this.parseIdent(!1);
              if (this.options.ecmaVersion >= 8 && !qe && at.name === "async" && !this.canInsertSemicolon() && this.eat(ie._function))
                return this.overrideContext(Je.f_expr), this.parseFunction(this.startNodeAt(Le, Ue), 0, !1, !0, J);
              if (Oe && !this.canInsertSemicolon()) {
                if (this.eat(ie.arrow))
                  return this.parseArrowExpression(this.startNodeAt(Le, Ue), [at], !1, J);
                if (this.options.ecmaVersion >= 8 && at.name === "async" && this.type === ie.name && !qe && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc))
                  return at = this.parseIdent(!1), !this.canInsertSemicolon() && this.eat(ie.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(Le, Ue), [at], !0, J);
              }
              return at;
            case ie.regexp:
              var gt = this.value;
              return (ge = this.parseLiteral(gt.value)).regex = { pattern: gt.pattern, flags: gt.flags }, ge;
            case ie.num:
            case ie.string:
              return this.parseLiteral(this.value);
            case ie._null:
            case ie._true:
            case ie._false:
              return (ge = this.startNode()).value = this.type === ie._null ? null : this.type === ie._true, ge.raw = this.type.keyword, this.next(), this.finishNode(ge, "Literal");
            case ie.parenL:
              var ot = this.start, Lt = this.parseParenAndDistinguishExpression(Oe, J);
              return x && (x.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(Lt) && (x.parenthesizedAssign = ot), x.parenthesizedBind < 0 && (x.parenthesizedBind = ot)), Lt;
            case ie.bracketL:
              return ge = this.startNode(), this.next(), ge.elements = this.parseExprList(ie.bracketR, !0, !0, x), this.finishNode(ge, "ArrayExpression");
            case ie.braceL:
              return this.overrideContext(Je.b_expr), this.parseObj(!1, x);
            case ie._function:
              return ge = this.startNode(), this.next(), this.parseFunction(ge, 0);
            case ie._class:
              return this.parseClass(this.startNode(), !1);
            case ie._new:
              return this.parseNew();
            case ie.backQuote:
              return this.parseTemplate();
            case ie._import:
              return this.options.ecmaVersion >= 11 ? this.parseExprImport(he) : this.unexpected();
            default:
              return this.parseExprAtomDefault();
          }
        }, rt.parseExprAtomDefault = function() {
          this.unexpected();
        }, rt.parseExprImport = function(x) {
          var J = this.startNode();
          this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import");
          var he = this.parseIdent(!0);
          return this.type !== ie.parenL || x ? this.type === ie.dot ? (J.meta = he, this.parseImportMeta(J)) : void this.unexpected() : this.parseDynamicImport(J);
        }, rt.parseDynamicImport = function(x) {
          if (this.next(), x.source = this.parseMaybeAssign(), !this.eat(ie.parenR)) {
            var J = this.start;
            this.eat(ie.comma) && this.eat(ie.parenR) ? this.raiseRecoverable(J, "Trailing comma is not allowed in import()") : this.unexpected(J);
          }
          return this.finishNode(x, "ImportExpression");
        }, rt.parseImportMeta = function(x) {
          this.next();
          var J = this.containsEsc;
          return x.property = this.parseIdent(!0), x.property.name !== "meta" && this.raiseRecoverable(x.property.start, "The only valid meta property for import is 'import.meta'"), J && this.raiseRecoverable(x.start, "'import.meta' must not contain escaped characters"), this.options.sourceType === "module" || this.options.allowImportExportEverywhere || this.raiseRecoverable(x.start, "Cannot use 'import.meta' outside a module"), this.finishNode(x, "MetaProperty");
        }, rt.parseLiteral = function(x) {
          var J = this.startNode();
          return J.value = x, J.raw = this.input.slice(this.start, this.end), J.raw.charCodeAt(J.raw.length - 1) === 110 && (J.bigint = J.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(J, "Literal");
        }, rt.parseParenExpression = function() {
          this.expect(ie.parenL);
          var x = this.parseExpression();
          return this.expect(ie.parenR), x;
        }, rt.shouldParseArrow = function(x) {
          return !this.canInsertSemicolon();
        }, rt.parseParenAndDistinguishExpression = function(x, J) {
          var he, ge = this.start, Oe = this.startLoc, Le = this.options.ecmaVersion >= 8;
          if (this.options.ecmaVersion >= 6) {
            this.next();
            var Ue, qe = this.start, at = this.startLoc, gt = [], ot = !0, Lt = !1, Ft = new nt(), ar = this.yieldPos, Er = this.awaitPos;
            for (this.yieldPos = 0, this.awaitPos = 0; this.type !== ie.parenR; ) {
              if (ot ? ot = !1 : this.expect(ie.comma), Le && this.afterTrailingComma(ie.parenR, !0)) {
                Lt = !0;
                break;
              }
              if (this.type === ie.ellipsis) {
                Ue = this.start, gt.push(this.parseParenItem(this.parseRestBinding())), this.type === ie.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
                break;
              }
              gt.push(this.parseMaybeAssign(!1, Ft, this.parseParenItem));
            }
            var Qr = this.lastTokEnd, gn = this.lastTokEndLoc;
            if (this.expect(ie.parenR), x && this.shouldParseArrow(gt) && this.eat(ie.arrow))
              return this.checkPatternErrors(Ft, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = ar, this.awaitPos = Er, this.parseParenArrowList(ge, Oe, gt, J);
            gt.length && !Lt || this.unexpected(this.lastTokStart), Ue && this.unexpected(Ue), this.checkExpressionErrors(Ft, !0), this.yieldPos = ar || this.yieldPos, this.awaitPos = Er || this.awaitPos, gt.length > 1 ? ((he = this.startNodeAt(qe, at)).expressions = gt, this.finishNodeAt(he, "SequenceExpression", Qr, gn)) : he = gt[0];
          } else
            he = this.parseParenExpression();
          if (this.options.preserveParens) {
            var Nr = this.startNodeAt(ge, Oe);
            return Nr.expression = he, this.finishNode(Nr, "ParenthesizedExpression");
          }
          return he;
        }, rt.parseParenItem = function(x) {
          return x;
        }, rt.parseParenArrowList = function(x, J, he, ge) {
          return this.parseArrowExpression(this.startNodeAt(x, J), he, !1, ge);
        };
        var Nt = [];
        rt.parseNew = function() {
          this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
          var x = this.startNode(), J = this.parseIdent(!0);
          if (this.options.ecmaVersion >= 6 && this.eat(ie.dot)) {
            x.meta = J;
            var he = this.containsEsc;
            return x.property = this.parseIdent(!0), x.property.name !== "target" && this.raiseRecoverable(x.property.start, "The only valid meta property for new is 'new.target'"), he && this.raiseRecoverable(x.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(x.start, "'new.target' can only be used in functions and class static block"), this.finishNode(x, "MetaProperty");
          }
          var ge = this.start, Oe = this.startLoc;
          return x.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), ge, Oe, !0, !1), this.eat(ie.parenL) ? x.arguments = this.parseExprList(ie.parenR, this.options.ecmaVersion >= 8, !1) : x.arguments = Nt, this.finishNode(x, "NewExpression");
        }, rt.parseTemplateElement = function(x) {
          var J = x.isTagged, he = this.startNode();
          return this.type === ie.invalidTemplate ? (J || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), he.value = { raw: this.value, cooked: null }) : he.value = { raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`), cooked: this.value }, this.next(), he.tail = this.type === ie.backQuote, this.finishNode(he, "TemplateElement");
        }, rt.parseTemplate = function(x) {
          x === void 0 && (x = {});
          var J = x.isTagged;
          J === void 0 && (J = !1);
          var he = this.startNode();
          this.next(), he.expressions = [];
          var ge = this.parseTemplateElement({ isTagged: J });
          for (he.quasis = [ge]; !ge.tail; )
            this.type === ie.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(ie.dollarBraceL), he.expressions.push(this.parseExpression()), this.expect(ie.braceR), he.quasis.push(ge = this.parseTemplateElement({ isTagged: J }));
          return this.next(), this.finishNode(he, "TemplateLiteral");
        }, rt.isAsyncProp = function(x) {
          return !x.computed && x.key.type === "Identifier" && x.key.name === "async" && (this.type === ie.name || this.type === ie.num || this.type === ie.string || this.type === ie.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === ie.star) && !we.test(this.input.slice(this.lastTokEnd, this.start));
        }, rt.parseObj = function(x, J) {
          var he = this.startNode(), ge = !0, Oe = {};
          for (he.properties = [], this.next(); !this.eat(ie.braceR); ) {
            if (ge)
              ge = !1;
            else if (this.expect(ie.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(ie.braceR))
              break;
            var Le = this.parseProperty(x, J);
            x || this.checkPropClash(Le, Oe, J), he.properties.push(Le);
          }
          return this.finishNode(he, x ? "ObjectPattern" : "ObjectExpression");
        }, rt.parseProperty = function(x, J) {
          var he, ge, Oe, Le, Ue = this.startNode();
          if (this.options.ecmaVersion >= 9 && this.eat(ie.ellipsis))
            return x ? (Ue.argument = this.parseIdent(!1), this.type === ie.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(Ue, "RestElement")) : (Ue.argument = this.parseMaybeAssign(!1, J), this.type === ie.comma && J && J.trailingComma < 0 && (J.trailingComma = this.start), this.finishNode(Ue, "SpreadElement"));
          this.options.ecmaVersion >= 6 && (Ue.method = !1, Ue.shorthand = !1, (x || J) && (Oe = this.start, Le = this.startLoc), x || (he = this.eat(ie.star)));
          var qe = this.containsEsc;
          return this.parsePropertyName(Ue), !x && !qe && this.options.ecmaVersion >= 8 && !he && this.isAsyncProp(Ue) ? (ge = !0, he = this.options.ecmaVersion >= 9 && this.eat(ie.star), this.parsePropertyName(Ue)) : ge = !1, this.parsePropertyValue(Ue, x, he, ge, Oe, Le, J, qe), this.finishNode(Ue, "Property");
        }, rt.parseGetterSetter = function(x) {
          x.kind = x.key.name, this.parsePropertyName(x), x.value = this.parseMethod(!1);
          var J = x.kind === "get" ? 0 : 1;
          if (x.value.params.length !== J) {
            var he = x.value.start;
            x.kind === "get" ? this.raiseRecoverable(he, "getter should have no params") : this.raiseRecoverable(he, "setter should have exactly one param");
          } else
            x.kind === "set" && x.value.params[0].type === "RestElement" && this.raiseRecoverable(x.value.params[0].start, "Setter cannot use rest params");
        }, rt.parsePropertyValue = function(x, J, he, ge, Oe, Le, Ue, qe) {
          (he || ge) && this.type === ie.colon && this.unexpected(), this.eat(ie.colon) ? (x.value = J ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, Ue), x.kind = "init") : this.options.ecmaVersion >= 6 && this.type === ie.parenL ? (J && this.unexpected(), x.kind = "init", x.method = !0, x.value = this.parseMethod(he, ge)) : J || qe || !(this.options.ecmaVersion >= 5) || x.computed || x.key.type !== "Identifier" || x.key.name !== "get" && x.key.name !== "set" || this.type === ie.comma || this.type === ie.braceR || this.type === ie.eq ? this.options.ecmaVersion >= 6 && !x.computed && x.key.type === "Identifier" ? ((he || ge) && this.unexpected(), this.checkUnreserved(x.key), x.key.name !== "await" || this.awaitIdentPos || (this.awaitIdentPos = Oe), x.kind = "init", J ? x.value = this.parseMaybeDefault(Oe, Le, this.copyNode(x.key)) : this.type === ie.eq && Ue ? (Ue.shorthandAssign < 0 && (Ue.shorthandAssign = this.start), x.value = this.parseMaybeDefault(Oe, Le, this.copyNode(x.key))) : x.value = this.copyNode(x.key), x.shorthand = !0) : this.unexpected() : ((he || ge) && this.unexpected(), this.parseGetterSetter(x));
        }, rt.parsePropertyName = function(x) {
          if (this.options.ecmaVersion >= 6) {
            if (this.eat(ie.bracketL))
              return x.computed = !0, x.key = this.parseMaybeAssign(), this.expect(ie.bracketR), x.key;
            x.computed = !1;
          }
          return x.key = this.type === ie.num || this.type === ie.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
        }, rt.initFunction = function(x) {
          x.id = null, this.options.ecmaVersion >= 6 && (x.generator = x.expression = !1), this.options.ecmaVersion >= 8 && (x.async = !1);
        }, rt.parseMethod = function(x, J, he) {
          var ge = this.startNode(), Oe = this.yieldPos, Le = this.awaitPos, Ue = this.awaitIdentPos;
          return this.initFunction(ge), this.options.ecmaVersion >= 6 && (ge.generator = x), this.options.ecmaVersion >= 8 && (ge.async = !!J), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(64 | Ce(J, ge.generator) | (he ? 128 : 0)), this.expect(ie.parenL), ge.params = this.parseBindingList(ie.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(ge, !1, !0, !1), this.yieldPos = Oe, this.awaitPos = Le, this.awaitIdentPos = Ue, this.finishNode(ge, "FunctionExpression");
        }, rt.parseArrowExpression = function(x, J, he, ge) {
          var Oe = this.yieldPos, Le = this.awaitPos, Ue = this.awaitIdentPos;
          return this.enterScope(16 | Ce(he, !1)), this.initFunction(x), this.options.ecmaVersion >= 8 && (x.async = !!he), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, x.params = this.toAssignableList(J, !0), this.parseFunctionBody(x, !0, !1, ge), this.yieldPos = Oe, this.awaitPos = Le, this.awaitIdentPos = Ue, this.finishNode(x, "ArrowFunctionExpression");
        }, rt.parseFunctionBody = function(x, J, he, ge) {
          var Oe = J && this.type !== ie.braceL, Le = this.strict, Ue = !1;
          if (Oe)
            x.body = this.parseMaybeAssign(ge), x.expression = !0, this.checkParams(x, !1);
          else {
            var qe = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(x.params);
            Le && !qe || (Ue = this.strictDirective(this.end)) && qe && this.raiseRecoverable(x.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            var at = this.labels;
            this.labels = [], Ue && (this.strict = !0), this.checkParams(x, !Le && !Ue && !J && !he && this.isSimpleParamList(x.params)), this.strict && x.id && this.checkLValSimple(x.id, 5), x.body = this.parseBlock(!1, void 0, Ue && !Le), x.expression = !1, this.adaptDirectivePrologue(x.body.body), this.labels = at;
          }
          this.exitScope();
        }, rt.isSimpleParamList = function(x) {
          for (var J = 0, he = x; J < he.length; J += 1)
            if (he[J].type !== "Identifier")
              return !1;
          return !0;
        }, rt.checkParams = function(x, J) {
          for (var he = /* @__PURE__ */ Object.create(null), ge = 0, Oe = x.params; ge < Oe.length; ge += 1) {
            var Le = Oe[ge];
            this.checkLValInnerPattern(Le, 1, J ? null : he);
          }
        }, rt.parseExprList = function(x, J, he, ge) {
          for (var Oe = [], Le = !0; !this.eat(x); ) {
            if (Le)
              Le = !1;
            else if (this.expect(ie.comma), J && this.afterTrailingComma(x))
              break;
            var Ue = void 0;
            he && this.type === ie.comma ? Ue = null : this.type === ie.ellipsis ? (Ue = this.parseSpread(ge), ge && this.type === ie.comma && ge.trailingComma < 0 && (ge.trailingComma = this.start)) : Ue = this.parseMaybeAssign(!1, ge), Oe.push(Ue);
          }
          return Oe;
        }, rt.checkUnreserved = function(x) {
          var J = x.start, he = x.end, ge = x.name;
          this.inGenerator && ge === "yield" && this.raiseRecoverable(J, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && ge === "await" && this.raiseRecoverable(J, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().inClassFieldInit && ge === "arguments" && this.raiseRecoverable(J, "Cannot use 'arguments' in class field initializer"), !this.inClassStaticBlock || ge !== "arguments" && ge !== "await" || this.raise(J, "Cannot use " + ge + " in class static initialization block"), this.keywords.test(ge) && this.raise(J, "Unexpected keyword '" + ge + "'"), this.options.ecmaVersion < 6 && this.input.slice(J, he).indexOf("\\") !== -1 || (this.strict ? this.reservedWordsStrict : this.reservedWords).test(ge) && (this.inAsync || ge !== "await" || this.raiseRecoverable(J, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(J, "The keyword '" + ge + "' is reserved"));
        }, rt.parseIdent = function(x) {
          var J = this.parseIdentNode();
          return this.next(!!x), this.finishNode(J, "Identifier"), x || (this.checkUnreserved(J), J.name !== "await" || this.awaitIdentPos || (this.awaitIdentPos = J.start)), J;
        }, rt.parseIdentNode = function() {
          var x = this.startNode();
          return this.type === ie.name ? x.name = this.value : this.type.keyword ? (x.name = this.type.keyword, x.name !== "class" && x.name !== "function" || this.lastTokEnd === this.lastTokStart + 1 && this.input.charCodeAt(this.lastTokStart) === 46 || this.context.pop()) : this.unexpected(), x;
        }, rt.parsePrivateIdent = function() {
          var x = this.startNode();
          return this.type === ie.privateId ? x.name = this.value : this.unexpected(), this.next(), this.finishNode(x, "PrivateIdentifier"), this.options.checkPrivateFields && (this.privateNameStack.length === 0 ? this.raise(x.start, "Private field '#" + x.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(x)), x;
        }, rt.parseYield = function(x) {
          this.yieldPos || (this.yieldPos = this.start);
          var J = this.startNode();
          return this.next(), this.type === ie.semi || this.canInsertSemicolon() || this.type !== ie.star && !this.type.startsExpr ? (J.delegate = !1, J.argument = null) : (J.delegate = this.eat(ie.star), J.argument = this.parseMaybeAssign(x)), this.finishNode(J, "YieldExpression");
        }, rt.parseAwait = function(x) {
          this.awaitPos || (this.awaitPos = this.start);
          var J = this.startNode();
          return this.next(), J.argument = this.parseMaybeUnary(null, !0, !1, x), this.finishNode(J, "AwaitExpression");
        };
        var Tt = xe.prototype;
        Tt.raise = function(x, J) {
          var he = ct(this.input, x);
          J += " (" + he.line + ":" + he.column + ")";
          var ge = new SyntaxError(J);
          throw ge.pos = x, ge.loc = he, ge.raisedAt = this.pos, ge;
        }, Tt.raiseRecoverable = Tt.raise, Tt.curPosition = function() {
          if (this.options.locations)
            return new Ye(this.curLine, this.pos - this.lineStart);
        };
        var Ot = xe.prototype, cr = function(x) {
          this.flags = x, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = !1;
        };
        Ot.enterScope = function(x) {
          this.scopeStack.push(new cr(x));
        }, Ot.exitScope = function() {
          this.scopeStack.pop();
        }, Ot.treatFunctionsAsVarInScope = function(x) {
          return 2 & x.flags || !this.inModule && 1 & x.flags;
        }, Ot.declareName = function(x, J, he) {
          var ge = !1;
          if (J === 2) {
            var Oe = this.currentScope();
            ge = Oe.lexical.indexOf(x) > -1 || Oe.functions.indexOf(x) > -1 || Oe.var.indexOf(x) > -1, Oe.lexical.push(x), this.inModule && 1 & Oe.flags && delete this.undefinedExports[x];
          } else if (J === 4)
            this.currentScope().lexical.push(x);
          else if (J === 3) {
            var Le = this.currentScope();
            ge = this.treatFunctionsAsVar ? Le.lexical.indexOf(x) > -1 : Le.lexical.indexOf(x) > -1 || Le.var.indexOf(x) > -1, Le.functions.push(x);
          } else
            for (var Ue = this.scopeStack.length - 1; Ue >= 0; --Ue) {
              var qe = this.scopeStack[Ue];
              if (qe.lexical.indexOf(x) > -1 && !(32 & qe.flags && qe.lexical[0] === x) || !this.treatFunctionsAsVarInScope(qe) && qe.functions.indexOf(x) > -1) {
                ge = !0;
                break;
              }
              if (qe.var.push(x), this.inModule && 1 & qe.flags && delete this.undefinedExports[x], 259 & qe.flags)
                break;
            }
          ge && this.raiseRecoverable(he, "Identifier '" + x + "' has already been declared");
        }, Ot.checkLocalExport = function(x) {
          this.scopeStack[0].lexical.indexOf(x.name) === -1 && this.scopeStack[0].var.indexOf(x.name) === -1 && (this.undefinedExports[x.name] = x);
        }, Ot.currentScope = function() {
          return this.scopeStack[this.scopeStack.length - 1];
        }, Ot.currentVarScope = function() {
          for (var x = this.scopeStack.length - 1; ; x--) {
            var J = this.scopeStack[x];
            if (259 & J.flags)
              return J;
          }
        }, Ot.currentThisScope = function() {
          for (var x = this.scopeStack.length - 1; ; x--) {
            var J = this.scopeStack[x];
            if (259 & J.flags && !(16 & J.flags))
              return J;
          }
        };
        var Wt = function(x, J, he) {
          this.type = "", this.start = J, this.end = 0, x.options.locations && (this.loc = new ht(x, he)), x.options.directSourceFile && (this.sourceFile = x.options.directSourceFile), x.options.ranges && (this.range = [J, 0]);
        }, Jt = xe.prototype;
        function pr(x, J, he, ge) {
          return x.type = J, x.end = he, this.options.locations && (x.loc.end = ge), this.options.ranges && (x.range[1] = he), x;
        }
        Jt.startNode = function() {
          return new Wt(this, this.start, this.startLoc);
        }, Jt.startNodeAt = function(x, J) {
          return new Wt(this, x, J);
        }, Jt.finishNode = function(x, J) {
          return pr.call(this, x, J, this.lastTokEnd, this.lastTokEndLoc);
        }, Jt.finishNodeAt = function(x, J, he, ge) {
          return pr.call(this, x, J, he, ge);
        }, Jt.copyNode = function(x) {
          var J = new Wt(this, x.start, this.startLoc);
          for (var he in x)
            J[he] = x[he];
          return J;
        };
        var $r = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", Ur = $r + " Extended_Pictographic", _r = Ur + " EBase EComp EMod EPres ExtPict", qn = { 9: $r, 10: Ur, 11: Ur, 12: _r, 13: _r, 14: _r }, Mn = { 9: "", 10: "", 11: "", 12: "", 13: "", 14: "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji" }, Ln = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", mn = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", jn = mn + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", yn = jn + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", bn = yn + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", En = bn + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", Vr = { 9: mn, 10: jn, 11: yn, 12: bn, 13: En, 14: En + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz" }, zi = {};
        function As(x) {
          var J = zi[x] = { binary: Ie(qn[x] + " " + Ln), binaryOfStrings: Ie(Mn[x]), nonBinary: { General_Category: Ie(Ln), Script: Ie(Vr[x]) } };
          J.nonBinary.Script_Extensions = J.nonBinary.Script, J.nonBinary.gc = J.nonBinary.General_Category, J.nonBinary.sc = J.nonBinary.Script, J.nonBinary.scx = J.nonBinary.Script_Extensions;
        }
        for (var ga = 0, Rt = [9, 10, 11, 12, 13, 14]; ga < Rt.length; ga += 1)
          As(Rt[ga]);
        var Pt = xe.prototype, ni = function(x) {
          this.parser = x, this.validFlags = "gim" + (x.options.ecmaVersion >= 6 ? "uy" : "") + (x.options.ecmaVersion >= 9 ? "s" : "") + (x.options.ecmaVersion >= 13 ? "d" : "") + (x.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = zi[x.options.ecmaVersion >= 14 ? 14 : x.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchV = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
        };
        function sc(x) {
          return x === 36 || x >= 40 && x <= 43 || x === 46 || x === 63 || x >= 91 && x <= 94 || x >= 123 && x <= 125;
        }
        function ac(x) {
          return x >= 65 && x <= 90 || x >= 97 && x <= 122;
        }
        ni.prototype.reset = function(x, J, he) {
          var ge = he.indexOf("v") !== -1, Oe = he.indexOf("u") !== -1;
          this.start = 0 | x, this.source = J + "", this.flags = he, ge && this.parser.options.ecmaVersion >= 15 ? (this.switchU = !0, this.switchV = !0, this.switchN = !0) : (this.switchU = Oe && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN = Oe && this.parser.options.ecmaVersion >= 9);
        }, ni.prototype.raise = function(x) {
          this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + x);
        }, ni.prototype.at = function(x, J) {
          J === void 0 && (J = !1);
          var he = this.source, ge = he.length;
          if (x >= ge)
            return -1;
          var Oe = he.charCodeAt(x);
          if (!J && !this.switchU || Oe <= 55295 || Oe >= 57344 || x + 1 >= ge)
            return Oe;
          var Le = he.charCodeAt(x + 1);
          return Le >= 56320 && Le <= 57343 ? (Oe << 10) + Le - 56613888 : Oe;
        }, ni.prototype.nextIndex = function(x, J) {
          J === void 0 && (J = !1);
          var he = this.source, ge = he.length;
          if (x >= ge)
            return ge;
          var Oe, Le = he.charCodeAt(x);
          return !J && !this.switchU || Le <= 55295 || Le >= 57344 || x + 1 >= ge || (Oe = he.charCodeAt(x + 1)) < 56320 || Oe > 57343 ? x + 1 : x + 2;
        }, ni.prototype.current = function(x) {
          return x === void 0 && (x = !1), this.at(this.pos, x);
        }, ni.prototype.lookahead = function(x) {
          return x === void 0 && (x = !1), this.at(this.nextIndex(this.pos, x), x);
        }, ni.prototype.advance = function(x) {
          x === void 0 && (x = !1), this.pos = this.nextIndex(this.pos, x);
        }, ni.prototype.eat = function(x, J) {
          return J === void 0 && (J = !1), this.current(J) === x && (this.advance(J), !0);
        }, ni.prototype.eatChars = function(x, J) {
          J === void 0 && (J = !1);
          for (var he = this.pos, ge = 0, Oe = x; ge < Oe.length; ge += 1) {
            var Le = Oe[ge], Ue = this.at(he, J);
            if (Ue === -1 || Ue !== Le)
              return !1;
            he = this.nextIndex(he, J);
          }
          return this.pos = he, !0;
        }, Pt.validateRegExpFlags = function(x) {
          for (var J = x.validFlags, he = x.flags, ge = !1, Oe = !1, Le = 0; Le < he.length; Le++) {
            var Ue = he.charAt(Le);
            J.indexOf(Ue) === -1 && this.raise(x.start, "Invalid regular expression flag"), he.indexOf(Ue, Le + 1) > -1 && this.raise(x.start, "Duplicate regular expression flag"), Ue === "u" && (ge = !0), Ue === "v" && (Oe = !0);
          }
          this.options.ecmaVersion >= 15 && ge && Oe && this.raise(x.start, "Invalid regular expression flag");
        }, Pt.validateRegExpPattern = function(x) {
          this.regexp_pattern(x), !x.switchN && this.options.ecmaVersion >= 9 && x.groupNames.length > 0 && (x.switchN = !0, this.regexp_pattern(x));
        }, Pt.regexp_pattern = function(x) {
          x.pos = 0, x.lastIntValue = 0, x.lastStringValue = "", x.lastAssertionIsQuantifiable = !1, x.numCapturingParens = 0, x.maxBackReference = 0, x.groupNames.length = 0, x.backReferenceNames.length = 0, this.regexp_disjunction(x), x.pos !== x.source.length && (x.eat(41) && x.raise("Unmatched ')'"), (x.eat(93) || x.eat(125)) && x.raise("Lone quantifier brackets")), x.maxBackReference > x.numCapturingParens && x.raise("Invalid escape");
          for (var J = 0, he = x.backReferenceNames; J < he.length; J += 1) {
            var ge = he[J];
            x.groupNames.indexOf(ge) === -1 && x.raise("Invalid named capture referenced");
          }
        }, Pt.regexp_disjunction = function(x) {
          for (this.regexp_alternative(x); x.eat(124); )
            this.regexp_alternative(x);
          this.regexp_eatQuantifier(x, !0) && x.raise("Nothing to repeat"), x.eat(123) && x.raise("Lone quantifier brackets");
        }, Pt.regexp_alternative = function(x) {
          for (; x.pos < x.source.length && this.regexp_eatTerm(x); )
            ;
        }, Pt.regexp_eatTerm = function(x) {
          return this.regexp_eatAssertion(x) ? (x.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(x) && x.switchU && x.raise("Invalid quantifier"), !0) : !!(x.switchU ? this.regexp_eatAtom(x) : this.regexp_eatExtendedAtom(x)) && (this.regexp_eatQuantifier(x), !0);
        }, Pt.regexp_eatAssertion = function(x) {
          var J = x.pos;
          if (x.lastAssertionIsQuantifiable = !1, x.eat(94) || x.eat(36))
            return !0;
          if (x.eat(92)) {
            if (x.eat(66) || x.eat(98))
              return !0;
            x.pos = J;
          }
          if (x.eat(40) && x.eat(63)) {
            var he = !1;
            if (this.options.ecmaVersion >= 9 && (he = x.eat(60)), x.eat(61) || x.eat(33))
              return this.regexp_disjunction(x), x.eat(41) || x.raise("Unterminated group"), x.lastAssertionIsQuantifiable = !he, !0;
          }
          return x.pos = J, !1;
        }, Pt.regexp_eatQuantifier = function(x, J) {
          return J === void 0 && (J = !1), !!this.regexp_eatQuantifierPrefix(x, J) && (x.eat(63), !0);
        }, Pt.regexp_eatQuantifierPrefix = function(x, J) {
          return x.eat(42) || x.eat(43) || x.eat(63) || this.regexp_eatBracedQuantifier(x, J);
        }, Pt.regexp_eatBracedQuantifier = function(x, J) {
          var he = x.pos;
          if (x.eat(123)) {
            var ge = 0, Oe = -1;
            if (this.regexp_eatDecimalDigits(x) && (ge = x.lastIntValue, x.eat(44) && this.regexp_eatDecimalDigits(x) && (Oe = x.lastIntValue), x.eat(125)))
              return Oe !== -1 && Oe < ge && !J && x.raise("numbers out of order in {} quantifier"), !0;
            x.switchU && !J && x.raise("Incomplete quantifier"), x.pos = he;
          }
          return !1;
        }, Pt.regexp_eatAtom = function(x) {
          return this.regexp_eatPatternCharacters(x) || x.eat(46) || this.regexp_eatReverseSolidusAtomEscape(x) || this.regexp_eatCharacterClass(x) || this.regexp_eatUncapturingGroup(x) || this.regexp_eatCapturingGroup(x);
        }, Pt.regexp_eatReverseSolidusAtomEscape = function(x) {
          var J = x.pos;
          if (x.eat(92)) {
            if (this.regexp_eatAtomEscape(x))
              return !0;
            x.pos = J;
          }
          return !1;
        }, Pt.regexp_eatUncapturingGroup = function(x) {
          var J = x.pos;
          if (x.eat(40)) {
            if (x.eat(63) && x.eat(58)) {
              if (this.regexp_disjunction(x), x.eat(41))
                return !0;
              x.raise("Unterminated group");
            }
            x.pos = J;
          }
          return !1;
        }, Pt.regexp_eatCapturingGroup = function(x) {
          if (x.eat(40)) {
            if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(x) : x.current() === 63 && x.raise("Invalid group"), this.regexp_disjunction(x), x.eat(41))
              return x.numCapturingParens += 1, !0;
            x.raise("Unterminated group");
          }
          return !1;
        }, Pt.regexp_eatExtendedAtom = function(x) {
          return x.eat(46) || this.regexp_eatReverseSolidusAtomEscape(x) || this.regexp_eatCharacterClass(x) || this.regexp_eatUncapturingGroup(x) || this.regexp_eatCapturingGroup(x) || this.regexp_eatInvalidBracedQuantifier(x) || this.regexp_eatExtendedPatternCharacter(x);
        }, Pt.regexp_eatInvalidBracedQuantifier = function(x) {
          return this.regexp_eatBracedQuantifier(x, !0) && x.raise("Nothing to repeat"), !1;
        }, Pt.regexp_eatSyntaxCharacter = function(x) {
          var J = x.current();
          return !!sc(J) && (x.lastIntValue = J, x.advance(), !0);
        }, Pt.regexp_eatPatternCharacters = function(x) {
          for (var J = x.pos, he = 0; (he = x.current()) !== -1 && !sc(he); )
            x.advance();
          return x.pos !== J;
        }, Pt.regexp_eatExtendedPatternCharacter = function(x) {
          var J = x.current();
          return !(J === -1 || J === 36 || J >= 40 && J <= 43 || J === 46 || J === 63 || J === 91 || J === 94 || J === 124) && (x.advance(), !0);
        }, Pt.regexp_groupSpecifier = function(x) {
          if (x.eat(63)) {
            if (this.regexp_eatGroupName(x))
              return x.groupNames.indexOf(x.lastStringValue) !== -1 && x.raise("Duplicate capture group name"), void x.groupNames.push(x.lastStringValue);
            x.raise("Invalid group");
          }
        }, Pt.regexp_eatGroupName = function(x) {
          if (x.lastStringValue = "", x.eat(60)) {
            if (this.regexp_eatRegExpIdentifierName(x) && x.eat(62))
              return !0;
            x.raise("Invalid capture group name");
          }
          return !1;
        }, Pt.regexp_eatRegExpIdentifierName = function(x) {
          if (x.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(x)) {
            for (x.lastStringValue += We(x.lastIntValue); this.regexp_eatRegExpIdentifierPart(x); )
              x.lastStringValue += We(x.lastIntValue);
            return !0;
          }
          return !1;
        }, Pt.regexp_eatRegExpIdentifierStart = function(x) {
          var J = x.pos, he = this.options.ecmaVersion >= 11, ge = x.current(he);
          return x.advance(he), ge === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(x, he) && (ge = x.lastIntValue), function(Oe) {
            return ye(Oe, !0) || Oe === 36 || Oe === 95;
          }(ge) ? (x.lastIntValue = ge, !0) : (x.pos = J, !1);
        }, Pt.regexp_eatRegExpIdentifierPart = function(x) {
          var J = x.pos, he = this.options.ecmaVersion >= 11, ge = x.current(he);
          return x.advance(he), ge === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(x, he) && (ge = x.lastIntValue), function(Oe) {
            return ve(Oe, !0) || Oe === 36 || Oe === 95 || Oe === 8204 || Oe === 8205;
          }(ge) ? (x.lastIntValue = ge, !0) : (x.pos = J, !1);
        }, Pt.regexp_eatAtomEscape = function(x) {
          return !!(this.regexp_eatBackReference(x) || this.regexp_eatCharacterClassEscape(x) || this.regexp_eatCharacterEscape(x) || x.switchN && this.regexp_eatKGroupName(x)) || (x.switchU && (x.current() === 99 && x.raise("Invalid unicode escape"), x.raise("Invalid escape")), !1);
        }, Pt.regexp_eatBackReference = function(x) {
          var J = x.pos;
          if (this.regexp_eatDecimalEscape(x)) {
            var he = x.lastIntValue;
            if (x.switchU)
              return he > x.maxBackReference && (x.maxBackReference = he), !0;
            if (he <= x.numCapturingParens)
              return !0;
            x.pos = J;
          }
          return !1;
        }, Pt.regexp_eatKGroupName = function(x) {
          if (x.eat(107)) {
            if (this.regexp_eatGroupName(x))
              return x.backReferenceNames.push(x.lastStringValue), !0;
            x.raise("Invalid named reference");
          }
          return !1;
        }, Pt.regexp_eatCharacterEscape = function(x) {
          return this.regexp_eatControlEscape(x) || this.regexp_eatCControlLetter(x) || this.regexp_eatZero(x) || this.regexp_eatHexEscapeSequence(x) || this.regexp_eatRegExpUnicodeEscapeSequence(x, !1) || !x.switchU && this.regexp_eatLegacyOctalEscapeSequence(x) || this.regexp_eatIdentityEscape(x);
        }, Pt.regexp_eatCControlLetter = function(x) {
          var J = x.pos;
          if (x.eat(99)) {
            if (this.regexp_eatControlLetter(x))
              return !0;
            x.pos = J;
          }
          return !1;
        }, Pt.regexp_eatZero = function(x) {
          return x.current() === 48 && !Ci(x.lookahead()) && (x.lastIntValue = 0, x.advance(), !0);
        }, Pt.regexp_eatControlEscape = function(x) {
          var J = x.current();
          return J === 116 ? (x.lastIntValue = 9, x.advance(), !0) : J === 110 ? (x.lastIntValue = 10, x.advance(), !0) : J === 118 ? (x.lastIntValue = 11, x.advance(), !0) : J === 102 ? (x.lastIntValue = 12, x.advance(), !0) : J === 114 && (x.lastIntValue = 13, x.advance(), !0);
        }, Pt.regexp_eatControlLetter = function(x) {
          var J = x.current();
          return !!ac(J) && (x.lastIntValue = J % 32, x.advance(), !0);
        }, Pt.regexp_eatRegExpUnicodeEscapeSequence = function(x, J) {
          J === void 0 && (J = !1);
          var he, ge = x.pos, Oe = J || x.switchU;
          if (x.eat(117)) {
            if (this.regexp_eatFixedHexDigits(x, 4)) {
              var Le = x.lastIntValue;
              if (Oe && Le >= 55296 && Le <= 56319) {
                var Ue = x.pos;
                if (x.eat(92) && x.eat(117) && this.regexp_eatFixedHexDigits(x, 4)) {
                  var qe = x.lastIntValue;
                  if (qe >= 56320 && qe <= 57343)
                    return x.lastIntValue = 1024 * (Le - 55296) + (qe - 56320) + 65536, !0;
                }
                x.pos = Ue, x.lastIntValue = Le;
              }
              return !0;
            }
            if (Oe && x.eat(123) && this.regexp_eatHexDigits(x) && x.eat(125) && (he = x.lastIntValue) >= 0 && he <= 1114111)
              return !0;
            Oe && x.raise("Invalid unicode escape"), x.pos = ge;
          }
          return !1;
        }, Pt.regexp_eatIdentityEscape = function(x) {
          if (x.switchU)
            return !!this.regexp_eatSyntaxCharacter(x) || !!x.eat(47) && (x.lastIntValue = 47, !0);
          var J = x.current();
          return !(J === 99 || x.switchN && J === 107) && (x.lastIntValue = J, x.advance(), !0);
        }, Pt.regexp_eatDecimalEscape = function(x) {
          x.lastIntValue = 0;
          var J = x.current();
          if (J >= 49 && J <= 57) {
            do
              x.lastIntValue = 10 * x.lastIntValue + (J - 48), x.advance();
            while ((J = x.current()) >= 48 && J <= 57);
            return !0;
          }
          return !1;
        };
        function Ki(x) {
          return ac(x) || x === 95;
        }
        function Yi(x) {
          return Ki(x) || Ci(x);
        }
        function Ci(x) {
          return x >= 48 && x <= 57;
        }
        function oc(x) {
          return x >= 48 && x <= 57 || x >= 65 && x <= 70 || x >= 97 && x <= 102;
        }
        function lc(x) {
          return x >= 65 && x <= 70 ? x - 65 + 10 : x >= 97 && x <= 102 ? x - 97 + 10 : x - 48;
        }
        function ml(x) {
          return x >= 48 && x <= 55;
        }
        Pt.regexp_eatCharacterClassEscape = function(x) {
          var J = x.current();
          if (function(Oe) {
            return Oe === 100 || Oe === 68 || Oe === 115 || Oe === 83 || Oe === 119 || Oe === 87;
          }(J))
            return x.lastIntValue = -1, x.advance(), 1;
          var he = !1;
          if (x.switchU && this.options.ecmaVersion >= 9 && ((he = J === 80) || J === 112)) {
            var ge;
            if (x.lastIntValue = -1, x.advance(), x.eat(123) && (ge = this.regexp_eatUnicodePropertyValueExpression(x)) && x.eat(125))
              return he && ge === 2 && x.raise("Invalid property name"), ge;
            x.raise("Invalid property name");
          }
          return 0;
        }, Pt.regexp_eatUnicodePropertyValueExpression = function(x) {
          var J = x.pos;
          if (this.regexp_eatUnicodePropertyName(x) && x.eat(61)) {
            var he = x.lastStringValue;
            if (this.regexp_eatUnicodePropertyValue(x)) {
              var ge = x.lastStringValue;
              return this.regexp_validateUnicodePropertyNameAndValue(x, he, ge), 1;
            }
          }
          if (x.pos = J, this.regexp_eatLoneUnicodePropertyNameOrValue(x)) {
            var Oe = x.lastStringValue;
            return this.regexp_validateUnicodePropertyNameOrValue(x, Oe);
          }
          return 0;
        }, Pt.regexp_validateUnicodePropertyNameAndValue = function(x, J, he) {
          be(x.unicodeProperties.nonBinary, J) || x.raise("Invalid property name"), x.unicodeProperties.nonBinary[J].test(he) || x.raise("Invalid property value");
        }, Pt.regexp_validateUnicodePropertyNameOrValue = function(x, J) {
          return x.unicodeProperties.binary.test(J) ? 1 : x.switchV && x.unicodeProperties.binaryOfStrings.test(J) ? 2 : void x.raise("Invalid property name");
        }, Pt.regexp_eatUnicodePropertyName = function(x) {
          var J = 0;
          for (x.lastStringValue = ""; Ki(J = x.current()); )
            x.lastStringValue += We(J), x.advance();
          return x.lastStringValue !== "";
        }, Pt.regexp_eatUnicodePropertyValue = function(x) {
          var J = 0;
          for (x.lastStringValue = ""; Yi(J = x.current()); )
            x.lastStringValue += We(J), x.advance();
          return x.lastStringValue !== "";
        }, Pt.regexp_eatLoneUnicodePropertyNameOrValue = function(x) {
          return this.regexp_eatUnicodePropertyValue(x);
        }, Pt.regexp_eatCharacterClass = function(x) {
          if (x.eat(91)) {
            var J = x.eat(94), he = this.regexp_classContents(x);
            return x.eat(93) || x.raise("Unterminated character class"), J && he === 2 && x.raise("Negated character class may contain strings"), !0;
          }
          return !1;
        }, Pt.regexp_classContents = function(x) {
          return x.current() === 93 ? 1 : x.switchV ? this.regexp_classSetExpression(x) : (this.regexp_nonEmptyClassRanges(x), 1);
        }, Pt.regexp_nonEmptyClassRanges = function(x) {
          for (; this.regexp_eatClassAtom(x); ) {
            var J = x.lastIntValue;
            if (x.eat(45) && this.regexp_eatClassAtom(x)) {
              var he = x.lastIntValue;
              !x.switchU || J !== -1 && he !== -1 || x.raise("Invalid character class"), J !== -1 && he !== -1 && J > he && x.raise("Range out of order in character class");
            }
          }
        }, Pt.regexp_eatClassAtom = function(x) {
          var J = x.pos;
          if (x.eat(92)) {
            if (this.regexp_eatClassEscape(x))
              return !0;
            if (x.switchU) {
              var he = x.current();
              (he === 99 || ml(he)) && x.raise("Invalid class escape"), x.raise("Invalid escape");
            }
            x.pos = J;
          }
          var ge = x.current();
          return ge !== 93 && (x.lastIntValue = ge, x.advance(), !0);
        }, Pt.regexp_eatClassEscape = function(x) {
          var J = x.pos;
          if (x.eat(98))
            return x.lastIntValue = 8, !0;
          if (x.switchU && x.eat(45))
            return x.lastIntValue = 45, !0;
          if (!x.switchU && x.eat(99)) {
            if (this.regexp_eatClassControlLetter(x))
              return !0;
            x.pos = J;
          }
          return this.regexp_eatCharacterClassEscape(x) || this.regexp_eatCharacterEscape(x);
        }, Pt.regexp_classSetExpression = function(x) {
          var J, he = 1;
          if (!this.regexp_eatClassSetRange(x))
            if (J = this.regexp_eatClassSetOperand(x)) {
              J === 2 && (he = 2);
              for (var ge = x.pos; x.eatChars([38, 38]); )
                x.current() !== 38 && (J = this.regexp_eatClassSetOperand(x)) ? J !== 2 && (he = 1) : x.raise("Invalid character in character class");
              if (ge !== x.pos)
                return he;
              for (; x.eatChars([45, 45]); )
                this.regexp_eatClassSetOperand(x) || x.raise("Invalid character in character class");
              if (ge !== x.pos)
                return he;
            } else
              x.raise("Invalid character in character class");
          for (; ; )
            if (!this.regexp_eatClassSetRange(x)) {
              if (!(J = this.regexp_eatClassSetOperand(x)))
                return he;
              J === 2 && (he = 2);
            }
        }, Pt.regexp_eatClassSetRange = function(x) {
          var J = x.pos;
          if (this.regexp_eatClassSetCharacter(x)) {
            var he = x.lastIntValue;
            if (x.eat(45) && this.regexp_eatClassSetCharacter(x)) {
              var ge = x.lastIntValue;
              return he !== -1 && ge !== -1 && he > ge && x.raise("Range out of order in character class"), !0;
            }
            x.pos = J;
          }
          return !1;
        }, Pt.regexp_eatClassSetOperand = function(x) {
          return this.regexp_eatClassSetCharacter(x) ? 1 : this.regexp_eatClassStringDisjunction(x) || this.regexp_eatNestedClass(x);
        }, Pt.regexp_eatNestedClass = function(x) {
          var J = x.pos;
          if (x.eat(91)) {
            var he = x.eat(94), ge = this.regexp_classContents(x);
            if (x.eat(93))
              return he && ge === 2 && x.raise("Negated character class may contain strings"), ge;
            x.pos = J;
          }
          if (x.eat(92)) {
            var Oe = this.regexp_eatCharacterClassEscape(x);
            if (Oe)
              return Oe;
            x.pos = J;
          }
          return null;
        }, Pt.regexp_eatClassStringDisjunction = function(x) {
          var J = x.pos;
          if (x.eatChars([92, 113])) {
            if (x.eat(123)) {
              var he = this.regexp_classStringDisjunctionContents(x);
              if (x.eat(125))
                return he;
            } else
              x.raise("Invalid escape");
            x.pos = J;
          }
          return null;
        }, Pt.regexp_classStringDisjunctionContents = function(x) {
          for (var J = this.regexp_classString(x); x.eat(124); )
            this.regexp_classString(x) === 2 && (J = 2);
          return J;
        }, Pt.regexp_classString = function(x) {
          for (var J = 0; this.regexp_eatClassSetCharacter(x); )
            J++;
          return J === 1 ? 1 : 2;
        }, Pt.regexp_eatClassSetCharacter = function(x) {
          var J = x.pos;
          if (x.eat(92))
            return !(!this.regexp_eatCharacterEscape(x) && !this.regexp_eatClassSetReservedPunctuator(x)) || (x.eat(98) ? (x.lastIntValue = 8, !0) : (x.pos = J, !1));
          var he = x.current();
          return !(he < 0 || he === x.lookahead() && function(ge) {
            return ge === 33 || ge >= 35 && ge <= 38 || ge >= 42 && ge <= 44 || ge === 46 || ge >= 58 && ge <= 64 || ge === 94 || ge === 96 || ge === 126;
          }(he)) && !function(ge) {
            return ge === 40 || ge === 41 || ge === 45 || ge === 47 || ge >= 91 && ge <= 93 || ge >= 123 && ge <= 125;
          }(he) && (x.advance(), x.lastIntValue = he, !0);
        }, Pt.regexp_eatClassSetReservedPunctuator = function(x) {
          var J = x.current();
          return !!function(he) {
            return he === 33 || he === 35 || he === 37 || he === 38 || he === 44 || he === 45 || he >= 58 && he <= 62 || he === 64 || he === 96 || he === 126;
          }(J) && (x.lastIntValue = J, x.advance(), !0);
        }, Pt.regexp_eatClassControlLetter = function(x) {
          var J = x.current();
          return !(!Ci(J) && J !== 95) && (x.lastIntValue = J % 32, x.advance(), !0);
        }, Pt.regexp_eatHexEscapeSequence = function(x) {
          var J = x.pos;
          if (x.eat(120)) {
            if (this.regexp_eatFixedHexDigits(x, 2))
              return !0;
            x.switchU && x.raise("Invalid escape"), x.pos = J;
          }
          return !1;
        }, Pt.regexp_eatDecimalDigits = function(x) {
          var J = x.pos, he = 0;
          for (x.lastIntValue = 0; Ci(he = x.current()); )
            x.lastIntValue = 10 * x.lastIntValue + (he - 48), x.advance();
          return x.pos !== J;
        }, Pt.regexp_eatHexDigits = function(x) {
          var J = x.pos, he = 0;
          for (x.lastIntValue = 0; oc(he = x.current()); )
            x.lastIntValue = 16 * x.lastIntValue + lc(he), x.advance();
          return x.pos !== J;
        }, Pt.regexp_eatLegacyOctalEscapeSequence = function(x) {
          if (this.regexp_eatOctalDigit(x)) {
            var J = x.lastIntValue;
            if (this.regexp_eatOctalDigit(x)) {
              var he = x.lastIntValue;
              J <= 3 && this.regexp_eatOctalDigit(x) ? x.lastIntValue = 64 * J + 8 * he + x.lastIntValue : x.lastIntValue = 8 * J + he;
            } else
              x.lastIntValue = J;
            return !0;
          }
          return !1;
        }, Pt.regexp_eatOctalDigit = function(x) {
          var J = x.current();
          return ml(J) ? (x.lastIntValue = J - 48, x.advance(), !0) : (x.lastIntValue = 0, !1);
        }, Pt.regexp_eatFixedHexDigits = function(x, J) {
          var he = x.pos;
          x.lastIntValue = 0;
          for (var ge = 0; ge < J; ++ge) {
            var Oe = x.current();
            if (!oc(Oe))
              return x.pos = he, !1;
            x.lastIntValue = 16 * x.lastIntValue + lc(Oe), x.advance();
          }
          return !0;
        };
        var yl = function(x) {
          this.type = x.type, this.value = x.value, this.start = x.start, this.end = x.end, x.options.locations && (this.loc = new ht(x, x.startLoc, x.endLoc)), x.options.ranges && (this.range = [x.start, x.end]);
        }, Qt = xe.prototype;
        function xt(x) {
          return typeof BigInt != "function" ? null : BigInt(x.replace(/_/g, ""));
        }
        Qt.next = function(x) {
          !x && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new yl(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
        }, Qt.getToken = function() {
          return this.next(), new yl(this);
        }, typeof Symbol < "u" && (Qt[Symbol.iterator] = function() {
          var x = this;
          return { next: function() {
            var J = x.getToken();
            return { done: J.type === ie.eof, value: J };
          } };
        }), Qt.nextToken = function() {
          var x = this.curContext();
          return x && x.preserveSpace || this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length ? this.finishToken(ie.eof) : x.override ? x.override(this) : void this.readToken(this.fullCharCodeAtPos());
        }, Qt.readToken = function(x) {
          return ye(x, this.options.ecmaVersion >= 6) || x === 92 ? this.readWord() : this.getTokenFromCode(x);
        }, Qt.fullCharCodeAtPos = function() {
          var x = this.input.charCodeAt(this.pos);
          if (x <= 55295 || x >= 56320)
            return x;
          var J = this.input.charCodeAt(this.pos + 1);
          return J <= 56319 || J >= 57344 ? x : (x << 10) + J - 56613888;
        }, Qt.skipBlockComment = function() {
          var x = this.options.onComment && this.curPosition(), J = this.pos, he = this.input.indexOf("*/", this.pos += 2);
          if (he === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = he + 2, this.options.locations)
            for (var ge = void 0, Oe = J; (ge = Ae(this.input, Oe, this.pos)) > -1; )
              ++this.curLine, Oe = this.lineStart = ge;
          this.options.onComment && this.options.onComment(!0, this.input.slice(J + 2, he), J, this.pos, x, this.curPosition());
        }, Qt.skipLineComment = function(x) {
          for (var J = this.pos, he = this.options.onComment && this.curPosition(), ge = this.input.charCodeAt(this.pos += x); this.pos < this.input.length && !Ee(ge); )
            ge = this.input.charCodeAt(++this.pos);
          this.options.onComment && this.options.onComment(!1, this.input.slice(J + x, this.pos), J, this.pos, he, this.curPosition());
        }, Qt.skipSpace = function() {
          e:
            for (; this.pos < this.input.length; ) {
              var x = this.input.charCodeAt(this.pos);
              switch (x) {
                case 32:
                case 160:
                  ++this.pos;
                  break;
                case 13:
                  this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
                case 10:
                case 8232:
                case 8233:
                  ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
                  break;
                case 47:
                  switch (this.input.charCodeAt(this.pos + 1)) {
                    case 42:
                      this.skipBlockComment();
                      break;
                    case 47:
                      this.skipLineComment(2);
                      break;
                    default:
                      break e;
                  }
                  break;
                default:
                  if (!(x > 8 && x < 14 || x >= 5760 && Me.test(String.fromCharCode(x))))
                    break e;
                  ++this.pos;
              }
            }
        }, Qt.finishToken = function(x, J) {
          this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
          var he = this.type;
          this.type = x, this.value = J, this.updateContext(he);
        }, Qt.readToken_dot = function() {
          var x = this.input.charCodeAt(this.pos + 1);
          if (x >= 48 && x <= 57)
            return this.readNumber(!0);
          var J = this.input.charCodeAt(this.pos + 2);
          return this.options.ecmaVersion >= 6 && x === 46 && J === 46 ? (this.pos += 3, this.finishToken(ie.ellipsis)) : (++this.pos, this.finishToken(ie.dot));
        }, Qt.readToken_slash = function() {
          var x = this.input.charCodeAt(this.pos + 1);
          return this.exprAllowed ? (++this.pos, this.readRegexp()) : x === 61 ? this.finishOp(ie.assign, 2) : this.finishOp(ie.slash, 1);
        }, Qt.readToken_mult_modulo_exp = function(x) {
          var J = this.input.charCodeAt(this.pos + 1), he = 1, ge = x === 42 ? ie.star : ie.modulo;
          return this.options.ecmaVersion >= 7 && x === 42 && J === 42 && (++he, ge = ie.starstar, J = this.input.charCodeAt(this.pos + 2)), J === 61 ? this.finishOp(ie.assign, he + 1) : this.finishOp(ge, he);
        }, Qt.readToken_pipe_amp = function(x) {
          var J = this.input.charCodeAt(this.pos + 1);
          return J === x ? this.options.ecmaVersion >= 12 && this.input.charCodeAt(this.pos + 2) === 61 ? this.finishOp(ie.assign, 3) : this.finishOp(x === 124 ? ie.logicalOR : ie.logicalAND, 2) : J === 61 ? this.finishOp(ie.assign, 2) : this.finishOp(x === 124 ? ie.bitwiseOR : ie.bitwiseAND, 1);
        }, Qt.readToken_caret = function() {
          return this.input.charCodeAt(this.pos + 1) === 61 ? this.finishOp(ie.assign, 2) : this.finishOp(ie.bitwiseXOR, 1);
        }, Qt.readToken_plus_min = function(x) {
          var J = this.input.charCodeAt(this.pos + 1);
          return J === x ? J !== 45 || this.inModule || this.input.charCodeAt(this.pos + 2) !== 62 || this.lastTokEnd !== 0 && !we.test(this.input.slice(this.lastTokEnd, this.pos)) ? this.finishOp(ie.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : J === 61 ? this.finishOp(ie.assign, 2) : this.finishOp(ie.plusMin, 1);
        }, Qt.readToken_lt_gt = function(x) {
          var J = this.input.charCodeAt(this.pos + 1), he = 1;
          return J === x ? (he = x === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + he) === 61 ? this.finishOp(ie.assign, he + 1) : this.finishOp(ie.bitShift, he)) : J !== 33 || x !== 60 || this.inModule || this.input.charCodeAt(this.pos + 2) !== 45 || this.input.charCodeAt(this.pos + 3) !== 45 ? (J === 61 && (he = 2), this.finishOp(ie.relational, he)) : (this.skipLineComment(4), this.skipSpace(), this.nextToken());
        }, Qt.readToken_eq_excl = function(x) {
          var J = this.input.charCodeAt(this.pos + 1);
          return J === 61 ? this.finishOp(ie.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : x === 61 && J === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(ie.arrow)) : this.finishOp(x === 61 ? ie.eq : ie.prefix, 1);
        }, Qt.readToken_question = function() {
          var x = this.options.ecmaVersion;
          if (x >= 11) {
            var J = this.input.charCodeAt(this.pos + 1);
            if (J === 46) {
              var he = this.input.charCodeAt(this.pos + 2);
              if (he < 48 || he > 57)
                return this.finishOp(ie.questionDot, 2);
            }
            if (J === 63)
              return x >= 12 && this.input.charCodeAt(this.pos + 2) === 61 ? this.finishOp(ie.assign, 3) : this.finishOp(ie.coalesce, 2);
          }
          return this.finishOp(ie.question, 1);
        }, Qt.readToken_numberSign = function() {
          var x = 35;
          if (this.options.ecmaVersion >= 13 && (++this.pos, ye(x = this.fullCharCodeAtPos(), !0) || x === 92))
            return this.finishToken(ie.privateId, this.readWord1());
          this.raise(this.pos, "Unexpected character '" + We(x) + "'");
        }, Qt.getTokenFromCode = function(x) {
          switch (x) {
            case 46:
              return this.readToken_dot();
            case 40:
              return ++this.pos, this.finishToken(ie.parenL);
            case 41:
              return ++this.pos, this.finishToken(ie.parenR);
            case 59:
              return ++this.pos, this.finishToken(ie.semi);
            case 44:
              return ++this.pos, this.finishToken(ie.comma);
            case 91:
              return ++this.pos, this.finishToken(ie.bracketL);
            case 93:
              return ++this.pos, this.finishToken(ie.bracketR);
            case 123:
              return ++this.pos, this.finishToken(ie.braceL);
            case 125:
              return ++this.pos, this.finishToken(ie.braceR);
            case 58:
              return ++this.pos, this.finishToken(ie.colon);
            case 96:
              if (this.options.ecmaVersion < 6)
                break;
              return ++this.pos, this.finishToken(ie.backQuote);
            case 48:
              var J = this.input.charCodeAt(this.pos + 1);
              if (J === 120 || J === 88)
                return this.readRadixNumber(16);
              if (this.options.ecmaVersion >= 6) {
                if (J === 111 || J === 79)
                  return this.readRadixNumber(8);
                if (J === 98 || J === 66)
                  return this.readRadixNumber(2);
              }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              return this.readNumber(!1);
            case 34:
            case 39:
              return this.readString(x);
            case 47:
              return this.readToken_slash();
            case 37:
            case 42:
              return this.readToken_mult_modulo_exp(x);
            case 124:
            case 38:
              return this.readToken_pipe_amp(x);
            case 94:
              return this.readToken_caret();
            case 43:
            case 45:
              return this.readToken_plus_min(x);
            case 60:
            case 62:
              return this.readToken_lt_gt(x);
            case 61:
            case 33:
              return this.readToken_eq_excl(x);
            case 63:
              return this.readToken_question();
            case 126:
              return this.finishOp(ie.prefix, 1);
            case 35:
              return this.readToken_numberSign();
          }
          this.raise(this.pos, "Unexpected character '" + We(x) + "'");
        }, Qt.finishOp = function(x, J) {
          var he = this.input.slice(this.pos, this.pos + J);
          return this.pos += J, this.finishToken(x, he);
        }, Qt.readRegexp = function() {
          for (var x, J, he = this.pos; ; ) {
            this.pos >= this.input.length && this.raise(he, "Unterminated regular expression");
            var ge = this.input.charAt(this.pos);
            if (we.test(ge) && this.raise(he, "Unterminated regular expression"), x)
              x = !1;
            else {
              if (ge === "[")
                J = !0;
              else if (ge === "]" && J)
                J = !1;
              else if (ge === "/" && !J)
                break;
              x = ge === "\\";
            }
            ++this.pos;
          }
          var Oe = this.input.slice(he, this.pos);
          ++this.pos;
          var Le = this.pos, Ue = this.readWord1();
          this.containsEsc && this.unexpected(Le);
          var qe = this.regexpState || (this.regexpState = new ni(this));
          qe.reset(he, Oe, Ue), this.validateRegExpFlags(qe), this.validateRegExpPattern(qe);
          var at = null;
          try {
            at = new RegExp(Oe, Ue);
          } catch {
          }
          return this.finishToken(ie.regexp, { pattern: Oe, flags: Ue, value: at });
        }, Qt.readInt = function(x, J, he) {
          for (var ge = this.options.ecmaVersion >= 12 && J === void 0, Oe = he && this.input.charCodeAt(this.pos) === 48, Le = this.pos, Ue = 0, qe = 0, at = 0, gt = J ?? 1 / 0; at < gt; ++at, ++this.pos) {
            var ot = this.input.charCodeAt(this.pos), Lt = void 0;
            if (ge && ot === 95)
              Oe && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), qe === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), at === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), qe = ot;
            else {
              if ((Lt = ot >= 97 ? ot - 97 + 10 : ot >= 65 ? ot - 65 + 10 : ot >= 48 && ot <= 57 ? ot - 48 : 1 / 0) >= x)
                break;
              qe = ot, Ue = Ue * x + Lt;
            }
          }
          return ge && qe === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === Le || J != null && this.pos - Le !== J ? null : Ue;
        }, Qt.readRadixNumber = function(x) {
          var J = this.pos;
          this.pos += 2;
          var he = this.readInt(x);
          return he == null && this.raise(this.start + 2, "Expected number in radix " + x), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (he = xt(this.input.slice(J, this.pos)), ++this.pos) : ye(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(ie.num, he);
        }, Qt.readNumber = function(x) {
          var J = this.pos;
          x || this.readInt(10, void 0, !0) !== null || this.raise(J, "Invalid number");
          var he = this.pos - J >= 2 && this.input.charCodeAt(J) === 48;
          he && this.strict && this.raise(J, "Invalid number");
          var ge = this.input.charCodeAt(this.pos);
          if (!he && !x && this.options.ecmaVersion >= 11 && ge === 110) {
            var Oe = xt(this.input.slice(J, this.pos));
            return ++this.pos, ye(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(ie.num, Oe);
          }
          he && /[89]/.test(this.input.slice(J, this.pos)) && (he = !1), ge !== 46 || he || (++this.pos, this.readInt(10), ge = this.input.charCodeAt(this.pos)), ge !== 69 && ge !== 101 || he || ((ge = this.input.charCodeAt(++this.pos)) !== 43 && ge !== 45 || ++this.pos, this.readInt(10) === null && this.raise(J, "Invalid number")), ye(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
          var Le, Ue = (Le = this.input.slice(J, this.pos), he ? parseInt(Le, 8) : parseFloat(Le.replace(/_/g, "")));
          return this.finishToken(ie.num, Ue);
        }, Qt.readCodePoint = function() {
          var x;
          if (this.input.charCodeAt(this.pos) === 123) {
            this.options.ecmaVersion < 6 && this.unexpected();
            var J = ++this.pos;
            x = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, x > 1114111 && this.invalidStringToken(J, "Code point out of bounds");
          } else
            x = this.readHexChar(4);
          return x;
        }, Qt.readString = function(x) {
          for (var J = "", he = ++this.pos; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
            var ge = this.input.charCodeAt(this.pos);
            if (ge === x)
              break;
            ge === 92 ? (J += this.input.slice(he, this.pos), J += this.readEscapedChar(!1), he = this.pos) : ge === 8232 || ge === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (Ee(ge) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
          }
          return J += this.input.slice(he, this.pos++), this.finishToken(ie.string, J);
        };
        var bl = {};
        Qt.tryReadTemplateToken = function() {
          this.inTemplateElement = !0;
          try {
            this.readTmplToken();
          } catch (x) {
            if (x !== bl)
              throw x;
            this.readInvalidTemplateToken();
          }
          this.inTemplateElement = !1;
        }, Qt.invalidStringToken = function(x, J) {
          if (this.inTemplateElement && this.options.ecmaVersion >= 9)
            throw bl;
          this.raise(x, J);
        }, Qt.readTmplToken = function() {
          for (var x = "", J = this.pos; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
            var he = this.input.charCodeAt(this.pos);
            if (he === 96 || he === 36 && this.input.charCodeAt(this.pos + 1) === 123)
              return this.pos !== this.start || this.type !== ie.template && this.type !== ie.invalidTemplate ? (x += this.input.slice(J, this.pos), this.finishToken(ie.template, x)) : he === 36 ? (this.pos += 2, this.finishToken(ie.dollarBraceL)) : (++this.pos, this.finishToken(ie.backQuote));
            if (he === 92)
              x += this.input.slice(J, this.pos), x += this.readEscapedChar(!0), J = this.pos;
            else if (Ee(he)) {
              switch (x += this.input.slice(J, this.pos), ++this.pos, he) {
                case 13:
                  this.input.charCodeAt(this.pos) === 10 && ++this.pos;
                case 10:
                  x += `
`;
                  break;
                default:
                  x += String.fromCharCode(he);
              }
              this.options.locations && (++this.curLine, this.lineStart = this.pos), J = this.pos;
            } else
              ++this.pos;
          }
        }, Qt.readInvalidTemplateToken = function() {
          for (; this.pos < this.input.length; this.pos++)
            switch (this.input[this.pos]) {
              case "\\":
                ++this.pos;
                break;
              case "$":
                if (this.input[this.pos + 1] !== "{")
                  break;
              case "`":
                return this.finishToken(ie.invalidTemplate, this.input.slice(this.start, this.pos));
            }
          this.raise(this.start, "Unterminated template");
        }, Qt.readEscapedChar = function(x) {
          var J = this.input.charCodeAt(++this.pos);
          switch (++this.pos, J) {
            case 110:
              return `
`;
            case 114:
              return "\r";
            case 120:
              return String.fromCharCode(this.readHexChar(2));
            case 117:
              return We(this.readCodePoint());
            case 116:
              return "	";
            case 98:
              return "\b";
            case 118:
              return "\v";
            case 102:
              return "\f";
            case 13:
              this.input.charCodeAt(this.pos) === 10 && ++this.pos;
            case 10:
              return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
            case 56:
            case 57:
              if (this.strict && this.invalidStringToken(this.pos - 1, "Invalid escape sequence"), x) {
                var he = this.pos - 1;
                this.invalidStringToken(he, "Invalid escape sequence in template string");
              }
            default:
              if (J >= 48 && J <= 55) {
                var ge = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], Oe = parseInt(ge, 8);
                return Oe > 255 && (ge = ge.slice(0, -1), Oe = parseInt(ge, 8)), this.pos += ge.length - 1, J = this.input.charCodeAt(this.pos), ge === "0" && J !== 56 && J !== 57 || !this.strict && !x || this.invalidStringToken(this.pos - 1 - ge.length, x ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(Oe);
              }
              return Ee(J) ? "" : String.fromCharCode(J);
          }
        }, Qt.readHexChar = function(x) {
          var J = this.pos, he = this.readInt(16, x);
          return he === null && this.invalidStringToken(J, "Bad character escape sequence"), he;
        }, Qt.readWord1 = function() {
          this.containsEsc = !1;
          for (var x = "", J = !0, he = this.pos, ge = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
            var Oe = this.fullCharCodeAtPos();
            if (ve(Oe, ge))
              this.pos += Oe <= 65535 ? 1 : 2;
            else {
              if (Oe !== 92)
                break;
              this.containsEsc = !0, x += this.input.slice(he, this.pos);
              var Le = this.pos;
              this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
              var Ue = this.readCodePoint();
              (J ? ye : ve)(Ue, ge) || this.invalidStringToken(Le, "Invalid Unicode escape"), x += We(Ue), he = this.pos;
            }
            J = !1;
          }
          return x + this.input.slice(he, this.pos);
        }, Qt.readWord = function() {
          var x = this.readWord1(), J = ie.name;
          return this.keywords.test(x) && (J = le[x]), this.finishToken(J, x);
        }, xe.acorn = { Parser: xe, version: "8.10.0", defaultOptions: st, Position: Ye, SourceLocation: ht, getLineInfo: ct, Node: Wt, TokenType: de, tokTypes: ie, keywordTypes: le, TokContext: Ne, tokContexts: Je, isIdentifierChar: ve, isIdentifierStart: ye, Token: yl, isNewLine: Ee, lineBreak: we, lineBreakG: De, nonASCIIwhitespace: Me };
        const uc = xr, Xi = Dn, kt = ds, cc = /\/$|\/\?/;
        function fc(x = "", J = !1) {
          return J ? cc.test(x) : x.endsWith("/");
        }
        function dc(x = "", J = !1) {
          if (!J)
            return x.endsWith("/") ? x : x + "/";
          if (fc(x, !0))
            return x || "/";
          const [he, ...ge] = x.split("?");
          return he + "/" + (ge.length > 0 ? `?${ge.join("?")}` : "");
        }
        function Wr(x) {
          return x && x !== "/";
        }
        const xs = /^\.?\//;
        function pc(x, ...J) {
          let he = x || "";
          for (const ge of J.filter((Oe) => Wr(Oe)))
            if (he) {
              const Oe = ge.replace(xs, "");
              he = dc(he) + Oe;
            } else
              he = ge;
          return he;
        }
        const Ii = ru(), Hs = sd, va = Lr, kp = xr, qs = mi, hc = new Set(uc.builtinModules);
        function Ea(x) {
          return x.replace(/\\/g, "/");
        }
        const Dp = Hs.platform === "win32", Np = {}.hasOwnProperty, gl = /^([A-Z][a-z\d]*)+$/, Rp = /* @__PURE__ */ new Set(["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"]), rn = {};
        function no(x, J = "and") {
          return x.length < 3 ? x.join(` ${J} `) : `${x.slice(0, -1).join(", ")}, ${J} ${x[x.length - 1]}`;
        }
        const Gs = /* @__PURE__ */ new Map();
        let vl;
        function Te(x, J, he) {
          return Gs.set(x, J), function(ge, Oe) {
            return Le;
            function Le(...Ue) {
              const qe = Error.stackTraceLimit;
              p() && (Error.stackTraceLimit = 0);
              const at = new ge();
              p() && (Error.stackTraceLimit = qe);
              const gt = function(ot, Lt, Ft) {
                const ar = Gs.get(ot);
                if (Ii(ar !== void 0, "expected `message` to be found"), typeof ar == "function")
                  return Ii(ar.length <= Lt.length, `Code: ${ot}; The provided arguments length (${Lt.length}) does not match the required ones (${ar.length}).`), Reflect.apply(ar, Ft, Lt);
                const Er = /%[dfijoOs]/g;
                let Qr = 0;
                for (; Er.exec(ar) !== null; )
                  Qr++;
                return Ii(Qr === Lt.length, `Code: ${ot}; The provided arguments length (${Lt.length}) does not match the required ones (${Qr}).`), Lt.length === 0 ? ar : (Lt.unshift(ar), Reflect.apply(qs.format, null, Lt));
              }(Oe, Ue, at);
              return Object.defineProperties(at, { message: { value: gt, enumerable: !1, writable: !0, configurable: !0 }, toString: { value() {
                return `${this.name} [${Oe}]: ${this.message}`;
              }, enumerable: !1, writable: !0, configurable: !0 } }), A(at), at.code = Oe, at;
            }
          }(he, x);
        }
        function p() {
          try {
            if (kp.startupSnapshot.isBuildingSnapshot())
              return !1;
          } catch {
          }
          const x = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
          return x === void 0 ? Object.isExtensible(Error) : Np.call(x, "writable") && x.writable !== void 0 ? x.writable : x.set !== void 0;
        }
        rn.ERR_INVALID_ARG_TYPE = Te("ERR_INVALID_ARG_TYPE", (x, J, he) => {
          Ii(typeof x == "string", "'name' must be a string"), Array.isArray(J) || (J = [J]);
          let ge = "The ";
          if (x.endsWith(" argument"))
            ge += `${x} `;
          else {
            const qe = x.includes(".") ? "property" : "argument";
            ge += `"${x}" ${qe} `;
          }
          ge += "must be ";
          const Oe = [], Le = [], Ue = [];
          for (const qe of J)
            Ii(typeof qe == "string", "All expected entries have to be of type string"), Rp.has(qe) ? Oe.push(qe.toLowerCase()) : gl.exec(qe) === null ? (Ii(qe !== "object", 'The value "object" should be written as "Object"'), Ue.push(qe)) : Le.push(qe);
          if (Le.length > 0) {
            const qe = Oe.indexOf("object");
            qe !== -1 && (Oe.slice(qe, 1), Le.push("Object"));
          }
          return Oe.length > 0 && (ge += `${Oe.length > 1 ? "one of type" : "of type"} ${no(Oe, "or")}`, (Le.length > 0 || Ue.length > 0) && (ge += " or ")), Le.length > 0 && (ge += `an instance of ${no(Le, "or")}`, Ue.length > 0 && (ge += " or ")), Ue.length > 0 && (Ue.length > 1 ? ge += `one of ${no(Ue, "or")}` : (Ue[0].toLowerCase() !== Ue[0] && (ge += "an "), ge += `${Ue[0]}`)), ge += `. Received ${function(qe) {
            if (qe == null)
              return String(qe);
            if (typeof qe == "function" && qe.name)
              return `function ${qe.name}`;
            if (typeof qe == "object")
              return qe.constructor && qe.constructor.name ? `an instance of ${qe.constructor.name}` : `${(0, qs.inspect)(qe, { depth: -1 })}`;
            let at = (0, qs.inspect)(qe, { colors: !1 });
            return at.length > 28 && (at = `${at.slice(0, 25)}...`), `type ${typeof qe} (${at})`;
          }(he)}`, ge;
        }, TypeError), rn.ERR_INVALID_MODULE_SPECIFIER = Te("ERR_INVALID_MODULE_SPECIFIER", (x, J, he = void 0) => `Invalid module "${x}" ${J}${he ? ` imported from ${he}` : ""}`, TypeError), rn.ERR_INVALID_PACKAGE_CONFIG = Te("ERR_INVALID_PACKAGE_CONFIG", (x, J, he) => `Invalid package config ${x}${J ? ` while importing ${J}` : ""}${he ? `. ${he}` : ""}`, Error), rn.ERR_INVALID_PACKAGE_TARGET = Te("ERR_INVALID_PACKAGE_TARGET", (x, J, he, ge = !1, Oe = void 0) => {
          const Le = typeof he == "string" && !ge && he.length > 0 && !he.startsWith("./");
          return J === "." ? (Ii(ge === !1), `Invalid "exports" main target ${JSON.stringify(he)} defined in the package config ${x}package.json${Oe ? ` imported from ${Oe}` : ""}${Le ? '; targets must start with "./"' : ""}`) : `Invalid "${ge ? "imports" : "exports"}" target ${JSON.stringify(he)} defined for '${J}' in the package config ${x}package.json${Oe ? ` imported from ${Oe}` : ""}${Le ? '; targets must start with "./"' : ""}`;
        }, Error), rn.ERR_MODULE_NOT_FOUND = Te("ERR_MODULE_NOT_FOUND", (x, J, he = "package") => `Cannot find ${he} '${x}' imported from ${J}`, Error), rn.ERR_NETWORK_IMPORT_DISALLOWED = Te("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error), rn.ERR_PACKAGE_IMPORT_NOT_DEFINED = Te("ERR_PACKAGE_IMPORT_NOT_DEFINED", (x, J, he) => `Package import specifier "${x}" is not defined${J ? ` in package ${J}package.json` : ""} imported from ${he}`, TypeError), rn.ERR_PACKAGE_PATH_NOT_EXPORTED = Te("ERR_PACKAGE_PATH_NOT_EXPORTED", (x, J, he = void 0) => J === "." ? `No "exports" main defined in ${x}package.json${he ? ` imported from ${he}` : ""}` : `Package subpath '${J}' is not defined by "exports" in ${x}package.json${he ? ` imported from ${he}` : ""}`, Error), rn.ERR_UNSUPPORTED_DIR_IMPORT = Te("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error), rn.ERR_UNKNOWN_FILE_EXTENSION = Te("ERR_UNKNOWN_FILE_EXTENSION", (x, J) => `Unknown file extension "${x}" for ${J}`, TypeError), rn.ERR_INVALID_ARG_VALUE = Te("ERR_INVALID_ARG_VALUE", (x, J, he = "is invalid") => {
          let ge = (0, qs.inspect)(J);
          return ge.length > 128 && (ge = `${ge.slice(0, 128)}...`), `The ${x.includes(".") ? "property" : "argument"} '${x}' ${he}. Received ${ge}`;
        }, TypeError), rn.ERR_UNSUPPORTED_ESM_URL_SCHEME = Te("ERR_UNSUPPORTED_ESM_URL_SCHEME", (x, J) => {
          let he = `Only URLs with a scheme in: ${no(J)} are supported by the default ESM loader`;
          return Dp && x.protocol.length === 2 && (he += ". On Windows, absolute paths must be valid file:// URLs"), he += `. Received protocol '${x.protocol}'`, he;
        }, Error);
        const A = function(x) {
          const J = "__node_internal_" + x.name;
          return Object.defineProperty(x, "name", { value: J }), x;
        }(function(x) {
          const J = p();
          return J && (vl = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(x), J && (Error.stackTraceLimit = vl), x;
        }), V = { read: function(x) {
          try {
            return { string: Xi.readFileSync(va.toNamespacedPath(va.join(va.dirname(x), "package.json")), "utf8") };
          } catch (J) {
            const he = J;
            if (he.code === "ENOENT")
              return { string: void 0 };
            throw he;
          }
        } }, { ERR_INVALID_PACKAGE_CONFIG: ee } = rn, fe = /* @__PURE__ */ new Map();
        function Se(x, J, he) {
          const ge = fe.get(x);
          if (ge !== void 0)
            return ge;
          const Oe = V.read(x).string;
          if (Oe === void 0) {
            const Ft = { pjsonPath: x, exists: !1, main: void 0, name: void 0, type: "none", exports: void 0, imports: void 0 };
            return fe.set(x, Ft), Ft;
          }
          let Le;
          try {
            Le = JSON.parse(Oe);
          } catch (Ft) {
            const ar = Ft;
            throw new ee(x, (he ? `"${J}" from ` : "") + (0, kt.fileURLToPath)(he || J), ar.message);
          }
          const { exports: Ue, imports: qe, main: at, name: gt, type: ot } = Le, Lt = { pjsonPath: x, exists: !0, main: typeof at == "string" ? at : void 0, name: typeof gt == "string" ? gt : void 0, type: ot === "module" || ot === "commonjs" ? ot : "none", exports: Ue, imports: qe && typeof qe == "object" ? qe : void 0 };
          return fe.set(x, Lt), Lt;
        }
        function Pe(x) {
          let J = new kt.URL("package.json", x);
          for (; !J.pathname.endsWith("node_modules/package.json"); ) {
            const Oe = Se((0, kt.fileURLToPath)(J), x);
            if (Oe.exists)
              return Oe;
            const Le = J;
            if (J = new kt.URL("../package.json", J), J.pathname === Le.pathname)
              break;
          }
          const he = (0, kt.fileURLToPath)(J), ge = { pjsonPath: he, exists: !1, main: void 0, name: void 0, type: "none", exports: void 0, imports: void 0 };
          return fe.set(he, ge), ge;
        }
        const { ERR_UNKNOWN_FILE_EXTENSION: Re } = rn, je = {}.hasOwnProperty, ze = { __proto__: null, ".cjs": "commonjs", ".js": "module", ".json": "json", ".mjs": "module" }, mt = { __proto__: null, "data:": function(x) {
          const { 1: J } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(x.pathname) || [null, null, null];
          return function(he) {
            return he && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(he) ? "module" : he === "application/json" ? "json" : null;
          }(J);
        }, "file:": function(x, J, he) {
          const ge = function(Ue) {
            const qe = Ue.pathname;
            let at = qe.length;
            for (; at--; ) {
              const gt = qe.codePointAt(at);
              if (gt === 47)
                return "";
              if (gt === 46)
                return qe.codePointAt(at - 1) === 47 ? "" : qe.slice(at);
            }
            return "";
          }(x);
          if (ge === ".js")
            return function(Ue) {
              return Pe(Ue).type;
            }(x) === "module" ? "module" : "commonjs";
          const Oe = ze[ge];
          if (Oe)
            return Oe;
          if (he)
            return;
          const Le = (0, kt.fileURLToPath)(x);
          throw new Re(ge, Le);
        }, "http:": Mt, "https:": Mt, "node:": () => "builtin" };
        function Mt() {
        }
        const St = RegExp.prototype[Symbol.replace], { ERR_NETWORK_IMPORT_DISALLOWED: Ut, ERR_INVALID_MODULE_SPECIFIER: Cr, ERR_INVALID_PACKAGE_CONFIG: nr, ERR_INVALID_PACKAGE_TARGET: hr, ERR_MODULE_NOT_FOUND: nn, ERR_PACKAGE_IMPORT_NOT_DEFINED: Mp, ERR_PACKAGE_PATH_NOT_EXPORTED: El, ERR_UNSUPPORTED_DIR_IMPORT: jI, ERR_UNSUPPORTED_ESM_URL_SCHEME: XX } = rn, pg = {}.hasOwnProperty, hg = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i, mg = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i, FI = /^\.|%|\\/, mc = /\*/g, BI = /%2f|%5c/i, yg = /* @__PURE__ */ new Set(), $I = /[/\\]{2}/;
        function bg(x, J, he, ge, Oe, Le, Ue) {
          const qe = (0, kt.fileURLToPath)(ge), at = $I.exec(Ue ? x : J) !== null;
          Hs.emitWarning(`Use of deprecated ${at ? "double slash" : "leading or trailing slash matching"} resolving "${x}" for module request "${J}" ${J === he ? "" : `matched to "${he}" `}in the "${Oe ? "imports" : "exports"}" field module resolution of the package at ${qe}${Le ? ` imported from ${(0, kt.fileURLToPath)(Le)}` : ""}.`, "DeprecationWarning", "DEP0166");
        }
        function gg(x, J, he, ge) {
          if (function(at, gt) {
            return je.call(mt, at.protocol) && mt[at.protocol](at, gt, !0) || null;
          }(x, { parentURL: he.href }) !== "module")
            return;
          const Le = (0, kt.fileURLToPath)(x.href), Ue = (0, kt.fileURLToPath)(new kt.URL(".", J)), qe = (0, kt.fileURLToPath)(he);
          ge ? Hs.emitWarning(`Package ${Ue} has a "main" field set to ${JSON.stringify(ge)}, excluding the full filename and extension to the resolved file at "${Le.slice(Ue.length)}", imported from ${qe}.
 Automatic extension resolution of the "main" field isdeprecated for ES modules.`, "DeprecationWarning", "DEP0151") : Hs.emitWarning(`No "main" or "exports" field defined in the package.json for ${Ue} resolving the main entry point "${Le.slice(Ue.length)}", imported from ${qe}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
        }
        function vg(x) {
          try {
            return (0, Xi.statSync)(x);
          } catch {
            return new Xi.Stats();
          }
        }
        function Lp(x) {
          const J = (0, Xi.statSync)(x, { throwIfNoEntry: !1 }), he = J ? J.isFile() : void 0;
          return he != null && he;
        }
        function UI(x, J, he) {
          let ge;
          if (J.main !== void 0) {
            if (ge = new kt.URL(J.main, x), Lp(ge))
              return ge;
            const Ue = [`./${J.main}.js`, `./${J.main}.json`, `./${J.main}.node`, `./${J.main}/index.js`, `./${J.main}/index.json`, `./${J.main}/index.node`];
            let qe = -1;
            for (; ++qe < Ue.length && (ge = new kt.URL(Ue[qe], x), !Lp(ge)); )
              ge = void 0;
            if (ge)
              return gg(ge, x, he, J.main), ge;
          }
          const Oe = ["./index.js", "./index.json", "./index.node"];
          let Le = -1;
          for (; ++Le < Oe.length && (ge = new kt.URL(Oe[Le], x), !Lp(ge)); )
            ge = void 0;
          if (ge)
            return gg(ge, x, he, J.main), ge;
          throw new nn((0, kt.fileURLToPath)(new kt.URL(".", x)), (0, kt.fileURLToPath)(he));
        }
        function jp(x, J, he) {
          return new El((0, kt.fileURLToPath)(new kt.URL(".", J)), x, he && (0, kt.fileURLToPath)(he));
        }
        function _l(x, J, he, ge, Oe) {
          return J = typeof J == "object" && J !== null ? JSON.stringify(J, null, "") : `${J}`, new hr((0, kt.fileURLToPath)(new kt.URL(".", he)), x, J, ge, Oe && (0, kt.fileURLToPath)(Oe));
        }
        function VI(x, J, he, ge, Oe, Le, Ue, qe, at) {
          if (J !== "" && !Le && x[x.length - 1] !== "/")
            throw _l(he, x, ge, Ue, Oe);
          if (!x.startsWith("./")) {
            if (Ue && !x.startsWith("../") && !x.startsWith("/")) {
              let Ft = !1;
              try {
                new kt.URL(x), Ft = !0;
              } catch {
              }
              if (!Ft)
                return Sg(Le ? St.call(mc, x, () => J) : x + J, ge, at);
            }
            throw _l(he, x, ge, Ue, Oe);
          }
          if (hg.exec(x.slice(2)) !== null) {
            if (mg.exec(x.slice(2)) !== null)
              throw _l(he, x, ge, Ue, Oe);
            if (!qe) {
              const Ft = Le ? he.replace("*", () => J) : he + J;
              bg(Le ? St.call(mc, x, () => J) : x, Ft, he, ge, Ue, Oe, !0);
            }
          }
          const gt = new kt.URL(x, ge), ot = gt.pathname, Lt = new kt.URL(".", ge).pathname;
          if (!ot.startsWith(Lt))
            throw _l(he, x, ge, Ue, Oe);
          if (J === "")
            return gt;
          if (hg.exec(J) !== null) {
            const Ft = Le ? he.replace("*", () => J) : he + J;
            mg.exec(J) === null ? qe || bg(Le ? St.call(mc, x, () => J) : x, Ft, he, ge, Ue, Oe, !1) : function(ar, Er, Qr, gn, Nr) {
              const _a = `request is not a valid match in pattern "${Er}" for the "${gn ? "imports" : "exports"}" resolution of ${(0, kt.fileURLToPath)(Qr)}`;
              throw new Cr(ar, _a, Nr && (0, kt.fileURLToPath)(Nr));
            }(Ft, he, ge, Ue, Oe);
          }
          return Le ? new kt.URL(St.call(mc, gt.href, () => J)) : new kt.URL(J, gt);
        }
        function WI(x) {
          const J = Number(x);
          return `${J}` === x && J >= 0 && J < 4294967295;
        }
        function io(x, J, he, ge, Oe, Le, Ue, qe, at) {
          if (typeof J == "string")
            return VI(J, he, ge, x, Oe, Le, Ue, qe, at);
          if (Array.isArray(J)) {
            const gt = J;
            if (gt.length === 0)
              return null;
            let ot, Lt = -1;
            for (; ++Lt < gt.length; ) {
              const Ft = gt[Lt];
              let ar;
              try {
                ar = io(x, Ft, he, ge, Oe, Le, Ue, qe, at);
              } catch (Er) {
                if (ot = Er, Er.code === "ERR_INVALID_PACKAGE_TARGET")
                  continue;
                throw Er;
              }
              if (ar !== void 0) {
                if (ar !== null)
                  return ar;
                ot = null;
              }
            }
            if (ot == null)
              return null;
            throw ot;
          }
          if (typeof J == "object" && J !== null) {
            const gt = Object.getOwnPropertyNames(J);
            let ot = -1;
            for (; ++ot < gt.length; )
              if (WI(gt[ot]))
                throw new nr((0, kt.fileURLToPath)(x), Oe, '"exports" cannot contain numeric property keys.');
            for (ot = -1; ++ot < gt.length; ) {
              const Lt = gt[ot];
              if (Lt === "default" || at && at.has(Lt)) {
                const Ft = io(x, J[Lt], he, ge, Oe, Le, Ue, qe, at);
                if (Ft === void 0)
                  continue;
                return Ft;
              }
            }
            return null;
          }
          if (J === null)
            return null;
          throw _l(ge, J, x, Ue, Oe);
        }
        function HI(x, J, he) {
          const ge = (0, kt.fileURLToPath)(J);
          yg.has(ge + "|" + x) || (yg.add(ge + "|" + x), Hs.emitWarning(`Use of deprecated trailing slash pattern mapping "${x}" in the "exports" field module resolution of the package at ${ge}${he ? ` imported from ${(0, kt.fileURLToPath)(he)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`, "DeprecationWarning", "DEP0155"));
        }
        function Eg(x, J, he, ge, Oe) {
          let Le = he.exports;
          if (function(ot, Lt, Ft) {
            if (typeof ot == "string" || Array.isArray(ot))
              return !0;
            if (typeof ot != "object" || ot === null)
              return !1;
            const ar = Object.getOwnPropertyNames(ot);
            let Er = !1, Qr = 0, gn = -1;
            for (; ++gn < ar.length; ) {
              const Nr = ar[gn], _a = Nr === "" || Nr[0] !== ".";
              if (Qr++ == 0)
                Er = _a;
              else if (Er !== _a)
                throw new nr((0, kt.fileURLToPath)(Lt), Ft, `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`);
            }
            return Er;
          }(Le, x, ge) && (Le = { ".": Le }), pg.call(Le, J) && !J.includes("*") && !J.endsWith("/")) {
            const ot = io(x, Le[J], "", J, ge, !1, !1, !1, Oe);
            if (ot == null)
              throw jp(J, x, ge);
            return ot;
          }
          let Ue = "", qe = "";
          const at = Object.getOwnPropertyNames(Le);
          let gt = -1;
          for (; ++gt < at.length; ) {
            const ot = at[gt], Lt = ot.indexOf("*");
            if (Lt !== -1 && J.startsWith(ot.slice(0, Lt))) {
              J.endsWith("/") && HI(J, x, ge);
              const Ft = ot.slice(Lt + 1);
              J.length >= ot.length && J.endsWith(Ft) && _g(Ue, ot) === 1 && ot.lastIndexOf("*") === Lt && (Ue = ot, qe = J.slice(Lt, J.length - Ft.length));
            }
          }
          if (Ue) {
            const ot = io(x, Le[Ue], qe, Ue, ge, !0, !1, J.endsWith("/"), Oe);
            if (ot == null)
              throw jp(J, x, ge);
            return ot;
          }
          throw jp(J, x, ge);
        }
        function _g(x, J) {
          const he = x.indexOf("*"), ge = J.indexOf("*"), Oe = he === -1 ? x.length : he + 1, Le = ge === -1 ? J.length : ge + 1;
          return Oe > Le ? -1 : Le > Oe || he === -1 ? 1 : ge === -1 || x.length > J.length ? -1 : J.length > x.length ? 1 : 0;
        }
        function qI(x, J, he) {
          if (x === "#" || x.startsWith("#/") || x.endsWith("/"))
            throw new Cr(x, "is not a valid internal imports specifier name", (0, kt.fileURLToPath)(J));
          let ge;
          const Oe = Pe(J);
          if (Oe.exists) {
            ge = (0, kt.pathToFileURL)(Oe.pjsonPath);
            const Le = Oe.imports;
            if (Le)
              if (pg.call(Le, x) && !x.includes("*")) {
                const Ue = io(ge, Le[x], "", x, J, !1, !0, !1, he);
                if (Ue != null)
                  return Ue;
              } else {
                let Ue = "", qe = "";
                const at = Object.getOwnPropertyNames(Le);
                let gt = -1;
                for (; ++gt < at.length; ) {
                  const ot = at[gt], Lt = ot.indexOf("*");
                  if (Lt !== -1 && x.startsWith(ot.slice(0, -1))) {
                    const Ft = ot.slice(Lt + 1);
                    x.length >= ot.length && x.endsWith(Ft) && _g(Ue, ot) === 1 && ot.lastIndexOf("*") === Lt && (Ue = ot, qe = x.slice(Lt, x.length - Ft.length));
                  }
                }
                if (Ue) {
                  const ot = io(ge, Le[Ue], qe, Ue, J, !0, !0, !1, he);
                  if (ot != null)
                    return ot;
                }
              }
          }
          throw function(Le, Ue, qe) {
            return new Mp(Le, Ue && (0, kt.fileURLToPath)(new kt.URL(".", Ue)), (0, kt.fileURLToPath)(qe));
          }(x, ge, J);
        }
        function Sg(x, J, he) {
          if (uc.builtinModules.includes(x))
            return new kt.URL("node:" + x);
          const { packageName: ge, packageSubpath: Oe, isScoped: Le } = function(ot, Lt) {
            let Ft = ot.indexOf("/"), ar = !0, Er = !1;
            ot[0] === "@" && (Er = !0, Ft === -1 || ot.length === 0 ? ar = !1 : Ft = ot.indexOf("/", Ft + 1));
            const Qr = Ft === -1 ? ot : ot.slice(0, Ft);
            if (FI.exec(Qr) !== null && (ar = !1), !ar)
              throw new Cr(ot, "is not a valid package name", (0, kt.fileURLToPath)(Lt));
            return { packageName: Qr, packageSubpath: "." + (Ft === -1 ? "" : ot.slice(Ft)), isScoped: Er };
          }(x, J), Ue = Pe(J);
          if (Ue.exists) {
            const ot = (0, kt.pathToFileURL)(Ue.pjsonPath);
            if (Ue.name === ge && Ue.exports !== void 0 && Ue.exports !== null)
              return Eg(ot, Oe, Ue, J, he);
          }
          let qe, at = new kt.URL("./node_modules/" + ge + "/package.json", J), gt = (0, kt.fileURLToPath)(at);
          do {
            if (!vg(gt.slice(0, -13)).isDirectory()) {
              qe = gt, at = new kt.URL((Le ? "../../../../node_modules/" : "../../../node_modules/") + ge + "/package.json", at), gt = (0, kt.fileURLToPath)(at);
              continue;
            }
            const ot = Se(gt, x, J);
            return ot.exports !== void 0 && ot.exports !== null ? Eg(at, Oe, ot, J, he) : Oe === "." ? UI(at, ot, J) : new kt.URL(Oe, at);
          } while (gt.length !== qe.length);
          throw new nn(ge, (0, kt.fileURLToPath)(J));
        }
        function GI(x, J, he, ge) {
          const Oe = J.protocol, Le = Oe === "http:" || Oe === "https:";
          let Ue;
          if (function(qe) {
            return qe !== "" && (qe[0] === "/" || function(at) {
              return at[0] === "." && (at.length === 1 || at[1] === "/" || at[1] === "." && (at.length === 2 || at[2] === "/"));
            }(qe));
          }(x))
            Ue = new kt.URL(x, J);
          else if (Le || x[0] !== "#")
            try {
              Ue = new kt.URL(x);
            } catch {
              Le || (Ue = Sg(x, J, he));
            }
          else
            Ue = qI(x, J, he);
          return Ii(Ue !== void 0, "expected to be defined"), Ue.protocol !== "file:" ? Ue : function(qe, at, gt) {
            if (BI.exec(qe.pathname) !== null)
              throw new Cr(qe.pathname, 'must not include encoded "/" or "\\" characters', (0, kt.fileURLToPath)(at));
            const ot = (0, kt.fileURLToPath)(qe), Lt = vg(ot.endsWith("/") ? ot.slice(-1) : ot);
            if (Lt.isDirectory()) {
              const Ft = new jI(ot, (0, kt.fileURLToPath)(at));
              throw Ft.url = String(qe), Ft;
            }
            if (!Lt.isFile())
              throw new nn(ot || qe.pathname, at && (0, kt.fileURLToPath)(at), "module");
            if (!gt) {
              const Ft = (0, Xi.realpathSync)(ot), { search: ar, hash: Er } = qe;
              (qe = (0, kt.pathToFileURL)(Ft + (ot.endsWith(va.sep) ? "/" : ""))).search = ar, qe.hash = Er;
            }
            return qe;
          }(Ue, J, ge);
        }
        function Fp(x) {
          return typeof x != "string" || x.startsWith("file://") ? Ea((0, kt.fileURLToPath)(x)) : Ea(x);
        }
        const zI = /* @__PURE__ */ new Set(["node", "import"]), KI = (0, kt.pathToFileURL)(Ve.process.cwd()), YI = [".mjs", ".cjs", ".js", ".json"], XI = /* @__PURE__ */ new Set(["ERR_MODULE_NOT_FOUND", "ERR_UNSUPPORTED_DIR_IMPORT", "MODULE_NOT_FOUND", "ERR_PACKAGE_PATH_NOT_EXPORTED"]);
        function wg(x, J, he) {
          try {
            return GI(x, J, he);
          } catch (ge) {
            if (!XI.has(ge.code))
              throw ge;
          }
        }
        function JI(x, J = {}) {
          if (/(node|data|http|https):/.test(x))
            return x;
          if (hc.has(x))
            return "node:" + x;
          if (g(x) && (0, Xi.existsSync)(x)) {
            const qe = (0, Xi.realpathSync)(Fp(x));
            return (0, kt.pathToFileURL)(qe).toString();
          }
          const he = J.conditions ? new Set(J.conditions) : zI, ge = (Array.isArray(J.url) ? J.url : [J.url]).filter(Boolean).map((qe) => new URL(function(at) {
            return typeof at != "string" && (at = at.toString()), /(node|data|http|https|file):/.test(at) ? at : hc.has(at) ? "node:" + at : "file://" + encodeURI(Ea(at));
          }(qe.toString())));
          ge.length === 0 && ge.push(KI);
          const Oe = [...ge];
          for (const qe of ge)
            qe.protocol === "file:" && Oe.push(new URL("./", qe), new URL(pc(qe.pathname, "_index.js"), qe), new URL("node_modules", qe));
          let Le;
          for (const qe of Oe) {
            if (Le = wg(x, qe, he), Le)
              break;
            for (const at of ["", "/index"]) {
              for (const gt of J.extensions || YI)
                if (Le = wg(x + at + gt, qe, he), Le)
                  break;
              if (Le)
                break;
            }
            if (Le)
              break;
          }
          if (!Le) {
            const qe = new Error(`Cannot find module ${x} imported from ${Oe.join(", ")}`);
            throw qe.code = "ERR_MODULE_NOT_FOUND", qe;
          }
          const Ue = (0, Xi.realpathSync)(Fp(Le));
          return (0, kt.pathToFileURL)(Ue).toString();
        }
        function QI(x, J) {
          return JI(x, J);
        }
        function ZI(x, J) {
          return Fp(QI(x, J));
        }
        const eO = /([\s;]|^)(import[\s\w*,{}]*from|import\s*["'*{]|export\b\s*(?:[*{]|default|class|type|function|const|var|let|async function)|import\.meta\b)/m;
        function tO(x) {
          return eO.test(x);
        }
        var rO = a("crypto");
        function Tg(x, J = 8) {
          return (0, rO.createHash)("md5").update(x).digest("hex").slice(0, J);
        }
        const nO = _(Ve.process.env.JITI_DEBUG), Ag = _(Ve.process.env.JITI_CACHE), iO = _(Ve.process.env.JITI_ESM_RESOLVE), xg = _(Ve.process.env.JITI_REQUIRE_CACHE), Pg = _(Ve.process.env.JITI_SOURCE_MAPS), sO = _(Ve.process.env.JITI_ALIAS), aO = _(Ve.process.env.JITI_TRANSFORM_MODULES), oO = _(Ve.process.env.JITI_NATIVE_MODULES), Cg = _(Ve.process.env.JITI_EXPERIMENTAL_BUN), lO = (0, i.platform)() === "win32", uO = { debug: nO, cache: Ag === void 0 || !!Ag, requireCache: xg === void 0 || !!xg, sourceMaps: Pg !== void 0 && !!Pg, interopDefault: !1, esmResolve: iO || !1, cacheVersion: "7", legacy: (0, O.lt)(Ve.process.version || "0.0.0", "14.0.0"), extensions: [".js", ".mjs", ".cjs", ".ts", ".mts", ".cts", ".json"], alias: sO, nativeModules: oO || [], transformModules: aO || [], experimentalBun: Cg === void 0 ? !!Ve.process.versions.bun : !!Cg }, cO = /\.(c|m)?j(sx?)$/, fO = /\.(c|m)?t(sx?)$/;
        function Ig(x, J = {}, he, ge) {
          (J = Object.assign(Object.assign({}, uO), J)).legacy && (J.cacheVersion += "-legacy"), J.transformOptions && (J.cacheVersion += "-" + k()(J.transformOptions));
          const Oe = J.alias && Object.keys(J.alias).length > 0 ? U(J.alias || {}) : null, Le = ["typescript", "jiti", ...J.nativeModules || []], Ue = [...J.transformModules || []], qe = new RegExp(`node_modules/(${Le.map((It) => T(It)).join("|")})/`), at = new RegExp(`node_modules/(${Ue.map((It) => T(It)).join("|")})/`);
          function gt(...It) {
            J.debug && console.log("[jiti]", ...It);
          }
          if (x || (x = Ve.process.cwd()), function(It) {
            try {
              return (0, u.lstatSync)(It).isDirectory();
            } catch {
              return !1;
            }
          }(x) && (x = E(x, "index.js")), J.cache === !0 && (J.cache = function() {
            let It = (0, i.tmpdir)();
            if (Ve.process.env.TMPDIR && It === Ve.process.cwd() && !Ve.process.env.JITI_RESPECT_TMPDIR_ENV) {
              const tr = Ve.process.env.TMPDIR;
              delete Ve.process.env.TMPDIR, It = (0, i.tmpdir)(), Ve.process.env.TMPDIR = tr;
            }
            return E(It, "node-jiti");
          }()), J.cache)
            try {
              if ((0, u.mkdirSync)(J.cache, { recursive: !0 }), !function(It) {
                try {
                  return (0, u.accessSync)(It, u.constants.W_OK), !0;
                } catch {
                  return !1;
                }
              }(J.cache))
                throw new Error("directory is not writable");
            } catch (It) {
              gt("Error creating cache directory at ", J.cache, It), J.cache = !1;
            }
          const ot = w()(lO ? x.replace(/\//g, "\\") : x), Lt = (It, tr) => {
            try {
              return ot.resolve(It, tr);
            } catch {
            }
          }, Ft = (0, s.pathToFileURL)(x), ar = [...J.extensions].filter((It) => It !== ".js"), Er = (It, tr) => {
            let lr, Rr;
            if (Oe && (It = function(Vt, Hr) {
              const Zr = o(Vt);
              Hr = U(Hr);
              for (const Gn in Hr)
                if (Zr.startsWith(Gn) && G.has(Zr[Gn.length]))
                  return E(Hr[Gn], Zr.slice(Gn.length));
              return Zr;
            }(It, Oe)), J.esmResolve) {
              const Vt = [["node", "require"], ["node", "import"]];
              for (const Hr of Vt) {
                try {
                  lr = ZI(It, { url: Ft, conditions: Hr, extensions: J.extensions });
                } catch (Zr) {
                  Rr = Zr;
                }
                if (lr)
                  return lr;
              }
            }
            try {
              return ot.resolve(It, tr);
            } catch (Vt) {
              Rr = Vt;
            }
            for (const Vt of ar)
              if (lr = Lt(It + Vt, tr) || Lt(It + "/index" + Vt, tr), lr || fO.test((he == null ? void 0 : he.filename) || "") && (lr = Lt(It.replace(cO, ".$1t$2"), tr), lr))
                return lr;
            throw Rr;
          };
          function Qr(It) {
            let tr = function(lr, Rr, Vt) {
              if (!J.cache || !lr)
                return Vt();
              const Hr = ` /* v${J.cacheVersion}-${Tg(Rr, 16)} */`, Zr = C(N(lr)) + "-" + C(lr), Gn = E(J.cache, Zr + "." + Tg(lr) + ".js");
              if ((0, u.existsSync)(Gn)) {
                const yc = (0, u.readFileSync)(Gn, "utf8");
                if (yc.endsWith(Hr))
                  return gt("[cache hit]", lr, "~>", Gn), yc;
              }
              gt("[cache miss]", lr);
              const so = Vt();
              return so.includes("__JITI_ERROR__") || (0, u.writeFileSync)(Gn, so + Hr, "utf8"), so;
            }(It.filename, It.source, () => {
              var lr;
              const Rr = J.transform(Object.assign(Object.assign(Object.assign({ legacy: J.legacy }, J.transformOptions), { babel: Object.assign(Object.assign({}, J.sourceMaps ? { sourceFileName: It.filename, sourceMaps: "inline" } : {}), (lr = J.transformOptions) === null || lr === void 0 ? void 0 : lr.babel) }), It));
              return Rr.error && J.debug && gt(Rr.error), Rr.code;
            });
            return tr.startsWith("#!") && (tr = "// " + tr), tr;
          }
          function gn(It) {
            return J.interopDefault ? function(tr) {
              if ((lr = tr) === null || typeof lr != "object" || !("default" in tr))
                return tr;
              var lr;
              const Rr = tr.default;
              for (const Vt in tr)
                if (Vt === "default")
                  try {
                    Vt in Rr || Object.defineProperty(Rr, Vt, { enumerable: !1, configurable: !1, get: () => Rr });
                  } catch {
                  }
                else
                  try {
                    Vt in Rr || Object.defineProperty(Rr, Vt, { enumerable: !0, configurable: !0, get: () => tr[Vt] });
                  } catch {
                  }
              return Rr;
            }(It) : It;
          }
          function Nr(It) {
            var tr, lr;
            const Rr = ge || {};
            if (It.startsWith("node:") ? It = It.slice(5) : It.startsWith("file:") && (It = (0, s.fileURLToPath)(It)), r.builtinModules.includes(It) || It === ".pnp.js")
              return ot(It);
            if (J.experimentalBun && !J.transformOptions)
              try {
                gt(`[bun] [native] ${It}`);
                const Zr = ot(It);
                return J.requireCache === !1 && delete ot.cache[It], gn(Zr);
              } catch (Zr) {
                gt(`[bun] Using fallback for ${It} because of an error:`, Zr);
              }
            const Vt = Er(It), Hr = R(Vt);
            if (Hr === ".json") {
              gt("[json]", Vt);
              const Zr = ot(It);
              return Object.defineProperty(Zr, "default", { value: Zr }), Zr;
            }
            return Hr && !J.extensions.includes(Hr) ? (gt("[unknown]", Vt), ot(It)) : qe.test(Vt) ? (gt("[native]", Vt), ot(It)) : Rr[Vt] ? gn((tr = Rr[Vt]) === null || tr === void 0 ? void 0 : tr.exports) : J.requireCache && ot.cache[Vt] ? gn((lr = ot.cache[Vt]) === null || lr === void 0 ? void 0 : lr.exports) : _a((0, u.readFileSync)(Vt, "utf8"), { id: It, filename: Vt, ext: Hr, cache: Rr });
          }
          function _a(It, tr = {}) {
            var lr;
            const Rr = tr.id || (tr.filename ? C(tr.filename) : `_jitiEval.${tr.ext || ".js"}`), Vt = tr.filename || Er(Rr), Hr = tr.ext || R(Vt), Zr = tr.cache || ge || {}, Gn = Hr === ".ts" || Hr === ".mts" || Hr === ".cts", so = Hr === ".mjs" || Hr === ".js" && ((lr = function(Fn) {
              for (; Fn && Fn !== "." && Fn !== "/"; ) {
                Fn = E(Fn, "..");
                try {
                  const bc = (0, u.readFileSync)(E(Fn, "package.json"), "utf8");
                  try {
                    return JSON.parse(bc);
                  } catch {
                  }
                  break;
                } catch {
                }
              }
            }(Vt)) === null || lr === void 0 ? void 0 : lr.type) === "module", yc = Hr !== ".cjs" && (Gn || so || at.test(Vt) || tO(It) || J.legacy && It.match(/\?\.|\?\?/)), dO = l.performance.now();
            if (yc)
              It = Qr({ filename: Vt, source: It, ts: Gn }), gt("[transpile]" + (so ? " [esm]" : ""), Vt, `(${Math.round(1e3 * (l.performance.now() - dO)) / 1e3}ms)`);
            else
              try {
                return gt("[native]", Vt), gn(ot(Rr));
              } catch (Fn) {
                gt("Native require error:", Fn), gt("[fallback]", Vt), It = Qr({ filename: Vt, source: It, ts: Gn });
              }
            const qr = new r.Module(Vt);
            let Og;
            qr.filename = Vt, he && (qr.parent = he, Array.isArray(he.children) && !he.children.includes(qr) && he.children.push(qr)), qr.require = Ig(Vt, J, qr, Zr), qr.path = N(Vt), qr.paths = r.Module._nodeModulePaths(qr.path), Zr[Vt] = qr, J.requireCache && (ot.cache[Vt] = qr);
            try {
              Og = d().runInThisContext(r.Module.wrap(It), { filename: Vt, lineOffset: 0, displayErrors: !1 });
            } catch (Fn) {
              J.requireCache && delete ot.cache[Vt], J.onError(Fn);
            }
            try {
              Og(qr.exports, qr.require, qr, qr.filename, N(qr.filename));
            } catch (Fn) {
              J.requireCache && delete ot.cache[Vt], J.onError(Fn);
            }
            if (qr.exports && qr.exports.__JITI_ERROR__) {
              const { filename: Fn, line: bc, column: kg, code: pO, message: hO } = qr.exports.__JITI_ERROR__, Dg = new Error(`${pO}: ${hO} 
 ${`${Fn}:${bc}:${kg}`}`);
              Error.captureStackTrace(Dg, Nr), J.onError(Dg);
            }
            return qr.loaded = !0, gn(qr.exports);
          }
          return Er.paths = ot.resolve.paths, Nr.resolve = Er, Nr.cache = J.requireCache ? ot.cache : {}, Nr.extensions = ot.extensions, Nr.main = ot.main, Nr.transform = Qr, Nr.register = function() {
            return (0, M.addHook)((It, tr) => Nr.transform({ source: It, filename: tr, ts: !!/\.[cm]?ts$/.test(tr) }), { exts: J.extensions });
          }, Nr.evalModule = _a, Nr;
        }
      })(), t.exports = c.default;
    })();
  }(_m)), _m.exports;
}
var Sm = { exports: {} }, jl = {}, Z_;
function $H() {
  if (Z_)
    return jl;
  Z_ = 1, jl.isatty = function() {
    return !1;
  };
  function t() {
    throw new Error("tty.ReadStream is not implemented");
  }
  jl.ReadStream = t;
  function e() {
    throw new Error("tty.WriteStream is not implemented");
  }
  return jl.WriteStream = e, jl;
}
var eS;
function UH() {
  return eS || (eS = 1, function(t) {
    (() => {
      var e = { "./node_modules/.pnpm/@ampproject+remapping@2.2.1/node_modules/@ampproject/remapping/dist/remapping.umd.js": function(u, r, l) {
        u.exports = function(i, f) {
          const d = o("", -1, -1, "", null), s = [];
          function o(C, I, D, j, F) {
            return { source: C, line: I, column: D, name: j, content: F };
          }
          function m(C, I, D, j) {
            return { map: C, sources: I, source: D, content: j };
          }
          function h(C, I) {
            return m(C, I, "", null);
          }
          function y(C, I) {
            return m(null, s, C, I);
          }
          function b(C) {
            const I = new f.GenMapping({ file: C.map.file }), { sources: D, map: j } = C, F = j.names, _ = i.decodedMappings(j);
            for (let T = 0; T < _.length; T++) {
              const v = _[T];
              for (let w = 0; w < v.length; w++) {
                const O = v[w], G = O[0];
                let W = d;
                if (O.length !== 1 && (W = E(D[O[1]], O[2], O[3], O.length === 5 ? F[O[4]] : ""), W == null))
                  continue;
                const { column: U, line: M, name: B, content: k, source: K } = W;
                f.maybeAddSegment(I, T, G, K, M, U, B), K && k != null && f.setSourceContent(I, K, k);
              }
            }
            return I;
          }
          function E(C, I, D, j) {
            if (!C.map)
              return o(C.source, I, D, j, C.content);
            const F = i.traceSegment(C.map, I, D);
            return F == null ? null : F.length === 1 ? d : E(C.sources[F[1]], F[2], F[3], F.length === 5 ? C.map.names[F[4]] : j);
          }
          function S(C) {
            return Array.isArray(C) ? C : [C];
          }
          function g(C, I) {
            const D = S(C).map((_) => new i.TraceMap(_, "")), j = D.pop();
            for (let _ = 0; _ < D.length; _++)
              if (D[_].sources.length > 1)
                throw new Error(`Transformation map ${_} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
            let F = P(j, I, "", 0);
            for (let _ = D.length - 1; _ >= 0; _--)
              F = h(D[_], [F]);
            return F;
          }
          function P(C, I, D, j) {
            const { resolvedSources: F, sourcesContent: _ } = C, T = j + 1;
            return h(C, F.map((v, w) => {
              const O = { importer: D, depth: T, source: v || "", content: void 0 }, G = I(O.source, O), { source: W, content: U } = O;
              return G ? P(new i.TraceMap(G, W), I, W, T) : y(W, U !== void 0 ? U : _ ? _[w] : null);
            }));
          }
          class R {
            constructor(I, D) {
              const j = D.decodedMappings ? f.toDecodedMap(I) : f.toEncodedMap(I);
              this.version = j.version, this.file = j.file, this.mappings = j.mappings, this.names = j.names, this.sourceRoot = j.sourceRoot, this.sources = j.sources, D.excludeContent || (this.sourcesContent = j.sourcesContent);
            }
            toString() {
              return JSON.stringify(this);
            }
          }
          function N(C, I, D) {
            const j = typeof D == "object" ? D : { excludeContent: !!D, decodedMappings: !1 }, F = g(C, I);
            return new R(b(F), j);
          }
          return N;
        }(l("./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.19/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"), l("./node_modules/.pnpm/@jridgewell+gen-mapping@0.3.3/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"));
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files lazy recursive": (u) => {
        function r(l) {
          return Promise.resolve().then(() => {
            var i = new Error("Cannot find module '" + l + "'");
            throw i.code = "MODULE_NOT_FOUND", i;
          });
        }
        r.keys = () => [], r.resolve = r, r.id = "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files lazy recursive", u.exports = r;
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files sync recursive": (u) => {
        function r(l) {
          var i = new Error("Cannot find module '" + l + "'");
          throw i.code = "MODULE_NOT_FOUND", i;
        }
        r.keys = () => [], r.resolve = r, r.id = "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files sync recursive", u.exports = r;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-class-properties@7.12.13_@babel+core@7.22.15/node_modules/@babel/plugin-syntax-class-properties/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = (0, l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((f) => (f.assertVersion(7), { name: "syntax-class-properties", manipulateOptions(d, s) {
          s.plugins.push("classProperties", "classPrivateProperties", "classPrivateMethods");
        } }));
        r.default = i;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-export-namespace-from@7.8.3_@babel+core@7.22.15/node_modules/@babel/plugin-syntax-export-namespace-from/lib/index.js": (u, r, l) => {
        r.Z = void 0;
        var i = (0, l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((f) => (f.assertVersion(7), { name: "syntax-export-namespace-from", manipulateOptions(d, s) {
          s.plugins.push("exportNamespaceFrom");
        } }));
        r.Z = i;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-nullish-coalescing-operator@7.8.3_@babel+core@7.22.15/node_modules/@babel/plugin-syntax-nullish-coalescing-operator/lib/index.js": (u, r, l) => {
        r.Z = void 0;
        var i = (0, l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((f) => (f.assertVersion(7), { name: "syntax-nullish-coalescing-operator", manipulateOptions(d, s) {
          s.plugins.push("nullishCoalescingOperator");
        } }));
        r.Z = i;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-optional-chaining@7.8.3_@babel+core@7.22.15/node_modules/@babel/plugin-syntax-optional-chaining/lib/index.js": (u, r, l) => {
        r.Z = void 0;
        var i = (0, l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((f) => (f.assertVersion(7), { name: "syntax-optional-chaining", manipulateOptions(d, s) {
          s.plugins.push("optionalChaining");
        } }));
        r.Z = i;
      }, "./node_modules/.pnpm/@jridgewell+gen-mapping@0.3.3/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js": function(u, r, l) {
        (function(i, f, d, s) {
          let S;
          i.addSegment = void 0, i.addMapping = void 0, i.maybeAddSegment = void 0, i.maybeAddMapping = void 0, i.setSourceContent = void 0, i.toDecodedMap = void 0, i.toEncodedMap = void 0, i.fromMap = void 0, i.allMappings = void 0;
          class g {
            constructor({ file: T, sourceRoot: v } = {}) {
              this._names = new f.SetArray(), this._sources = new f.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = T, this.sourceRoot = v;
            }
          }
          function P(_, T) {
            for (let v = _.length; v <= T; v++)
              _[v] = [];
            return _[T];
          }
          function R(_, T) {
            let v = _.length;
            for (let w = v - 1; w >= 0 && !(T >= _[w][0]); v = w--)
              ;
            return v;
          }
          function N(_, T, v) {
            for (let w = _.length; w > T; w--)
              _[w] = _[w - 1];
            _[T] = v;
          }
          function C(_) {
            const { length: T } = _;
            let v = T;
            for (let w = v - 1; w >= 0 && !(_[w].length > 0); v = w, w--)
              ;
            v < T && (_.length = v);
          }
          function I(_, T) {
            for (let v = 0; v < T.length; v++)
              f.put(_, T[v]);
          }
          function D(_, T) {
            return T === 0 || _[T - 1].length === 1;
          }
          function j(_, T, v, w, O, G) {
            if (T === 0)
              return !1;
            const W = _[T - 1];
            return W.length !== 1 && v === W[1] && w === W[2] && O === W[3] && G === (W.length === 5 ? W[4] : -1);
          }
          function F(_, T, v) {
            const { generated: w, source: O, original: G, name: W, content: U } = v;
            if (!O)
              return S(_, T, w.line - 1, w.column, null, null, null, null, null);
            const M = O;
            return S(_, T, w.line - 1, w.column, M, G.line - 1, G.column, W, U);
          }
          i.addSegment = (_, T, v, w, O, G, W, U) => S(!1, _, T, v, w, O, G, W, U), i.maybeAddSegment = (_, T, v, w, O, G, W, U) => S(!0, _, T, v, w, O, G, W, U), i.addMapping = (_, T) => F(!1, _, T), i.maybeAddMapping = (_, T) => F(!0, _, T), i.setSourceContent = (_, T, v) => {
            const { _sources: w, _sourcesContent: O } = _;
            O[f.put(w, T)] = v;
          }, i.toDecodedMap = (_) => {
            const { file: T, sourceRoot: v, _mappings: w, _sources: O, _sourcesContent: G, _names: W } = _;
            return C(w), { version: 3, file: T || void 0, names: W.array, sourceRoot: v || void 0, sources: O.array, sourcesContent: G, mappings: w };
          }, i.toEncodedMap = (_) => {
            const T = i.toDecodedMap(_);
            return Object.assign(Object.assign({}, T), { mappings: d.encode(T.mappings) });
          }, i.allMappings = (_) => {
            const T = [], { _mappings: v, _sources: w, _names: O } = _;
            for (let G = 0; G < v.length; G++) {
              const W = v[G];
              for (let U = 0; U < W.length; U++) {
                const M = W[U], B = { line: G + 1, column: M[0] };
                let k, K, te;
                M.length !== 1 && (k = w.array[M[1]], K = { line: M[2] + 1, column: M[3] }, M.length === 5 && (te = O.array[M[4]])), T.push({ generated: B, source: k, original: K, name: te });
              }
            }
            return T;
          }, i.fromMap = (_) => {
            const T = new s.TraceMap(_), v = new g({ file: T.file, sourceRoot: T.sourceRoot });
            return I(v._names, T.names), I(v._sources, T.sources), v._sourcesContent = T.sourcesContent || T.sources.map(() => null), v._mappings = s.decodedMappings(T), v;
          }, S = (_, T, v, w, O, G, W, U, M) => {
            const { _mappings: B, _sources: k, _sourcesContent: K, _names: te } = T, z = P(B, v), q = R(z, w);
            if (!O)
              return _ && D(z, q) ? void 0 : N(z, q, [w]);
            const $ = f.put(k, O), Y = U ? f.put(te, U) : -1;
            if ($ === K.length && (K[$] = M ?? null), !_ || !j(z, q, $, G, W, Y))
              return N(z, q, U ? [w, $, G, W, Y] : [w, $, G, W]);
          }, i.GenMapping = g, Object.defineProperty(i, "__esModule", { value: !0 });
        })(r, l("./node_modules/.pnpm/@jridgewell+set-array@1.1.2/node_modules/@jridgewell/set-array/dist/set-array.umd.js"), l("./node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.15/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"), l("./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.19/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"));
      }, "./node_modules/.pnpm/@jridgewell+resolve-uri@3.1.1/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js": function(u) {
        u.exports = function() {
          const r = /^[\w+.-]+:\/\//, l = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, i = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
          var f;
          function d(C) {
            return r.test(C);
          }
          function s(C) {
            return C.startsWith("//");
          }
          function o(C) {
            return C.startsWith("/");
          }
          function m(C) {
            return C.startsWith("file:");
          }
          function h(C) {
            return /^[.?#]/.test(C);
          }
          function y(C) {
            const I = l.exec(C);
            return E(I[1], I[2] || "", I[3], I[4] || "", I[5] || "/", I[6] || "", I[7] || "");
          }
          function b(C) {
            const I = i.exec(C), D = I[2];
            return E("file:", "", I[1] || "", "", o(D) ? D : "/" + D, I[3] || "", I[4] || "");
          }
          function E(C, I, D, j, F, _, T) {
            return { scheme: C, user: I, host: D, port: j, path: F, query: _, hash: T, type: f.Absolute };
          }
          function S(C) {
            if (s(C)) {
              const D = y("http:" + C);
              return D.scheme = "", D.type = f.SchemeRelative, D;
            }
            if (o(C)) {
              const D = y("http://foo.com" + C);
              return D.scheme = "", D.host = "", D.type = f.AbsolutePath, D;
            }
            if (m(C))
              return b(C);
            if (d(C))
              return y(C);
            const I = y("http://foo.com/" + C);
            return I.scheme = "", I.host = "", I.type = C ? C.startsWith("?") ? f.Query : C.startsWith("#") ? f.Hash : f.RelativePath : f.Empty, I;
          }
          function g(C) {
            if (C.endsWith("/.."))
              return C;
            const I = C.lastIndexOf("/");
            return C.slice(0, I + 1);
          }
          function P(C, I) {
            R(I, I.type), C.path === "/" ? C.path = I.path : C.path = g(I.path) + C.path;
          }
          function R(C, I) {
            const D = I <= f.RelativePath, j = C.path.split("/");
            let F = 1, _ = 0, T = !1;
            for (let w = 1; w < j.length; w++) {
              const O = j[w];
              O ? (T = !1, O !== "." && (O !== ".." ? (j[F++] = O, _++) : _ ? (T = !0, _--, F--) : D && (j[F++] = O))) : T = !0;
            }
            let v = "";
            for (let w = 1; w < F; w++)
              v += "/" + j[w];
            (!v || T && !v.endsWith("/..")) && (v += "/"), C.path = v;
          }
          function N(C, I) {
            if (!C && !I)
              return "";
            const D = S(C);
            let j = D.type;
            if (I && j !== f.Absolute) {
              const _ = S(I), T = _.type;
              switch (j) {
                case f.Empty:
                  D.hash = _.hash;
                case f.Hash:
                  D.query = _.query;
                case f.Query:
                case f.RelativePath:
                  P(D, _);
                case f.AbsolutePath:
                  D.user = _.user, D.host = _.host, D.port = _.port;
                case f.SchemeRelative:
                  D.scheme = _.scheme;
              }
              T > j && (j = T);
            }
            R(D, j);
            const F = D.query + D.hash;
            switch (j) {
              case f.Hash:
              case f.Query:
                return F;
              case f.RelativePath: {
                const _ = D.path.slice(1);
                return _ ? h(I || C) && !h(_) ? "./" + _ + F : _ + F : F || ".";
              }
              case f.AbsolutePath:
                return D.path + F;
              default:
                return D.scheme + "//" + D.user + D.host + D.port + D.path + F;
            }
          }
          return function(C) {
            C[C.Empty = 1] = "Empty", C[C.Hash = 2] = "Hash", C[C.Query = 3] = "Query", C[C.RelativePath = 4] = "RelativePath", C[C.AbsolutePath = 5] = "AbsolutePath", C[C.SchemeRelative = 6] = "SchemeRelative", C[C.Absolute = 7] = "Absolute";
          }(f || (f = {})), N;
        }();
      }, "./node_modules/.pnpm/@jridgewell+set-array@1.1.2/node_modules/@jridgewell/set-array/dist/set-array.umd.js": function(u, r) {
        (function(l) {
          l.get = void 0, l.put = void 0, l.pop = void 0;
          class i {
            constructor() {
              this._indexes = { __proto__: null }, this.array = [];
            }
          }
          l.get = (f, d) => f._indexes[d], l.put = (f, d) => {
            const s = l.get(f, d);
            if (s !== void 0)
              return s;
            const { array: o, _indexes: m } = f;
            return m[d] = o.push(d) - 1;
          }, l.pop = (f) => {
            const { array: d, _indexes: s } = f;
            d.length !== 0 && (s[d.pop()] = void 0);
          }, l.SetArray = i, Object.defineProperty(l, "__esModule", { value: !0 });
        })(r);
      }, "./node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.15/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js": function(u, r) {
        (function(l) {
          const i = ",".charCodeAt(0), f = ";".charCodeAt(0), d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = new Uint8Array(64), o = new Uint8Array(128);
          for (let N = 0; N < d.length; N++) {
            const C = d.charCodeAt(N);
            s[N] = C, o[C] = N;
          }
          const m = typeof TextDecoder < "u" ? new TextDecoder() : typeof Ve.Buffer < "u" ? { decode: (N) => Ve.Buffer.from(N.buffer, N.byteOffset, N.byteLength).toString() } : { decode(N) {
            let C = "";
            for (let I = 0; I < N.length; I++)
              C += String.fromCharCode(N[I]);
            return C;
          } };
          function h(N) {
            const C = new Int32Array(5), I = [];
            let D = 0;
            do {
              const j = y(N, D), F = [];
              let _ = !0, T = 0;
              C[0] = 0;
              for (let v = D; v < j; v++) {
                let w;
                v = b(N, v, C, 0);
                const O = C[0];
                O < T && (_ = !1), T = O, E(N, v, j) ? (v = b(N, v, C, 1), v = b(N, v, C, 2), v = b(N, v, C, 3), E(N, v, j) ? (v = b(N, v, C, 4), w = [O, C[1], C[2], C[3], C[4]]) : w = [O, C[1], C[2], C[3]]) : w = [O], F.push(w);
              }
              _ || S(F), I.push(F), D = j + 1;
            } while (D <= N.length);
            return I;
          }
          function y(N, C) {
            const I = N.indexOf(";", C);
            return I === -1 ? N.length : I;
          }
          function b(N, C, I, D) {
            let j = 0, F = 0, _ = 0;
            do {
              const v = N.charCodeAt(C++);
              _ = o[v], j |= (31 & _) << F, F += 5;
            } while (32 & _);
            const T = 1 & j;
            return j >>>= 1, T && (j = -2147483648 | -j), I[D] += j, C;
          }
          function E(N, C, I) {
            return !(C >= I) && N.charCodeAt(C) !== i;
          }
          function S(N) {
            N.sort(g);
          }
          function g(N, C) {
            return N[0] - C[0];
          }
          function P(N) {
            const C = new Int32Array(5), I = 16384, D = I - 36, j = new Uint8Array(I), F = j.subarray(0, D);
            let _ = 0, T = "";
            for (let v = 0; v < N.length; v++) {
              const w = N[v];
              if (v > 0 && (_ === I && (T += m.decode(j), _ = 0), j[_++] = f), w.length !== 0) {
                C[0] = 0;
                for (let O = 0; O < w.length; O++) {
                  const G = w[O];
                  _ > D && (T += m.decode(F), j.copyWithin(0, D, _), _ -= D), O > 0 && (j[_++] = i), _ = R(j, _, C, G, 0), G.length !== 1 && (_ = R(j, _, C, G, 1), _ = R(j, _, C, G, 2), _ = R(j, _, C, G, 3), G.length !== 4 && (_ = R(j, _, C, G, 4)));
                }
              }
            }
            return T + m.decode(j.subarray(0, _));
          }
          function R(N, C, I, D, j) {
            const F = D[j];
            let _ = F - I[j];
            I[j] = F, _ = _ < 0 ? -_ << 1 | 1 : _ << 1;
            do {
              let T = 31 & _;
              _ >>>= 5, _ > 0 && (T |= 32), N[C++] = s[T];
            } while (_ > 0);
            return C;
          }
          l.decode = h, l.encode = P, Object.defineProperty(l, "__esModule", { value: !0 });
        })(r);
      }, "./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.19/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js": function(u, r, l) {
        (function(i, f, d) {
          function s(de) {
            return de && typeof de == "object" && "default" in de ? de : { default: de };
          }
          var o = s(d);
          function m(de, oe) {
            return oe && !oe.endsWith("/") && (oe += "/"), o.default(de, oe);
          }
          function h(de) {
            if (!de)
              return "";
            const oe = de.lastIndexOf("/");
            return de.slice(0, oe + 1);
          }
          const y = 0, b = 1, E = 2, S = 3, g = 4, P = 1, R = 2;
          function N(de, oe) {
            const re = C(de, 0);
            if (re === de.length)
              return de;
            oe || (de = de.slice());
            for (let ae = re; ae < de.length; ae = C(de, ae + 1))
              de[ae] = D(de[ae], oe);
            return de;
          }
          function C(de, oe) {
            for (let re = oe; re < de.length; re++)
              if (!I(de[re]))
                return re;
            return de.length;
          }
          function I(de) {
            for (let oe = 1; oe < de.length; oe++)
              if (de[oe][y] < de[oe - 1][y])
                return !1;
            return !0;
          }
          function D(de, oe) {
            return oe || (de = de.slice()), de.sort(j);
          }
          function j(de, oe) {
            return de[y] - oe[y];
          }
          let F = !1;
          function _(de, oe, re, ae) {
            for (; re <= ae; ) {
              const le = re + (ae - re >> 1), ue = de[le][y] - oe;
              if (ue === 0)
                return F = !0, le;
              ue < 0 ? re = le + 1 : ae = le - 1;
            }
            return F = !1, re - 1;
          }
          function T(de, oe, re) {
            for (let ae = re + 1; ae < de.length && de[ae][y] === oe; re = ae++)
              ;
            return re;
          }
          function v(de, oe, re) {
            for (let ae = re - 1; ae >= 0 && de[ae][y] === oe; re = ae--)
              ;
            return re;
          }
          function w() {
            return { lastKey: -1, lastNeedle: -1, lastIndex: -1 };
          }
          function O(de, oe, re, ae) {
            const { lastKey: le, lastNeedle: ue, lastIndex: ie } = re;
            let we = 0, De = de.length - 1;
            if (ae === le) {
              if (oe === ue)
                return F = ie !== -1 && de[ie][y] === oe, ie;
              oe >= ue ? we = ie === -1 ? 0 : ie : De = ie;
            }
            return re.lastKey = ae, re.lastNeedle = oe, re.lastIndex = _(de, oe, we, De);
          }
          function G(de, oe) {
            const re = oe.map(U);
            for (let ae = 0; ae < de.length; ae++) {
              const le = de[ae];
              for (let ue = 0; ue < le.length; ue++) {
                const ie = le[ue];
                if (ie.length === 1)
                  continue;
                const we = ie[b], De = ie[E], Ee = ie[S], Ae = re[we], Me = Ae[De] || (Ae[De] = []), me = oe[we], se = T(Me, Ee, O(Me, Ee, me, De));
                W(Me, me.lastIndex = se + 1, [Ee, ae, ie[y]]);
              }
            }
            return re;
          }
          function W(de, oe, re) {
            for (let ae = de.length; ae > oe; ae--)
              de[ae] = de[ae - 1];
            de[oe] = re;
          }
          function U() {
            return { __proto__: null };
          }
          const M = function(de, oe) {
            const re = typeof de == "string" ? JSON.parse(de) : de;
            if (!("sections" in re))
              return new H(re, oe);
            const ae = [], le = [], ue = [], ie = [];
            B(re, oe, ae, le, ue, ie, 0, 0, 1 / 0, 1 / 0);
            const we = { version: 3, file: re.file, names: ie, sources: le, sourcesContent: ue, mappings: ae };
            return i.presortedDecodedMap(we);
          };
          function B(de, oe, re, ae, le, ue, ie, we, De, Ee) {
            const { sections: Ae } = de;
            for (let Me = 0; Me < Ae.length; Me++) {
              const { map: me, offset: se } = Ae[Me];
              let Z = De, pe = Ee;
              if (Me + 1 < Ae.length) {
                const be = Ae[Me + 1].offset;
                Z = Math.min(De, ie + be.line), Z === De ? pe = Math.min(Ee, we + be.column) : Z < De && (pe = we + be.column);
              }
              k(me, oe, re, ae, le, ue, ie + se.line, we + se.column, Z, pe);
            }
          }
          function k(de, oe, re, ae, le, ue, ie, we, De, Ee) {
            if ("sections" in de)
              return B(...arguments);
            const Ae = new H(de, oe), Me = ae.length, me = ue.length, se = i.decodedMappings(Ae), { resolvedSources: Z, sourcesContent: pe } = Ae;
            if (K(ae, Z), K(ue, Ae.names), pe)
              K(le, pe);
            else
              for (let be = 0; be < Z.length; be++)
                le.push(null);
            for (let be = 0; be < se.length; be++) {
              const _e = ie + be;
              if (_e > De)
                return;
              const Ie = te(re, _e), We = be === 0 ? we : 0, tt = se[be];
              for (let Ye = 0; Ye < tt.length; Ye++) {
                const ht = tt[Ye], ct = We + ht[y];
                if (_e === De && ct >= Ee)
                  return;
                if (ht.length === 1) {
                  Ie.push([ct]);
                  continue;
                }
                const st = Me + ht[b], Xe = ht[E], Ke = ht[S];
                Ie.push(ht.length === 4 ? [ct, st, Xe, Ke] : [ct, st, Xe, Ke, me + ht[g]]);
              }
            }
          }
          function K(de, oe) {
            for (let re = 0; re < oe.length; re++)
              de.push(oe[re]);
          }
          function te(de, oe) {
            for (let re = de.length; re <= oe; re++)
              de[re] = [];
            return de[oe];
          }
          const z = "`line` must be greater than 0 (lines start at line 1)", q = "`column` must be greater than or equal to 0 (columns start at column 0)", $ = -1, Y = 1;
          i.encodedMappings = void 0, i.decodedMappings = void 0, i.traceSegment = void 0, i.originalPositionFor = void 0, i.generatedPositionFor = void 0, i.allGeneratedPositionsFor = void 0, i.eachMapping = void 0, i.sourceContentFor = void 0, i.presortedDecodedMap = void 0, i.decodedMap = void 0, i.encodedMap = void 0;
          class H {
            constructor(oe, re) {
              const ae = typeof oe == "string";
              if (!ae && oe._decodedMemo)
                return oe;
              const le = ae ? JSON.parse(oe) : oe, { version: ue, file: ie, names: we, sourceRoot: De, sources: Ee, sourcesContent: Ae } = le;
              this.version = ue, this.file = ie, this.names = we, this.sourceRoot = De, this.sources = Ee, this.sourcesContent = Ae;
              const Me = m(De || "", h(re));
              this.resolvedSources = Ee.map((se) => m(se || "", Me));
              const { mappings: me } = le;
              typeof me == "string" ? (this._encoded = me, this._decoded = void 0) : (this._encoded = void 0, this._decoded = N(me, ae)), this._decodedMemo = w(), this._bySources = void 0, this._bySourceMemos = void 0;
            }
          }
          function Q(de, oe) {
            return { version: de.version, file: de.file, names: de.names, sourceRoot: de.sourceRoot, sources: de.sources, sourcesContent: de.sourcesContent, mappings: oe };
          }
          function X(de, oe, re, ae) {
            return { source: de, line: oe, column: re, name: ae };
          }
          function ne(de, oe) {
            return { line: de, column: oe };
          }
          function ye(de, oe, re, ae, le) {
            let ue = O(de, ae, oe, re);
            return F ? ue = (le === $ ? T : v)(de, ae, ue) : le === $ && ue++, ue === -1 || ue === de.length ? -1 : ue;
          }
          function ve(de, oe, re, ae, le) {
            let ue = ye(de, oe, re, ae, Y);
            if (F || le !== $ || ue++, ue === -1 || ue === de.length)
              return [];
            const ie = F ? ae : de[ue][y];
            F || (ue = v(de, ie, ue));
            const we = T(de, ie, ue), De = [];
            for (; ue <= we; ue++) {
              const Ee = de[ue];
              De.push(ne(Ee[P] + 1, Ee[R]));
            }
            return De;
          }
          (() => {
            function de(oe, re, ae, le, ue, ie) {
              if (--ae < 0)
                throw new Error(z);
              if (le < 0)
                throw new Error(q);
              const { sources: we, resolvedSources: De } = oe;
              let Ee = we.indexOf(re);
              if (Ee === -1 && (Ee = De.indexOf(re)), Ee === -1)
                return ie ? [] : ne(null, null);
              const Ae = (oe._bySources || (oe._bySources = G(i.decodedMappings(oe), oe._bySourceMemos = we.map(w))))[Ee][ae];
              if (Ae == null)
                return ie ? [] : ne(null, null);
              const Me = oe._bySourceMemos[Ee];
              if (ie)
                return ve(Ae, Me, ae, le, ue);
              const me = ye(Ae, Me, ae, le, ue);
              if (me === -1)
                return ne(null, null);
              const se = Ae[me];
              return ne(se[P] + 1, se[R]);
            }
            i.encodedMappings = (oe) => {
              var re;
              return (re = oe._encoded) !== null && re !== void 0 ? re : oe._encoded = f.encode(oe._decoded);
            }, i.decodedMappings = (oe) => oe._decoded || (oe._decoded = f.decode(oe._encoded)), i.traceSegment = (oe, re, ae) => {
              const le = i.decodedMappings(oe);
              if (re >= le.length)
                return null;
              const ue = le[re], ie = ye(ue, oe._decodedMemo, re, ae, Y);
              return ie === -1 ? null : ue[ie];
            }, i.originalPositionFor = (oe, { line: re, column: ae, bias: le }) => {
              if (--re < 0)
                throw new Error(z);
              if (ae < 0)
                throw new Error(q);
              const ue = i.decodedMappings(oe);
              if (re >= ue.length)
                return X(null, null, null, null);
              const ie = ue[re], we = ye(ie, oe._decodedMemo, re, ae, le || Y);
              if (we === -1)
                return X(null, null, null, null);
              const De = ie[we];
              if (De.length === 1)
                return X(null, null, null, null);
              const { names: Ee, resolvedSources: Ae } = oe;
              return X(Ae[De[b]], De[E] + 1, De[S], De.length === 5 ? Ee[De[g]] : null);
            }, i.allGeneratedPositionsFor = (oe, { source: re, line: ae, column: le, bias: ue }) => de(oe, re, ae, le, ue || $, !0), i.generatedPositionFor = (oe, { source: re, line: ae, column: le, bias: ue }) => de(oe, re, ae, le, ue || Y, !1), i.eachMapping = (oe, re) => {
              const ae = i.decodedMappings(oe), { names: le, resolvedSources: ue } = oe;
              for (let ie = 0; ie < ae.length; ie++) {
                const we = ae[ie];
                for (let De = 0; De < we.length; De++) {
                  const Ee = we[De], Ae = ie + 1, Me = Ee[0];
                  let me = null, se = null, Z = null, pe = null;
                  Ee.length !== 1 && (me = ue[Ee[1]], se = Ee[2] + 1, Z = Ee[3]), Ee.length === 5 && (pe = le[Ee[4]]), re({ generatedLine: Ae, generatedColumn: Me, source: me, originalLine: se, originalColumn: Z, name: pe });
                }
              }
            }, i.sourceContentFor = (oe, re) => {
              const { sources: ae, resolvedSources: le, sourcesContent: ue } = oe;
              if (ue == null)
                return null;
              let ie = ae.indexOf(re);
              return ie === -1 && (ie = le.indexOf(re)), ie === -1 ? null : ue[ie];
            }, i.presortedDecodedMap = (oe, re) => {
              const ae = new H(Q(oe, []), re);
              return ae._decoded = oe.mappings, ae;
            }, i.decodedMap = (oe) => Q(oe, i.decodedMappings(oe)), i.encodedMap = (oe) => Q(oe, i.encodedMappings(oe));
          })(), i.AnyMap = M, i.GREATEST_LOWER_BOUND = Y, i.LEAST_UPPER_BOUND = $, i.TraceMap = H, Object.defineProperty(i, "__esModule", { value: !0 });
        })(r, l("./node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.15/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"), l("./node_modules/.pnpm/@jridgewell+resolve-uri@3.1.1/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"));
      }, "./node_modules/.pnpm/babel-plugin-dynamic-import-node@2.3.3/node_modules/babel-plugin-dynamic-import-node/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f) {
          var d = (0, i.createDynamicImportTransform)(f);
          return { manipulateOptions: function(s, o) {
            o.plugins.push("dynamicImport");
          }, visitor: { Import: function(s) {
            d(this, s);
          } } };
        };
        var i = l("./node_modules/.pnpm/babel-plugin-dynamic-import-node@2.3.3/node_modules/babel-plugin-dynamic-import-node/lib/utils.js");
        u.exports = r.default;
      }, "./node_modules/.pnpm/babel-plugin-dynamic-import-node@2.3.3/node_modules/babel-plugin-dynamic-import-node/lib/utils.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 });
        var l = function(f, d) {
          if (Array.isArray(f))
            return f;
          if (Symbol.iterator in Object(f))
            return function(s, o) {
              var m = [], h = !0, y = !1, b = void 0;
              try {
                for (var E, S = s[Symbol.iterator](); !(h = (E = S.next()).done) && (m.push(E.value), !o || m.length !== o); h = !0)
                  ;
              } catch (g) {
                y = !0, b = g;
              } finally {
                try {
                  !h && S.return && S.return();
                } finally {
                  if (y)
                    throw b;
                }
              }
              return m;
            }(f, d);
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
        function i(f, d) {
          var s = d.arguments, o = l(s, 1)[0];
          return f.isStringLiteral(o) || f.isTemplateLiteral(o) ? (f.removeComments(o), o) : f.templateLiteral([f.templateElement({ raw: "", cooked: "" }), f.templateElement({ raw: "", cooked: "" }, !0)], s);
        }
        r.getImportSource = i, r.createDynamicImportTransform = function(f) {
          var d = f.template, s = f.types, o = { static: { interop: d("Promise.resolve().then(() => INTEROP(require(SOURCE)))"), noInterop: d("Promise.resolve().then(() => require(SOURCE))") }, dynamic: { interop: d("Promise.resolve(SOURCE).then(s => INTEROP(require(s)))"), noInterop: d("Promise.resolve(SOURCE).then(s => require(s))") } }, m = typeof WeakSet == "function" && /* @__PURE__ */ new WeakSet();
          return function(h, y) {
            if (m) {
              if (m.has(y))
                return;
              m.add(y);
            }
            var b, E = i(s, y.parent), S = (b = E, s.isStringLiteral(b) || s.isTemplateLiteral(b) && b.expressions.length === 0 ? o.static : o.dynamic), g = h.opts.noInterop ? S.noInterop({ SOURCE: E }) : S.interop({ SOURCE: E, INTEROP: h.addHelper("interopRequireWildcard") });
            y.parentPath.replaceWith(g);
          };
        };
      }, "./node_modules/.pnpm/babel-plugin-parameter-decorator@1.0.16/node_modules/babel-plugin-parameter-decorator/lib/index.js": (u, r, l) => {
        var i = l("path");
        function f(d) {
          switch (d.parent.type) {
            case "TSTypeReference":
            case "TSQualifiedName":
            case "TSExpressionWithTypeArguments":
            case "TSTypeQuery":
              return !0;
            default:
              return !1;
          }
        }
        u.exports = function(d) {
          var s = d.types, o = function(h, y) {
            return function(b) {
              var E = s.callExpression(h.expression, [s.Identifier(b), s.Identifier("undefined"), s.NumericLiteral(y.key)]), S = s.logicalExpression("||", E, s.Identifier(b)), g = s.assignmentExpression("=", s.Identifier(b), S);
              return s.expressionStatement(g);
            };
          }, m = function(h, y) {
            return function(b, E) {
              var S = s.callExpression(h.expression, [s.Identifier("".concat(b, ".prototype")), s.StringLiteral(E), s.NumericLiteral(y.key)]);
              return s.expressionStatement(S);
            };
          };
          return { visitor: { Program: function(h, y) {
            var b = (0, i.extname)(y.file.opts.filename);
            b !== ".ts" && b !== ".tsx" || function() {
              var E = /* @__PURE__ */ Object.create(null);
              h.node.body.filter(function(v) {
                var w = v.type, O = v.declaration;
                switch (w) {
                  case "ClassDeclaration":
                    return !0;
                  case "ExportNamedDeclaration":
                  case "ExportDefaultDeclaration":
                    return O && O.type === "ClassDeclaration";
                  default:
                    return !1;
                }
              }).map(function(v) {
                return v.type === "ClassDeclaration" ? v : v.declaration;
              }).forEach(function(v) {
                v.body.body.forEach(function(w) {
                  (w.params || []).forEach(function(O) {
                    (O.decorators || []).forEach(function(G) {
                      G.expression.callee ? E[G.expression.callee.name] = G : E[G.expression.name] = G;
                    });
                  });
                });
              });
              var S = !0, g = !1, P = void 0;
              try {
                for (var R, N = h.get("body")[Symbol.iterator](); !(S = (R = N.next()).done); S = !0) {
                  var C = R.value;
                  if (C.node.type === "ImportDeclaration") {
                    if (C.node.specifiers.length === 0)
                      continue;
                    var I = !0, D = !1, j = void 0;
                    try {
                      for (var F, _ = function() {
                        var v = F.value, w = C.scope.getBinding(v.local.name);
                        w.referencePaths.length ? w.referencePaths.reduce(function(O, G) {
                          return O || f(G);
                        }, !1) && Object.keys(E).forEach(function(O) {
                          var G = E[O];
                          (G.expression.arguments || []).forEach(function(W) {
                            W.name === v.local.name && w.referencePaths.push({ parent: G.expression });
                          });
                        }) : E[v.local.name] && w.referencePaths.push({ parent: E[v.local.name] });
                      }, T = C.node.specifiers[Symbol.iterator](); !(I = (F = T.next()).done); I = !0)
                        _();
                    } catch (v) {
                      D = !0, j = v;
                    } finally {
                      try {
                        I || T.return == null || T.return();
                      } finally {
                        if (D)
                          throw j;
                      }
                    }
                  }
                }
              } catch (v) {
                g = !0, P = v;
              } finally {
                try {
                  S || N.return == null || N.return();
                } finally {
                  if (g)
                    throw P;
                }
              }
            }();
          }, Function: function(h) {
            var y = "";
            h.node.id ? y = h.node.id.name : h.node.key && (y = h.node.key.name), (h.get("params") || []).slice().forEach(function(b) {
              var E = b.node.decorators || [], S = E.length;
              if (E.slice().forEach(function(P) {
                if (h.type === "ClassMethod") {
                  var R, N = h.parentPath.parentPath, C = h.findParent(function(v) {
                    return v.type === "ClassDeclaration";
                  });
                  if (C ? R = C.node.id.name : (N.insertAfter(null), R = function(v) {
                    var w = v.findParent(function(O) {
                      return O.node.type === "AssignmentExpression";
                    });
                    return w.node.right.type === "SequenceExpression" ? w.node.right.expressions[1].name : w.node.right.type === "ClassExpression" ? w.node.left.name : null;
                  }(h)), y === "constructor") {
                    var I = o(P, b)(R);
                    N.insertAfter(I);
                  } else {
                    var D = m(P, b)(R, y);
                    N.insertAfter(D);
                  }
                } else {
                  var j = h.findParent(function(v) {
                    return v.node.type === "VariableDeclarator";
                  }).node.id.name;
                  if (y === j) {
                    var F = o(P, b)(j);
                    h.parentKey === "body" ? h.insertAfter(F) : h.findParent(function(v) {
                      return v.parentKey === "body";
                    }).insertAfter(F);
                  } else {
                    var _ = h.findParent(function(v) {
                      return v.node.type === "CallExpression";
                    }), T = m(P, b)(j, y);
                    _.insertAfter(T);
                  }
                }
              }), S) {
                var g = function(P) {
                  switch (P.node.type) {
                    case "ObjectPattern":
                      return s.ObjectPattern(P.node.properties);
                    case "AssignmentPattern":
                      return s.AssignmentPattern(P.node.left, P.node.right);
                    case "TSParameterProperty":
                      return s.Identifier(P.node.parameter.name);
                    default:
                      return s.Identifier(P.node.name);
                  }
                }(b);
                b.replaceWith(g);
              }
            });
          } } };
        };
      }, "./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.22.15/node_modules/babel-plugin-transform-typescript-metadata/lib/metadata/metadataVisitor.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.metadataVisitor = function(s, o) {
          const m = o.node, h = s.node;
          switch (m.type) {
            case "ClassMethod":
              const y = m.kind === "constructor" ? h.decorators : m.decorators;
              if (!y || y.length === 0)
                return;
              y.push(d("design:type", i.types.identifier("Function"))), y.push(d("design:paramtypes", i.types.arrayExpression(m.params.map((b) => (0, f.serializeType)(s, b)))));
              break;
            case "ClassProperty":
              if (!m.decorators || m.decorators.length === 0 || !m.typeAnnotation || m.typeAnnotation.type !== "TSTypeAnnotation")
                return;
              m.decorators.push(d("design:type", (0, f.serializeType)(s, m)));
          }
        };
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js"), f = l("./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.22.15/node_modules/babel-plugin-transform-typescript-metadata/lib/metadata/serializeType.js");
        function d(s, o) {
          return i.types.decorator(i.types.callExpression(i.types.memberExpression(i.types.identifier("Reflect"), i.types.identifier("metadata")), [i.types.stringLiteral(s), o]));
        }
      }, "./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.22.15/node_modules/babel-plugin-transform-typescript-metadata/lib/metadata/serializeType.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.serializeType = function(b, E) {
          const S = d(E);
          if (S == null || !S.typeAnnotation || S.typeAnnotation.type !== "TSTypeAnnotation")
            return f();
          const g = S.typeAnnotation.typeAnnotation;
          return h(b.node.id ? b.node.id.name : "", g);
        }, r.isClassType = o;
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js");
        function f() {
          return i.types.unaryExpression("void", i.types.numericLiteral(0));
        }
        function d(b) {
          return b == null ? null : b.type === "ClassProperty" || b.type === "Identifier" || b.type === "ObjectPattern" ? b : b.type === "AssignmentPattern" && b.left.type === "Identifier" ? b.left : b.type === "TSParameterProperty" ? d(b.parameter) : null;
        }
        function s(b, E) {
          const S = m(E.typeName);
          return o(b, S) ? i.types.identifier("Object") : i.types.conditionalExpression(i.types.binaryExpression("===", i.types.unaryExpression("typeof", S), i.types.stringLiteral("undefined")), i.types.identifier("Object"), i.types.cloneDeep(S));
        }
        function o(b, E) {
          switch (E.type) {
            case "Identifier":
              return E.name === b;
            case "MemberExpression":
              return o(b, E.object);
            default:
              throw new Error(`The property expression at ${E.start} is not valid as a Type to be used in Reflect.metadata`);
          }
        }
        function m(b) {
          return b.type === "Identifier" ? i.types.identifier(b.name) : i.types.memberExpression(m(b.left), b.right);
        }
        function h(b, E) {
          if (E === void 0)
            return i.types.identifier("Object");
          switch (E.type) {
            case "TSVoidKeyword":
            case "TSUndefinedKeyword":
            case "TSNullKeyword":
            case "TSNeverKeyword":
              return f();
            case "TSParenthesizedType":
              return h(b, E.typeAnnotation);
            case "TSFunctionType":
            case "TSConstructorType":
              return i.types.identifier("Function");
            case "TSArrayType":
            case "TSTupleType":
              return i.types.identifier("Array");
            case "TSTypePredicate":
            case "TSBooleanKeyword":
              return i.types.identifier("Boolean");
            case "TSStringKeyword":
              return i.types.identifier("String");
            case "TSObjectKeyword":
              return i.types.identifier("Object");
            case "TSLiteralType":
              switch (E.literal.type) {
                case "StringLiteral":
                  return i.types.identifier("String");
                case "NumericLiteral":
                  return i.types.identifier("Number");
                case "BooleanLiteral":
                  return i.types.identifier("Boolean");
                default:
                  throw new Error("Bad type for decorator" + E.literal);
              }
            case "TSNumberKeyword":
            case "TSBigIntKeyword":
              return i.types.identifier("Number");
            case "TSSymbolKeyword":
              return i.types.identifier("Symbol");
            case "TSTypeReference":
              return s(b, E);
            case "TSIntersectionType":
            case "TSUnionType":
              return y(b, E.types);
            case "TSConditionalType":
              return y(b, [E.trueType, E.falseType]);
            case "TSTypeQuery":
            case "TSTypeOperator":
            case "TSIndexedAccessType":
            case "TSMappedType":
            case "TSTypeLiteral":
            case "TSAnyKeyword":
            case "TSUnknownKeyword":
            case "TSThisType":
              break;
            default:
              throw new Error("Bad type for decorator");
          }
          return i.types.identifier("Object");
        }
        function y(b, E) {
          let S;
          for (let g of E) {
            for (; g.type === "TSParenthesizedType"; )
              g = g.typeAnnotation;
            if (g.type === "TSNeverKeyword" || g.type === "TSNullKeyword" || g.type === "TSUndefinedKeyword")
              continue;
            const P = h(b, g);
            if (i.types.isIdentifier(P) && P.name === "Object")
              return P;
            if (S) {
              if (!i.types.isIdentifier(S) || !i.types.isIdentifier(P) || S.name !== P.name)
                return i.types.identifier("Object");
            } else
              S = P;
          }
          return S || f();
        }
      }, "./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.22.15/node_modules/babel-plugin-transform-typescript-metadata/lib/parameter/parameterVisitor.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.parameterVisitor = function(d, s) {
          if (s.type !== "ClassMethod" || s.node.type !== "ClassMethod" || s.node.key.type !== "Identifier")
            return;
          const o = s;
          (o.get("params") || []).slice().forEach(function(m) {
            let h;
            (m.node.type === "Identifier" || m.node.type === "ObjectPattern" ? m.node : m.node.type === "TSParameterProperty" && m.node.parameter.type === "Identifier" ? m.node.parameter : null) != null && ((m.node.decorators || []).slice().forEach(function(y) {
              o.node.kind === "constructor" ? (h = f(m.key, y.expression, !0), d.node.decorators || (d.node.decorators = []), d.node.decorators.push(h)) : (h = f(m.key, y.expression, !1), o.node.decorators || (o.node.decorators = []), o.node.decorators.push(h));
            }), h && (m.node.decorators = null));
          });
        };
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js");
        function f(d, s, o = !1) {
          return i.types.decorator(i.types.functionExpression(null, [i.types.identifier("target"), i.types.identifier("key")], i.types.blockStatement([i.types.returnStatement(i.types.callExpression(s, [i.types.identifier("target"), i.types.identifier(o ? "undefined" : "key"), i.types.numericLiteral(d)]))])));
        }
      }, "./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.22.15/node_modules/babel-plugin-transform-typescript-metadata/lib/plugin.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js"), f = l("./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.22.15/node_modules/babel-plugin-transform-typescript-metadata/lib/parameter/parameterVisitor.js"), d = l("./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.22.15/node_modules/babel-plugin-transform-typescript-metadata/lib/metadata/metadataVisitor.js"), s = (0, i.declare)((o) => (o.assertVersion(7), { visitor: { Program(m) {
          m.traverse({ ClassDeclaration(h) {
            for (const y of h.get("body").get("body"))
              y.type !== "ClassMethod" && y.type !== "ClassProperty" || ((0, f.parameterVisitor)(h, y), (0, d.metadataVisitor)(h, y));
            h.parentPath.scope.crawl();
          } });
        } } }));
        r.default = s;
      }, "./node_modules/.pnpm/convert-source-map@1.9.0/node_modules/convert-source-map/index.js": (u, r, l) => {
        var i, f = l("fs"), d = l("path");
        function s(o, m) {
          (m = m || {}).isFileComment && (o = function(h, y) {
            var b = r.mapFileCommentRegex.exec(h), E = b[1] || b[2], S = d.resolve(y, E);
            try {
              return f.readFileSync(S, "utf8");
            } catch (g) {
              throw new Error("An error occurred while trying to read the map file at " + S + `
` + g);
            }
          }(o, m.commentFileDir)), m.hasComment && (o = function(h) {
            return h.split(",").pop();
          }(o)), m.isEncoded && (o = i(o)), (m.isJSON || m.isEncoded) && (o = JSON.parse(o)), this.sourcemap = o;
        }
        Object.defineProperty(r, "commentRegex", { get: function() {
          return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/gm;
        } }), Object.defineProperty(r, "mapFileCommentRegex", { get: function() {
          return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/gm;
        } }), i = typeof Ve.Buffer < "u" ? typeof Ve.Buffer.from == "function" ? function(o) {
          return Ve.Buffer.from(o, "base64").toString();
        } : function(o) {
          if (typeof value == "number")
            throw new TypeError("The value to decode must not be of type number.");
          return new Ve.Buffer(o, "base64").toString();
        } : function(o) {
          return decodeURIComponent(escape(atob(o)));
        }, s.prototype.toJSON = function(o) {
          return JSON.stringify(this.sourcemap, null, o);
        }, typeof Ve.Buffer < "u" ? typeof Ve.Buffer.from == "function" ? s.prototype.toBase64 = function() {
          var o = this.toJSON();
          return Ve.Buffer.from(o, "utf8").toString("base64");
        } : s.prototype.toBase64 = function() {
          var o = this.toJSON();
          if (typeof o == "number")
            throw new TypeError("The json to encode must not be of type number.");
          return new Ve.Buffer(o, "utf8").toString("base64");
        } : s.prototype.toBase64 = function() {
          var o = this.toJSON();
          return btoa(unescape(encodeURIComponent(o)));
        }, s.prototype.toComment = function(o) {
          var m = "sourceMappingURL=data:application/json;charset=utf-8;base64," + this.toBase64();
          return o && o.multiline ? "/*# " + m + " */" : "//# " + m;
        }, s.prototype.toObject = function() {
          return JSON.parse(this.toJSON());
        }, s.prototype.addProperty = function(o, m) {
          if (this.sourcemap.hasOwnProperty(o))
            throw new Error('property "' + o + '" already exists on the sourcemap, use set property instead');
          return this.setProperty(o, m);
        }, s.prototype.setProperty = function(o, m) {
          return this.sourcemap[o] = m, this;
        }, s.prototype.getProperty = function(o) {
          return this.sourcemap[o];
        }, r.fromObject = function(o) {
          return new s(o);
        }, r.fromJSON = function(o) {
          return new s(o, { isJSON: !0 });
        }, r.fromBase64 = function(o) {
          return new s(o, { isEncoded: !0 });
        }, r.fromComment = function(o) {
          return new s(o = o.replace(/^\/\*/g, "//").replace(/\*\/$/g, ""), { isEncoded: !0, hasComment: !0 });
        }, r.fromMapFileComment = function(o, m) {
          return new s(o, { commentFileDir: m, isFileComment: !0, isJSON: !0 });
        }, r.fromSource = function(o) {
          var m = o.match(r.commentRegex);
          return m ? r.fromComment(m.pop()) : null;
        }, r.fromMapFileSource = function(o, m) {
          var h = o.match(r.mapFileCommentRegex);
          return h ? r.fromMapFileComment(h.pop(), m) : null;
        }, r.removeComments = function(o) {
          return o.replace(r.commentRegex, "");
        }, r.removeMapFileComments = function(o) {
          return o.replace(r.mapFileCommentRegex, "");
        }, r.generateMapFileComment = function(o, m) {
          var h = "sourceMappingURL=" + o;
          return m && m.multiline ? "/*# " + h + " */" : "//# " + h;
        };
      }, "./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js": (u, r, l) => {
        r.formatArgs = function(f) {
          if (f[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + f[0] + (this.useColors ? "%c " : " ") + "+" + u.exports.humanize(this.diff), !this.useColors)
            return;
          const d = "color: " + this.color;
          f.splice(1, 0, d, "color: inherit");
          let s = 0, o = 0;
          f[0].replace(/%[a-zA-Z%]/g, (m) => {
            m !== "%%" && (s++, m === "%c" && (o = s));
          }), f.splice(o, 0, d);
        }, r.save = function(f) {
          try {
            f ? r.storage.setItem("debug", f) : r.storage.removeItem("debug");
          } catch {
          }
        }, r.load = function() {
          let f;
          try {
            f = r.storage.getItem("debug");
          } catch {
          }
          return !f && typeof Ve.process < "u" && "env" in Ve.process && (f = Ve.process.env.DEBUG), f;
        }, r.useColors = function() {
          return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }, r.storage = function() {
          try {
            return localStorage;
          } catch {
          }
        }(), r.destroy = (() => {
          let f = !1;
          return () => {
            f || (f = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
          };
        })(), r.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], r.log = console.debug || console.log || (() => {
        }), u.exports = l("./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js")(r);
        const { formatters: i } = u.exports;
        i.j = function(f) {
          try {
            return JSON.stringify(f);
          } catch (d) {
            return "[UnexpectedJSONParseError]: " + d.message;
          }
        };
      }, "./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js": (u, r, l) => {
        u.exports = function(i) {
          function f(o) {
            let m, h, y, b = null;
            function E(...S) {
              if (!E.enabled)
                return;
              const g = E, P = Number(/* @__PURE__ */ new Date()), R = P - (m || P);
              g.diff = R, g.prev = m, g.curr = P, m = P, S[0] = f.coerce(S[0]), typeof S[0] != "string" && S.unshift("%O");
              let N = 0;
              S[0] = S[0].replace(/%([a-zA-Z%])/g, (C, I) => {
                if (C === "%%")
                  return "%";
                N++;
                const D = f.formatters[I];
                if (typeof D == "function") {
                  const j = S[N];
                  C = D.call(g, j), S.splice(N, 1), N--;
                }
                return C;
              }), f.formatArgs.call(g, S), (g.log || f.log).apply(g, S);
            }
            return E.namespace = o, E.useColors = f.useColors(), E.color = f.selectColor(o), E.extend = d, E.destroy = f.destroy, Object.defineProperty(E, "enabled", { enumerable: !0, configurable: !1, get: () => b !== null ? b : (h !== f.namespaces && (h = f.namespaces, y = f.enabled(o)), y), set: (S) => {
              b = S;
            } }), typeof f.init == "function" && f.init(E), E;
          }
          function d(o, m) {
            const h = f(this.namespace + (m === void 0 ? ":" : m) + o);
            return h.log = this.log, h;
          }
          function s(o) {
            return o.toString().substring(2, o.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          return f.debug = f, f.default = f, f.coerce = function(o) {
            return o instanceof Error ? o.stack || o.message : o;
          }, f.disable = function() {
            const o = [...f.names.map(s), ...f.skips.map(s).map((m) => "-" + m)].join(",");
            return f.enable(""), o;
          }, f.enable = function(o) {
            let m;
            f.save(o), f.namespaces = o, f.names = [], f.skips = [];
            const h = (typeof o == "string" ? o : "").split(/[\s,]+/), y = h.length;
            for (m = 0; m < y; m++)
              h[m] && ((o = h[m].replace(/\*/g, ".*?"))[0] === "-" ? f.skips.push(new RegExp("^" + o.slice(1) + "$")) : f.names.push(new RegExp("^" + o + "$")));
          }, f.enabled = function(o) {
            if (o[o.length - 1] === "*")
              return !0;
            let m, h;
            for (m = 0, h = f.skips.length; m < h; m++)
              if (f.skips[m].test(o))
                return !1;
            for (m = 0, h = f.names.length; m < h; m++)
              if (f.names[m].test(o))
                return !0;
            return !1;
          }, f.humanize = l("./node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js"), f.destroy = function() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }, Object.keys(i).forEach((o) => {
            f[o] = i[o];
          }), f.names = [], f.skips = [], f.formatters = {}, f.selectColor = function(o) {
            let m = 0;
            for (let h = 0; h < o.length; h++)
              m = (m << 5) - m + o.charCodeAt(h), m |= 0;
            return f.colors[Math.abs(m) % f.colors.length];
          }, f.enable(f.load()), f;
        };
      }, "./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js": (u, r, l) => {
        typeof Ve.process > "u" || Ve.process.type === "renderer" || Ve.process.browser === !0 || Ve.process.__nwjs ? u.exports = l("./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js") : u.exports = l("./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/node.js");
      }, "./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/node.js": (u, r, l) => {
        const i = l("tty"), f = l("util");
        r.init = function(s) {
          s.inspectOpts = {};
          const o = Object.keys(r.inspectOpts);
          for (let m = 0; m < o.length; m++)
            s.inspectOpts[o[m]] = r.inspectOpts[o[m]];
        }, r.log = function(...s) {
          return Ve.process.stderr.write(f.format(...s) + `
`);
        }, r.formatArgs = function(s) {
          const { namespace: o, useColors: m } = this;
          if (m) {
            const h = this.color, y = "\x1B[3" + (h < 8 ? h : "8;5;" + h), b = `  ${y};1m${o} \x1B[0m`;
            s[0] = b + s[0].split(`
`).join(`
` + b), s.push(y + "m+" + u.exports.humanize(this.diff) + "\x1B[0m");
          } else
            s[0] = function() {
              return r.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
            }() + o + " " + s[0];
        }, r.save = function(s) {
          s ? Ve.process.env.DEBUG = s : delete Ve.process.env.DEBUG;
        }, r.load = function() {
          return Ve.process.env.DEBUG;
        }, r.useColors = function() {
          return "colors" in r.inspectOpts ? !!r.inspectOpts.colors : i.isatty(Ve.process.stderr.fd);
        }, r.destroy = f.deprecate(() => {
        }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."), r.colors = [6, 2, 3, 4, 5, 1];
        try {
          const s = l("./node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js");
          s && (s.stderr || s).level >= 2 && (r.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
        } catch {
        }
        r.inspectOpts = Object.keys(Ve.process.env).filter((s) => /^debug_/i.test(s)).reduce((s, o) => {
          const m = o.substring(6).toLowerCase().replace(/_([a-z])/g, (y, b) => b.toUpperCase());
          let h = Ve.process.env[o];
          return h = !!/^(yes|on|true|enabled)$/i.test(h) || !/^(no|off|false|disabled)$/i.test(h) && (h === "null" ? null : Number(h)), s[m] = h, s;
        }, {}), u.exports = l("./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js")(r);
        const { formatters: d } = u.exports;
        d.o = function(s) {
          return this.inspectOpts.colors = this.useColors, f.inspect(s, this.inspectOpts).split(`
`).map((o) => o.trim()).join(" ");
        }, d.O = function(s) {
          return this.inspectOpts.colors = this.useColors, f.inspect(s, this.inspectOpts);
        };
      }, "./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js": (u) => {
        const r = Symbol.for("gensync:v1:start"), l = Symbol.for("gensync:v1:suspend"), i = "GENSYNC_EXPECTED_START", f = "GENSYNC_EXPECTED_SUSPEND", d = "GENSYNC_OPTIONS_ERROR";
        function s(P, R, N, C) {
          if (typeof N === P || C && N === void 0)
            return;
          let I;
          throw I = C ? `Expected opts.${R} to be either a ${P}, or undefined.` : `Expected opts.${R} to be a ${P}.`, o(I, d);
        }
        function o(P, R) {
          return Object.assign(new Error(P), { code: R });
        }
        function m({ name: P, arity: R, sync: N, async: C }) {
          return g(P, R, function* (...I) {
            const D = yield r;
            if (!D)
              return N.call(this, I);
            let j;
            try {
              C.call(this, I, (F) => {
                j || (j = { value: F }, D());
              }, (F) => {
                j || (j = { err: F }, D());
              });
            } catch (F) {
              j = { err: F }, D();
            }
            if (yield l, j.hasOwnProperty("err"))
              throw j.err;
            return j.value;
          });
        }
        function h(P) {
          let R;
          for (; !({ value: R } = P.next()).done; )
            b(R, P);
          return R;
        }
        function y(P, R, N) {
          (function C() {
            try {
              let I;
              for (; !({ value: I } = P.next()).done; ) {
                b(I, P);
                let D = !0, j = !1;
                const F = P.next(() => {
                  D ? j = !0 : C();
                });
                if (D = !1, E(F, P), !j)
                  return;
              }
              return R(I);
            } catch (I) {
              return N(I);
            }
          })();
        }
        function b(P, R) {
          P !== r && S(R, o(`Got unexpected yielded value in gensync generator: ${JSON.stringify(P)}. Did you perhaps mean to use 'yield*' instead of 'yield'?`, i));
        }
        function E({ value: P, done: R }, N) {
          (R || P !== l) && S(N, o(R ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(P)}. If you get this, it is probably a gensync bug.`, f));
        }
        function S(P, R) {
          throw P.throw && P.throw(R), R;
        }
        function g(P, R, N) {
          if (typeof P == "string") {
            const C = Object.getOwnPropertyDescriptor(N, "name");
            C && !C.configurable || Object.defineProperty(N, "name", Object.assign(C || {}, { configurable: !0, value: P }));
          }
          if (typeof R == "number") {
            const C = Object.getOwnPropertyDescriptor(N, "length");
            C && !C.configurable || Object.defineProperty(N, "length", Object.assign(C || {}, { configurable: !0, value: R }));
          }
          return N;
        }
        u.exports = Object.assign(function(P) {
          let R = P;
          return R = typeof P != "function" ? function({ name: N, arity: C, sync: I, async: D, errback: j }) {
            if (s("string", "name", N, !0), s("number", "arity", C, !0), s("function", "sync", I), s("function", "async", D, !0), s("function", "errback", j, !0), D && j)
              throw o("Expected one of either opts.async or opts.errback, but got _both_.", d);
            if (typeof N != "string") {
              let F;
              j && j.name && j.name !== "errback" && (F = j.name), D && D.name && D.name !== "async" && (F = D.name.replace(/Async$/, "")), I && I.name && I.name !== "sync" && (F = I.name.replace(/Sync$/, "")), typeof F == "string" && (N = F);
            }
            return typeof C != "number" && (C = I.length), m({ name: N, arity: C, sync: function(F) {
              return I.apply(this, F);
            }, async: function(F, _, T) {
              D ? D.apply(this, F).then(_, T) : j ? j.call(this, ...F, (v, w) => {
                v == null ? _(w) : T(v);
              }) : _(I.apply(this, F));
            } });
          }(P) : function(N) {
            return g(N.name, N.length, function(...C) {
              return N.apply(this, C);
            });
          }(P), Object.assign(R, function(N) {
            return { sync: function(...I) {
              return h(N.apply(this, I));
            }, async: function(...I) {
              return new Promise((D, j) => {
                y(N.apply(this, I), D, j);
              });
            }, errback: function(...I) {
              const D = I.pop();
              if (typeof D != "function")
                throw o("Asynchronous function called without callback", "GENSYNC_ERRBACK_NO_CALLBACK");
              let j;
              try {
                j = N.apply(this, I);
              } catch (F) {
                return void D(F);
              }
              y(j, (F) => D(void 0, F), (F) => D(F));
            } };
          }(R));
        }, { all: m({ name: "all", arity: 1, sync: function(P) {
          return Array.from(P[0]).map((R) => h(R));
        }, async: function(P, R, N) {
          const C = Array.from(P[0]);
          if (C.length === 0)
            return void Promise.resolve().then(() => R([]));
          let I = 0;
          const D = C.map(() => {
          });
          C.forEach((j, F) => {
            y(j, (_) => {
              D[F] = _, I += 1, I === D.length && R(D);
            }, N);
          });
        } }), race: m({ name: "race", arity: 1, sync: function(P) {
          const R = Array.from(P[0]);
          if (R.length === 0)
            throw o("Must race at least 1 item", "GENSYNC_RACE_NONEMPTY");
          return h(R[0]);
        }, async: function(P, R, N) {
          const C = Array.from(P[0]);
          if (C.length === 0)
            throw o("Must race at least 1 item", "GENSYNC_RACE_NONEMPTY");
          for (const I of C)
            y(I, R, N);
        } }) });
      }, "./node_modules/.pnpm/globals@11.12.0/node_modules/globals/index.js": (u, r, l) => {
        u.exports = l("./node_modules/.pnpm/globals@11.12.0/node_modules/globals/globals.json");
      }, "./node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js": (u) => {
        u.exports = (r, l = Ve.process.argv) => {
          const i = r.startsWith("-") ? "" : r.length === 1 ? "-" : "--", f = l.indexOf(i + r), d = l.indexOf("--");
          return f !== -1 && (d === -1 || f < d);
        };
      }, "./node_modules/.pnpm/jsesc@2.5.2/node_modules/jsesc/jsesc.js": (u) => {
        const r = {}, l = r.hasOwnProperty, i = (E, S) => {
          for (const g in E)
            l.call(E, g) && S(g, E[g]);
        }, f = r.toString, d = Array.isArray, s = Ve.Buffer.isBuffer, o = { '"': '\\"', "'": "\\'", "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t" }, m = /["'\\\b\f\n\r\t]/, h = /[0-9]/, y = /[ !#-&\(-\[\]-_a-~]/, b = (E, S) => {
          const g = () => {
            _ = F, ++S.indentLevel, F = S.indent.repeat(S.indentLevel);
          }, P = { escapeEverything: !1, minimal: !1, isScriptContext: !1, quotes: "single", wrap: !1, es6: !1, json: !1, compact: !0, lowercaseHex: !1, numbers: "decimal", indent: "	", indentLevel: 0, __inline1__: !1, __inline2__: !1 }, R = S && S.json;
          var N, C;
          R && (P.quotes = "double", P.wrap = !0), N = P, (S = ((C = S) && i(C, (z, q) => {
            N[z] = q;
          }), N)).quotes != "single" && S.quotes != "double" && S.quotes != "backtick" && (S.quotes = "single");
          const I = S.quotes == "double" ? '"' : S.quotes == "backtick" ? "`" : "'", D = S.compact, j = S.lowercaseHex;
          let F = S.indent.repeat(S.indentLevel), _ = "";
          const T = S.__inline1__, v = S.__inline2__, w = D ? "" : `
`;
          let O, G = !0;
          const W = S.numbers == "binary", U = S.numbers == "octal", M = S.numbers == "decimal", B = S.numbers == "hexadecimal";
          if (R && E && ((z) => typeof z == "function")(E.toJSON) && (E = E.toJSON()), !((z) => typeof z == "string" || f.call(z) == "[object String]")(E)) {
            if (((z) => f.call(z) == "[object Map]")(E))
              return E.size == 0 ? "new Map()" : (D || (S.__inline1__ = !0, S.__inline2__ = !1), "new Map(" + b(Array.from(E), S) + ")");
            if (((z) => f.call(z) == "[object Set]")(E))
              return E.size == 0 ? "new Set()" : "new Set(" + b(Array.from(E), S) + ")";
            if (s(E))
              return E.length == 0 ? "Buffer.from([])" : "Buffer.from(" + b(Array.from(E), S) + ")";
            if (d(E))
              return O = [], S.wrap = !0, T && (S.__inline1__ = !1, S.__inline2__ = !0), v || g(), ((z, q) => {
                const $ = z.length;
                let Y = -1;
                for (; ++Y < $; )
                  q(z[Y]);
              })(E, (z) => {
                G = !1, v && (S.__inline2__ = !1), O.push((D || v ? "" : F) + b(z, S));
              }), G ? "[]" : v ? "[" + O.join(", ") + "]" : "[" + w + O.join("," + w) + w + (D ? "" : _) + "]";
            if (!((z) => typeof z == "number" || f.call(z) == "[object Number]")(E))
              return ((z) => f.call(z) == "[object Object]")(E) ? (O = [], S.wrap = !0, g(), i(E, (z, q) => {
                G = !1, O.push((D ? "" : F) + b(z, S) + ":" + (D ? "" : " ") + b(q, S));
              }), G ? "{}" : "{" + w + O.join("," + w) + w + (D ? "" : _) + "}") : R ? JSON.stringify(E) || "null" : String(E);
            if (R)
              return JSON.stringify(E);
            if (M)
              return String(E);
            if (B) {
              let z = E.toString(16);
              return j || (z = z.toUpperCase()), "0x" + z;
            }
            if (W)
              return "0b" + E.toString(2);
            if (U)
              return "0o" + E.toString(8);
          }
          const k = E;
          let K = -1;
          const te = k.length;
          for (O = ""; ++K < te; ) {
            const z = k.charAt(K);
            if (S.es6) {
              const Q = k.charCodeAt(K);
              if (Q >= 55296 && Q <= 56319 && te > K + 1) {
                const X = k.charCodeAt(K + 1);
                if (X >= 56320 && X <= 57343) {
                  let ne = (1024 * (Q - 55296) + X - 56320 + 65536).toString(16);
                  j || (ne = ne.toUpperCase()), O += "\\u{" + ne + "}", ++K;
                  continue;
                }
              }
            }
            if (!S.escapeEverything) {
              if (y.test(z)) {
                O += z;
                continue;
              }
              if (z == '"') {
                O += I == z ? '\\"' : z;
                continue;
              }
              if (z == "`") {
                O += I == z ? "\\`" : z;
                continue;
              }
              if (z == "'") {
                O += I == z ? "\\'" : z;
                continue;
              }
            }
            if (z == "\0" && !R && !h.test(k.charAt(K + 1))) {
              O += "\\0";
              continue;
            }
            if (m.test(z)) {
              O += o[z];
              continue;
            }
            const q = z.charCodeAt(0);
            if (S.minimal && q != 8232 && q != 8233) {
              O += z;
              continue;
            }
            let $ = q.toString(16);
            j || ($ = $.toUpperCase());
            const Y = $.length > 2 || R, H = "\\" + (Y ? "u" : "x") + ("0000" + $).slice(Y ? -4 : -2);
            O += H;
          }
          return S.wrap && (O = I + O + I), I == "`" && (O = O.replace(/\$\{/g, "\\${")), S.isScriptContext ? O.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, R ? "\\u003C!--" : "\\x3C!--") : O;
        };
        b.version = "2.5.2", u.exports = b;
      }, "./node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js": (u) => {
        var r = 1e3, l = 60 * r, i = 60 * l, f = 24 * i, d = 7 * f, s = 365.25 * f;
        function o(m, h, y, b) {
          var E = h >= 1.5 * y;
          return Math.round(m / y) + " " + b + (E ? "s" : "");
        }
        u.exports = function(m, h) {
          h = h || {};
          var y = typeof m;
          if (y === "string" && m.length > 0)
            return function(b) {
              if (!((b = String(b)).length > 100)) {
                var E = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(b);
                if (E) {
                  var S = parseFloat(E[1]);
                  switch ((E[2] || "ms").toLowerCase()) {
                    case "years":
                    case "year":
                    case "yrs":
                    case "yr":
                    case "y":
                      return S * s;
                    case "weeks":
                    case "week":
                    case "w":
                      return S * d;
                    case "days":
                    case "day":
                    case "d":
                      return S * f;
                    case "hours":
                    case "hour":
                    case "hrs":
                    case "hr":
                    case "h":
                      return S * i;
                    case "minutes":
                    case "minute":
                    case "mins":
                    case "min":
                    case "m":
                      return S * l;
                    case "seconds":
                    case "second":
                    case "secs":
                    case "sec":
                    case "s":
                      return S * r;
                    case "milliseconds":
                    case "millisecond":
                    case "msecs":
                    case "msec":
                    case "ms":
                      return S;
                    default:
                      return;
                  }
                }
              }
            }(m);
          if (y === "number" && isFinite(m))
            return h.long ? function(b) {
              var E = Math.abs(b);
              return E >= f ? o(b, E, f, "day") : E >= i ? o(b, E, i, "hour") : E >= l ? o(b, E, l, "minute") : E >= r ? o(b, E, r, "second") : b + " ms";
            }(m) : function(b) {
              var E = Math.abs(b);
              return E >= f ? Math.round(b / f) + "d" : E >= i ? Math.round(b / i) + "h" : E >= l ? Math.round(b / l) + "m" : E >= r ? Math.round(b / r) + "s" : b + "ms";
            }(m);
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(m));
        };
      }, "./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js": (u, r) => {
        var l;
        r = u.exports = R, l = typeof Ve.process == "object" && Ve.process.env && Ve.process.env.NODE_DEBUG && /\bsemver\b/i.test(Ve.process.env.NODE_DEBUG) ? function() {
          var z = Array.prototype.slice.call(arguments, 0);
          z.unshift("SEMVER"), console.log.apply(console, z);
        } : function() {
        }, r.SEMVER_SPEC_VERSION = "2.0.0";
        var i = 256, f = Number.MAX_SAFE_INTEGER || 9007199254740991, d = i - 6, s = r.re = [], o = r.safeRe = [], m = r.src = [], h = r.tokens = {}, y = 0;
        function b(z) {
          h[z] = y++;
        }
        var E = [["\\s", 1], ["\\d", i], ["[a-zA-Z0-9-]", d]];
        function S(z) {
          for (var q = 0; q < E.length; q++) {
            var $ = E[q][0], Y = E[q][1];
            z = z.split($ + "*").join($ + "{0," + Y + "}").split($ + "+").join($ + "{1," + Y + "}");
          }
          return z;
        }
        b("NUMERICIDENTIFIER"), m[h.NUMERICIDENTIFIER] = "0|[1-9]\\d*", b("NUMERICIDENTIFIERLOOSE"), m[h.NUMERICIDENTIFIERLOOSE] = "\\d+", b("NONNUMERICIDENTIFIER"), m[h.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*", b("MAINVERSION"), m[h.MAINVERSION] = "(" + m[h.NUMERICIDENTIFIER] + ")\\.(" + m[h.NUMERICIDENTIFIER] + ")\\.(" + m[h.NUMERICIDENTIFIER] + ")", b("MAINVERSIONLOOSE"), m[h.MAINVERSIONLOOSE] = "(" + m[h.NUMERICIDENTIFIERLOOSE] + ")\\.(" + m[h.NUMERICIDENTIFIERLOOSE] + ")\\.(" + m[h.NUMERICIDENTIFIERLOOSE] + ")", b("PRERELEASEIDENTIFIER"), m[h.PRERELEASEIDENTIFIER] = "(?:" + m[h.NUMERICIDENTIFIER] + "|" + m[h.NONNUMERICIDENTIFIER] + ")", b("PRERELEASEIDENTIFIERLOOSE"), m[h.PRERELEASEIDENTIFIERLOOSE] = "(?:" + m[h.NUMERICIDENTIFIERLOOSE] + "|" + m[h.NONNUMERICIDENTIFIER] + ")", b("PRERELEASE"), m[h.PRERELEASE] = "(?:-(" + m[h.PRERELEASEIDENTIFIER] + "(?:\\." + m[h.PRERELEASEIDENTIFIER] + ")*))", b("PRERELEASELOOSE"), m[h.PRERELEASELOOSE] = "(?:-?(" + m[h.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + m[h.PRERELEASEIDENTIFIERLOOSE] + ")*))", b("BUILDIDENTIFIER"), m[h.BUILDIDENTIFIER] = "[a-zA-Z0-9-]+", b("BUILD"), m[h.BUILD] = "(?:\\+(" + m[h.BUILDIDENTIFIER] + "(?:\\." + m[h.BUILDIDENTIFIER] + ")*))", b("FULL"), b("FULLPLAIN"), m[h.FULLPLAIN] = "v?" + m[h.MAINVERSION] + m[h.PRERELEASE] + "?" + m[h.BUILD] + "?", m[h.FULL] = "^" + m[h.FULLPLAIN] + "$", b("LOOSEPLAIN"), m[h.LOOSEPLAIN] = "[v=\\s]*" + m[h.MAINVERSIONLOOSE] + m[h.PRERELEASELOOSE] + "?" + m[h.BUILD] + "?", b("LOOSE"), m[h.LOOSE] = "^" + m[h.LOOSEPLAIN] + "$", b("GTLT"), m[h.GTLT] = "((?:<|>)?=?)", b("XRANGEIDENTIFIERLOOSE"), m[h.XRANGEIDENTIFIERLOOSE] = m[h.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*", b("XRANGEIDENTIFIER"), m[h.XRANGEIDENTIFIER] = m[h.NUMERICIDENTIFIER] + "|x|X|\\*", b("XRANGEPLAIN"), m[h.XRANGEPLAIN] = "[v=\\s]*(" + m[h.XRANGEIDENTIFIER] + ")(?:\\.(" + m[h.XRANGEIDENTIFIER] + ")(?:\\.(" + m[h.XRANGEIDENTIFIER] + ")(?:" + m[h.PRERELEASE] + ")?" + m[h.BUILD] + "?)?)?", b("XRANGEPLAINLOOSE"), m[h.XRANGEPLAINLOOSE] = "[v=\\s]*(" + m[h.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + m[h.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + m[h.XRANGEIDENTIFIERLOOSE] + ")(?:" + m[h.PRERELEASELOOSE] + ")?" + m[h.BUILD] + "?)?)?", b("XRANGE"), m[h.XRANGE] = "^" + m[h.GTLT] + "\\s*" + m[h.XRANGEPLAIN] + "$", b("XRANGELOOSE"), m[h.XRANGELOOSE] = "^" + m[h.GTLT] + "\\s*" + m[h.XRANGEPLAINLOOSE] + "$", b("COERCE"), m[h.COERCE] = "(^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])", b("COERCERTL"), s[h.COERCERTL] = new RegExp(m[h.COERCE], "g"), o[h.COERCERTL] = new RegExp(S(m[h.COERCE]), "g"), b("LONETILDE"), m[h.LONETILDE] = "(?:~>?)", b("TILDETRIM"), m[h.TILDETRIM] = "(\\s*)" + m[h.LONETILDE] + "\\s+", s[h.TILDETRIM] = new RegExp(m[h.TILDETRIM], "g"), o[h.TILDETRIM] = new RegExp(S(m[h.TILDETRIM]), "g"), b("TILDE"), m[h.TILDE] = "^" + m[h.LONETILDE] + m[h.XRANGEPLAIN] + "$", b("TILDELOOSE"), m[h.TILDELOOSE] = "^" + m[h.LONETILDE] + m[h.XRANGEPLAINLOOSE] + "$", b("LONECARET"), m[h.LONECARET] = "(?:\\^)", b("CARETTRIM"), m[h.CARETTRIM] = "(\\s*)" + m[h.LONECARET] + "\\s+", s[h.CARETTRIM] = new RegExp(m[h.CARETTRIM], "g"), o[h.CARETTRIM] = new RegExp(S(m[h.CARETTRIM]), "g"), b("CARET"), m[h.CARET] = "^" + m[h.LONECARET] + m[h.XRANGEPLAIN] + "$", b("CARETLOOSE"), m[h.CARETLOOSE] = "^" + m[h.LONECARET] + m[h.XRANGEPLAINLOOSE] + "$", b("COMPARATORLOOSE"), m[h.COMPARATORLOOSE] = "^" + m[h.GTLT] + "\\s*(" + m[h.LOOSEPLAIN] + ")$|^$", b("COMPARATOR"), m[h.COMPARATOR] = "^" + m[h.GTLT] + "\\s*(" + m[h.FULLPLAIN] + ")$|^$", b("COMPARATORTRIM"), m[h.COMPARATORTRIM] = "(\\s*)" + m[h.GTLT] + "\\s*(" + m[h.LOOSEPLAIN] + "|" + m[h.XRANGEPLAIN] + ")", s[h.COMPARATORTRIM] = new RegExp(m[h.COMPARATORTRIM], "g"), o[h.COMPARATORTRIM] = new RegExp(S(m[h.COMPARATORTRIM]), "g"), b("HYPHENRANGE"), m[h.HYPHENRANGE] = "^\\s*(" + m[h.XRANGEPLAIN] + ")\\s+-\\s+(" + m[h.XRANGEPLAIN] + ")\\s*$", b("HYPHENRANGELOOSE"), m[h.HYPHENRANGELOOSE] = "^\\s*(" + m[h.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + m[h.XRANGEPLAINLOOSE] + ")\\s*$", b("STAR"), m[h.STAR] = "(<|>)?=?\\s*\\*";
        for (var g = 0; g < y; g++)
          l(g, m[g]), s[g] || (s[g] = new RegExp(m[g]), o[g] = new RegExp(S(m[g])));
        function P(z, q) {
          if (q && typeof q == "object" || (q = { loose: !!q, includePrerelease: !1 }), z instanceof R)
            return z;
          if (typeof z != "string" || z.length > i || !(q.loose ? o[h.LOOSE] : o[h.FULL]).test(z))
            return null;
          try {
            return new R(z, q);
          } catch {
            return null;
          }
        }
        function R(z, q) {
          if (q && typeof q == "object" || (q = { loose: !!q, includePrerelease: !1 }), z instanceof R) {
            if (z.loose === q.loose)
              return z;
            z = z.version;
          } else if (typeof z != "string")
            throw new TypeError("Invalid Version: " + z);
          if (z.length > i)
            throw new TypeError("version is longer than " + i + " characters");
          if (!(this instanceof R))
            return new R(z, q);
          l("SemVer", z, q), this.options = q, this.loose = !!q.loose;
          var $ = z.trim().match(q.loose ? o[h.LOOSE] : o[h.FULL]);
          if (!$)
            throw new TypeError("Invalid Version: " + z);
          if (this.raw = z, this.major = +$[1], this.minor = +$[2], this.patch = +$[3], this.major > f || this.major < 0)
            throw new TypeError("Invalid major version");
          if (this.minor > f || this.minor < 0)
            throw new TypeError("Invalid minor version");
          if (this.patch > f || this.patch < 0)
            throw new TypeError("Invalid patch version");
          $[4] ? this.prerelease = $[4].split(".").map(function(Y) {
            if (/^[0-9]+$/.test(Y)) {
              var H = +Y;
              if (H >= 0 && H < f)
                return H;
            }
            return Y;
          }) : this.prerelease = [], this.build = $[5] ? $[5].split(".") : [], this.format();
        }
        r.parse = P, r.valid = function(z, q) {
          var $ = P(z, q);
          return $ ? $.version : null;
        }, r.clean = function(z, q) {
          var $ = P(z.trim().replace(/^[=v]+/, ""), q);
          return $ ? $.version : null;
        }, r.SemVer = R, R.prototype.format = function() {
          return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
        }, R.prototype.toString = function() {
          return this.version;
        }, R.prototype.compare = function(z) {
          return l("SemVer.compare", this.version, this.options, z), z instanceof R || (z = new R(z, this.options)), this.compareMain(z) || this.comparePre(z);
        }, R.prototype.compareMain = function(z) {
          return z instanceof R || (z = new R(z, this.options)), C(this.major, z.major) || C(this.minor, z.minor) || C(this.patch, z.patch);
        }, R.prototype.comparePre = function(z) {
          if (z instanceof R || (z = new R(z, this.options)), this.prerelease.length && !z.prerelease.length)
            return -1;
          if (!this.prerelease.length && z.prerelease.length)
            return 1;
          if (!this.prerelease.length && !z.prerelease.length)
            return 0;
          var q = 0;
          do {
            var $ = this.prerelease[q], Y = z.prerelease[q];
            if (l("prerelease compare", q, $, Y), $ === void 0 && Y === void 0)
              return 0;
            if (Y === void 0)
              return 1;
            if ($ === void 0)
              return -1;
            if ($ !== Y)
              return C($, Y);
          } while (++q);
        }, R.prototype.compareBuild = function(z) {
          z instanceof R || (z = new R(z, this.options));
          var q = 0;
          do {
            var $ = this.build[q], Y = z.build[q];
            if (l("prerelease compare", q, $, Y), $ === void 0 && Y === void 0)
              return 0;
            if (Y === void 0)
              return 1;
            if ($ === void 0)
              return -1;
            if ($ !== Y)
              return C($, Y);
          } while (++q);
        }, R.prototype.inc = function(z, q) {
          switch (z) {
            case "premajor":
              this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", q);
              break;
            case "preminor":
              this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", q);
              break;
            case "prepatch":
              this.prerelease.length = 0, this.inc("patch", q), this.inc("pre", q);
              break;
            case "prerelease":
              this.prerelease.length === 0 && this.inc("patch", q), this.inc("pre", q);
              break;
            case "major":
              this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
              break;
            case "minor":
              this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
              break;
            case "patch":
              this.prerelease.length === 0 && this.patch++, this.prerelease = [];
              break;
            case "pre":
              if (this.prerelease.length === 0)
                this.prerelease = [0];
              else {
                for (var $ = this.prerelease.length; --$ >= 0; )
                  typeof this.prerelease[$] == "number" && (this.prerelease[$]++, $ = -2);
                $ === -1 && this.prerelease.push(0);
              }
              q && (this.prerelease[0] === q ? isNaN(this.prerelease[1]) && (this.prerelease = [q, 0]) : this.prerelease = [q, 0]);
              break;
            default:
              throw new Error("invalid increment argument: " + z);
          }
          return this.format(), this.raw = this.version, this;
        }, r.inc = function(z, q, $, Y) {
          typeof $ == "string" && (Y = $, $ = void 0);
          try {
            return new R(z, $).inc(q, Y).version;
          } catch {
            return null;
          }
        }, r.diff = function(z, q) {
          if (F(z, q))
            return null;
          var $ = P(z), Y = P(q), H = "";
          if ($.prerelease.length || Y.prerelease.length) {
            H = "pre";
            var Q = "prerelease";
          }
          for (var X in $)
            if ((X === "major" || X === "minor" || X === "patch") && $[X] !== Y[X])
              return H + X;
          return Q;
        }, r.compareIdentifiers = C;
        var N = /^[0-9]+$/;
        function C(z, q) {
          var $ = N.test(z), Y = N.test(q);
          return $ && Y && (z = +z, q = +q), z === q ? 0 : $ && !Y ? -1 : Y && !$ ? 1 : z < q ? -1 : 1;
        }
        function I(z, q, $) {
          return new R(z, $).compare(new R(q, $));
        }
        function D(z, q, $) {
          return I(z, q, $) > 0;
        }
        function j(z, q, $) {
          return I(z, q, $) < 0;
        }
        function F(z, q, $) {
          return I(z, q, $) === 0;
        }
        function _(z, q, $) {
          return I(z, q, $) !== 0;
        }
        function T(z, q, $) {
          return I(z, q, $) >= 0;
        }
        function v(z, q, $) {
          return I(z, q, $) <= 0;
        }
        function w(z, q, $, Y) {
          switch (q) {
            case "===":
              return typeof z == "object" && (z = z.version), typeof $ == "object" && ($ = $.version), z === $;
            case "!==":
              return typeof z == "object" && (z = z.version), typeof $ == "object" && ($ = $.version), z !== $;
            case "":
            case "=":
            case "==":
              return F(z, $, Y);
            case "!=":
              return _(z, $, Y);
            case ">":
              return D(z, $, Y);
            case ">=":
              return T(z, $, Y);
            case "<":
              return j(z, $, Y);
            case "<=":
              return v(z, $, Y);
            default:
              throw new TypeError("Invalid operator: " + q);
          }
        }
        function O(z, q) {
          if (q && typeof q == "object" || (q = { loose: !!q, includePrerelease: !1 }), z instanceof O) {
            if (z.loose === !!q.loose)
              return z;
            z = z.value;
          }
          if (!(this instanceof O))
            return new O(z, q);
          z = z.trim().split(/\s+/).join(" "), l("comparator", z, q), this.options = q, this.loose = !!q.loose, this.parse(z), this.semver === G ? this.value = "" : this.value = this.operator + this.semver.version, l("comp", this);
        }
        r.rcompareIdentifiers = function(z, q) {
          return C(q, z);
        }, r.major = function(z, q) {
          return new R(z, q).major;
        }, r.minor = function(z, q) {
          return new R(z, q).minor;
        }, r.patch = function(z, q) {
          return new R(z, q).patch;
        }, r.compare = I, r.compareLoose = function(z, q) {
          return I(z, q, !0);
        }, r.compareBuild = function(z, q, $) {
          var Y = new R(z, $), H = new R(q, $);
          return Y.compare(H) || Y.compareBuild(H);
        }, r.rcompare = function(z, q, $) {
          return I(q, z, $);
        }, r.sort = function(z, q) {
          return z.sort(function($, Y) {
            return r.compareBuild($, Y, q);
          });
        }, r.rsort = function(z, q) {
          return z.sort(function($, Y) {
            return r.compareBuild(Y, $, q);
          });
        }, r.gt = D, r.lt = j, r.eq = F, r.neq = _, r.gte = T, r.lte = v, r.cmp = w, r.Comparator = O;
        var G = {};
        function W(z, q) {
          if (q && typeof q == "object" || (q = { loose: !!q, includePrerelease: !1 }), z instanceof W)
            return z.loose === !!q.loose && z.includePrerelease === !!q.includePrerelease ? z : new W(z.raw, q);
          if (z instanceof O)
            return new W(z.value, q);
          if (!(this instanceof W))
            return new W(z, q);
          if (this.options = q, this.loose = !!q.loose, this.includePrerelease = !!q.includePrerelease, this.raw = z.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map(function($) {
            return this.parseRange($.trim());
          }, this).filter(function($) {
            return $.length;
          }), !this.set.length)
            throw new TypeError("Invalid SemVer Range: " + this.raw);
          this.format();
        }
        function U(z, q) {
          for (var $ = !0, Y = z.slice(), H = Y.pop(); $ && Y.length; )
            $ = Y.every(function(Q) {
              return H.intersects(Q, q);
            }), H = Y.pop();
          return $;
        }
        function M(z) {
          return !z || z.toLowerCase() === "x" || z === "*";
        }
        function B(z, q, $, Y, H, Q, X, ne, ye, ve, de, oe, re) {
          return ((q = M($) ? "" : M(Y) ? ">=" + $ + ".0.0" : M(H) ? ">=" + $ + "." + Y + ".0" : ">=" + q) + " " + (ne = M(ye) ? "" : M(ve) ? "<" + (+ye + 1) + ".0.0" : M(de) ? "<" + ye + "." + (+ve + 1) + ".0" : oe ? "<=" + ye + "." + ve + "." + de + "-" + oe : "<=" + ne)).trim();
        }
        function k(z, q, $) {
          for (var Y = 0; Y < z.length; Y++)
            if (!z[Y].test(q))
              return !1;
          if (q.prerelease.length && !$.includePrerelease) {
            for (Y = 0; Y < z.length; Y++)
              if (l(z[Y].semver), z[Y].semver !== G && z[Y].semver.prerelease.length > 0) {
                var H = z[Y].semver;
                if (H.major === q.major && H.minor === q.minor && H.patch === q.patch)
                  return !0;
              }
            return !1;
          }
          return !0;
        }
        function K(z, q, $) {
          try {
            q = new W(q, $);
          } catch {
            return !1;
          }
          return q.test(z);
        }
        function te(z, q, $, Y) {
          var H, Q, X, ne, ye;
          switch (z = new R(z, Y), q = new W(q, Y), $) {
            case ">":
              H = D, Q = v, X = j, ne = ">", ye = ">=";
              break;
            case "<":
              H = j, Q = T, X = D, ne = "<", ye = "<=";
              break;
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"');
          }
          if (K(z, q, Y))
            return !1;
          for (var ve = 0; ve < q.set.length; ++ve) {
            var de = q.set[ve], oe = null, re = null;
            if (de.forEach(function(ae) {
              ae.semver === G && (ae = new O(">=0.0.0")), oe = oe || ae, re = re || ae, H(ae.semver, oe.semver, Y) ? oe = ae : X(ae.semver, re.semver, Y) && (re = ae);
            }), oe.operator === ne || oe.operator === ye || (!re.operator || re.operator === ne) && Q(z, re.semver) || re.operator === ye && X(z, re.semver))
              return !1;
          }
          return !0;
        }
        O.prototype.parse = function(z) {
          var q = this.options.loose ? o[h.COMPARATORLOOSE] : o[h.COMPARATOR], $ = z.match(q);
          if (!$)
            throw new TypeError("Invalid comparator: " + z);
          this.operator = $[1] !== void 0 ? $[1] : "", this.operator === "=" && (this.operator = ""), $[2] ? this.semver = new R($[2], this.options.loose) : this.semver = G;
        }, O.prototype.toString = function() {
          return this.value;
        }, O.prototype.test = function(z) {
          if (l("Comparator.test", z, this.options.loose), this.semver === G || z === G)
            return !0;
          if (typeof z == "string")
            try {
              z = new R(z, this.options);
            } catch {
              return !1;
            }
          return w(z, this.operator, this.semver, this.options);
        }, O.prototype.intersects = function(z, q) {
          if (!(z instanceof O))
            throw new TypeError("a Comparator is required");
          var $;
          if (q && typeof q == "object" || (q = { loose: !!q, includePrerelease: !1 }), this.operator === "")
            return this.value === "" || ($ = new W(z.value, q), K(this.value, $, q));
          if (z.operator === "")
            return z.value === "" || ($ = new W(this.value, q), K(z.semver, $, q));
          var Y = !(this.operator !== ">=" && this.operator !== ">" || z.operator !== ">=" && z.operator !== ">"), H = !(this.operator !== "<=" && this.operator !== "<" || z.operator !== "<=" && z.operator !== "<"), Q = this.semver.version === z.semver.version, X = !(this.operator !== ">=" && this.operator !== "<=" || z.operator !== ">=" && z.operator !== "<="), ne = w(this.semver, "<", z.semver, q) && (this.operator === ">=" || this.operator === ">") && (z.operator === "<=" || z.operator === "<"), ye = w(this.semver, ">", z.semver, q) && (this.operator === "<=" || this.operator === "<") && (z.operator === ">=" || z.operator === ">");
          return Y || H || Q && X || ne || ye;
        }, r.Range = W, W.prototype.format = function() {
          return this.range = this.set.map(function(z) {
            return z.join(" ").trim();
          }).join("||").trim(), this.range;
        }, W.prototype.toString = function() {
          return this.range;
        }, W.prototype.parseRange = function(z) {
          var q = this.options.loose, $ = q ? o[h.HYPHENRANGELOOSE] : o[h.HYPHENRANGE];
          z = z.replace($, B), l("hyphen replace", z), z = z.replace(o[h.COMPARATORTRIM], "$1$2$3"), l("comparator trim", z, o[h.COMPARATORTRIM]), z = (z = (z = z.replace(o[h.TILDETRIM], "$1~")).replace(o[h.CARETTRIM], "$1^")).split(/\s+/).join(" ");
          var Y = q ? o[h.COMPARATORLOOSE] : o[h.COMPARATOR], H = z.split(" ").map(function(Q) {
            return function(X, ne) {
              return l("comp", X, ne), X = function(ye, ve) {
                return ye.trim().split(/\s+/).map(function(de) {
                  return function(oe, re) {
                    l("caret", oe, re);
                    var ae = re.loose ? o[h.CARETLOOSE] : o[h.CARET];
                    return oe.replace(ae, function(le, ue, ie, we, De) {
                      var Ee;
                      return l("caret", oe, le, ue, ie, we, De), M(ue) ? Ee = "" : M(ie) ? Ee = ">=" + ue + ".0.0 <" + (+ue + 1) + ".0.0" : M(we) ? Ee = ue === "0" ? ">=" + ue + "." + ie + ".0 <" + ue + "." + (+ie + 1) + ".0" : ">=" + ue + "." + ie + ".0 <" + (+ue + 1) + ".0.0" : De ? (l("replaceCaret pr", De), Ee = ue === "0" ? ie === "0" ? ">=" + ue + "." + ie + "." + we + "-" + De + " <" + ue + "." + ie + "." + (+we + 1) : ">=" + ue + "." + ie + "." + we + "-" + De + " <" + ue + "." + (+ie + 1) + ".0" : ">=" + ue + "." + ie + "." + we + "-" + De + " <" + (+ue + 1) + ".0.0") : (l("no pr"), Ee = ue === "0" ? ie === "0" ? ">=" + ue + "." + ie + "." + we + " <" + ue + "." + ie + "." + (+we + 1) : ">=" + ue + "." + ie + "." + we + " <" + ue + "." + (+ie + 1) + ".0" : ">=" + ue + "." + ie + "." + we + " <" + (+ue + 1) + ".0.0"), l("caret return", Ee), Ee;
                    });
                  }(de, ve);
                }).join(" ");
              }(X, ne), l("caret", X), X = function(ye, ve) {
                return ye.trim().split(/\s+/).map(function(de) {
                  return function(oe, re) {
                    var ae = re.loose ? o[h.TILDELOOSE] : o[h.TILDE];
                    return oe.replace(ae, function(le, ue, ie, we, De) {
                      var Ee;
                      return l("tilde", oe, le, ue, ie, we, De), M(ue) ? Ee = "" : M(ie) ? Ee = ">=" + ue + ".0.0 <" + (+ue + 1) + ".0.0" : M(we) ? Ee = ">=" + ue + "." + ie + ".0 <" + ue + "." + (+ie + 1) + ".0" : De ? (l("replaceTilde pr", De), Ee = ">=" + ue + "." + ie + "." + we + "-" + De + " <" + ue + "." + (+ie + 1) + ".0") : Ee = ">=" + ue + "." + ie + "." + we + " <" + ue + "." + (+ie + 1) + ".0", l("tilde return", Ee), Ee;
                    });
                  }(de, ve);
                }).join(" ");
              }(X, ne), l("tildes", X), X = function(ye, ve) {
                return l("replaceXRanges", ye, ve), ye.split(/\s+/).map(function(de) {
                  return function(oe, re) {
                    oe = oe.trim();
                    var ae = re.loose ? o[h.XRANGELOOSE] : o[h.XRANGE];
                    return oe.replace(ae, function(le, ue, ie, we, De, Ee) {
                      l("xRange", oe, le, ue, ie, we, De, Ee);
                      var Ae = M(ie), Me = Ae || M(we), me = Me || M(De), se = me;
                      return ue === "=" && se && (ue = ""), Ee = re.includePrerelease ? "-0" : "", Ae ? le = ue === ">" || ue === "<" ? "<0.0.0-0" : "*" : ue && se ? (Me && (we = 0), De = 0, ue === ">" ? (ue = ">=", Me ? (ie = +ie + 1, we = 0, De = 0) : (we = +we + 1, De = 0)) : ue === "<=" && (ue = "<", Me ? ie = +ie + 1 : we = +we + 1), le = ue + ie + "." + we + "." + De + Ee) : Me ? le = ">=" + ie + ".0.0" + Ee + " <" + (+ie + 1) + ".0.0" + Ee : me && (le = ">=" + ie + "." + we + ".0" + Ee + " <" + ie + "." + (+we + 1) + ".0" + Ee), l("xRange return", le), le;
                    });
                  }(de, ve);
                }).join(" ");
              }(X, ne), l("xrange", X), X = function(ye, ve) {
                return l("replaceStars", ye, ve), ye.trim().replace(o[h.STAR], "");
              }(X, ne), l("stars", X), X;
            }(Q, this.options);
          }, this).join(" ").split(/\s+/);
          return this.options.loose && (H = H.filter(function(Q) {
            return !!Q.match(Y);
          })), H = H.map(function(Q) {
            return new O(Q, this.options);
          }, this);
        }, W.prototype.intersects = function(z, q) {
          if (!(z instanceof W))
            throw new TypeError("a Range is required");
          return this.set.some(function($) {
            return U($, q) && z.set.some(function(Y) {
              return U(Y, q) && $.every(function(H) {
                return Y.every(function(Q) {
                  return H.intersects(Q, q);
                });
              });
            });
          });
        }, r.toComparators = function(z, q) {
          return new W(z, q).set.map(function($) {
            return $.map(function(Y) {
              return Y.value;
            }).join(" ").trim().split(" ");
          });
        }, W.prototype.test = function(z) {
          if (!z)
            return !1;
          if (typeof z == "string")
            try {
              z = new R(z, this.options);
            } catch {
              return !1;
            }
          for (var q = 0; q < this.set.length; q++)
            if (k(this.set[q], z, this.options))
              return !0;
          return !1;
        }, r.satisfies = K, r.maxSatisfying = function(z, q, $) {
          var Y = null, H = null;
          try {
            var Q = new W(q, $);
          } catch {
            return null;
          }
          return z.forEach(function(X) {
            Q.test(X) && (Y && H.compare(X) !== -1 || (H = new R(Y = X, $)));
          }), Y;
        }, r.minSatisfying = function(z, q, $) {
          var Y = null, H = null;
          try {
            var Q = new W(q, $);
          } catch {
            return null;
          }
          return z.forEach(function(X) {
            Q.test(X) && (Y && H.compare(X) !== 1 || (H = new R(Y = X, $)));
          }), Y;
        }, r.minVersion = function(z, q) {
          z = new W(z, q);
          var $ = new R("0.0.0");
          if (z.test($) || ($ = new R("0.0.0-0"), z.test($)))
            return $;
          $ = null;
          for (var Y = 0; Y < z.set.length; ++Y)
            z.set[Y].forEach(function(H) {
              var Q = new R(H.semver.version);
              switch (H.operator) {
                case ">":
                  Q.prerelease.length === 0 ? Q.patch++ : Q.prerelease.push(0), Q.raw = Q.format();
                case "":
                case ">=":
                  $ && !D($, Q) || ($ = Q);
                  break;
                case "<":
                case "<=":
                  break;
                default:
                  throw new Error("Unexpected operation: " + H.operator);
              }
            });
          return $ && z.test($) ? $ : null;
        }, r.validRange = function(z, q) {
          try {
            return new W(z, q).range || "*";
          } catch {
            return null;
          }
        }, r.ltr = function(z, q, $) {
          return te(z, q, "<", $);
        }, r.gtr = function(z, q, $) {
          return te(z, q, ">", $);
        }, r.outside = te, r.prerelease = function(z, q) {
          var $ = P(z, q);
          return $ && $.prerelease.length ? $.prerelease : null;
        }, r.intersects = function(z, q, $) {
          return z = new W(z, $), q = new W(q, $), z.intersects(q);
        }, r.coerce = function(z, q) {
          if (z instanceof R)
            return z;
          if (typeof z == "number" && (z = String(z)), typeof z != "string")
            return null;
          var $ = null;
          if ((q = q || {}).rtl) {
            for (var Y; (Y = o[h.COERCERTL].exec(z)) && (!$ || $.index + $[0].length !== z.length); )
              $ && Y.index + Y[0].length === $.index + $[0].length || ($ = Y), o[h.COERCERTL].lastIndex = Y.index + Y[1].length + Y[2].length;
            o[h.COERCERTL].lastIndex = -1;
          } else
            $ = z.match(o[h.COERCE]);
          return $ === null ? null : P($[2] + "." + ($[3] || "0") + "." + ($[4] || "0"), q);
        };
      }, "./node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js": (u, r, l) => {
        const i = l("os"), f = l("tty"), d = l("./node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"), { env: s } = Ve.process;
        let o;
        function m(y) {
          return y !== 0 && { level: y, hasBasic: !0, has256: y >= 2, has16m: y >= 3 };
        }
        function h(y, b) {
          if (o === 0)
            return 0;
          if (d("color=16m") || d("color=full") || d("color=truecolor"))
            return 3;
          if (d("color=256"))
            return 2;
          if (y && !b && o === void 0)
            return 0;
          const E = o || 0;
          if (s.TERM === "dumb")
            return E;
          if (Ve.process.platform === "win32") {
            const S = i.release().split(".");
            return Number(S[0]) >= 10 && Number(S[2]) >= 10586 ? Number(S[2]) >= 14931 ? 3 : 2 : 1;
          }
          if ("CI" in s)
            return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((S) => S in s) || s.CI_NAME === "codeship" ? 1 : E;
          if ("TEAMCITY_VERSION" in s)
            return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(s.TEAMCITY_VERSION) ? 1 : 0;
          if (s.COLORTERM === "truecolor")
            return 3;
          if ("TERM_PROGRAM" in s) {
            const S = parseInt((s.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (s.TERM_PROGRAM) {
              case "iTerm.app":
                return S >= 3 ? 3 : 2;
              case "Apple_Terminal":
                return 2;
            }
          }
          return /-256(color)?$/i.test(s.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(s.TERM) || "COLORTERM" in s ? 1 : E;
        }
        d("no-color") || d("no-colors") || d("color=false") || d("color=never") ? o = 0 : (d("color") || d("colors") || d("color=true") || d("color=always")) && (o = 1), "FORCE_COLOR" in s && (o = s.FORCE_COLOR === "true" ? 1 : s.FORCE_COLOR === "false" ? 0 : s.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(s.FORCE_COLOR, 10), 3)), u.exports = { supportsColor: function(y) {
          return m(h(y, y && y.isTTY));
        }, stdout: m(h(!0, f.isatty(1))), stderr: m(h(!0, f.isatty(2))) };
      }, "./node_modules/.pnpm/to-fast-properties@2.0.0/node_modules/to-fast-properties/index.js": (u) => {
        let r = null;
        function l(i) {
          if (r !== null && (r.property, 1)) {
            const f = r;
            return r = l.prototype = null, f;
          }
          return r = l.prototype = i ?? /* @__PURE__ */ Object.create(null), new l();
        }
        l(), u.exports = function(i) {
          return l(i);
        };
      }, "./stubs/babel-codeframe.js": (u, r, l) => {
        function i() {
          return "";
        }
        l.r(r), l.d(r, { codeFrameColumns: () => i });
      }, "./stubs/helper-compilation-targets.js": (u, r, l) => {
        function i() {
          return {};
        }
        l.r(r), l.d(r, { default: () => i });
      }, assert: (u) => {
        u.exports = ru();
      }, fs: (u) => {
        u.exports = Dn;
      }, module: (u) => {
        u.exports = xr;
      }, os: (u) => {
        u.exports = jr;
      }, path: (u) => {
        u.exports = Lr;
      }, process: (u) => {
        u.exports = sd;
      }, tty: (u) => {
        u.exports = $H();
      }, url: (u) => {
        u.exports = ds;
      }, util: (u) => {
        u.exports = mi;
      }, v8: (u) => {
        u.exports = xr;
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/caching.js": (u, r, l) => {
        function i() {
          const R = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return i = function() {
            return R;
          }, R;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.assertSimpleType = g, r.makeStrongCache = h, r.makeStrongCacheSync = function(R) {
          return s(h(R));
        }, r.makeWeakCache = m, r.makeWeakCacheSync = function(R) {
          return s(m(R));
        };
        var f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/gensync-utils/async.js"), d = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/util.js");
        const s = (R) => i()(R).sync;
        function* o() {
          return !0;
        }
        function m(R) {
          return y(WeakMap, R);
        }
        function h(R) {
          return y(Map, R);
        }
        function y(R, N) {
          const C = new R(), I = new R(), D = new R();
          return function* (j, F) {
            const _ = yield* (0, f.isAsync)(), T = _ ? I : C, v = yield* function* (U, M, B, k, K) {
              const te = yield* b(M, k, K);
              if (te.valid)
                return te;
              if (U) {
                const z = yield* b(B, k, K);
                if (z.valid)
                  return { valid: !0, value: yield* (0, f.waitFor)(z.value.promise) };
              }
              return { valid: !1, value: null };
            }(_, T, D, j, F);
            if (v.valid)
              return v.value;
            const w = new S(F), O = N(j, w);
            let G, W;
            return W = (0, d.isIterableIterator)(O) ? yield* (0, f.onFirstPause)(O, () => {
              G = function(U, M, B) {
                const k = new P();
                return E(M, U, B, k), k;
              }(w, D, j);
            }) : O, E(T, w, j, W), G && (D.delete(j), G.release(W)), W;
          };
        }
        function* b(R, N, C) {
          const I = R.get(N);
          if (I) {
            for (const { value: D, valid: j } of I)
              if (yield* j(C))
                return { valid: !0, value: D };
          }
          return { valid: !1, value: null };
        }
        function E(R, N, C, I) {
          N.configured() || N.forever();
          let D = R.get(C);
          switch (N.deactivate(), N.mode()) {
            case "forever":
              D = [{ value: I, valid: o }], R.set(C, D);
              break;
            case "invalidate":
              D = [{ value: I, valid: N.validator() }], R.set(C, D);
              break;
            case "valid":
              D ? D.push({ value: I, valid: N.validator() }) : (D = [{ value: I, valid: N.validator() }], R.set(C, D));
          }
        }
        class S {
          constructor(N) {
            this._active = !0, this._never = !1, this._forever = !1, this._invalidate = !1, this._configured = !1, this._pairs = [], this._data = void 0, this._data = N;
          }
          simple() {
            return function(N) {
              function C(I) {
                if (typeof I != "boolean")
                  return N.using(() => g(I()));
                I ? N.forever() : N.never();
              }
              return C.forever = () => N.forever(), C.never = () => N.never(), C.using = (I) => N.using(() => g(I())), C.invalidate = (I) => N.invalidate(() => g(I())), C;
            }(this);
          }
          mode() {
            return this._never ? "never" : this._forever ? "forever" : this._invalidate ? "invalidate" : "valid";
          }
          forever() {
            if (!this._active)
              throw new Error("Cannot change caching after evaluation has completed.");
            if (this._never)
              throw new Error("Caching has already been configured with .never()");
            this._forever = !0, this._configured = !0;
          }
          never() {
            if (!this._active)
              throw new Error("Cannot change caching after evaluation has completed.");
            if (this._forever)
              throw new Error("Caching has already been configured with .forever()");
            this._never = !0, this._configured = !0;
          }
          using(N) {
            if (!this._active)
              throw new Error("Cannot change caching after evaluation has completed.");
            if (this._never || this._forever)
              throw new Error("Caching has already been configured with .never or .forever()");
            this._configured = !0;
            const C = N(this._data), I = (0, f.maybeAsync)(N, "You appear to be using an async cache handler, but Babel has been called synchronously");
            return (0, f.isThenable)(C) ? C.then((D) => (this._pairs.push([D, I]), D)) : (this._pairs.push([C, I]), C);
          }
          invalidate(N) {
            return this._invalidate = !0, this.using(N);
          }
          validator() {
            const N = this._pairs;
            return function* (C) {
              for (const [I, D] of N)
                if (I !== (yield* D(C)))
                  return !1;
              return !0;
            };
          }
          deactivate() {
            this._active = !1;
          }
          configured() {
            return this._configured;
          }
        }
        function g(R) {
          if ((0, f.isThenable)(R))
            throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously handle your caching logic.");
          if (R != null && typeof R != "string" && typeof R != "boolean" && typeof R != "number")
            throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
          return R;
        }
        class P {
          constructor() {
            this.released = !1, this.promise = void 0, this._resolve = void 0, this.promise = new Promise((N) => {
              this._resolve = N;
            });
          }
          release(N) {
            this.released = !0, this._resolve(N);
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/config-chain.js": (u, r, l) => {
        function i() {
          const de = l("path");
          return i = function() {
            return de;
          }, de;
        }
        function f() {
          const de = l("./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js");
          return f = function() {
            return de;
          }, de;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.buildPresetChain = function* (de, oe) {
          const re = yield* g(de, oe);
          return re ? { plugins: Y(re.plugins), presets: Y(re.presets), options: re.options.map((ae) => $(ae)), files: /* @__PURE__ */ new Set() } : null;
        }, r.buildPresetChainWalker = void 0, r.buildRootChain = function* (de, oe) {
          let re, ae;
          const le = new o.ConfigPrinter(), ue = yield* F({ options: de, dirname: oe.cwd }, oe, void 0, le);
          if (!ue)
            return null;
          const ie = yield* le.output();
          let we;
          typeof de.configFile == "string" ? we = yield* (0, y.loadConfig)(de.configFile, oe.cwd, oe.envName, oe.caller) : de.configFile !== !1 && (we = yield* (0, y.findRootConfig)(oe.root, oe.envName, oe.caller));
          let { babelrc: De, babelrcRoots: Ee } = de, Ae = oe.cwd;
          const Me = q(), me = new o.ConfigPrinter();
          if (we) {
            const Ie = I(we), We = yield* T(Ie, oe, void 0, me);
            if (!We)
              return null;
            re = yield* me.output(), De === void 0 && (De = Ie.options.babelrc), Ee === void 0 && (Ae = Ie.dirname, Ee = Ie.options.babelrcRoots), te(Me, We);
          }
          let se, Z, pe = !1;
          const be = q();
          if ((De === !0 || De === void 0) && typeof oe.filename == "string") {
            const Ie = yield* (0, y.findPackageData)(oe.filename);
            if (Ie && function(We, tt, Ye, ht) {
              if (typeof Ye == "boolean")
                return Ye;
              const ct = We.root;
              if (Ye === void 0)
                return tt.directories.indexOf(ct) !== -1;
              let st = Ye;
              return Array.isArray(st) || (st = [st]), st = st.map((Xe) => typeof Xe == "string" ? i().resolve(ht, Xe) : Xe), st.length === 1 && st[0] === ct ? tt.directories.indexOf(ct) !== -1 : st.some((Xe) => (typeof Xe == "string" && (Xe = (0, s.default)(Xe, ht)), tt.directories.some((Ke) => ve(Xe, ht, Ke, We))));
            }(oe, Ie, Ee, Ae)) {
              if ({ ignore: se, config: Z } = yield* (0, y.findRelativeConfig)(Ie, oe.envName, oe.caller), se && be.files.add(se.filepath), se && ne(oe, se.ignore, null, se.dirname) && (pe = !0), Z && !pe) {
                const We = D(Z), tt = new o.ConfigPrinter(), Ye = yield* T(We, oe, void 0, tt);
                Ye ? (ae = yield* tt.output(), te(be, Ye)) : pe = !0;
              }
              Z && pe && be.files.add(Z.filepath);
            }
          }
          oe.showConfig && console.log(`Babel configs on "${oe.filename}" (ascending priority):
` + [re, ae, ie].filter((Ie) => !!Ie).join(`

`) + `
-----End Babel configs-----`);
          const _e = te(te(te(q(), Me), be), ue);
          return { plugins: pe ? [] : Y(_e.plugins), presets: pe ? [] : Y(_e.presets), options: pe ? [] : _e.options.map((Ie) => $(Ie)), fileHandling: pe ? "ignored" : "transpile", ignore: se || void 0, babelrc: Z || void 0, config: we || void 0, files: _e.files };
        };
        var d = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/validation/options.js"), s = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/pattern-to-regex.js"), o = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/printer.js"), m = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js"), h = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/errors/config-error.js"), y = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/index.js"), b = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/caching.js"), E = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/config-descriptors.js");
        const S = f()("babel:config:config-chain"), g = k({ root: (de) => P(de), env: (de, oe) => R(de)(oe), overrides: (de, oe) => N(de)(oe), overridesEnv: (de, oe, re) => C(de)(oe)(re), createLogger: () => () => {
        } });
        r.buildPresetChainWalker = g;
        const P = (0, b.makeWeakCacheSync)((de) => W(de, de.alias, E.createUncachedDescriptors)), R = (0, b.makeWeakCacheSync)((de) => (0, b.makeStrongCacheSync)((oe) => U(de, de.alias, E.createUncachedDescriptors, oe))), N = (0, b.makeWeakCacheSync)((de) => (0, b.makeStrongCacheSync)((oe) => M(de, de.alias, E.createUncachedDescriptors, oe))), C = (0, b.makeWeakCacheSync)((de) => (0, b.makeStrongCacheSync)((oe) => (0, b.makeStrongCacheSync)((re) => B(de, de.alias, E.createUncachedDescriptors, oe, re)))), I = (0, b.makeWeakCacheSync)((de) => ({ filepath: de.filepath, dirname: de.dirname, options: (0, d.validate)("configfile", de.options, de.filepath) })), D = (0, b.makeWeakCacheSync)((de) => ({ filepath: de.filepath, dirname: de.dirname, options: (0, d.validate)("babelrcfile", de.options, de.filepath) })), j = (0, b.makeWeakCacheSync)((de) => ({ filepath: de.filepath, dirname: de.dirname, options: (0, d.validate)("extendsfile", de.options, de.filepath) })), F = k({ root: (de) => W(de, "base", E.createCachedDescriptors), env: (de, oe) => U(de, "base", E.createCachedDescriptors, oe), overrides: (de, oe) => M(de, "base", E.createCachedDescriptors, oe), overridesEnv: (de, oe, re) => B(de, "base", E.createCachedDescriptors, oe, re), createLogger: (de, oe, re) => function(ae, le, ue) {
          var ie;
          return ue ? ue.configure(le.showConfig, o.ChainFormatter.Programmatic, { callerName: (ie = le.caller) == null ? void 0 : ie.name }) : () => {
          };
        }(0, oe, re) }), _ = k({ root: (de) => v(de), env: (de, oe) => w(de)(oe), overrides: (de, oe) => O(de)(oe), overridesEnv: (de, oe, re) => G(de)(oe)(re), createLogger: (de, oe, re) => function(ae, le, ue) {
          return ue ? ue.configure(le.showConfig, o.ChainFormatter.Config, { filepath: ae }) : () => {
          };
        }(de.filepath, oe, re) });
        function* T(de, oe, re, ae) {
          const le = yield* _(de, oe, re, ae);
          return le == null || le.files.add(de.filepath), le;
        }
        const v = (0, b.makeWeakCacheSync)((de) => W(de, de.filepath, E.createUncachedDescriptors)), w = (0, b.makeWeakCacheSync)((de) => (0, b.makeStrongCacheSync)((oe) => U(de, de.filepath, E.createUncachedDescriptors, oe))), O = (0, b.makeWeakCacheSync)((de) => (0, b.makeStrongCacheSync)((oe) => M(de, de.filepath, E.createUncachedDescriptors, oe))), G = (0, b.makeWeakCacheSync)((de) => (0, b.makeStrongCacheSync)((oe) => (0, b.makeStrongCacheSync)((re) => B(de, de.filepath, E.createUncachedDescriptors, oe, re))));
        function W({ dirname: de, options: oe }, re, ae) {
          return ae(de, oe, re);
        }
        function U({ dirname: de, options: oe }, re, ae, le) {
          var ue;
          const ie = (ue = oe.env) == null ? void 0 : ue[le];
          return ie ? ae(de, ie, `${re}.env["${le}"]`) : null;
        }
        function M({ dirname: de, options: oe }, re, ae, le) {
          var ue;
          const ie = (ue = oe.overrides) == null ? void 0 : ue[le];
          if (!ie)
            throw new Error("Assertion failure - missing override");
          return ae(de, ie, `${re}.overrides[${le}]`);
        }
        function B({ dirname: de, options: oe }, re, ae, le, ue) {
          var ie, we;
          const De = (ie = oe.overrides) == null ? void 0 : ie[le];
          if (!De)
            throw new Error("Assertion failure - missing override");
          const Ee = (we = De.env) == null ? void 0 : we[ue];
          return Ee ? ae(de, Ee, `${re}.overrides[${le}].env["${ue}"]`) : null;
        }
        function k({ root: de, env: oe, overrides: re, overridesEnv: ae, createLogger: le }) {
          return function* (ue, ie, we = /* @__PURE__ */ new Set(), De) {
            const { dirname: Ee } = ue, Ae = [], Me = de(ue);
            if (H(Me, Ee, ie, ue.filepath)) {
              Ae.push({ config: Me, envName: void 0, index: void 0 });
              const Z = oe(ue, ie.envName);
              Z && H(Z, Ee, ie, ue.filepath) && Ae.push({ config: Z, envName: ie.envName, index: void 0 }), (Me.options.overrides || []).forEach((pe, be) => {
                const _e = re(ue, be);
                if (H(_e, Ee, ie, ue.filepath)) {
                  Ae.push({ config: _e, index: be, envName: void 0 });
                  const Ie = ae(ue, be, ie.envName);
                  Ie && H(Ie, Ee, ie, ue.filepath) && Ae.push({ config: Ie, index: be, envName: ie.envName });
                }
              });
            }
            if (Ae.some(({ config: { options: { ignore: Z, only: pe } } }) => ne(ie, Z, pe, Ee)))
              return null;
            const me = q(), se = le(ue, ie, De);
            for (const { config: Z, index: pe, envName: be } of Ae) {
              if (!(yield* K(me, Z.options, Ee, ie, we, De)))
                return null;
              se(Z, pe, be), yield* z(me, Z);
            }
            return me;
          };
        }
        function* K(de, oe, re, ae, le, ue) {
          if (oe.extends === void 0)
            return !0;
          const ie = yield* (0, y.loadConfig)(oe.extends, re, ae.envName, ae.caller);
          if (le.has(ie))
            throw new Error(`Configuration cycle detected loading ${ie.filepath}.
File already loaded following the config chain:
` + Array.from(le, (De) => ` - ${De.filepath}`).join(`
`));
          le.add(ie);
          const we = yield* T(j(ie), ae, le, ue);
          return le.delete(ie), !!we && (te(de, we), !0);
        }
        function te(de, oe) {
          de.options.push(...oe.options), de.plugins.push(...oe.plugins), de.presets.push(...oe.presets);
          for (const re of oe.files)
            de.files.add(re);
          return de;
        }
        function* z(de, { options: oe, plugins: re, presets: ae }) {
          return de.options.push(oe), de.plugins.push(...yield* re()), de.presets.push(...yield* ae()), de;
        }
        function q() {
          return { options: [], presets: [], plugins: [], files: /* @__PURE__ */ new Set() };
        }
        function $(de) {
          const oe = Object.assign({}, de);
          return delete oe.extends, delete oe.env, delete oe.overrides, delete oe.plugins, delete oe.presets, delete oe.passPerPreset, delete oe.ignore, delete oe.only, delete oe.test, delete oe.include, delete oe.exclude, Object.prototype.hasOwnProperty.call(oe, "sourceMap") && (oe.sourceMaps = oe.sourceMap, delete oe.sourceMap), oe;
        }
        function Y(de) {
          const oe = /* @__PURE__ */ new Map(), re = [];
          for (const ae of de)
            if (typeof ae.value == "function") {
              const le = ae.value;
              let ue = oe.get(le);
              ue || (ue = /* @__PURE__ */ new Map(), oe.set(le, ue));
              let ie = ue.get(ae.name);
              ie ? ie.value = ae : (ie = { value: ae }, re.push(ie), ae.ownPass || ue.set(ae.name, ie));
            } else
              re.push({ value: ae });
          return re.reduce((ae, le) => (ae.push(le.value), ae), []);
        }
        function H({ options: de }, oe, re, ae) {
          return (de.test === void 0 || Q(re, de.test, oe, ae)) && (de.include === void 0 || Q(re, de.include, oe, ae)) && (de.exclude === void 0 || !Q(re, de.exclude, oe, ae));
        }
        function Q(de, oe, re, ae) {
          return ye(de, Array.isArray(oe) ? oe : [oe], re, ae);
        }
        function X(de, oe) {
          return oe instanceof RegExp ? String(oe) : oe;
        }
        function ne(de, oe, re, ae) {
          if (oe && ye(de, oe, ae)) {
            var le;
            const ie = `No config is applied to "${(le = de.filename) != null ? le : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(oe, X)}\` from "${ae}"`;
            return S(ie), de.showConfig && console.log(ie), !0;
          }
          if (re && !ye(de, re, ae)) {
            var ue;
            const ie = `No config is applied to "${(ue = de.filename) != null ? ue : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(re, X)}\` from "${ae}"`;
            return S(ie), de.showConfig && console.log(ie), !0;
          }
          return !1;
        }
        function ye(de, oe, re, ae) {
          return oe.some((le) => ve(le, re, de.filename, de, ae));
        }
        function ve(de, oe, re, ae, le) {
          if (typeof de == "function")
            return !!(0, m.endHiddenCallStack)(de)(re, { dirname: oe, envName: ae.envName, caller: ae.caller });
          if (typeof re != "string")
            throw new h.default("Configuration contains string/RegExp pattern, but no filename was passed to Babel", le);
          return typeof de == "string" && (de = (0, s.default)(de, oe)), de.test(re);
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/config-descriptors.js": (u, r, l) => {
        function i() {
          const j = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return i = function() {
            return j;
          }, j;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.createCachedDescriptors = function(j, F, _) {
          const { plugins: T, presets: v, passPerPreset: w } = F;
          return { options: y(F, j), plugins: T ? () => g(T, j)(_) : () => h([]), presets: v ? () => E(v, j)(_)(!!w) : () => h([]) };
        }, r.createDescriptor = D, r.createUncachedDescriptors = function(j, F, _) {
          return { options: y(F, j), plugins: (0, f.once)(() => C(F.plugins || [], j, _)), presets: (0, f.once)(() => N(F.presets || [], j, _, !!F.passPerPreset)) };
        };
        var f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/gensync-utils/functional.js"), d = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/index.js"), s = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/item.js"), o = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/caching.js"), m = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/resolve-targets.js");
        function* h(j) {
          return j;
        }
        function y(j, F) {
          return typeof j.browserslistConfigFile == "string" && (j.browserslistConfigFile = (0, m.resolveBrowserslistConfigFile)(j.browserslistConfigFile, F)), j;
        }
        const b = /* @__PURE__ */ new WeakMap(), E = (0, o.makeWeakCacheSync)((j, F) => {
          const _ = F.using((T) => T);
          return (0, o.makeStrongCacheSync)((T) => (0, o.makeStrongCache)(function* (v) {
            return (yield* N(j, _, T, v)).map((w) => R(b, w));
          }));
        }), S = /* @__PURE__ */ new WeakMap(), g = (0, o.makeWeakCacheSync)((j, F) => {
          const _ = F.using((T) => T);
          return (0, o.makeStrongCache)(function* (T) {
            return (yield* C(j, _, T)).map((v) => R(S, v));
          });
        }), P = {};
        function R(j, F) {
          const { value: _, options: T = P } = F;
          if (T === !1)
            return F;
          let v = j.get(_);
          v || (v = /* @__PURE__ */ new WeakMap(), j.set(_, v));
          let w = v.get(T);
          if (w || (w = [], v.set(T, w)), w.indexOf(F) === -1) {
            const O = w.filter((G) => {
              return U = F, (W = G).name === U.name && W.value === U.value && W.options === U.options && W.dirname === U.dirname && W.alias === U.alias && W.ownPass === U.ownPass && ((M = W.file) == null ? void 0 : M.request) === ((B = U.file) == null ? void 0 : B.request) && ((k = W.file) == null ? void 0 : k.resolved) === ((K = U.file) == null ? void 0 : K.resolved);
              var W, U, M, B, k, K;
            });
            if (O.length > 0)
              return O[0];
            w.push(F);
          }
          return F;
        }
        function* N(j, F, _, T) {
          return yield* I("preset", j, F, _, T);
        }
        function* C(j, F, _) {
          return yield* I("plugin", j, F, _);
        }
        function* I(j, F, _, T, v) {
          const w = yield* i().all(F.map((O, G) => D(O, _, { type: j, alias: `${T}$${G}`, ownPass: !!v })));
          return function(O) {
            const G = /* @__PURE__ */ new Map();
            for (const W of O) {
              if (typeof W.value != "function")
                continue;
              let U = G.get(W.value);
              if (U || (U = /* @__PURE__ */ new Set(), G.set(W.value, U)), U.has(W.name)) {
                const M = O.filter((B) => B.value === W.value);
                throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separate names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detected are:", `${JSON.stringify(M, null, 2)}`].join(`
`));
              }
              U.add(W.name);
            }
          }(w), w;
        }
        function* D(j, F, { type: _, alias: T, ownPass: v }) {
          const w = (0, s.getItemDescriptor)(j);
          if (w)
            return w;
          let O, G, W, U = j;
          Array.isArray(U) && (U.length === 3 ? [U, G, O] = U : [U, G] = U);
          let M = null;
          if (typeof U == "string") {
            if (typeof _ != "string")
              throw new Error("To resolve a string-based item, the type of item must be given");
            const B = _ === "plugin" ? d.loadPlugin : d.loadPreset, k = U;
            ({ filepath: M, value: U } = yield* B(U, F)), W = { request: k, resolved: M };
          }
          if (!U)
            throw new Error(`Unexpected falsy value: ${String(U)}`);
          if (typeof U == "object" && U.__esModule) {
            if (!U.default)
              throw new Error("Must export a default export when using ES6 modules.");
            U = U.default;
          }
          if (typeof U != "object" && typeof U != "function")
            throw new Error(`Unsupported format: ${typeof U}. Expected an object or a function.`);
          if (M !== null && typeof U == "object" && U)
            throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${M}`);
          return { name: O, alias: M || T, value: U, options: G, dirname: F, ownPass: v, file: W };
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/configuration.js": (u, r, l) => {
        function i() {
          const G = l("./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js");
          return i = function() {
            return G;
          }, G;
        }
        function f() {
          const G = l("fs");
          return f = function() {
            return G;
          }, G;
        }
        function d() {
          const G = l("path");
          return d = function() {
            return G;
          }, G;
        }
        function s() {
          const G = l("./node_modules/.pnpm/json5@2.2.3/node_modules/json5/dist/index.mjs");
          return s = function() {
            return G;
          }, G;
        }
        function o() {
          const G = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return o = function() {
            return G;
          }, G;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.ROOT_CONFIG_FILENAMES = void 0, r.findConfigUpwards = function(G) {
          let W = G;
          for (; ; ) {
            for (const M of N)
              if (f().existsSync(d().join(W, M)))
                return W;
            const U = d().dirname(W);
            if (W === U)
              break;
            W = U;
          }
          return null;
        }, r.findRelativeConfig = function* (G, W, U) {
          let M = null, B = null;
          const k = d().dirname(G.filepath);
          for (const te of G.directories) {
            var K;
            if (M || (M = yield* w(C, te, W, U, ((K = G.pkg) == null ? void 0 : K.dirname) === te ? _(G.pkg) : null)), !B) {
              const z = d().join(te, I);
              B = yield* v(z), B && R("Found ignore %o from %o.", B.filepath, k);
            }
          }
          return { config: M, ignore: B };
        }, r.findRootConfig = function(G, W, U) {
          return w(N, G, W, U);
        }, r.loadConfig = function* (G, W, U, M) {
          const B = (K = Ve.process.versions.node, te = "8.9", K = K.split("."), te = te.split("."), +K[0] > +te[0] || K[0] == te[0] && +K[1] >= +te[1] ? l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files sync recursive").resolve : (z, { paths: [q] }, $ = l("module")) => {
            let Y = $._findPath(z, $._nodeModulePaths(q).concat(q));
            if (Y)
              return Y;
            throw Y = new Error(`Cannot resolve module '${z}'`), Y.code = "MODULE_NOT_FOUND", Y;
          })(G, { paths: [W] }), k = yield* O(B, U, M);
          var K, te;
          if (!k)
            throw new S.default("Config file contains no configuration data", B);
          return R("Loaded config %o from %o.", G, W), k;
        }, r.resolveShowConfigPath = function* (G) {
          const W = Ve.process.env.BABEL_SHOW_CONFIG_FOR;
          if (W != null) {
            const U = d().resolve(G, W);
            if (!(yield* g.stat(U)).isFile())
              throw new Error(`${U}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`);
            return U;
          }
          return null;
        };
        var m = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/caching.js"), h = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/helpers/config-api.js"), y = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/utils.js"), b = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/module-types.js"), E = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/pattern-to-regex.js"), S = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/errors/config-error.js"), g = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/gensync-utils/fs.js"), P = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const R = i()("babel:config:loading:files:configuration"), N = ["babel.config.js", "babel.config.cjs", "babel.config.mjs", "babel.config.json", "babel.config.cts"];
        r.ROOT_CONFIG_FILENAMES = N;
        const C = [".babelrc", ".babelrc.js", ".babelrc.cjs", ".babelrc.mjs", ".babelrc.json", ".babelrc.cts"], I = ".babelignore", D = (0, m.makeWeakCache)(function* (G, W) {
          return yield* [], { options: (0, P.endHiddenCallStack)(G)((0, h.makeConfigAPI)(W)), cacheNeedsConfiguration: !W.configured() };
        });
        function* j(G, W) {
          if (!f().existsSync(G))
            return null;
          let U = yield* (0, b.default)(G, "You appear to be using a native ECMAScript module configuration file, which is only supported when running Babel asynchronously."), M = !1;
          if (typeof U == "function" && ({ options: U, cacheNeedsConfiguration: M } = yield* D(U, W)), !U || typeof U != "object" || Array.isArray(U))
            throw new S.default("Configuration should be an exported JavaScript object.", G);
          if (typeof U.then == "function")
            throw U.catch == null || U.catch(() => {
            }), new S.default("You appear to be using an async configuration, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously return your config.", G);
          return M && function(B) {
            throw new S.default(`Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured
for various types of caching, using the first param of their handler functions:

module.exports = function(api) {
  // The API exposes the following:

  // Cache the returned value forever and don't call this function again.
  api.cache(true);

  // Don't cache at all. Not recommended because it will be very slow.
  api.cache(false);

  // Cached based on the value of some function. If this function returns a value different from
  // a previously-encountered value, the plugins will re-evaluate.
  var env = api.cache(() => process.env.NODE_ENV);

  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for
  // any possible NODE_ENV value that might come up during plugin execution.
  var isProd = api.cache(() => process.env.NODE_ENV === "production");

  // .cache(fn) will perform a linear search though instances to find the matching plugin based
  // based on previous instantiated plugins. If you want to recreate the plugin and discard the
  // previous instance whenever something changes, you may use:
  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");

  // Note, we also expose the following more-verbose versions of the above examples:
  api.cache.forever(); // api.cache(true)
  api.cache.never();   // api.cache(false)
  api.cache.using(fn); // api.cache(fn)

  // Return the value that will be cached.
  return { };
};`, B);
          }(G), function(B, k) {
            let K = F.get(B);
            K || F.set(B, K = /* @__PURE__ */ new Map());
            let te = K.get(k);
            return te || (te = { filepath: k, dirname: d().dirname(k), options: B }, K.set(k, te)), te;
          }(U, G);
        }
        const F = /* @__PURE__ */ new WeakMap(), _ = (0, m.makeWeakCacheSync)((G) => {
          const W = G.options.babel;
          if (W === void 0)
            return null;
          if (typeof W != "object" || Array.isArray(W) || W === null)
            throw new S.default(".babel property must be an object", G.filepath);
          return { filepath: G.filepath, dirname: G.dirname, options: W };
        }), T = (0, y.makeStaticFileCache)((G, W) => {
          let U;
          try {
            U = s().parse(W);
          } catch (M) {
            throw new S.default(`Error while parsing config - ${M.message}`, G);
          }
          if (!U)
            throw new S.default("No config detected", G);
          if (typeof U != "object")
            throw new S.default("Config returned typeof " + typeof U, G);
          if (Array.isArray(U))
            throw new S.default("Expected config object but found array", G);
          return delete U.$schema, { filepath: G, dirname: d().dirname(G), options: U };
        }), v = (0, y.makeStaticFileCache)((G, W) => {
          const U = d().dirname(G), M = W.split(`
`).map((B) => B.replace(/#(.*?)$/, "").trim()).filter((B) => !!B);
          for (const B of M)
            if (B[0] === "!")
              throw new S.default("Negation of file paths is not supported.", G);
          return { filepath: G, dirname: d().dirname(G), ignore: M.map((B) => (0, E.default)(B, U)) };
        });
        function* w(G, W, U, M, B = null) {
          const k = (yield* o().all(G.map((K) => O(d().join(W, K), U, M)))).reduce((K, te) => {
            if (te && K)
              throw new S.default(`Multiple configuration files found. Please remove one:
 - ${d().basename(K.filepath)}
 - ${te.filepath}
from ${W}`);
            return te || K;
          }, B);
          return k && R("Found configuration %o from %o.", k.filepath, W), k;
        }
        function O(G, W, U) {
          switch (d().extname(G)) {
            case ".js":
            case ".cjs":
            case ".mjs":
            case ".cts":
              return j(G, { envName: W, caller: U });
            default:
              return T(G);
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/import-meta-resolve.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(d, s) {
          return f(d, s);
        };
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/vendor/import-meta-resolve.js");
        let f;
        f = i.resolve;
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/import.cjs": (u, r, l) => {
        u.exports = function(i) {
          return l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files lazy recursive")(i);
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), Object.defineProperty(r, "ROOT_CONFIG_FILENAMES", { enumerable: !0, get: function() {
          return f.ROOT_CONFIG_FILENAMES;
        } }), Object.defineProperty(r, "findConfigUpwards", { enumerable: !0, get: function() {
          return f.findConfigUpwards;
        } }), Object.defineProperty(r, "findPackageData", { enumerable: !0, get: function() {
          return i.findPackageData;
        } }), Object.defineProperty(r, "findRelativeConfig", { enumerable: !0, get: function() {
          return f.findRelativeConfig;
        } }), Object.defineProperty(r, "findRootConfig", { enumerable: !0, get: function() {
          return f.findRootConfig;
        } }), Object.defineProperty(r, "loadConfig", { enumerable: !0, get: function() {
          return f.loadConfig;
        } }), Object.defineProperty(r, "loadPlugin", { enumerable: !0, get: function() {
          return d.loadPlugin;
        } }), Object.defineProperty(r, "loadPreset", { enumerable: !0, get: function() {
          return d.loadPreset;
        } }), Object.defineProperty(r, "resolvePlugin", { enumerable: !0, get: function() {
          return d.resolvePlugin;
        } }), Object.defineProperty(r, "resolvePreset", { enumerable: !0, get: function() {
          return d.resolvePreset;
        } }), Object.defineProperty(r, "resolveShowConfigPath", { enumerable: !0, get: function() {
          return f.resolveShowConfigPath;
        } });
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/package.js"), f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/configuration.js"), d = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/plugins.js");
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/module-types.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function* (I, D) {
          switch (f().extname(I)) {
            case ".cjs":
              return R(I, arguments[2]);
            case ".mjs":
              break;
            case ".cts":
              return function(j) {
                const F = ".cts", _ = !!(l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files sync recursive").extensions[".ts"] || l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files sync recursive").extensions[".cts"] || l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files sync recursive").extensions[".mts"]);
                let T;
                if (!_) {
                  const v = { babelrc: !1, configFile: !1, sourceType: "unambiguous", sourceMaps: "inline", sourceFileName: f().basename(j), presets: [[C(j), Object.assign({ onlyRemoveTypeImports: !0, optimizeConstEnums: !0 }, { allowDeclareFields: !0 })]] };
                  T = function(w, O) {
                    if (T && O.endsWith(F))
                      try {
                        return w._compile((0, y.transformFileSync)(O, Object.assign({}, v, { filename: O })).code, O);
                      } catch (G) {
                        if (!_) {
                          const W = l("./node_modules/.pnpm/@babel+preset-typescript@7.22.15_@babel+core@7.22.15/node_modules/@babel/preset-typescript/package.json");
                          s().lt(W.version, "7.21.4") && console.error("`.cts` configuration file failed to load, please try to update `@babel/preset-typescript`.");
                        }
                        throw G;
                      }
                    return l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files sync recursive").extensions[".js"](w, O);
                  }, l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files sync recursive").extensions[F] = T;
                }
                try {
                  return R(j);
                } finally {
                  _ || (l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files sync recursive").extensions[F] === T && delete l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files sync recursive").extensions[F], T = void 0);
                }
              }(I);
            default:
              try {
                return R(I, arguments[2]);
              } catch (j) {
                if (j.code !== "ERR_REQUIRE_ESM")
                  throw j;
              }
          }
          if (yield* (0, i.isAsync)())
            return yield* (0, i.waitFor)(function(j) {
              return N.apply(this, arguments);
            }(I));
          throw new h.default(D, I);
        }, r.supportsESM = void 0;
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/gensync-utils/async.js");
        function f() {
          const I = l("path");
          return f = function() {
            return I;
          }, I;
        }
        function d() {
          const I = l("url");
          return d = function() {
            return I;
          }, I;
        }
        function s() {
          const I = l("./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js");
          return s = function() {
            return I;
          }, I;
        }
        function o() {
          const I = l("./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js");
          return o = function() {
            return I;
          }, I;
        }
        var m = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js"), h = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/errors/config-error.js"), y = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transform-file.js");
        function b(I, D, j, F, _, T, v) {
          try {
            var w = I[T](v), O = w.value;
          } catch (G) {
            return void j(G);
          }
          w.done ? D(O) : Promise.resolve(O).then(F, _);
        }
        const E = o()("babel:config:loading:files:module-types");
        let S;
        try {
          S = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/import.cjs");
        } catch {
        }
        const g = s().satisfies(Ve.process.versions.node, "^12.17 || >=13.2");
        r.supportsESM = g;
        const P = /* @__PURE__ */ new Set();
        function R(I) {
          if (P.has(I))
            return E("Auto-ignoring usage of config %o.", I), {};
          let D;
          try {
            P.add(I), D = (0, m.endHiddenCallStack)(l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files sync recursive"))(I);
          } finally {
            P.delete(I);
          }
          var j;
          return (j = D) != null && j.__esModule ? D.default || (arguments[1] ? D : void 0) : D;
        }
        function N() {
          var I;
          return I = function* (D) {
            if (!S)
              throw new h.default(`Internal error: Native ECMAScript modules aren't supported by this platform.
`, D);
            return (yield (0, m.endHiddenCallStack)(S)((0, d().pathToFileURL)(D))).default;
          }, N = function() {
            var D = this, j = arguments;
            return new Promise(function(F, _) {
              var T = I.apply(D, j);
              function v(O) {
                b(T, F, _, v, w, "next", O);
              }
              function w(O) {
                b(T, F, _, v, w, "throw", O);
              }
              v(void 0);
            });
          }, N.apply(this, arguments);
        }
        function C(I) {
          try {
            return l("./node_modules/.pnpm/@babel+preset-typescript@7.22.15_@babel+core@7.22.15/node_modules/@babel/preset-typescript/lib/index.js");
          } catch (D) {
            if (D.code !== "MODULE_NOT_FOUND")
              throw D;
            let j = "You appear to be using a .cts file as Babel configuration, but the `@babel/preset-typescript` package was not found: please install it!";
            throw Ve.process.versions.pnp && (j += `
If you are using Yarn Plug'n'Play, you may also need to add the following configuration to your .yarnrc.yml file:

packageExtensions:
	"@babel/core@*":
		peerDependencies:
			"@babel/preset-typescript": "*"
`), new h.default(j, I);
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/package.js": (u, r, l) => {
        function i() {
          const m = l("path");
          return i = function() {
            return m;
          }, m;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.findPackageData = function* (m) {
          let h = null;
          const y = [];
          let b = !0, E = i().dirname(m);
          for (; !h && i().basename(E) !== "node_modules"; ) {
            y.push(E), h = yield* o(i().join(E, s));
            const S = i().dirname(E);
            if (E === S) {
              b = !1;
              break;
            }
            E = S;
          }
          return { filepath: m, directories: y, pkg: h, isPackage: b };
        };
        var f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/utils.js"), d = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/errors/config-error.js");
        const s = "package.json", o = (0, f.makeStaticFileCache)((m, h) => {
          let y;
          try {
            y = JSON.parse(h);
          } catch (b) {
            throw new d.default(`Error while parsing JSON - ${b.message}`, m);
          }
          if (!y)
            throw new Error(`${m}: No config detected`);
          if (typeof y != "object")
            throw new d.default("Config returned typeof " + typeof y, m);
          if (Array.isArray(y))
            throw new d.default("Expected config object but found array", m);
          return { filepath: m, dirname: i().dirname(m), options: y };
        });
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/plugins.js": (u, r, l) => {
        function i() {
          const G = l("./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js");
          return i = function() {
            return G;
          }, G;
        }
        function f() {
          const G = l("path");
          return f = function() {
            return G;
          }, G;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.loadPlugin = function* (G, W) {
          const U = C(G, W, yield* (0, d.isAsync)()), M = yield* O("plugin", U);
          return h("Loaded plugin %o from %o.", G, W), { filepath: U, value: M };
        }, r.loadPreset = function* (G, W) {
          const U = I(G, W, yield* (0, d.isAsync)()), M = yield* O("preset", U);
          return h("Loaded preset %o from %o.", G, W), { filepath: U, value: M };
        }, r.resolvePreset = r.resolvePlugin = void 0;
        var d = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/gensync-utils/async.js"), s = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/module-types.js");
        function o() {
          const G = l("url");
          return o = function() {
            return G;
          }, G;
        }
        var m = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/import-meta-resolve.js");
        const h = i()("babel:config:loading:files:plugins"), y = /^module:/, b = /^(?!@|module:|[^/]+\/|babel-plugin-)/, E = /^(?!@|module:|[^/]+\/|babel-preset-)/, S = /^(@babel\/)(?!plugin-|[^/]+\/)/, g = /^(@babel\/)(?!preset-|[^/]+\/)/, P = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/, R = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/, N = /^(@(?!babel$)[^/]+)$/, C = v.bind(null, "plugin");
        r.resolvePlugin = C;
        const I = v.bind(null, "preset");
        function D(G, W) {
          if (f().isAbsolute(W))
            return W;
          const U = G === "preset";
          return W.replace(U ? E : b, `babel-${G}-`).replace(U ? g : S, `$1${G}-`).replace(U ? R : P, `$1babel-${G}-`).replace(N, `$1/babel-${G}`).replace(y, "");
        }
        function* j(G, W) {
          const U = D(G, W), { error: M, value: B } = yield U;
          if (!M)
            return B;
          if (M.code !== "MODULE_NOT_FOUND")
            throw M;
          U === W || (yield W).error || (M.message += `
- If you want to resolve "${W}", use "module:${W}"`), (yield D(G, "@babel/" + W)).error || (M.message += `
- Did you mean "@babel/${W}"?`);
          const k = G === "preset" ? "plugin" : "preset";
          if ((yield D(k, W)).error || (M.message += `
- Did you accidentally pass a ${k} as a ${G}?`), G === "plugin") {
            const K = U.replace("-proposal-", "-transform-");
            K === U || (yield K).error || (M.message += `
- Did you mean "${K}"?`);
          }
          throw M.message += `

Make sure that all the Babel plugins and presets you are using
are defined as dependencies or devDependencies in your package.json
file. It's possible that the missing plugin is loaded by a preset
you are using that forgot to add the plugin to its dependencies: you
can workaround this problem by explicitly adding the missing package
to your top-level package.json.
`, M;
        }
        function F(G, W) {
          try {
            return W ? { error: null, value: (U = Ve.process.versions.node, M = "8.9", U = U.split("."), M = M.split("."), +U[0] > +M[0] || U[0] == M[0] && +U[1] >= +M[1] ? l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files sync recursive").resolve : (B, { paths: [k] }, K = l("module")) => {
              let te = K._findPath(B, K._nodeModulePaths(k).concat(k));
              if (te)
                return te;
              throw te = new Error(`Cannot resolve module '${B}'`), te.code = "MODULE_NOT_FOUND", te;
            })(G, { paths: [W] }) } : { error: null, value: l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files sync recursive").resolve(G) };
          } catch (B) {
            return { error: B, value: null };
          }
          var U, M;
        }
        function _(G, W) {
          try {
            return { error: null, value: (0, m.default)(G, W) };
          } catch (U) {
            return { error: U, value: null };
          }
        }
        function T(G, W, U) {
          const M = j(G, W);
          let B = M.next();
          for (; !B.done; )
            B = M.next(F(B.value, U));
          return B.value;
        }
        function v(G, W, U, M) {
          if (!s.supportsESM || !M)
            return T(G, W, U);
          try {
            return function(B, k, K) {
              const te = (0, o().pathToFileURL)(f().join(K, "./babel-virtual-resolve-base.js")).href, z = j(B, k);
              let q = z.next();
              for (; !q.done; )
                q = z.next(_(q.value, te));
              return (0, o().fileURLToPath)(q.value);
            }(G, W, U);
          } catch (B) {
            try {
              return T(G, W, U);
            } catch (k) {
              throw B.type === "MODULE_NOT_FOUND" ? B : k.type === "MODULE_NOT_FOUND" ? k : B;
            }
          }
        }
        r.resolvePreset = I;
        var w = /* @__PURE__ */ new Set();
        function* O(G, W) {
          if (!(yield* (0, d.isAsync)()) && w.has(W))
            throw new Error(`Reentrant ${G} detected trying to load "${W}". This module is not ignored and is trying to load itself while compiling itself, leading to a dependency cycle. We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.`);
          try {
            return w.add(W), yield* (0, s.default)(W, `You appear to be using a native ECMAScript module ${G}, which is only supported when running Babel asynchronously.`, !0);
          } catch (U) {
            throw U.message = `[BABEL]: ${U.message} (While processing: ${W})`, U;
          } finally {
            w.delete(W);
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/utils.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.makeStaticFileCache = function(s) {
          return (0, i.makeStrongCache)(function* (o, m) {
            return m.invalidate(() => function(y) {
              if (!d().existsSync(y))
                return null;
              try {
                return +d().statSync(y).mtime;
              } catch (b) {
                if (b.code !== "ENOENT" && b.code !== "ENOTDIR")
                  throw b;
              }
              return null;
            }(o)) === null ? null : s(o, yield* f.readFile(o, "utf8"));
          });
        };
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/caching.js"), f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/gensync-utils/fs.js");
        function d() {
          const s = l("fs");
          return d = function() {
            return s;
          }, s;
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/full.js": (u, r, l) => {
        function i() {
          const M = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return i = function() {
            return M;
          }, M;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/gensync-utils/async.js"), d = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/util.js"), s = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js"), o = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/plugin.js"), m = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/item.js"), h = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/config-chain.js"), y = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/helpers/deep-array.js");
        function b() {
          const M = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/index.js");
          return b = function() {
            return M;
          }, M;
        }
        var E = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/caching.js"), S = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/validation/options.js"), g = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/validation/plugins.js"), P = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/helpers/config-api.js"), R = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/partial.js"), N = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/errors/config-error.js"), C = i()(function* (M) {
          var B;
          const k = yield* (0, R.default)(M);
          if (!k)
            return null;
          const { options: K, context: te, fileHandling: z } = k;
          if (z === "ignored")
            return null;
          const q = {}, { plugins: $, presets: Y } = K;
          if (!$ || !Y)
            throw new Error("Assertion failure - plugins and presets exist");
          const H = Object.assign({}, te, { targets: K.targets }), Q = (le) => {
            const ue = (0, m.getItemDescriptor)(le);
            if (!ue)
              throw new Error("Assertion failure - must be config item");
            return ue;
          }, X = Y.map(Q), ne = $.map(Q), ye = [[]], ve = [], de = [];
          if (yield* I(te, function* le(ue, ie) {
            const we = [];
            for (let Ee = 0; Ee < ue.length; Ee++) {
              const Ae = ue[Ee];
              if (Ae.options !== !1) {
                try {
                  var De = yield* W(Ae, H);
                } catch (Me) {
                  throw Me.code === "BABEL_UNKNOWN_OPTION" && (0, S.checkNoUnwrappedItemOptionPairs)(ue, Ee, "preset", Me), Me;
                }
                de.push(De.externalDependencies), Ae.ownPass ? we.push({ preset: De.chain, pass: [] }) : we.unshift({ preset: De.chain, pass: ie });
              }
            }
            if (we.length > 0) {
              ye.splice(1, 0, ...we.map((Ee) => Ee.pass).filter((Ee) => Ee !== ie));
              for (const { preset: Ee, pass: Ae } of we) {
                if (!Ee || (Ae.push(...Ee.plugins), yield* le(Ee.presets, Ae)))
                  return !0;
                Ee.options.forEach((Me) => {
                  (0, d.mergeOptions)(q, Me);
                });
              }
            }
          })(X, ye[0]))
            return null;
          const re = q;
          (0, d.mergeOptions)(re, K);
          const ae = Object.assign({}, H, { assumptions: (B = re.assumptions) != null ? B : {} });
          return yield* I(te, function* () {
            ye[0].unshift(...ne);
            for (const ue of ye) {
              const ie = [];
              ve.push(ie);
              for (let we = 0; we < ue.length; we++) {
                const De = ue[we];
                if (De.options !== !1) {
                  try {
                    var le = yield* T(De, ae);
                  } catch (Ee) {
                    throw Ee.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY" && (0, S.checkNoUnwrappedItemOptionPairs)(ue, we, "plugin", Ee), Ee;
                  }
                  ie.push(le), de.push(le.externalDependencies);
                }
              }
            }
          })(), re.plugins = ve[0], re.presets = ve.slice(1).filter((le) => le.length > 0).map((le) => ({ plugins: le })), re.passPerPreset = re.presets.length > 0, { options: re, passes: ve, externalDependencies: (0, y.finalize)(de) };
        });
        function I(M, B) {
          return function* (k, K) {
            try {
              return yield* B(k, K);
            } catch (z) {
              var te;
              throw /^\[BABEL\]/.test(z.message) || (z.message = `[BABEL] ${(te = M.filename) != null ? te : "unknown file"}: ${z.message}`), z;
            }
          };
        }
        r.default = C;
        const D = (M) => (0, E.makeWeakCache)(function* ({ value: B, options: k, dirname: K, alias: te }, z) {
          if (k === !1)
            throw new Error("Assertion failure");
          k = k || {};
          const q = [];
          let $ = B;
          if (typeof B == "function") {
            const Y = (0, f.maybeAsync)(B, "You appear to be using an async plugin/preset, but Babel has been called synchronously"), H = Object.assign({}, s, M(z, q));
            try {
              $ = yield* Y(H, k, K);
            } catch (Q) {
              throw te && (Q.message += ` (While processing: ${JSON.stringify(te)})`), Q;
            }
          }
          if (!$ || typeof $ != "object")
            throw new Error("Plugin/Preset did not return an object.");
          if ((0, f.isThenable)($))
            throw yield* [], new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". (While processing: ${JSON.stringify(te)})`);
          if (q.length > 0 && (!z.configured() || z.mode() === "forever")) {
            let Y = `A plugin/preset has external untracked dependencies (${q[0]}), but the cache `;
            throw z.configured() ? Y += " has been configured to never be invalidated. " : Y += "has not been configured to be invalidated when the external dependencies change. ", Y += `Plugins/presets should configure their cache to be invalidated when the external dependencies change, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`
(While processing: ${JSON.stringify(te)})`, new Error(Y);
          }
          return { value: $, options: k, dirname: K, alias: te, externalDependencies: (0, y.finalize)(q) };
        }), j = D(P.makePluginAPI), F = D(P.makePresetAPI), _ = (0, E.makeWeakCache)(function* ({ value: M, options: B, dirname: k, alias: K, externalDependencies: te }, z) {
          const q = (0, g.validatePluginObject)(M), $ = Object.assign({}, q);
          if ($.visitor && ($.visitor = b().default.explode(Object.assign({}, $.visitor))), $.inherits) {
            const Y = { name: void 0, alias: `${K}$inherits`, value: $.inherits, options: B, dirname: k }, H = yield* (0, f.forwardAsync)(T, (Q) => z.invalidate((X) => Q(Y, X)));
            $.pre = U(H.pre, $.pre), $.post = U(H.post, $.post), $.manipulateOptions = U(H.manipulateOptions, $.manipulateOptions), $.visitor = b().default.visitors.merge([H.visitor || {}, $.visitor || {}]), H.externalDependencies.length > 0 && (te = te.length === 0 ? H.externalDependencies : (0, y.finalize)([te, H.externalDependencies]));
          }
          return new o.default($, B, K, te);
        });
        function* T(M, B) {
          if (M.value instanceof o.default) {
            if (M.options)
              throw new Error("Passed options to an existing Plugin instance will not work.");
            return M.value;
          }
          return yield* _(yield* j(M, B), B);
        }
        const v = (M) => M && typeof M != "function", w = (M, B) => {
          if (v(M.test) || v(M.include) || v(M.exclude)) {
            const k = B.name ? `"${B.name}"` : "/* your preset */";
            throw new N.default([`Preset ${k} requires a filename to be set when babel is called directly,`, "```", `babel.transformSync(code, { filename: 'file.ts', presets: [${k}] });`, "```", "See https://babeljs.io/docs/en/options#filename for more information."].join(`
`));
          }
        }, O = (M, B, k) => {
          if (!B.filename) {
            var K;
            const { options: te } = M;
            w(te, k), (K = te.overrides) == null || K.forEach((z) => w(z, k));
          }
        }, G = (0, E.makeWeakCacheSync)(({ value: M, dirname: B, alias: k, externalDependencies: K }) => ({ options: (0, S.validate)("preset", M), alias: k, dirname: B, externalDependencies: K }));
        function* W(M, B) {
          const k = G(yield* F(M, B));
          return O(k, B, M), { chain: yield* (0, h.buildPresetChain)(k, B), externalDependencies: k.externalDependencies };
        }
        function U(M, B) {
          const k = [M, B].filter(Boolean);
          return k.length <= 1 ? k[0] : function(...K) {
            for (const te of k)
              te.apply(this, K);
          };
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/helpers/config-api.js": (u, r, l) => {
        function i() {
          const h = l("./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js");
          return i = function() {
            return h;
          }, h;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.makeConfigAPI = s, r.makePluginAPI = function(h, y) {
          return Object.assign({}, o(h, y), { assumption: (b) => h.using((E) => E.assumptions[b]) });
        }, r.makePresetAPI = o;
        var f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js"), d = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/caching.js");
        function s(h) {
          return { version: f.version, cache: h.simple(), env: (y) => h.using((b) => y === void 0 ? b.envName : typeof y == "function" ? (0, d.assertSimpleType)(y(b.envName)) : (Array.isArray(y) ? y : [y]).some((E) => {
            if (typeof E != "string")
              throw new Error("Unexpected non-string value");
            return E === b.envName;
          })), async: () => !1, caller: (y) => h.using((b) => (0, d.assertSimpleType)(y(b.caller))), assertVersion: m };
        }
        function o(h, y) {
          return Object.assign({}, s(h), { targets: () => JSON.parse(h.using((b) => JSON.stringify(b.targets))), addExternalDependency: (b) => {
            y.push(b);
          } });
        }
        function m(h) {
          if (typeof h == "number") {
            if (!Number.isInteger(h))
              throw new Error("Expected string or integer value.");
            h = `^${h}.0.0-0`;
          }
          if (typeof h != "string")
            throw new Error("Expected string or integer value.");
          if (i().satisfies(f.version, h))
            return;
          const y = Error.stackTraceLimit;
          typeof y == "number" && y < 25 && (Error.stackTraceLimit = 25);
          const b = new Error(`Requires Babel "${h}", but was loaded with "${f.version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
          throw typeof y == "number" && (Error.stackTraceLimit = y), Object.assign(b, { code: "BABEL_VERSION_UNSUPPORTED", version: f.version, range: h });
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/helpers/deep-array.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.finalize = function(l) {
          return Object.freeze(l);
        }, r.flattenToSet = function(l) {
          const i = /* @__PURE__ */ new Set(), f = [l];
          for (; f.length > 0; )
            for (const d of f.pop())
              Array.isArray(d) ? f.push(d) : i.add(d);
          return i;
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/helpers/environment.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.getEnv = function(l = "development") {
          return Ve.process.env.BABEL_ENV || Ve.process.env.NODE_ENV || l;
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/index.js": (u, r, l) => {
        function i() {
          const g = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return i = function() {
            return g;
          }, g;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.createConfigItem = function(g, P, R) {
          if (R !== void 0)
            (0, o.beginHiddenCallStack)(E.errback)(g, P, R);
          else {
            if (typeof P != "function")
              return S(g, P);
            (0, o.beginHiddenCallStack)(E.errback)(g, void 0, R);
          }
        }, r.createConfigItemAsync = function(...g) {
          return (0, o.beginHiddenCallStack)(E.async)(...g);
        }, r.createConfigItemSync = S, Object.defineProperty(r, "default", { enumerable: !0, get: function() {
          return f.default;
        } }), r.loadOptions = function(g, P) {
          if (P !== void 0)
            (0, o.beginHiddenCallStack)(y.errback)(g, P);
          else {
            if (typeof g != "function")
              return b(g);
            (0, o.beginHiddenCallStack)(y.errback)(void 0, g);
          }
        }, r.loadOptionsAsync = function(...g) {
          return (0, o.beginHiddenCallStack)(y.async)(...g);
        }, r.loadOptionsSync = b, r.loadPartialConfig = function(g, P) {
          if (P !== void 0)
            (0, o.beginHiddenCallStack)(m.errback)(g, P);
          else {
            if (typeof g != "function")
              return h(g);
            (0, o.beginHiddenCallStack)(m.errback)(void 0, g);
          }
        }, r.loadPartialConfigAsync = function(...g) {
          return (0, o.beginHiddenCallStack)(m.async)(...g);
        }, r.loadPartialConfigSync = h;
        var f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/full.js"), d = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/partial.js"), s = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/item.js"), o = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const m = i()(d.loadPartialConfig);
        function h(...g) {
          return (0, o.beginHiddenCallStack)(m.sync)(...g);
        }
        const y = i()(function* (g) {
          var P;
          const R = yield* (0, f.default)(g);
          return (P = R == null ? void 0 : R.options) != null ? P : null;
        });
        function b(...g) {
          return (0, o.beginHiddenCallStack)(y.sync)(...g);
        }
        const E = i()(s.createConfigItem);
        function S(...g) {
          return (0, o.beginHiddenCallStack)(E.sync)(...g);
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/item.js": (u, r, l) => {
        function i() {
          const m = l("path");
          return i = function() {
            return m;
          }, m;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.createConfigItem = function* (m, { dirname: h = ".", type: y } = {}) {
          return d(yield* (0, f.createDescriptor)(m, i().resolve(h), { type: y, alias: "programmatic item" }));
        }, r.createItemFromDescriptor = d, r.getItemDescriptor = function(m) {
          if (m != null && m[s])
            return m._descriptor;
        };
        var f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/config-descriptors.js");
        function d(m) {
          return new o(m);
        }
        const s = Symbol.for("@babel/core@7 - ConfigItem");
        class o {
          constructor(h) {
            this._descriptor = void 0, this[s] = !0, this.value = void 0, this.options = void 0, this.dirname = void 0, this.name = void 0, this.file = void 0, this._descriptor = h, Object.defineProperty(this, "_descriptor", { enumerable: !1 }), Object.defineProperty(this, s, { enumerable: !1 }), this.value = this._descriptor.value, this.options = this._descriptor.options, this.dirname = this._descriptor.dirname, this.name = this._descriptor.name, this.file = this._descriptor.file ? { request: this._descriptor.file.request, resolved: this._descriptor.file.resolved } : void 0, Object.freeze(this);
          }
        }
        Object.freeze(o.prototype);
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/partial.js": (u, r, l) => {
        function i() {
          const P = l("path");
          return i = function() {
            return P;
          }, P;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = S, r.loadPartialConfig = function* (P) {
          let R = !1;
          if (typeof P == "object" && P !== null && !Array.isArray(P)) {
            var N = P;
            ({ showIgnoredFiles: R } = N), P = function(v, w) {
              if (v == null)
                return {};
              var O, G, W = {}, U = Object.keys(v);
              for (G = 0; G < U.length; G++)
                O = U[G], w.indexOf(O) >= 0 || (W[O] = v[O]);
              return W;
            }(N, E);
          }
          const C = yield* S(P);
          if (!C)
            return null;
          const { options: I, babelrc: D, ignore: j, config: F, fileHandling: _, files: T } = C;
          return _ === "ignored" && !R ? null : ((I.plugins || []).forEach((v) => {
            if (v.value instanceof f.default)
              throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
          }), new g(I, D ? D.filepath : void 0, j ? j.filepath : void 0, F ? F.filepath : void 0, _, T));
        };
        var f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/plugin.js"), d = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/util.js"), s = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/item.js"), o = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/config-chain.js"), m = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/helpers/environment.js"), h = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/validation/options.js"), y = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/index.js"), b = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/resolve-targets.js");
        const E = ["showIgnoredFiles"];
        function* S(P) {
          if (P != null && (typeof P != "object" || Array.isArray(P)))
            throw new Error("Babel options must be an object, null, or undefined");
          const R = P ? (0, h.validate)("arguments", P) : {}, { envName: N = (0, m.getEnv)(), cwd: C = ".", root: I = ".", rootMode: D = "root", caller: j, cloneInputAst: F = !0 } = R, _ = i().resolve(C), T = function(W, U) {
            switch (U) {
              case "root":
                return W;
              case "upward-optional": {
                const M = (0, y.findConfigUpwards)(W);
                return M === null ? W : M;
              }
              case "upward": {
                const M = (0, y.findConfigUpwards)(W);
                if (M !== null)
                  return M;
                throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${W}".
One of the following config files must be in the directory tree: "${y.ROOT_CONFIG_FILENAMES.join(", ")}".`), { code: "BABEL_ROOT_NOT_FOUND", dirname: W });
              }
              default:
                throw new Error("Assertion failure - unknown rootMode value.");
            }
          }(i().resolve(_, I), D), v = typeof R.filename == "string" ? i().resolve(C, R.filename) : void 0, w = { filename: v, cwd: _, root: T, envName: N, caller: j, showConfig: (yield* (0, y.resolveShowConfigPath)(_)) === v }, O = yield* (0, o.buildRootChain)(R, w);
          if (!O)
            return null;
          const G = { assumptions: {} };
          return O.options.forEach((W) => {
            (0, d.mergeOptions)(G, W);
          }), { options: Object.assign({}, G, { targets: (0, b.resolveTargets)(G, T), cloneInputAst: F, babelrc: !1, configFile: !1, browserslistConfigFile: !1, passPerPreset: !1, envName: w.envName, cwd: w.cwd, root: w.root, rootMode: "root", filename: typeof w.filename == "string" ? w.filename : void 0, plugins: O.plugins.map((W) => (0, s.createItemFromDescriptor)(W)), presets: O.presets.map((W) => (0, s.createItemFromDescriptor)(W)) }), context: w, fileHandling: O.fileHandling, ignore: O.ignore, babelrc: O.babelrc, config: O.config, files: O.files };
        }
        class g {
          constructor(R, N, C, I, D, j) {
            this.options = void 0, this.babelrc = void 0, this.babelignore = void 0, this.config = void 0, this.fileHandling = void 0, this.files = void 0, this.options = R, this.babelignore = C, this.babelrc = N, this.config = I, this.fileHandling = D, this.files = j, Object.freeze(this);
          }
          hasFilesystemConfig() {
            return this.babelrc !== void 0 || this.config !== void 0;
          }
        }
        Object.freeze(g.prototype);
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/pattern-to-regex.js": (u, r, l) => {
        function i() {
          const E = l("path");
          return i = function() {
            return E;
          }, E;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(E, S) {
          const g = i().resolve(S, E).split(i().sep);
          return new RegExp(["^", ...g.map((P, R) => {
            const N = R === g.length - 1;
            return P === "**" ? N ? y : h : P === "*" ? N ? m : o : P.indexOf("*.") === 0 ? s + b(P.slice(1)) + (N ? d : f) : b(P) + (N ? d : f);
          })].join(""));
        };
        const f = `\\${i().sep}`, d = `(?:${f}|$)`, s = `[^${f}]+`, o = `(?:${s}${f})`, m = `(?:${s}${d})`, h = `${o}*?`, y = `${o}*?${m}?`;
        function b(E) {
          return E.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/plugin.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/helpers/deep-array.js");
        r.default = class {
          constructor(f, d, s, o = (0, i.finalize)([])) {
            this.key = void 0, this.manipulateOptions = void 0, this.post = void 0, this.pre = void 0, this.visitor = void 0, this.parserOverride = void 0, this.generatorOverride = void 0, this.options = void 0, this.externalDependencies = void 0, this.key = f.name || s, this.manipulateOptions = f.manipulateOptions, this.post = f.post, this.pre = f.pre, this.visitor = f.visitor || {}, this.parserOverride = f.parserOverride, this.generatorOverride = f.generatorOverride, this.options = d, this.externalDependencies = o;
          }
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/printer.js": (u, r, l) => {
        function i() {
          const m = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return i = function() {
            return m;
          }, m;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.ConfigPrinter = r.ChainFormatter = void 0;
        const f = { Programmatic: 0, Config: 1 };
        r.ChainFormatter = f;
        const d = { title(m, h, y) {
          let b = "";
          return m === f.Programmatic ? (b = "programmatic options", h && (b += " from " + h)) : b = "config " + y, b;
        }, loc(m, h) {
          let y = "";
          return m != null && (y += `.overrides[${m}]`), h != null && (y += `.env["${h}"]`), y;
        }, *optionsAndDescriptors(m) {
          const h = Object.assign({}, m.options);
          delete h.overrides, delete h.env;
          const y = [...yield* m.plugins()];
          y.length && (h.plugins = y.map((E) => s(E)));
          const b = [...yield* m.presets()];
          return b.length && (h.presets = [...b].map((E) => s(E))), JSON.stringify(h, void 0, 2);
        } };
        function s(m) {
          var h;
          let y = (h = m.file) == null ? void 0 : h.request;
          return y == null && (typeof m.value == "object" ? y = m.value : typeof m.value == "function" && (y = `[Function: ${m.value.toString().slice(0, 50)} ... ]`)), y == null && (y = "[Unknown]"), m.options === void 0 ? y : m.name == null ? [y, m.options] : [y, m.options, m.name];
        }
        class o {
          constructor() {
            this._stack = [];
          }
          configure(h, y, { callerName: b, filepath: E }) {
            return h ? (S, g, P) => {
              this._stack.push({ type: y, callerName: b, filepath: E, content: S, index: g, envName: P });
            } : () => {
            };
          }
          static *format(h) {
            let y = d.title(h.type, h.callerName, h.filepath);
            const b = d.loc(h.index, h.envName);
            return b && (y += ` ${b}`), `${y}
${yield* d.optionsAndDescriptors(h.content)}`;
          }
          *output() {
            return this._stack.length === 0 ? "" : (yield* i().all(this._stack.map((h) => o.format(h)))).join(`

`);
          }
        }
        r.ConfigPrinter = o;
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/resolve-targets.js": (u, r, l) => {
        function i() {
          const d = l("path");
          return i = function() {
            return d;
          }, d;
        }
        function f() {
          const d = l("./stubs/helper-compilation-targets.js");
          return f = function() {
            return d;
          }, d;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.resolveBrowserslistConfigFile = function(d, s) {
          return i().resolve(s, d);
        }, r.resolveTargets = function(d, s) {
          const o = d.targets;
          let m;
          typeof o == "string" || Array.isArray(o) ? m = { browsers: o } : o && (m = "esmodules" in o ? Object.assign({}, o, { esmodules: "intersect" }) : o);
          const { browserslistConfigFile: h } = d;
          let y, b = !1;
          return typeof h == "string" ? y = h : b = h === !1, (0, f().default)(m, { ignoreBrowserslistConfig: b, configFile: y, configPath: s, browserslistEnv: d.browserslistEnv });
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/util.js": (u, r) => {
        function l(i, f) {
          for (const d of Object.keys(f)) {
            const s = f[d];
            s !== void 0 && (i[d] = s);
          }
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.isIterableIterator = function(i) {
          return !!i && typeof i.next == "function" && typeof i[Symbol.iterator] == "function";
        }, r.mergeOptions = function(i, f) {
          for (const d of Object.keys(f))
            if (d !== "parserOpts" && d !== "generatorOpts" && d !== "assumptions" || !f[d]) {
              const s = f[d];
              s !== void 0 && (i[d] = s);
            } else {
              const s = f[d];
              l(i[d] || (i[d] = {}), s);
            }
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/validation/option-assertions.js": (u, r, l) => {
        function i() {
          const g = l("./stubs/helper-compilation-targets.js");
          return i = function() {
            return g;
          }, g;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.access = s, r.assertArray = h, r.assertAssumptions = function(g, P) {
          if (P === void 0)
            return;
          if (typeof P != "object" || P === null)
            throw new Error(`${d(g)} must be an object or undefined.`);
          let R = g;
          do
            R = R.parent;
          while (R.type !== "root");
          const N = R.source === "preset";
          for (const C of Object.keys(P)) {
            const I = s(g, C);
            if (!f.assumptionsNames.has(C))
              throw new Error(`${d(I)} is not a supported assumption.`);
            if (typeof P[C] != "boolean")
              throw new Error(`${d(I)} must be a boolean.`);
            if (N && P[C] === !1)
              throw new Error(`${d(I)} cannot be set to 'false' inside presets.`);
          }
          return P;
        }, r.assertBabelrcSearch = function(g, P) {
          if (P === void 0 || typeof P == "boolean")
            return P;
          if (Array.isArray(P))
            P.forEach((R, N) => {
              if (!y(R))
                throw new Error(`${d(s(g, N))} must be a string/Function/RegExp.`);
            });
          else if (!y(P))
            throw new Error(`${d(g)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(P)}`);
          return P;
        }, r.assertBoolean = o, r.assertCallerMetadata = function(g, P) {
          const R = m(g, P);
          if (R) {
            if (typeof R.name != "string")
              throw new Error(`${d(g)} set but does not contain "name" property string`);
            for (const N of Object.keys(R)) {
              const C = s(g, N), I = R[N];
              if (I != null && typeof I != "boolean" && typeof I != "string" && typeof I != "number")
                throw new Error(`${d(C)} must be null, undefined, a boolean, a string, or a number.`);
            }
          }
          return P;
        }, r.assertCompact = function(g, P) {
          if (P !== void 0 && typeof P != "boolean" && P !== "auto")
            throw new Error(`${d(g)} must be a boolean, "auto", or undefined`);
          return P;
        }, r.assertConfigApplicableTest = function(g, P) {
          if (P === void 0)
            return P;
          if (Array.isArray(P))
            P.forEach((R, N) => {
              if (!y(R))
                throw new Error(`${d(s(g, N))} must be a string/Function/RegExp.`);
            });
          else if (!y(P))
            throw new Error(`${d(g)} must be a string/Function/RegExp, or an array of those`);
          return P;
        }, r.assertConfigFileSearch = function(g, P) {
          if (P !== void 0 && typeof P != "boolean" && typeof P != "string")
            throw new Error(`${d(g)} must be a undefined, a boolean, a string, got ${JSON.stringify(P)}`);
          return P;
        }, r.assertFunction = function(g, P) {
          if (P !== void 0 && typeof P != "function")
            throw new Error(`${d(g)} must be a function, or undefined`);
          return P;
        }, r.assertIgnoreList = function(g, P) {
          const R = h(g, P);
          return R == null || R.forEach((N, C) => function(I, D) {
            if (typeof D != "string" && typeof D != "function" && !(D instanceof RegExp))
              throw new Error(`${d(I)} must be an array of string/Function/RegExp values, or undefined`);
            return D;
          }(s(g, C), N)), R;
        }, r.assertInputSourceMap = function(g, P) {
          if (P !== void 0 && typeof P != "boolean" && (typeof P != "object" || !P))
            throw new Error(`${d(g)} must be a boolean, object, or undefined`);
          return P;
        }, r.assertObject = m, r.assertPluginList = function(g, P) {
          const R = h(g, P);
          return R && R.forEach((N, C) => function(I, D) {
            if (Array.isArray(D)) {
              if (D.length === 0)
                throw new Error(`${d(I)} must include an object`);
              if (D.length > 3)
                throw new Error(`${d(I)} may only be a two-tuple or three-tuple`);
              if (b(s(I, 0), D[0]), D.length > 1) {
                const j = D[1];
                if (j !== void 0 && j !== !1 && (typeof j != "object" || Array.isArray(j) || j === null))
                  throw new Error(`${d(s(I, 1))} must be an object, false, or undefined`);
              }
              if (D.length === 3) {
                const j = D[2];
                if (j !== void 0 && typeof j != "string")
                  throw new Error(`${d(s(I, 2))} must be a string, or undefined`);
              }
            } else
              b(I, D);
            return D;
          }(s(g, C), N)), R;
        }, r.assertRootMode = function(g, P) {
          if (P !== void 0 && P !== "root" && P !== "upward" && P !== "upward-optional")
            throw new Error(`${d(g)} must be a "root", "upward", "upward-optional" or undefined`);
          return P;
        }, r.assertSourceMaps = function(g, P) {
          if (P !== void 0 && typeof P != "boolean" && P !== "inline" && P !== "both")
            throw new Error(`${d(g)} must be a boolean, "inline", "both", or undefined`);
          return P;
        }, r.assertSourceType = function(g, P) {
          if (P !== void 0 && P !== "module" && P !== "script" && P !== "unambiguous")
            throw new Error(`${d(g)} must be "module", "script", "unambiguous", or undefined`);
          return P;
        }, r.assertString = function(g, P) {
          if (P !== void 0 && typeof P != "string")
            throw new Error(`${d(g)} must be a string, or undefined`);
          return P;
        }, r.assertTargets = function(g, P) {
          if ((0, i().isBrowsersQueryValid)(P))
            return P;
          if (typeof P != "object" || !P || Array.isArray(P))
            throw new Error(`${d(g)} must be a string, an array of strings or an object`);
          const R = s(g, "browsers"), N = s(g, "esmodules");
          E(R, P.browsers), o(N, P.esmodules);
          for (const C of Object.keys(P)) {
            const I = P[C], D = s(g, C);
            if (C === "esmodules")
              o(D, I);
            else if (C === "browsers")
              E(D, I);
            else {
              if (!Object.hasOwnProperty.call(i().TargetNames, C)) {
                const j = Object.keys(i().TargetNames).join(", ");
                throw new Error(`${d(D)} is not a valid target. Supported targets are ${j}`);
              }
              S(D, I);
            }
          }
          return P;
        }, r.msg = d;
        var f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/validation/options.js");
        function d(g) {
          switch (g.type) {
            case "root":
              return "";
            case "env":
              return `${d(g.parent)}.env["${g.name}"]`;
            case "overrides":
              return `${d(g.parent)}.overrides[${g.index}]`;
            case "option":
              return `${d(g.parent)}.${g.name}`;
            case "access":
              return `${d(g.parent)}[${JSON.stringify(g.name)}]`;
            default:
              throw new Error(`Assertion failure: Unknown type ${g.type}`);
          }
        }
        function s(g, P) {
          return { type: "access", name: P, parent: g };
        }
        function o(g, P) {
          if (P !== void 0 && typeof P != "boolean")
            throw new Error(`${d(g)} must be a boolean, or undefined`);
          return P;
        }
        function m(g, P) {
          if (P !== void 0 && (typeof P != "object" || Array.isArray(P) || !P))
            throw new Error(`${d(g)} must be an object, or undefined`);
          return P;
        }
        function h(g, P) {
          if (P != null && !Array.isArray(P))
            throw new Error(`${d(g)} must be an array, or undefined`);
          return P;
        }
        function y(g) {
          return typeof g == "string" || typeof g == "function" || g instanceof RegExp;
        }
        function b(g, P) {
          if ((typeof P != "object" || !P) && typeof P != "string" && typeof P != "function")
            throw new Error(`${d(g)} must be a string, object, function`);
          return P;
        }
        function E(g, P) {
          if (P !== void 0 && !(0, i().isBrowsersQueryValid)(P))
            throw new Error(`${d(g)} must be undefined, a string or an array of strings`);
        }
        function S(g, P) {
          if ((typeof P != "number" || Math.round(P) !== P) && typeof P != "string")
            throw new Error(`${d(g)} must be a string or an integer number`);
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/validation/options.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.assumptionsNames = void 0, r.checkNoUnwrappedItemOptionPairs = function(P, R, N, C) {
          if (R === 0)
            return;
          const I = P[R - 1], D = P[R];
          I.file && I.options === void 0 && typeof D.value == "object" && (C.message += `
- Maybe you meant to use
"${N}s": [
  ["${I.file.request}", ${JSON.stringify(D.value, void 0, 2)}]
]
To be a valid ${N}, its name and options should be wrapped in a pair of brackets`);
        }, r.validate = function(P, R, N) {
          try {
            return E({ type: "root", source: P }, R);
          } catch (C) {
            const I = new d.default(C.message, N);
            throw C.code && (I.code = C.code), I;
          }
        };
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/validation/removed.js"), f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/validation/option-assertions.js"), d = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/errors/config-error.js");
        const s = { cwd: f.assertString, root: f.assertString, rootMode: f.assertRootMode, configFile: f.assertConfigFileSearch, caller: f.assertCallerMetadata, filename: f.assertString, filenameRelative: f.assertString, code: f.assertBoolean, ast: f.assertBoolean, cloneInputAst: f.assertBoolean, envName: f.assertString }, o = { babelrc: f.assertBoolean, babelrcRoots: f.assertBabelrcSearch }, m = { extends: f.assertString, ignore: f.assertIgnoreList, only: f.assertIgnoreList, targets: f.assertTargets, browserslistConfigFile: f.assertConfigFileSearch, browserslistEnv: f.assertString }, h = { inputSourceMap: f.assertInputSourceMap, presets: f.assertPluginList, plugins: f.assertPluginList, passPerPreset: f.assertBoolean, assumptions: f.assertAssumptions, env: function(P, R) {
          if (P.parent.type === "env")
            throw new Error(`${(0, f.msg)(P)} is not allowed inside of another .env block`);
          const N = P.parent, C = (0, f.assertObject)(P, R);
          if (C)
            for (const I of Object.keys(C)) {
              const D = (0, f.assertObject)((0, f.access)(P, I), C[I]);
              D && E({ type: "env", name: I, parent: N }, D);
            }
          return C;
        }, overrides: function(P, R) {
          if (P.parent.type === "env")
            throw new Error(`${(0, f.msg)(P)} is not allowed inside an .env block`);
          if (P.parent.type === "overrides")
            throw new Error(`${(0, f.msg)(P)} is not allowed inside an .overrides block`);
          const N = P.parent, C = (0, f.assertArray)(P, R);
          if (C)
            for (const [I, D] of C.entries()) {
              const j = (0, f.access)(P, I), F = (0, f.assertObject)(j, D);
              if (!F)
                throw new Error(`${(0, f.msg)(j)} must be an object`);
              E({ type: "overrides", index: I, parent: N }, F);
            }
          return C;
        }, test: f.assertConfigApplicableTest, include: f.assertConfigApplicableTest, exclude: f.assertConfigApplicableTest, retainLines: f.assertBoolean, comments: f.assertBoolean, shouldPrintComment: f.assertFunction, compact: f.assertCompact, minified: f.assertBoolean, auxiliaryCommentBefore: f.assertString, auxiliaryCommentAfter: f.assertString, sourceType: f.assertSourceType, wrapPluginVisitorMethod: f.assertFunction, highlightCode: f.assertBoolean, sourceMaps: f.assertSourceMaps, sourceMap: f.assertSourceMaps, sourceFileName: f.assertString, sourceRoot: f.assertString, parserOpts: f.assertObject, generatorOpts: f.assertObject };
        Object.assign(h, { getModuleId: f.assertFunction, moduleRoot: f.assertString, moduleIds: f.assertBoolean, moduleId: f.assertString });
        const y = /* @__PURE__ */ new Set(["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitiveHint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "objectRestNoSymbols", "privateFieldsAsSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods", "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"]);
        function b(P) {
          return P.type === "root" ? P.source : b(P.parent);
        }
        function E(P, R) {
          const N = b(P);
          return function(C) {
            if (g(C, "sourceMap") && g(C, "sourceMaps"))
              throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
          }(R), Object.keys(R).forEach((C) => {
            const I = { type: "option", name: C, parent: P };
            if (N === "preset" && m[C])
              throw new Error(`${(0, f.msg)(I)} is not allowed in preset options`);
            if (N !== "arguments" && s[C])
              throw new Error(`${(0, f.msg)(I)} is only allowed in root programmatic options`);
            if (N !== "arguments" && N !== "configfile" && o[C])
              throw N === "babelrcfile" || N === "extendsfile" ? new Error(`${(0, f.msg)(I)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, or babel.config.js/config file options`) : new Error(`${(0, f.msg)(I)} is only allowed in root programmatic options, or babel.config.js/config file options`);
            (h[C] || m[C] || o[C] || s[C] || S)(I, R[C]);
          }), R;
        }
        function S(P) {
          const R = P.name;
          if (i.default[R]) {
            const { message: N, version: C = 5 } = i.default[R];
            throw new Error(`Using removed Babel ${C} option: ${(0, f.msg)(P)} - ${N}`);
          }
          {
            const N = new Error(`Unknown option: ${(0, f.msg)(P)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);
            throw N.code = "BABEL_UNKNOWN_OPTION", N;
          }
        }
        function g(P, R) {
          return Object.prototype.hasOwnProperty.call(P, R);
        }
        r.assumptionsNames = y;
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/validation/plugins.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.validatePluginObject = function(d) {
          const s = { type: "root", source: "plugin" };
          return Object.keys(d).forEach((o) => {
            const m = f[o];
            if (!m) {
              const h = new Error(`.${o} is not a valid Plugin property`);
              throw h.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY", h;
            }
            m({ type: "option", name: o, parent: s }, d[o]);
          }), d;
        };
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/validation/option-assertions.js");
        const f = { name: i.assertString, manipulateOptions: i.assertFunction, pre: i.assertFunction, post: i.assertFunction, inherits: i.assertFunction, visitor: function(d, s) {
          const o = (0, i.assertObject)(d, s);
          if (o && (Object.keys(o).forEach((m) => {
            m !== "_exploded" && m !== "_verified" && function(h, y) {
              if (y && typeof y == "object")
                Object.keys(y).forEach((b) => {
                  if (b !== "enter" && b !== "exit")
                    throw new Error(`.visitor["${h}"] may only have .enter and/or .exit handlers.`);
                });
              else if (typeof y != "function")
                throw new Error(`.visitor["${h}"] must be a function`);
            }(m, o[m]);
          }), o.enter || o.exit))
            throw new Error(`${(0, i.msg)(d)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
          return o;
        }, parserOverride: i.assertFunction, generatorOverride: i.assertFunction };
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/validation/removed.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0, r.default = { auxiliaryComment: { message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`" }, blacklist: { message: "Put the specific transforms you want in the `plugins` option" }, breakConfig: { message: "This is not a necessary option in Babel 6" }, experimental: { message: "Put the specific transforms you want in the `plugins` option" }, externalHelpers: { message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/" }, extra: { message: "" }, jsxPragma: { message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/" }, loose: { message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option." }, metadataUsedHelpers: { message: "Not required anymore as this is enabled by default" }, modules: { message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules" }, nonStandard: { message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/" }, optional: { message: "Put the specific transforms you want in the `plugins` option" }, sourceMapName: { message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves." }, stage: { message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets" }, whitelist: { message: "Put the specific transforms you want in the `plugins` option" }, resolveModuleSource: { version: 6, message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options" }, metadata: { version: 6, message: "Generated plugin metadata is always included in the output result" }, sourceMapTarget: { version: 6, message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves." } };
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/errors/config-error.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        class f extends Error {
          constructor(s, o) {
            super(s), (0, i.expectedError)(this), o && (0, i.injectVirtualStackFrame)(this, o);
          }
        }
        r.default = f;
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js": (u, r) => {
        var l;
        Object.defineProperty(r, "__esModule", { value: !0 }), r.beginHiddenCallStack = function(b) {
          return f ? Object.defineProperty(function(...E) {
            return h(), b(...E);
          }, "name", { value: s }) : b;
        }, r.endHiddenCallStack = function(b) {
          return f ? Object.defineProperty(function(...E) {
            return b(...E);
          }, "name", { value: d }) : b;
        }, r.expectedError = function(b) {
          if (f)
            return o.add(b), b;
        }, r.injectVirtualStackFrame = function(b, E) {
          if (!f)
            return;
          let S = m.get(b);
          return S || m.set(b, S = []), S.push(function(g) {
            return /* @__PURE__ */ Object.create({ isNative: () => !1, isConstructor: () => !1, isToplevel: () => !0, getFileName: () => g, getLineNumber: () => {
            }, getColumnNumber: () => {
            }, getFunctionName: () => {
            }, getMethodName: () => {
            }, getTypeName: () => {
            }, toString: () => g });
          }(E)), b;
        };
        const i = Function.call.bind(Error.prototype.toString), f = !!Error.captureStackTrace && ((l = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit")) == null ? void 0 : l.writable) === !0, d = "startHiding - secret - don't use this - v1", s = "stopHiding - secret - don't use this - v1", o = /* @__PURE__ */ new WeakSet(), m = /* @__PURE__ */ new WeakMap();
        function h() {
          h = () => {
          };
          const { prepareStackTrace: b = y } = Error;
          Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, 50)), Error.prepareStackTrace = function(E, S) {
            let g = [], P = o.has(E) ? "hiding" : "unknown";
            for (let R = 0; R < S.length; R++) {
              const N = S[R].getFunctionName();
              if (N === d)
                P = "hiding";
              else if (N === s) {
                if (P === "hiding")
                  P = "showing", m.has(E) && g.unshift(...m.get(E));
                else if (P === "unknown") {
                  g = S;
                  break;
                }
              } else
                P !== "hiding" && g.push(S[R]);
            }
            return b(E, g);
          };
        }
        function y(b, E) {
          return E.length === 0 ? i(b) : `${i(b)}
    at ${E.join(`
    at `)}`;
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/gensync-utils/async.js": (u, r, l) => {
        function i() {
          const g = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return i = function() {
            return g;
          }, g;
        }
        function f(g, P, R, N, C, I, D) {
          try {
            var j = g[I](D), F = j.value;
          } catch (_) {
            return void R(_);
          }
          j.done ? P(F) : Promise.resolve(F).then(N, C);
        }
        function d(g) {
          return function() {
            var P = this, R = arguments;
            return new Promise(function(N, C) {
              var I = g.apply(P, R);
              function D(F) {
                f(I, N, C, D, j, "next", F);
              }
              function j(F) {
                f(I, N, C, D, j, "throw", F);
              }
              D(void 0);
            });
          };
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.forwardAsync = function(g, P) {
          const R = i()(g);
          return m((N) => {
            const C = R[N];
            return P(C);
          });
        }, r.isAsync = void 0, r.isThenable = S, r.maybeAsync = function(g, P) {
          return i()({ sync(...R) {
            const N = g.apply(this, R);
            if (S(N))
              throw new Error(P);
            return N;
          }, async(...R) {
            return Promise.resolve(g.apply(this, R));
          } });
        }, r.waitFor = r.onFirstPause = void 0;
        const s = i()(function* (g) {
          return yield* g;
        }), o = i()({ sync: () => !1, errback: (g) => g(null, !0) });
        r.isAsync = o;
        const m = i()({ sync: (g) => g("sync"), async: (h = d(function* (g) {
          return g("async");
        }), function(g) {
          return h.apply(this, arguments);
        }) });
        var h;
        const y = i()({ name: "onFirstPause", arity: 2, sync: function(g) {
          return s.sync(g);
        }, errback: function(g, P, R) {
          let N = !1;
          s.errback(g, (C, I) => {
            N = !0, R(C, I);
          }), N || P();
        } });
        r.onFirstPause = y;
        const b = i()({ sync: (g) => g, async: (E = d(function* (g) {
          return g;
        }), function(g) {
          return E.apply(this, arguments);
        }) });
        var E;
        function S(g) {
          return !(!g || typeof g != "object" && typeof g != "function" || !g.then || typeof g.then != "function");
        }
        r.waitFor = b;
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/gensync-utils/fs.js": (u, r, l) => {
        function i() {
          const o = l("fs");
          return i = function() {
            return o;
          }, o;
        }
        function f() {
          const o = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return f = function() {
            return o;
          }, o;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.stat = r.readFile = void 0;
        const d = f()({ sync: i().readFileSync, errback: i().readFile });
        r.readFile = d;
        const s = f()({ sync: i().statSync, errback: i().stat });
        r.stat = s;
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/gensync-utils/functional.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.once = function(f) {
          let d, s;
          return function* () {
            if (d)
              return d;
            if (!(yield* (0, i.isAsync)()))
              return d = yield* f();
            if (s)
              return yield* (0, i.waitFor)(s);
            let o, m;
            s = new Promise((h, y) => {
              o = h, m = y;
            });
            try {
              return d = yield* f(), s = null, o(d), d;
            } catch (h) {
              throw m(h), h;
            }
          };
        };
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/gensync-utils/async.js");
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.DEFAULT_EXTENSIONS = void 0, Object.defineProperty(r, "File", { enumerable: !0, get: function() {
          return i.default;
        } }), Object.defineProperty(r, "buildExternalHelpers", { enumerable: !0, get: function() {
          return f.default;
        } }), Object.defineProperty(r, "createConfigItem", { enumerable: !0, get: function() {
          return b.createConfigItem;
        } }), Object.defineProperty(r, "createConfigItemAsync", { enumerable: !0, get: function() {
          return b.createConfigItemAsync;
        } }), Object.defineProperty(r, "createConfigItemSync", { enumerable: !0, get: function() {
          return b.createConfigItemSync;
        } }), Object.defineProperty(r, "getEnv", { enumerable: !0, get: function() {
          return s.getEnv;
        } }), Object.defineProperty(r, "loadOptions", { enumerable: !0, get: function() {
          return b.loadOptions;
        } }), Object.defineProperty(r, "loadOptionsAsync", { enumerable: !0, get: function() {
          return b.loadOptionsAsync;
        } }), Object.defineProperty(r, "loadOptionsSync", { enumerable: !0, get: function() {
          return b.loadOptionsSync;
        } }), Object.defineProperty(r, "loadPartialConfig", { enumerable: !0, get: function() {
          return b.loadPartialConfig;
        } }), Object.defineProperty(r, "loadPartialConfigAsync", { enumerable: !0, get: function() {
          return b.loadPartialConfigAsync;
        } }), Object.defineProperty(r, "loadPartialConfigSync", { enumerable: !0, get: function() {
          return b.loadPartialConfigSync;
        } }), Object.defineProperty(r, "parse", { enumerable: !0, get: function() {
          return P.parse;
        } }), Object.defineProperty(r, "parseAsync", { enumerable: !0, get: function() {
          return P.parseAsync;
        } }), Object.defineProperty(r, "parseSync", { enumerable: !0, get: function() {
          return P.parseSync;
        } }), Object.defineProperty(r, "resolvePlugin", { enumerable: !0, get: function() {
          return d.resolvePlugin;
        } }), Object.defineProperty(r, "resolvePreset", { enumerable: !0, get: function() {
          return d.resolvePreset;
        } }), Object.defineProperty(r, "template", { enumerable: !0, get: function() {
          return y().default;
        } }), Object.defineProperty(r, "tokTypes", { enumerable: !0, get: function() {
          return m().tokTypes;
        } }), Object.defineProperty(r, "transform", { enumerable: !0, get: function() {
          return E.transform;
        } }), Object.defineProperty(r, "transformAsync", { enumerable: !0, get: function() {
          return E.transformAsync;
        } }), Object.defineProperty(r, "transformFile", { enumerable: !0, get: function() {
          return S.transformFile;
        } }), Object.defineProperty(r, "transformFileAsync", { enumerable: !0, get: function() {
          return S.transformFileAsync;
        } }), Object.defineProperty(r, "transformFileSync", { enumerable: !0, get: function() {
          return S.transformFileSync;
        } }), Object.defineProperty(r, "transformFromAst", { enumerable: !0, get: function() {
          return g.transformFromAst;
        } }), Object.defineProperty(r, "transformFromAstAsync", { enumerable: !0, get: function() {
          return g.transformFromAstAsync;
        } }), Object.defineProperty(r, "transformFromAstSync", { enumerable: !0, get: function() {
          return g.transformFromAstSync;
        } }), Object.defineProperty(r, "transformSync", { enumerable: !0, get: function() {
          return E.transformSync;
        } }), Object.defineProperty(r, "traverse", { enumerable: !0, get: function() {
          return h().default;
        } }), r.version = r.types = void 0;
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/file/file.js"), f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/tools/build-external-helpers.js"), d = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/files/index.js"), s = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/helpers/environment.js");
        function o() {
          const N = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
          return o = function() {
            return N;
          }, N;
        }
        function m() {
          const N = l("./node_modules/.pnpm/@babel+parser@7.22.16/node_modules/@babel/parser/lib/index.js");
          return m = function() {
            return N;
          }, N;
        }
        function h() {
          const N = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/index.js");
          return h = function() {
            return N;
          }, N;
        }
        function y() {
          const N = l("./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/index.js");
          return y = function() {
            return N;
          }, N;
        }
        Object.defineProperty(r, "types", { enumerable: !0, get: function() {
          return o();
        } });
        var b = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/index.js"), E = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transform.js"), S = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transform-file.js"), g = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transform-ast.js"), P = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/parse.js");
        l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js"), r.version = "7.22.15";
        const R = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]);
        r.DEFAULT_EXTENSIONS = R, r.OptionManager = class {
          init(N) {
            return (0, b.loadOptionsSync)(N);
          }
        }, r.Plugin = function(N) {
          throw new Error(`The (${N}) Babel 5 plugin is being run with an unsupported Babel version.`);
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/parse.js": (u, r, l) => {
        function i() {
          const h = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return i = function() {
            return h;
          }, h;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.parse = void 0, r.parseAsync = function(...h) {
          return (0, o.beginHiddenCallStack)(m.async)(...h);
        }, r.parseSync = function(...h) {
          return (0, o.beginHiddenCallStack)(m.sync)(...h);
        };
        var f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/index.js"), d = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/parser/index.js"), s = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/normalize-opts.js"), o = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const m = i()(function* (h, y) {
          const b = yield* (0, f.default)(y);
          return b === null ? null : yield* (0, d.default)(b.passes, (0, s.default)(b), h);
        });
        r.parse = function(h, y, b) {
          if (typeof y == "function" && (b = y, y = void 0), b === void 0)
            return (0, o.beginHiddenCallStack)(m.sync)(h, y);
          (0, o.beginHiddenCallStack)(m.errback)(h, y, b);
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/parser/index.js": (u, r, l) => {
        function i() {
          const s = l("./node_modules/.pnpm/@babel+parser@7.22.16/node_modules/@babel/parser/lib/index.js");
          return i = function() {
            return s;
          }, s;
        }
        function f() {
          const s = l("./stubs/babel-codeframe.js");
          return f = function() {
            return s;
          }, s;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function* (s, { parserOpts: o, highlightCode: m = !0, filename: h = "unknown" }, y) {
          try {
            const b = [];
            for (const E of s)
              for (const S of E) {
                const { parserOverride: g } = S;
                if (g) {
                  const P = g(y, o, i().parse);
                  P !== void 0 && b.push(P);
                }
              }
            if (b.length === 0)
              return (0, i().parse)(y, o);
            if (b.length === 1) {
              if (yield* [], typeof b[0].then == "function")
                throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
              return b[0];
            }
            throw new Error("More than one plugin attempted to override parsing.");
          } catch (b) {
            b.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" && (b.message += `
Consider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.`);
            const { loc: E, missingPlugin: S } = b;
            if (E) {
              const g = (0, f().codeFrameColumns)(y, { start: { line: E.line, column: E.column + 1 } }, { highlightCode: m });
              b.message = S ? `${h}: ` + (0, d.default)(S[0], E, g) : `${h}: ${b.message}

` + g, b.code = "BABEL_PARSE_ERROR";
            }
            throw b;
          }
        };
        var d = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js");
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f, d, s) {
          let o = `Support for the experimental syntax '${f}' isn't currently enabled (${d.line}:${d.column + 1}):

` + s;
          const m = l[f];
          if (m) {
            const { syntax: h, transform: y } = m;
            if (h) {
              const b = i(h);
              y ? o += `

Add ${i(y)} to the '${y.name.startsWith("@babel/plugin") ? "plugins" : "presets"}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${b} to the 'plugins' section to enable parsing.` : o += `

Add ${b} to the 'plugins' section of your Babel config to enable parsing.`;
            }
          }
          return o;
        };
        const l = { asyncDoExpressions: { syntax: { name: "@babel/plugin-syntax-async-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions" } }, decimal: { syntax: { name: "@babel/plugin-syntax-decimal", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal" } }, decorators: { syntax: { name: "@babel/plugin-syntax-decorators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators" }, transform: { name: "@babel/plugin-proposal-decorators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators" } }, doExpressions: { syntax: { name: "@babel/plugin-syntax-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions" }, transform: { name: "@babel/plugin-proposal-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions" } }, exportDefaultFrom: { syntax: { name: "@babel/plugin-syntax-export-default-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from" }, transform: { name: "@babel/plugin-proposal-export-default-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from" } }, flow: { syntax: { name: "@babel/plugin-syntax-flow", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow" }, transform: { name: "@babel/preset-flow", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow" } }, functionBind: { syntax: { name: "@babel/plugin-syntax-function-bind", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind" }, transform: { name: "@babel/plugin-proposal-function-bind", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind" } }, functionSent: { syntax: { name: "@babel/plugin-syntax-function-sent", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent" }, transform: { name: "@babel/plugin-proposal-function-sent", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent" } }, jsx: { syntax: { name: "@babel/plugin-syntax-jsx", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx" }, transform: { name: "@babel/preset-react", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react" } }, importAttributes: { syntax: { name: "@babel/plugin-syntax-import-attributes", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes" } }, pipelineOperator: { syntax: { name: "@babel/plugin-syntax-pipeline-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator" }, transform: { name: "@babel/plugin-proposal-pipeline-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator" } }, recordAndTuple: { syntax: { name: "@babel/plugin-syntax-record-and-tuple", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple" } }, throwExpressions: { syntax: { name: "@babel/plugin-syntax-throw-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions" }, transform: { name: "@babel/plugin-proposal-throw-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions" } }, typescript: { syntax: { name: "@babel/plugin-syntax-typescript", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript" }, transform: { name: "@babel/preset-typescript", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript" } } };
        Object.assign(l, { asyncGenerators: { syntax: { name: "@babel/plugin-syntax-async-generators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators" }, transform: { name: "@babel/plugin-transform-async-generator-functions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions" } }, classProperties: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties" } }, classPrivateProperties: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties" } }, classPrivateMethods: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-private-methods", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods" } }, classStaticBlock: { syntax: { name: "@babel/plugin-syntax-class-static-block", url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block" }, transform: { name: "@babel/plugin-transform-class-static-block", url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block" } }, dynamicImport: { syntax: { name: "@babel/plugin-syntax-dynamic-import", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import" } }, exportNamespaceFrom: { syntax: { name: "@babel/plugin-syntax-export-namespace-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from" }, transform: { name: "@babel/plugin-transform-export-namespace-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from" } }, importAssertions: { syntax: { name: "@babel/plugin-syntax-import-assertions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions" } }, importMeta: { syntax: { name: "@babel/plugin-syntax-import-meta", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta" } }, logicalAssignment: { syntax: { name: "@babel/plugin-syntax-logical-assignment-operators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators" }, transform: { name: "@babel/plugin-transform-logical-assignment-operators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators" } }, moduleStringNames: { syntax: { name: "@babel/plugin-syntax-module-string-names", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names" } }, numericSeparator: { syntax: { name: "@babel/plugin-syntax-numeric-separator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator" }, transform: { name: "@babel/plugin-transform-numeric-separator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator" } }, nullishCoalescingOperator: { syntax: { name: "@babel/plugin-syntax-nullish-coalescing-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator" }, transform: { name: "@babel/plugin-transform-nullish-coalescing-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator" } }, objectRestSpread: { syntax: { name: "@babel/plugin-syntax-object-rest-spread", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread" }, transform: { name: "@babel/plugin-transform-object-rest-spread", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread" } }, optionalCatchBinding: { syntax: { name: "@babel/plugin-syntax-optional-catch-binding", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding" }, transform: { name: "@babel/plugin-transform-optional-catch-binding", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding" } }, optionalChaining: { syntax: { name: "@babel/plugin-syntax-optional-chaining", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining" }, transform: { name: "@babel/plugin-transform-optional-chaining", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining" } }, privateIn: { syntax: { name: "@babel/plugin-syntax-private-property-in-object", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object" }, transform: { name: "@babel/plugin-transform-private-property-in-object", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object" } }, regexpUnicodeSets: { syntax: { name: "@babel/plugin-syntax-unicode-sets-regex", url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md" }, transform: { name: "@babel/plugin-transform-unicode-sets-regex", url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md" } } });
        const i = ({ name: f, url: d }) => `${f} (${d})`;
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/tools/build-external-helpers.js": (u, r, l) => {
        function i() {
          const k = l("./node_modules/.pnpm/@babel+helpers@7.22.15/node_modules/@babel/helpers/lib/index.js");
          return i = function() {
            return k;
          }, k;
        }
        function f() {
          const k = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/index.js");
          return f = function() {
            return k;
          }, k;
        }
        function d() {
          const k = l("./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/index.js");
          return d = function() {
            return k;
          }, k;
        }
        function s() {
          const k = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
          return s = function() {
            return k;
          }, k;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(k, K = "global") {
          let te;
          const z = { global: G, module: W, umd: U, var: M }[K];
          if (!z)
            throw new Error(`Unsupported output type ${K}`);
          return te = z(k), (0, f().default)(te).code;
        };
        var o = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/file/file.js");
        const { arrayExpression: m, assignmentExpression: h, binaryExpression: y, blockStatement: b, callExpression: E, cloneNode: S, conditionalExpression: g, exportNamedDeclaration: P, exportSpecifier: R, expressionStatement: N, functionExpression: C, identifier: I, memberExpression: D, objectExpression: j, program: F, stringLiteral: _, unaryExpression: T, variableDeclaration: v, variableDeclarator: w } = s(), O = (k) => d().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(k);
        function G(k) {
          const K = I("babelHelpers"), te = [], z = C(null, [I("global")], b(te)), q = F([N(E(z, [g(y("===", T("typeof", I("global")), _("undefined")), I("self"), I("global"))]))]);
          return te.push(v("var", [w(K, h("=", D(I("global"), K), j([])))])), B(te, K, k), q;
        }
        function W(k) {
          const K = [], te = B(K, null, k);
          return K.unshift(P(null, Object.keys(te).map((z) => R(S(te[z]), I(z))))), F(K, [], "module");
        }
        function U(k) {
          const K = I("babelHelpers"), te = [];
          return te.push(v("var", [w(K, I("global"))])), B(te, K, k), F([O({ FACTORY_PARAMETERS: I("global"), BROWSER_ARGUMENTS: h("=", D(I("root"), K), j([])), COMMON_ARGUMENTS: I("exports"), AMD_ARGUMENTS: m([_("exports")]), FACTORY_BODY: te, UMD_ROOT: I("this") })]);
        }
        function M(k) {
          const K = I("babelHelpers"), te = [];
          te.push(v("var", [w(K, j([]))]));
          const z = F(te);
          return B(te, K, k), te.push(N(K)), z;
        }
        function B(k, K, te) {
          const z = ($) => K ? D(K, I($)) : I(`_${$}`), q = {};
          return i().list.forEach(function($) {
            if (te && te.indexOf($) < 0)
              return;
            const Y = q[$] = z($);
            i().ensure($, o.default);
            const { nodes: H } = i().get($, z, Y);
            k.push(...H);
          }), q;
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transform-ast.js": (u, r, l) => {
        function i() {
          const m = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return i = function() {
            return m;
          }, m;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.transformFromAst = void 0, r.transformFromAstAsync = function(...m) {
          return (0, s.beginHiddenCallStack)(o.async)(...m);
        }, r.transformFromAstSync = function(...m) {
          return (0, s.beginHiddenCallStack)(o.sync)(...m);
        };
        var f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/index.js"), d = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/index.js"), s = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const o = i()(function* (m, h, y) {
          const b = yield* (0, f.default)(y);
          if (b === null)
            return null;
          if (!m)
            throw new Error("No AST given");
          return yield* (0, d.run)(b, h, m);
        });
        r.transformFromAst = function(m, h, y, b) {
          let E, S;
          if (typeof y == "function" ? (S = y, E = void 0) : (E = y, S = b), S === void 0)
            return (0, s.beginHiddenCallStack)(o.sync)(m, h, E);
          (0, s.beginHiddenCallStack)(o.errback)(m, h, E, S);
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transform-file.js": (u, r, l) => {
        function i() {
          const m = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return i = function() {
            return m;
          }, m;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.transformFile = function(...m) {
          o.errback(...m);
        }, r.transformFileAsync = function(...m) {
          return o.async(...m);
        }, r.transformFileSync = function(...m) {
          return o.sync(...m);
        };
        var f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/index.js"), d = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/index.js"), s = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/gensync-utils/fs.js");
        const o = i()(function* (m, h) {
          const y = Object.assign({}, h, { filename: m }), b = yield* (0, f.default)(y);
          if (b === null)
            return null;
          const E = yield* s.readFile(m, "utf8");
          return yield* (0, d.run)(b, E);
        });
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transform.js": (u, r, l) => {
        function i() {
          const m = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return i = function() {
            return m;
          }, m;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.transform = void 0, r.transformAsync = function(...m) {
          return (0, s.beginHiddenCallStack)(o.async)(...m);
        }, r.transformSync = function(...m) {
          return (0, s.beginHiddenCallStack)(o.sync)(...m);
        };
        var f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/index.js"), d = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/index.js"), s = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const o = i()(function* (m, h) {
          const y = yield* (0, f.default)(h);
          return y === null ? null : yield* (0, d.run)(y, m);
        });
        r.transform = function(m, h, y) {
          let b, E;
          if (typeof h == "function" ? (E = h, b = void 0) : (b = h, E = y), E === void 0)
            return (0, s.beginHiddenCallStack)(o.sync)(m, b);
          (0, s.beginHiddenCallStack)(o.errback)(m, b, E);
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/block-hoist-plugin.js": (u, r, l) => {
        function i() {
          const m = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/index.js");
          return i = function() {
            return m;
          }, m;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function() {
          return d || (d = new f.default(Object.assign({}, s, { visitor: i().default.explode(s.visitor) }), {})), d;
        };
        var f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/plugin.js");
        let d;
        const s = { name: "internal.blockHoist", visitor: { Block: { exit({ node: m }) {
          const { body: h } = m;
          let y = Math.pow(2, 30) - 1, b = !1;
          for (let E = 0; E < h.length; E++) {
            const S = o(h[E]);
            if (S > y) {
              b = !0;
              break;
            }
            y = S;
          }
          b && (m.body = function(E) {
            const S = /* @__PURE__ */ Object.create(null);
            for (let R = 0; R < E.length; R++) {
              const N = E[R], C = o(N);
              (S[C] || (S[C] = [])).push(N);
            }
            const g = Object.keys(S).map((R) => +R).sort((R, N) => N - R);
            let P = 0;
            for (const R of g) {
              const N = S[R];
              for (const C of N)
                E[P++] = C;
            }
            return E;
          }(h.slice()));
        } } } };
        function o(m) {
          const h = m == null ? void 0 : m._blockHoist;
          return h == null ? 1 : h === !0 ? 2 : h;
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/file/file.js": (u, r, l) => {
        function i() {
          const S = l("./node_modules/.pnpm/@babel+helpers@7.22.15/node_modules/@babel/helpers/lib/index.js");
          return i = function() {
            return S;
          }, S;
        }
        function f() {
          const S = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/index.js");
          return f = function() {
            return S;
          }, S;
        }
        function d() {
          const S = l("./stubs/babel-codeframe.js");
          return d = function() {
            return S;
          }, S;
        }
        function s() {
          const S = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
          return s = function() {
            return S;
          }, S;
        }
        function o() {
          const S = l("./node_modules/.pnpm/@babel+helper-module-transforms@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-module-transforms/lib/index.js");
          return o = function() {
            return S;
          }, S;
        }
        function m() {
          const S = l("./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js");
          return m = function() {
            return S;
          }, S;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        const { cloneNode: h, interpreterDirective: y } = s(), b = { enter(S, g) {
          const P = S.node.loc;
          P && (g.loc = P, S.stop());
        } };
        class E {
          constructor(g, { code: P, ast: R, inputMap: N }) {
            this._map = /* @__PURE__ */ new Map(), this.opts = void 0, this.declarations = {}, this.path = void 0, this.ast = void 0, this.scope = void 0, this.metadata = {}, this.code = "", this.inputMap = void 0, this.hub = { file: this, getCode: () => this.code, getScope: () => this.scope, addHelper: this.addHelper.bind(this), buildError: this.buildCodeFrameError.bind(this) }, this.opts = g, this.code = P, this.ast = R, this.inputMap = N, this.path = f().NodePath.get({ hub: this.hub, parentPath: null, parent: this.ast, container: this.ast, key: "program" }).setContext(), this.scope = this.path.scope;
          }
          get shebang() {
            const { interpreter: g } = this.path.node;
            return g ? g.value : "";
          }
          set shebang(g) {
            g ? this.path.get("interpreter").replaceWith(y(g)) : this.path.get("interpreter").remove();
          }
          set(g, P) {
            if (g === "helpersNamespace")
              throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'.");
            this._map.set(g, P);
          }
          get(g) {
            return this._map.get(g);
          }
          has(g) {
            return this._map.has(g);
          }
          getModuleName() {
            return (0, o().getModuleName)(this.opts, this.opts);
          }
          addImport() {
            throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-module-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
          }
          availableHelper(g, P) {
            let R;
            try {
              R = i().minVersion(g);
            } catch (N) {
              if (N.code !== "BABEL_HELPER_UNKNOWN")
                throw N;
              return !1;
            }
            return typeof P != "string" || (m().valid(P) && (P = `^${P}`), !m().intersects(`<${R}`, P) && !m().intersects(">=8.0.0", P));
          }
          addHelper(g) {
            const P = this.declarations[g];
            if (P)
              return h(P);
            const R = this.get("helperGenerator");
            if (R) {
              const j = R(g);
              if (j)
                return j;
            }
            i().ensure(g, E);
            const N = this.declarations[g] = this.scope.generateUidIdentifier(g), C = {};
            for (const j of i().getDependencies(g))
              C[j] = this.addHelper(j);
            const { nodes: I, globals: D } = i().get(g, (j) => C[j], N, Object.keys(this.scope.getAllBindings()));
            return D.forEach((j) => {
              this.path.scope.hasBinding(j, !0) && this.path.scope.rename(j);
            }), I.forEach((j) => {
              j._compact = !0;
            }), this.path.unshiftContainer("body", I), this.path.get("body").forEach((j) => {
              I.indexOf(j.node) !== -1 && j.isVariableDeclaration() && this.scope.registerDeclaration(j);
            }), N;
          }
          addTemplateObject() {
            throw new Error("This function has been moved into the template literal transform itself.");
          }
          buildCodeFrameError(g, P, R = SyntaxError) {
            let N = g && (g.loc || g._loc);
            if (!N && g) {
              const C = { loc: null };
              (0, f().default)(g, b, this.scope, C), N = C.loc;
              let I = "This is an error on an internal node. Probably an internal error.";
              N && (I += " Location has been estimated."), P += ` (${I})`;
            }
            if (N) {
              const { highlightCode: C = !0 } = this.opts;
              P += `
` + (0, d().codeFrameColumns)(this.code, { start: { line: N.start.line, column: N.start.column + 1 }, end: N.end && N.start.line === N.end.line ? { line: N.end.line, column: N.end.column + 1 } : void 0 }, { highlightCode: C });
            }
            return new R(P);
          }
        }
        r.default = E;
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/file/generate.js": (u, r, l) => {
        function i() {
          const s = l("./node_modules/.pnpm/convert-source-map@1.9.0/node_modules/convert-source-map/index.js");
          return i = function() {
            return s;
          }, s;
        }
        function f() {
          const s = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/index.js");
          return f = function() {
            return s;
          }, s;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(s, o) {
          const { opts: m, ast: h, code: y, inputMap: b } = o, { generatorOpts: E } = m;
          E.inputSourceMap = b == null ? void 0 : b.toObject();
          const S = [];
          for (const N of s)
            for (const C of N) {
              const { generatorOverride: I } = C;
              if (I) {
                const D = I(h, E, y, f().default);
                D !== void 0 && S.push(D);
              }
            }
          let g;
          if (S.length === 0)
            g = (0, f().default)(h, E, y);
          else {
            if (S.length !== 1)
              throw new Error("More than one plugin attempted to override codegen.");
            if (g = S[0], typeof g.then == "function")
              throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
          }
          let { code: P, decodedMap: R = g.map } = g;
          return g.__mergedMap ? R = Object.assign({}, g.map) : R && (R = b ? (0, d.default)(b.toObject(), R, E.sourceFileName) : g.map), m.sourceMaps !== "inline" && m.sourceMaps !== "both" || (P += `
` + i().fromObject(R).toComment()), m.sourceMaps === "inline" && (R = null), { outputCode: P, outputMap: R };
        };
        var d = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/file/merge-map.js");
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/file/merge-map.js": (u, r, l) => {
        function i() {
          const d = l("./node_modules/.pnpm/@ampproject+remapping@2.2.1/node_modules/@ampproject/remapping/dist/remapping.umd.js");
          return i = function() {
            return d;
          }, d;
        }
        function f(d) {
          return Object.assign({}, d, { sourceRoot: null });
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(d, s, o) {
          const m = o.replace(/\\/g, "/");
          let h = !1;
          const y = i()(f(s), (b, E) => b !== m || h ? null : (h = !0, E.source = "", f(d)));
          return typeof d.sourceRoot == "string" && (y.sourceRoot = d.sourceRoot), Object.assign({}, y);
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/index.js": (u, r, l) => {
        function i() {
          const b = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/index.js");
          return i = function() {
            return b;
          }, b;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.run = function* (b, E, S) {
          const g = yield* (0, o.default)(b.passes, (0, s.default)(b), E, S), P = g.opts;
          try {
            yield* function* (D, j) {
              for (const F of j) {
                const _ = [], T = [], v = [];
                for (const O of F.concat([(0, d.default)()])) {
                  const G = new f.default(D, O.key, O.options);
                  _.push([O, G]), T.push(G), v.push(O.visitor);
                }
                for (const [O, G] of _) {
                  const W = O.pre;
                  if (W) {
                    const U = W.call(G, D);
                    if (yield* [], y(U))
                      throw new Error("You appear to be using an plugin with an async .pre, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
                  }
                }
                const w = i().default.visitors.merge(v, T, D.opts.wrapPluginVisitorMethod);
                (0, i().default)(D.ast, w, D.scope);
                for (const [O, G] of _) {
                  const W = O.post;
                  if (W) {
                    const U = W.call(G, D);
                    if (yield* [], y(U))
                      throw new Error("You appear to be using an plugin with an async .post, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
                  }
                }
              }
            }(g, b.passes);
          } catch (D) {
            var R;
            throw D.message = `${(R = P.filename) != null ? R : "unknown file"}: ${D.message}`, D.code || (D.code = "BABEL_TRANSFORM_ERROR"), D;
          }
          let N, C;
          try {
            P.code !== !1 && ({ outputCode: N, outputMap: C } = (0, m.default)(b.passes, g));
          } catch (D) {
            var I;
            throw D.message = `${(I = P.filename) != null ? I : "unknown file"}: ${D.message}`, D.code || (D.code = "BABEL_GENERATE_ERROR"), D;
          }
          return { metadata: g.metadata, options: P, ast: P.ast === !0 ? g.ast : null, code: N === void 0 ? null : N, map: C === void 0 ? null : C, sourceType: g.ast.program.sourceType, externalDependencies: (0, h.flattenToSet)(b.externalDependencies) };
        };
        var f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/plugin-pass.js"), d = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/block-hoist-plugin.js"), s = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/normalize-opts.js"), o = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/normalize-file.js"), m = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/file/generate.js"), h = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/config/helpers/deep-array.js");
        function y(b) {
          return !(!b || typeof b != "object" && typeof b != "function" || !b.then || typeof b.then != "function");
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/normalize-file.js": (u, r, l) => {
        function i() {
          const C = l("fs");
          return i = function() {
            return C;
          }, C;
        }
        function f() {
          const C = l("path");
          return f = function() {
            return C;
          }, C;
        }
        function d() {
          const C = l("./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js");
          return d = function() {
            return C;
          }, C;
        }
        function s() {
          const C = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
          return s = function() {
            return C;
          }, C;
        }
        function o() {
          const C = l("./node_modules/.pnpm/convert-source-map@1.9.0/node_modules/convert-source-map/index.js");
          return o = function() {
            return C;
          }, C;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function* (C, I, D, j) {
          if (D = `${D || ""}`, j) {
            if (j.type === "Program")
              j = b(j, [], []);
            else if (j.type !== "File")
              throw new Error("AST root must be a Program or File node");
            I.cloneInputAst && (j = (0, y.default)(j));
          } else
            j = yield* (0, h.default)(C, I, D);
          let F = null;
          if (I.inputSourceMap !== !1) {
            if (typeof I.inputSourceMap == "object" && (F = o().fromObject(I.inputSourceMap)), !F) {
              const _ = N(g, j);
              if (_)
                try {
                  F = o().fromComment(_);
                } catch (T) {
                  S("discarding unknown inline input sourcemap", T);
                }
            }
            if (!F) {
              const _ = N(P, j);
              if (typeof I.filename == "string" && _)
                try {
                  const T = P.exec(_), v = i().readFileSync(f().resolve(f().dirname(I.filename), T[1]), "utf8");
                  F = o().fromJSON(v);
                } catch (T) {
                  S("discarding unknown file input sourcemap", T);
                }
              else
                _ && S("discarding un-loadable file input sourcemap");
            }
          }
          return new m.default(I, { code: D, ast: j, inputMap: F });
        };
        var m = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/file/file.js"), h = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/parser/index.js"), y = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/util/clone-deep.js");
        const { file: b, traverseFast: E } = s(), S = d()("babel:transform:file"), g = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/, P = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
        function R(C, I, D) {
          return I && (I = I.filter(({ value: j }) => !C.test(j) || (D = j, !1))), [I, D];
        }
        function N(C, I) {
          let D = null;
          return E(I, (j) => {
            [j.leadingComments, D] = R(C, j.leadingComments, D), [j.innerComments, D] = R(C, j.innerComments, D), [j.trailingComments, D] = R(C, j.trailingComments, D);
          }), D;
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/normalize-opts.js": (u, r, l) => {
        function i() {
          const f = l("path");
          return i = function() {
            return f;
          }, f;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f) {
          const { filename: d, cwd: s, filenameRelative: o = typeof d == "string" ? i().relative(s, d) : "unknown", sourceType: m = "module", inputSourceMap: h, sourceMaps: y = !!h, sourceRoot: b = f.options.moduleRoot, sourceFileName: E = i().basename(o), comments: S = !0, compact: g = "auto" } = f.options, P = f.options, R = Object.assign({}, P, { parserOpts: Object.assign({ sourceType: i().extname(o) === ".mjs" ? "module" : m, sourceFileName: d, plugins: [] }, P.parserOpts), generatorOpts: Object.assign({ filename: d, auxiliaryCommentBefore: P.auxiliaryCommentBefore, auxiliaryCommentAfter: P.auxiliaryCommentAfter, retainLines: P.retainLines, comments: S, shouldPrintComment: P.shouldPrintComment, compact: g, minified: P.minified, sourceMaps: y, sourceRoot: b, sourceFileName: E }, P.generatorOpts) });
          for (const N of f.passes)
            for (const C of N)
              C.manipulateOptions && C.manipulateOptions(R, R.parserOpts);
          return R;
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/plugin-pass.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        class l {
          constructor(f, d, s) {
            this._map = /* @__PURE__ */ new Map(), this.key = void 0, this.file = void 0, this.opts = void 0, this.cwd = void 0, this.filename = void 0, this.key = d, this.file = f, this.opts = s || {}, this.cwd = f.opts.cwd, this.filename = f.opts.filename;
          }
          set(f, d) {
            this._map.set(f, d);
          }
          get(f) {
            return this._map.get(f);
          }
          availableHelper(f, d) {
            return this.file.availableHelper(f, d);
          }
          addHelper(f) {
            return this.file.addHelper(f);
          }
          buildCodeFrameError(f, d, s) {
            return this.file.buildCodeFrameError(f, d, s);
          }
        }
        r.default = l, l.prototype.getModuleName = function() {
          return this.file.getModuleName();
        }, l.prototype.addImport = function() {
          this.file.addImport();
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/transformation/util/clone-deep.js": (u, r) => {
        function l(i, f) {
          if (i !== null) {
            if (f.has(i))
              return f.get(i);
            let d;
            if (Array.isArray(i)) {
              d = new Array(i.length), f.set(i, d);
              for (let s = 0; s < i.length; s++)
                d[s] = typeof i[s] != "object" ? i[s] : l(i[s], f);
            } else {
              d = {}, f.set(i, d);
              const s = Object.keys(i);
              for (let o = 0; o < s.length; o++) {
                const m = s[o];
                d[m] = typeof i[m] != "object" ? i[m] : l(i[m], f);
              }
            }
            return d;
          }
          return i;
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(i) {
          return typeof i != "object" ? i : l(i, /* @__PURE__ */ new Map());
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/vendor/import-meta-resolve.js": (u, r, l) => {
        function i() {
          const Ce = l("assert");
          return i = function() {
            return Ce;
          }, Ce;
        }
        function f() {
          const Ce = function(xe, He) {
            if (!He && xe && xe.__esModule)
              return xe;
            if (xe === null || typeof xe != "object" && typeof xe != "function")
              return { default: xe };
            var Be = b(He);
            if (Be && Be.has(xe))
              return Be.get(xe);
            var Ze = {}, nt = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var $e in xe)
              if ($e !== "default" && Object.prototype.hasOwnProperty.call(xe, $e)) {
                var ut = nt ? Object.getOwnPropertyDescriptor(xe, $e) : null;
                ut && (ut.get || ut.set) ? Object.defineProperty(Ze, $e, ut) : Ze[$e] = xe[$e];
              }
            return Ze.default = xe, Be && Be.set(xe, Ze), Ze;
          }(l("fs"), !0);
          return f = function() {
            return Ce;
          }, Ce;
        }
        function d() {
          const Ce = l("process");
          return d = function() {
            return Ce;
          }, Ce;
        }
        function s() {
          const Ce = l("url");
          return s = function() {
            return Ce;
          }, Ce;
        }
        function o() {
          const Ce = l("path");
          return o = function() {
            return Ce;
          }, Ce;
        }
        function m() {
          const Ce = l("module");
          return m = function() {
            return Ce;
          }, Ce;
        }
        function h() {
          const Ce = l("v8");
          return h = function() {
            return Ce;
          }, Ce;
        }
        function y() {
          const Ce = l("util");
          return y = function() {
            return Ce;
          }, Ce;
        }
        function b(Ce) {
          if (typeof WeakMap != "function")
            return null;
          var xe = /* @__PURE__ */ new WeakMap(), He = /* @__PURE__ */ new WeakMap();
          return (b = function(Be) {
            return Be ? He : xe;
          })(Ce);
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.moduleResolve = Ke, r.resolve = function(Ce, xe) {
          if (!xe)
            throw new Error("Please pass `parent`: `import-meta-resolve` cannot ponyfill that");
          try {
            return function(He, Be = {}) {
              const { parentURL: Ze } = Be;
              let nt, $e;
              if (i()(Ze !== void 0, "expected `parentURL` to be defined"), function(et) {
                if (et !== void 0) {
                  if (typeof et != "string" && (bt = et, !(bt && typeof bt == "object" && "href" in bt && typeof bt.href == "string" && "protocol" in bt && typeof bt.protocol == "string" && bt.href && bt.protocol)))
                    throw new R.ERR_INVALID_ARG_TYPE("parentURL", ["string", "URL"], et);
                  var bt;
                }
              }(Ze), Ze)
                try {
                  nt = new (s()).URL(Ze);
                } catch {
                }
              try {
                $e = Xe(He) ? new (s()).URL(He, nt) : new (s()).URL(He);
                const et = $e.protocol;
                if (et === "data:" || $ && (et === "https:" || et === "http:"))
                  return { url: $e.href, format: null };
              } catch {
              }
              const ut = function(et, bt, lt) {
                if (lt) {
                  const Et = lt.protocol;
                  if (Et === "http:" || Et === "https:") {
                    if (Xe(et)) {
                      const wt = bt == null ? void 0 : bt.protocol;
                      if (wt && wt !== "https:" && wt !== "http:")
                        throw new Y(et, lt, "remote imports cannot import from a local location.");
                      return { url: (bt == null ? void 0 : bt.href) || "" };
                    }
                    throw m().builtinModules.includes(et) ? new Y(et, lt, "remote imports cannot import from a local location.") : new Y(et, lt, "only relative and absolute specifiers are supported.");
                  }
                }
              }(He, $e, nt);
              if (ut)
                return ut;
              if ($e && $e.protocol === "node:")
                return { url: He };
              (function(et, bt) {
                const lt = et == null ? void 0 : et.protocol;
                if (lt && lt !== "file:" && lt !== "data:" && (!bt || lt !== "https:" && lt !== "http:"))
                  throw new oe(et, ["file", "data"].concat(bt ? ["https", "http"] : []));
              })($e, $);
              const vt = function(et) {
                if (et !== void 0 && et !== te) {
                  if (!Array.isArray(et))
                    throw new K("conditions", et, "expected an array");
                  return new Set(et);
                }
                return z;
              }(Be.conditions), yt = Ke(He, new (s()).URL(Ze), vt, !1);
              return function(et) {
                const bt = et.protocol;
                if (bt !== "file:" && bt !== "data:" && bt !== "node:")
                  throw new oe(et);
              }(yt), { url: yt.href, format: k(yt, { parentURL: Ze }) };
            }(Ce, { parentURL: xe }).url;
          } catch (He) {
            const Be = He;
            if (Be.code === "ERR_UNSUPPORTED_DIR_IMPORT" && typeof Be.url == "string")
              return Be.url;
            throw He;
          }
        };
        const E = d().platform === "win32", S = {}.hasOwnProperty, g = /^([A-Z][a-z\d]*)+$/, P = /* @__PURE__ */ new Set(["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"]), R = {};
        function N(Ce, xe = "and") {
          return Ce.length < 3 ? Ce.join(` ${xe} `) : `${Ce.slice(0, -1).join(", ")}, ${xe} ${Ce[Ce.length - 1]}`;
        }
        const C = /* @__PURE__ */ new Map();
        let I;
        function D(Ce, xe, He) {
          return C.set(Ce, xe), function(Be, Ze) {
            return nt;
            function nt(...$e) {
              const ut = Error.stackTraceLimit;
              j() && (Error.stackTraceLimit = 0);
              const vt = new Be();
              j() && (Error.stackTraceLimit = ut);
              const yt = function(et, bt, lt) {
                const Et = C.get(et);
                if (i()(Et !== void 0, "expected `message` to be found"), typeof Et == "function")
                  return i()(Et.length <= bt.length, `Code: ${et}; The provided arguments length (${bt.length}) does not match the required ones (${Et.length}).`), Reflect.apply(Et, lt, bt);
                const wt = /%[dfijoOs]/g;
                let Ne = 0;
                for (; wt.exec(Et) !== null; )
                  Ne++;
                return i()(Ne === bt.length, `Code: ${et}; The provided arguments length (${bt.length}) does not match the required ones (${Ne}).`), bt.length === 0 ? Et : (bt.unshift(Et), Reflect.apply(y().format, null, bt));
              }(Ze, $e, vt);
              return Object.defineProperties(vt, { message: { value: yt, enumerable: !1, writable: !0, configurable: !0 }, toString: { value() {
                return `${this.name} [${Ze}]: ${this.message}`;
              }, enumerable: !1, writable: !0, configurable: !0 } }), F(vt), vt.code = Ze, vt;
            }
          }(He, Ce);
        }
        function j() {
          try {
            if (h().startupSnapshot.isBuildingSnapshot())
              return !1;
          } catch {
          }
          const Ce = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
          return Ce === void 0 ? Object.isExtensible(Error) : S.call(Ce, "writable") && Ce.writable !== void 0 ? Ce.writable : Ce.set !== void 0;
        }
        R.ERR_INVALID_ARG_TYPE = D("ERR_INVALID_ARG_TYPE", (Ce, xe, He) => {
          i()(typeof Ce == "string", "'name' must be a string"), Array.isArray(xe) || (xe = [xe]);
          let Be = "The ";
          if (Ce.endsWith(" argument"))
            Be += `${Ce} `;
          else {
            const ut = Ce.includes(".") ? "property" : "argument";
            Be += `"${Ce}" ${ut} `;
          }
          Be += "must be ";
          const Ze = [], nt = [], $e = [];
          for (const ut of xe)
            i()(typeof ut == "string", "All expected entries have to be of type string"), P.has(ut) ? Ze.push(ut.toLowerCase()) : g.exec(ut) === null ? (i()(ut !== "object", 'The value "object" should be written as "Object"'), $e.push(ut)) : nt.push(ut);
          if (nt.length > 0) {
            const ut = Ze.indexOf("object");
            ut !== -1 && (Ze.slice(ut, 1), nt.push("Object"));
          }
          return Ze.length > 0 && (Be += `${Ze.length > 1 ? "one of type" : "of type"} ${N(Ze, "or")}`, (nt.length > 0 || $e.length > 0) && (Be += " or ")), nt.length > 0 && (Be += `an instance of ${N(nt, "or")}`, $e.length > 0 && (Be += " or ")), $e.length > 0 && ($e.length > 1 ? Be += `one of ${N($e, "or")}` : ($e[0].toLowerCase() !== $e[0] && (Be += "an "), Be += `${$e[0]}`)), Be += `. Received ${function(ut) {
            if (ut == null)
              return String(ut);
            if (typeof ut == "function" && ut.name)
              return `function ${ut.name}`;
            if (typeof ut == "object")
              return ut.constructor && ut.constructor.name ? `an instance of ${ut.constructor.name}` : `${(0, y().inspect)(ut, { depth: -1 })}`;
            let vt = (0, y().inspect)(ut, { colors: !1 });
            return vt.length > 28 && (vt = `${vt.slice(0, 25)}...`), `type ${typeof ut} (${vt})`;
          }(He)}`, Be;
        }, TypeError), R.ERR_INVALID_MODULE_SPECIFIER = D("ERR_INVALID_MODULE_SPECIFIER", (Ce, xe, He = void 0) => `Invalid module "${Ce}" ${xe}${He ? ` imported from ${He}` : ""}`, TypeError), R.ERR_INVALID_PACKAGE_CONFIG = D("ERR_INVALID_PACKAGE_CONFIG", (Ce, xe, He) => `Invalid package config ${Ce}${xe ? ` while importing ${xe}` : ""}${He ? `. ${He}` : ""}`, Error), R.ERR_INVALID_PACKAGE_TARGET = D("ERR_INVALID_PACKAGE_TARGET", (Ce, xe, He, Be = !1, Ze = void 0) => {
          const nt = typeof He == "string" && !Be && He.length > 0 && !He.startsWith("./");
          return xe === "." ? (i()(Be === !1), `Invalid "exports" main target ${JSON.stringify(He)} defined in the package config ${Ce}package.json${Ze ? ` imported from ${Ze}` : ""}${nt ? '; targets must start with "./"' : ""}`) : `Invalid "${Be ? "imports" : "exports"}" target ${JSON.stringify(He)} defined for '${xe}' in the package config ${Ce}package.json${Ze ? ` imported from ${Ze}` : ""}${nt ? '; targets must start with "./"' : ""}`;
        }, Error), R.ERR_MODULE_NOT_FOUND = D("ERR_MODULE_NOT_FOUND", (Ce, xe, He = "package") => `Cannot find ${He} '${Ce}' imported from ${xe}`, Error), R.ERR_NETWORK_IMPORT_DISALLOWED = D("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error), R.ERR_PACKAGE_IMPORT_NOT_DEFINED = D("ERR_PACKAGE_IMPORT_NOT_DEFINED", (Ce, xe, He) => `Package import specifier "${Ce}" is not defined${xe ? ` in package ${xe}package.json` : ""} imported from ${He}`, TypeError), R.ERR_PACKAGE_PATH_NOT_EXPORTED = D("ERR_PACKAGE_PATH_NOT_EXPORTED", (Ce, xe, He = void 0) => xe === "." ? `No "exports" main defined in ${Ce}package.json${He ? ` imported from ${He}` : ""}` : `Package subpath '${xe}' is not defined by "exports" in ${Ce}package.json${He ? ` imported from ${He}` : ""}`, Error), R.ERR_UNSUPPORTED_DIR_IMPORT = D("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error), R.ERR_UNKNOWN_FILE_EXTENSION = D("ERR_UNKNOWN_FILE_EXTENSION", (Ce, xe) => `Unknown file extension "${Ce}" for ${xe}`, TypeError), R.ERR_INVALID_ARG_VALUE = D("ERR_INVALID_ARG_VALUE", (Ce, xe, He = "is invalid") => {
          let Be = (0, y().inspect)(xe);
          return Be.length > 128 && (Be = `${Be.slice(0, 128)}...`), `The ${Ce.includes(".") ? "property" : "argument"} '${Ce}' ${He}. Received ${Be}`;
        }, TypeError), R.ERR_UNSUPPORTED_ESM_URL_SCHEME = D("ERR_UNSUPPORTED_ESM_URL_SCHEME", (Ce, xe) => {
          let He = `Only URLs with a scheme in: ${N(xe)} are supported by the default ESM loader`;
          return E && Ce.protocol.length === 2 && (He += ". On Windows, absolute paths must be valid file:// URLs"), He += `. Received protocol '${Ce.protocol}'`, He;
        }, Error);
        const F = function(Ce) {
          const xe = "__node_internal_" + Ce.name;
          return Object.defineProperty(Ce, "name", { value: xe }), Ce;
        }(function(Ce) {
          const xe = j();
          return xe && (I = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(Ce), xe && (Error.stackTraceLimit = I), Ce;
        });
        var _ = { read: function(Ce) {
          try {
            return { string: f().default.readFileSync(o().toNamespacedPath(o().join(o().dirname(Ce), "package.json")), "utf8") };
          } catch (xe) {
            const He = xe;
            if (He.code === "ENOENT")
              return { string: void 0 };
            throw He;
          }
        } };
        const { ERR_INVALID_PACKAGE_CONFIG: T } = R, v = /* @__PURE__ */ new Map();
        function w(Ce, xe, He) {
          const Be = v.get(Ce);
          if (Be !== void 0)
            return Be;
          const Ze = _.read(Ce).string;
          if (Ze === void 0) {
            const lt = { pjsonPath: Ce, exists: !1, main: void 0, name: void 0, type: "none", exports: void 0, imports: void 0 };
            return v.set(Ce, lt), lt;
          }
          let nt;
          try {
            nt = JSON.parse(Ze);
          } catch (lt) {
            const Et = lt;
            throw new T(Ce, (He ? `"${xe}" from ` : "") + (0, s().fileURLToPath)(He || xe), Et.message);
          }
          const { exports: $e, imports: ut, main: vt, name: yt, type: et } = nt, bt = { pjsonPath: Ce, exists: !0, main: typeof vt == "string" ? vt : void 0, name: typeof yt == "string" ? yt : void 0, type: et === "module" || et === "commonjs" ? et : "none", exports: $e, imports: ut && typeof ut == "object" ? ut : void 0 };
          return v.set(Ce, bt), bt;
        }
        function O(Ce) {
          let xe = new (s()).URL("package.json", Ce);
          for (; !xe.pathname.endsWith("node_modules/package.json"); ) {
            const Ze = w((0, s().fileURLToPath)(xe), Ce);
            if (Ze.exists)
              return Ze;
            const nt = xe;
            if (xe = new (s()).URL("../package.json", xe), xe.pathname === nt.pathname)
              break;
          }
          const He = (0, s().fileURLToPath)(xe), Be = { pjsonPath: He, exists: !1, main: void 0, name: void 0, type: "none", exports: void 0, imports: void 0 };
          return v.set(He, Be), Be;
        }
        const { ERR_UNKNOWN_FILE_EXTENSION: G } = R, W = {}.hasOwnProperty, U = { __proto__: null, ".cjs": "commonjs", ".js": "module", ".json": "json", ".mjs": "module" }, M = { __proto__: null, "data:": function(Ce) {
          const { 1: xe } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(Ce.pathname) || [null, null, null];
          return function(He) {
            return He && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(He) ? "module" : He === "application/json" ? "json" : null;
          }(xe);
        }, "file:": function(Ce, xe, He) {
          const Be = function($e) {
            const ut = $e.pathname;
            let vt = ut.length;
            for (; vt--; ) {
              const yt = ut.codePointAt(vt);
              if (yt === 47)
                return "";
              if (yt === 46)
                return ut.codePointAt(vt - 1) === 47 ? "" : ut.slice(vt);
            }
            return "";
          }(Ce);
          if (Be === ".js")
            return function($e) {
              return O($e).type;
            }(Ce) === "module" ? "module" : "commonjs";
          const Ze = U[Be];
          if (Ze)
            return Ze;
          if (He)
            return;
          const nt = (0, s().fileURLToPath)(Ce);
          throw new G(Be, nt);
        }, "http:": B, "https:": B, "node:": () => "builtin" };
        function B() {
        }
        function k(Ce, xe) {
          return W.call(M, Ce.protocol) && M[Ce.protocol](Ce, xe, !0) || null;
        }
        const { ERR_INVALID_ARG_VALUE: K } = R, te = Object.freeze(["node", "import"]), z = new Set(te), q = RegExp.prototype[Symbol.replace], $ = !1, { ERR_NETWORK_IMPORT_DISALLOWED: Y, ERR_INVALID_MODULE_SPECIFIER: H, ERR_INVALID_PACKAGE_CONFIG: Q, ERR_INVALID_PACKAGE_TARGET: X, ERR_MODULE_NOT_FOUND: ne, ERR_PACKAGE_IMPORT_NOT_DEFINED: ye, ERR_PACKAGE_PATH_NOT_EXPORTED: ve, ERR_UNSUPPORTED_DIR_IMPORT: de, ERR_UNSUPPORTED_ESM_URL_SCHEME: oe } = R, re = {}.hasOwnProperty, ae = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i, le = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i, ue = /^\.|%|\\/, ie = /\*/g, we = /%2f|%5c/i, De = /* @__PURE__ */ new Set(), Ee = /[/\\]{2}/;
        function Ae(Ce, xe, He, Be, Ze, nt, $e) {
          const ut = (0, s().fileURLToPath)(Be), vt = Ee.exec($e ? Ce : xe) !== null;
          d().emitWarning(`Use of deprecated ${vt ? "double slash" : "leading or trailing slash matching"} resolving "${Ce}" for module request "${xe}" ${xe === He ? "" : `matched to "${He}" `}in the "${Ze ? "imports" : "exports"}" field module resolution of the package at ${ut}${nt ? ` imported from ${(0, s().fileURLToPath)(nt)}` : ""}.`, "DeprecationWarning", "DEP0166");
        }
        function Me(Ce, xe, He, Be) {
          if (k(Ce, { parentURL: He.href }) !== "module")
            return;
          const Ze = (0, s().fileURLToPath)(Ce.href), nt = (0, s().fileURLToPath)(new (s()).URL(".", xe)), $e = (0, s().fileURLToPath)(He);
          Be ? d().emitWarning(`Package ${nt} has a "main" field set to ${JSON.stringify(Be)}, excluding the full filename and extension to the resolved file at "${Ze.slice(nt.length)}", imported from ${$e}.
 Automatic extension resolution of the "main" field isdeprecated for ES modules.`, "DeprecationWarning", "DEP0151") : d().emitWarning(`No "main" or "exports" field defined in the package.json for ${nt} resolving the main entry point "${Ze.slice(nt.length)}", imported from ${$e}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
        }
        function me(Ce) {
          try {
            return (0, f().statSync)(Ce);
          } catch {
            return new (f()).Stats();
          }
        }
        function se(Ce) {
          const xe = (0, f().statSync)(Ce, { throwIfNoEntry: !1 }), He = xe ? xe.isFile() : void 0;
          return He != null && He;
        }
        function Z(Ce, xe, He) {
          let Be;
          if (xe.main !== void 0) {
            if (Be = new (s()).URL(xe.main, Ce), se(Be))
              return Be;
            const $e = [`./${xe.main}.js`, `./${xe.main}.json`, `./${xe.main}.node`, `./${xe.main}/index.js`, `./${xe.main}/index.json`, `./${xe.main}/index.node`];
            let ut = -1;
            for (; ++ut < $e.length && (Be = new (s()).URL($e[ut], Ce), !se(Be)); )
              Be = void 0;
            if (Be)
              return Me(Be, Ce, He, xe.main), Be;
          }
          const Ze = ["./index.js", "./index.json", "./index.node"];
          let nt = -1;
          for (; ++nt < Ze.length && (Be = new (s()).URL(Ze[nt], Ce), !se(Be)); )
            Be = void 0;
          if (Be)
            return Me(Be, Ce, He, xe.main), Be;
          throw new ne((0, s().fileURLToPath)(new (s()).URL(".", Ce)), (0, s().fileURLToPath)(He));
        }
        function pe(Ce, xe, He) {
          return new ve((0, s().fileURLToPath)(new (s()).URL(".", xe)), Ce, He && (0, s().fileURLToPath)(He));
        }
        function be(Ce, xe, He, Be, Ze) {
          return xe = typeof xe == "object" && xe !== null ? JSON.stringify(xe, null, "") : `${xe}`, new X((0, s().fileURLToPath)(new (s()).URL(".", He)), Ce, xe, Be, Ze && (0, s().fileURLToPath)(Ze));
        }
        function _e(Ce, xe, He, Be, Ze, nt, $e, ut, vt) {
          if (xe !== "" && !nt && Ce[Ce.length - 1] !== "/")
            throw be(He, Ce, Be, $e, Ze);
          if (!Ce.startsWith("./")) {
            if ($e && !Ce.startsWith("../") && !Ce.startsWith("/")) {
              let lt = !1;
              try {
                new (s()).URL(Ce), lt = !0;
              } catch {
              }
              if (!lt)
                return st(nt ? q.call(ie, Ce, () => xe) : Ce + xe, Be, vt);
            }
            throw be(He, Ce, Be, $e, Ze);
          }
          if (ae.exec(Ce.slice(2)) !== null) {
            if (le.exec(Ce.slice(2)) !== null)
              throw be(He, Ce, Be, $e, Ze);
            if (!ut) {
              const lt = nt ? He.replace("*", () => xe) : He + xe;
              Ae(nt ? q.call(ie, Ce, () => xe) : Ce, lt, He, Be, $e, Ze, !0);
            }
          }
          const yt = new (s()).URL(Ce, Be), et = yt.pathname, bt = new (s()).URL(".", Be).pathname;
          if (!et.startsWith(bt))
            throw be(He, Ce, Be, $e, Ze);
          if (xe === "")
            return yt;
          if (ae.exec(xe) !== null) {
            const lt = nt ? He.replace("*", () => xe) : He + xe;
            le.exec(xe) === null ? ut || Ae(nt ? q.call(ie, Ce, () => xe) : Ce, lt, He, Be, $e, Ze, !1) : function(Et, wt, Ne, Je, ft) {
              const rt = `request is not a valid match in pattern "${wt}" for the "${Je ? "imports" : "exports"}" resolution of ${(0, s().fileURLToPath)(Ne)}`;
              throw new H(Et, rt, ft && (0, s().fileURLToPath)(ft));
            }(lt, He, Be, $e, Ze);
          }
          return nt ? new (s()).URL(q.call(ie, yt.href, () => xe)) : new (s()).URL(xe, yt);
        }
        function Ie(Ce) {
          const xe = Number(Ce);
          return `${xe}` === Ce && xe >= 0 && xe < 4294967295;
        }
        function We(Ce, xe, He, Be, Ze, nt, $e, ut, vt) {
          if (typeof xe == "string")
            return _e(xe, He, Be, Ce, Ze, nt, $e, ut, vt);
          if (Array.isArray(xe)) {
            const yt = xe;
            if (yt.length === 0)
              return null;
            let et, bt = -1;
            for (; ++bt < yt.length; ) {
              const lt = yt[bt];
              let Et;
              try {
                Et = We(Ce, lt, He, Be, Ze, nt, $e, ut, vt);
              } catch (wt) {
                if (et = wt, wt.code === "ERR_INVALID_PACKAGE_TARGET")
                  continue;
                throw wt;
              }
              if (Et !== void 0) {
                if (Et !== null)
                  return Et;
                et = null;
              }
            }
            if (et == null)
              return null;
            throw et;
          }
          if (typeof xe == "object" && xe !== null) {
            const yt = Object.getOwnPropertyNames(xe);
            let et = -1;
            for (; ++et < yt.length; )
              if (Ie(yt[et]))
                throw new Q((0, s().fileURLToPath)(Ce), Ze, '"exports" cannot contain numeric property keys.');
            for (et = -1; ++et < yt.length; ) {
              const bt = yt[et];
              if (bt === "default" || vt && vt.has(bt)) {
                const lt = We(Ce, xe[bt], He, Be, Ze, nt, $e, ut, vt);
                if (lt === void 0)
                  continue;
                return lt;
              }
            }
            return null;
          }
          if (xe === null)
            return null;
          throw be(Be, xe, Ce, $e, Ze);
        }
        function tt(Ce, xe, He) {
          const Be = (0, s().fileURLToPath)(xe);
          De.has(Be + "|" + Ce) || (De.add(Be + "|" + Ce), d().emitWarning(`Use of deprecated trailing slash pattern mapping "${Ce}" in the "exports" field module resolution of the package at ${Be}${He ? ` imported from ${(0, s().fileURLToPath)(He)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`, "DeprecationWarning", "DEP0155"));
        }
        function Ye(Ce, xe, He, Be, Ze) {
          let nt = He.exports;
          if (function(et, bt, lt) {
            if (typeof et == "string" || Array.isArray(et))
              return !0;
            if (typeof et != "object" || et === null)
              return !1;
            const Et = Object.getOwnPropertyNames(et);
            let wt = !1, Ne = 0, Je = -1;
            for (; ++Je < Et.length; ) {
              const ft = Et[Je], rt = ft === "" || ft[0] !== ".";
              if (Ne++ == 0)
                wt = rt;
              else if (wt !== rt)
                throw new Q((0, s().fileURLToPath)(bt), lt, `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`);
            }
            return wt;
          }(nt, Ce, Be) && (nt = { ".": nt }), re.call(nt, xe) && !xe.includes("*") && !xe.endsWith("/")) {
            const et = We(Ce, nt[xe], "", xe, Be, !1, !1, !1, Ze);
            if (et == null)
              throw pe(xe, Ce, Be);
            return et;
          }
          let $e = "", ut = "";
          const vt = Object.getOwnPropertyNames(nt);
          let yt = -1;
          for (; ++yt < vt.length; ) {
            const et = vt[yt], bt = et.indexOf("*");
            if (bt !== -1 && xe.startsWith(et.slice(0, bt))) {
              xe.endsWith("/") && tt(xe, Ce, Be);
              const lt = et.slice(bt + 1);
              xe.length >= et.length && xe.endsWith(lt) && ht($e, et) === 1 && et.lastIndexOf("*") === bt && ($e = et, ut = xe.slice(bt, xe.length - lt.length));
            }
          }
          if ($e) {
            const et = We(Ce, nt[$e], ut, $e, Be, !0, !1, xe.endsWith("/"), Ze);
            if (et == null)
              throw pe(xe, Ce, Be);
            return et;
          }
          throw pe(xe, Ce, Be);
        }
        function ht(Ce, xe) {
          const He = Ce.indexOf("*"), Be = xe.indexOf("*"), Ze = He === -1 ? Ce.length : He + 1, nt = Be === -1 ? xe.length : Be + 1;
          return Ze > nt ? -1 : nt > Ze || He === -1 ? 1 : Be === -1 || Ce.length > xe.length ? -1 : xe.length > Ce.length ? 1 : 0;
        }
        function ct(Ce, xe, He) {
          if (Ce === "#" || Ce.startsWith("#/") || Ce.endsWith("/"))
            throw new H(Ce, "is not a valid internal imports specifier name", (0, s().fileURLToPath)(xe));
          let Be;
          const Ze = O(xe);
          if (Ze.exists) {
            Be = (0, s().pathToFileURL)(Ze.pjsonPath);
            const nt = Ze.imports;
            if (nt)
              if (re.call(nt, Ce) && !Ce.includes("*")) {
                const $e = We(Be, nt[Ce], "", Ce, xe, !1, !0, !1, He);
                if ($e != null)
                  return $e;
              } else {
                let $e = "", ut = "";
                const vt = Object.getOwnPropertyNames(nt);
                let yt = -1;
                for (; ++yt < vt.length; ) {
                  const et = vt[yt], bt = et.indexOf("*");
                  if (bt !== -1 && Ce.startsWith(et.slice(0, -1))) {
                    const lt = et.slice(bt + 1);
                    Ce.length >= et.length && Ce.endsWith(lt) && ht($e, et) === 1 && et.lastIndexOf("*") === bt && ($e = et, ut = Ce.slice(bt, Ce.length - lt.length));
                  }
                }
                if ($e) {
                  const et = We(Be, nt[$e], ut, $e, xe, !0, !0, !1, He);
                  if (et != null)
                    return et;
                }
              }
          }
          throw function(nt, $e, ut) {
            return new ye(nt, $e && (0, s().fileURLToPath)(new (s()).URL(".", $e)), (0, s().fileURLToPath)(ut));
          }(Ce, Be, xe);
        }
        function st(Ce, xe, He) {
          if (m().builtinModules.includes(Ce))
            return new (s()).URL("node:" + Ce);
          const { packageName: Be, packageSubpath: Ze, isScoped: nt } = function(et, bt) {
            let lt = et.indexOf("/"), Et = !0, wt = !1;
            et[0] === "@" && (wt = !0, lt === -1 || et.length === 0 ? Et = !1 : lt = et.indexOf("/", lt + 1));
            const Ne = lt === -1 ? et : et.slice(0, lt);
            if (ue.exec(Ne) !== null && (Et = !1), !Et)
              throw new H(et, "is not a valid package name", (0, s().fileURLToPath)(bt));
            return { packageName: Ne, packageSubpath: "." + (lt === -1 ? "" : et.slice(lt)), isScoped: wt };
          }(Ce, xe), $e = O(xe);
          if ($e.exists) {
            const et = (0, s().pathToFileURL)($e.pjsonPath);
            if ($e.name === Be && $e.exports !== void 0 && $e.exports !== null)
              return Ye(et, Ze, $e, xe, He);
          }
          let ut, vt = new (s()).URL("./node_modules/" + Be + "/package.json", xe), yt = (0, s().fileURLToPath)(vt);
          do {
            if (!me(yt.slice(0, -13)).isDirectory()) {
              ut = yt, vt = new (s()).URL((nt ? "../../../../node_modules/" : "../../../node_modules/") + Be + "/package.json", vt), yt = (0, s().fileURLToPath)(vt);
              continue;
            }
            const et = w(yt, Ce, xe);
            return et.exports !== void 0 && et.exports !== null ? Ye(vt, Ze, et, xe, He) : Ze === "." ? Z(vt, et, xe) : new (s()).URL(Ze, vt);
          } while (yt.length !== ut.length);
          throw new ne(Be, (0, s().fileURLToPath)(xe));
        }
        function Xe(Ce) {
          return Ce !== "" && (Ce[0] === "/" || function(xe) {
            return xe[0] === "." && (xe.length === 1 || xe[1] === "/" || xe[1] === "." && (xe.length === 2 || xe[2] === "/"));
          }(Ce));
        }
        function Ke(Ce, xe, He, Be) {
          const Ze = xe.protocol, nt = Ze === "http:" || Ze === "https:";
          let $e;
          if (Xe(Ce))
            $e = new (s()).URL(Ce, xe);
          else if (nt || Ce[0] !== "#")
            try {
              $e = new (s()).URL(Ce);
            } catch {
              nt || ($e = st(Ce, xe, He));
            }
          else
            $e = ct(Ce, xe, He);
          return i()($e !== void 0, "expected to be defined"), $e.protocol !== "file:" ? $e : function(ut, vt, yt) {
            if (we.exec(ut.pathname) !== null)
              throw new H(ut.pathname, 'must not include encoded "/" or "\\" characters', (0, s().fileURLToPath)(vt));
            const et = (0, s().fileURLToPath)(ut), bt = me(et.endsWith("/") ? et.slice(-1) : et);
            if (bt.isDirectory()) {
              const lt = new de(et, (0, s().fileURLToPath)(vt));
              throw lt.url = String(ut), lt;
            }
            if (!bt.isFile())
              throw new ne(et || ut.pathname, vt && (0, s().fileURLToPath)(vt), "module");
            if (!yt) {
              const lt = (0, f().realpathSync)(et), { search: Et, hash: wt } = ut;
              (ut = (0, s().pathToFileURL)(lt + (et.endsWith(o().sep) ? "/" : ""))).search = Et, ut.hash = wt;
            }
            return ut;
          }($e, xe, Be);
        }
      }, "./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/buffer.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0, r.default = class {
          constructor(l) {
            this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this._canMarkIdName = !0, this._position = { line: 1, column: 0 }, this._sourcePosition = { identifierName: void 0, identifierNamePos: void 0, line: void 0, column: void 0, filename: void 0 }, this._map = l, this._allocQueue();
          }
          _allocQueue() {
            const l = this._queue;
            for (let i = 0; i < 16; i++)
              l.push({ char: 0, repeat: 1, line: void 0, column: void 0, identifierName: void 0, identifierNamePos: void 0, filename: "" });
          }
          _pushQueue(l, i, f, d, s) {
            const o = this._queueCursor;
            o === this._queue.length && this._allocQueue();
            const m = this._queue[o];
            m.char = l, m.repeat = i, m.line = f, m.column = d, m.filename = s, this._queueCursor++;
          }
          _popQueue() {
            if (this._queueCursor === 0)
              throw new Error("Cannot pop from empty queue");
            return this._queue[--this._queueCursor];
          }
          get() {
            this._flush();
            const l = this._map, i = { code: (this._buf + this._str).trimRight(), decodedMap: l == null ? void 0 : l.getDecoded(), get __mergedMap() {
              return this.map;
            }, get map() {
              const f = l ? l.get() : null;
              return i.map = f, f;
            }, set map(f) {
              Object.defineProperty(i, "map", { value: f, writable: !0 });
            }, get rawMappings() {
              const f = l == null ? void 0 : l.getRawMappings();
              return i.rawMappings = f, f;
            }, set rawMappings(f) {
              Object.defineProperty(i, "rawMappings", { value: f, writable: !0 });
            } };
            return i;
          }
          append(l, i) {
            this._flush(), this._append(l, this._sourcePosition, i);
          }
          appendChar(l) {
            this._flush(), this._appendChar(l, 1, this._sourcePosition);
          }
          queue(l) {
            if (l === 10)
              for (; this._queueCursor !== 0; ) {
                const f = this._queue[this._queueCursor - 1].char;
                if (f !== 32 && f !== 9)
                  break;
                this._queueCursor--;
              }
            const i = this._sourcePosition;
            this._pushQueue(l, 1, i.line, i.column, i.filename);
          }
          queueIndentation(l, i) {
            this._pushQueue(l, i, void 0, void 0, void 0);
          }
          _flush() {
            const l = this._queueCursor, i = this._queue;
            for (let f = 0; f < l; f++) {
              const d = i[f];
              this._appendChar(d.char, d.repeat, d);
            }
            this._queueCursor = 0;
          }
          _appendChar(l, i, f) {
            this._last = l, this._str += i > 1 ? String.fromCharCode(l).repeat(i) : String.fromCharCode(l), l !== 10 ? (this._mark(f.line, f.column, f.identifierName, f.identifierNamePos, f.filename), this._position.column += i) : (this._position.line++, this._position.column = 0), this._canMarkIdName && (f.identifierName = void 0, f.identifierNamePos = void 0);
          }
          _append(l, i, f) {
            const d = l.length, s = this._position;
            if (this._last = l.charCodeAt(d - 1), ++this._appendCount > 4096 ? (this._str, this._buf += this._str, this._str = l, this._appendCount = 0) : this._str += l, !f && !this._map)
              return void (s.column += d);
            const { column: o, identifierName: m, identifierNamePos: h, filename: y } = i;
            let b = i.line;
            m == null && h == null || !this._canMarkIdName || (i.identifierName = void 0, i.identifierNamePos = void 0);
            let E = l.indexOf(`
`), S = 0;
            for (E !== 0 && this._mark(b, o, m, h, y); E !== -1; )
              s.line++, s.column = 0, S = E + 1, S < d && b !== void 0 && this._mark(++b, 0, null, null, y), E = l.indexOf(`
`, S);
            s.column += d - S;
          }
          _mark(l, i, f, d, s) {
            var o;
            (o = this._map) == null || o.mark(this._position, l, i, f, d, s);
          }
          removeTrailingNewline() {
            const l = this._queueCursor;
            l !== 0 && this._queue[l - 1].char === 10 && this._queueCursor--;
          }
          removeLastSemicolon() {
            const l = this._queueCursor;
            l !== 0 && this._queue[l - 1].char === 59 && this._queueCursor--;
          }
          getLastChar() {
            const l = this._queueCursor;
            return l !== 0 ? this._queue[l - 1].char : this._last;
          }
          getNewlineCount() {
            const l = this._queueCursor;
            let i = 0;
            if (l === 0)
              return this._last === 10 ? 1 : 0;
            for (let f = l - 1; f >= 0 && this._queue[f].char === 10; f--)
              i++;
            return i === l && this._last === 10 ? i + 1 : i;
          }
          endsWithCharAndNewline() {
            const l = this._queue, i = this._queueCursor;
            if (i !== 0)
              return l[i - 1].char !== 10 ? void 0 : i > 1 ? l[i - 2].char : this._last;
          }
          hasContent() {
            return this._queueCursor !== 0 || !!this._last;
          }
          exactSource(l, i) {
            if (!this._map)
              return void i();
            this.source("start", l);
            const f = l.identifierName, d = this._sourcePosition;
            f && (this._canMarkIdName = !1, d.identifierName = f), i(), f && (this._canMarkIdName = !0, d.identifierName = void 0, d.identifierNamePos = void 0), this.source("end", l);
          }
          source(l, i) {
            this._map && this._normalizePosition(l, i, 0);
          }
          sourceWithOffset(l, i, f) {
            this._map && this._normalizePosition(l, i, f);
          }
          withSource(l, i, f) {
            this._map && this.source(l, i), f();
          }
          _normalizePosition(l, i, f) {
            const d = i[l], s = this._sourcePosition;
            d && (s.line = d.line, s.column = Math.max(d.column + f, 0), s.filename = i.filename);
          }
          getCurrentColumn() {
            const l = this._queue, i = this._queueCursor;
            let f = -1, d = 0;
            for (let s = 0; s < i; s++) {
              const o = l[s];
              o.char === 10 && (f = d), d += o.repeat;
            }
            return f === -1 ? this._position.column + d : d - 1 - f;
          }
          getCurrentLine() {
            let l = 0;
            const i = this._queue;
            for (let f = 0; f < this._queueCursor; f++)
              i[f].char === 10 && l++;
            return this._position.line + l;
          }
        };
      }, "./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/base.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.BlockStatement = function(f) {
          var d;
          this.tokenChar(123);
          const s = (d = f.directives) == null ? void 0 : d.length;
          if (s) {
            var o;
            const m = f.body.length ? 2 : 1;
            this.printSequence(f.directives, f, { indent: !0, trailingCommentsLineOffset: m }), (o = f.directives[s - 1].trailingComments) != null && o.length || this.newline(m);
          }
          this.printSequence(f.body, f, { indent: !0 }), this.rightBrace(f);
        }, r.Directive = function(f) {
          this.print(f.value, f), this.semicolon();
        }, r.DirectiveLiteral = function(f) {
          const d = this.getPossibleRaw(f);
          if (!this.format.minified && d !== void 0)
            return void this.token(d);
          const { value: s } = f;
          if (i.test(s)) {
            if (l.test(s))
              throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
            this.token(`'${s}'`);
          } else
            this.token(`"${s}"`);
        }, r.File = function(f) {
          f.program && this.print(f.program.interpreter, f), this.print(f.program, f);
        }, r.InterpreterDirective = function(f) {
          this.token(`#!${f.value}`), this.newline(1, !0);
        }, r.Placeholder = function(f) {
          this.token("%%"), this.print(f.name), this.token("%%"), f.expectedNode === "Statement" && this.semicolon();
        }, r.Program = function(f) {
          var d;
          this.noIndentInnerCommentsHere(), this.printInnerComments();
          const s = (d = f.directives) == null ? void 0 : d.length;
          if (s) {
            var o;
            const m = f.body.length ? 2 : 1;
            this.printSequence(f.directives, f, { trailingCommentsLineOffset: m }), (o = f.directives[s - 1].trailingComments) != null && o.length || this.newline(m);
          }
          this.printSequence(f.body, f);
        };
        const l = /(?:^|[^\\])(?:\\\\)*'/, i = /(?:^|[^\\])(?:\\\\)*"/;
      }, "./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/classes.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.ClassAccessorProperty = function(s) {
          var o;
          this.printJoin(s.decorators, s);
          const m = (o = s.key.loc) == null || (o = o.end) == null ? void 0 : o.line;
          m && this.catchUp(m), this.tsPrintClassMemberModifiers(s), this.word("accessor", !0), this.space(), s.computed ? (this.tokenChar(91), this.print(s.key, s), this.tokenChar(93)) : (this._variance(s), this.print(s.key, s)), s.optional && this.tokenChar(63), s.definite && this.tokenChar(33), this.print(s.typeAnnotation, s), s.value && (this.space(), this.tokenChar(61), this.space(), this.print(s.value, s)), this.semicolon();
        }, r.ClassBody = function(s) {
          this.tokenChar(123), s.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(s.body, s, { indent: !0 }), this.endsWith(10) || this.newline(), this.rightBrace(s));
        }, r.ClassExpression = r.ClassDeclaration = function(s, o) {
          (f(o) || d(o)) && this._shouldPrintDecoratorsBeforeExport(o) || this.printJoin(s.decorators, s), s.declare && (this.word("declare"), this.space()), s.abstract && (this.word("abstract"), this.space()), this.word("class"), s.id && (this.space(), this.print(s.id, s)), this.print(s.typeParameters, s), s.superClass && (this.space(), this.word("extends"), this.space(), this.print(s.superClass, s), this.print(s.superTypeParameters, s)), s.implements && (this.space(), this.word("implements"), this.space(), this.printList(s.implements, s)), this.space(), this.print(s.body, s);
        }, r.ClassMethod = function(s) {
          this._classMethodHead(s), this.space(), this.print(s.body, s);
        }, r.ClassPrivateMethod = function(s) {
          this._classMethodHead(s), this.space(), this.print(s.body, s);
        }, r.ClassPrivateProperty = function(s) {
          this.printJoin(s.decorators, s), s.static && (this.word("static"), this.space()), this.print(s.key, s), this.print(s.typeAnnotation, s), s.value && (this.space(), this.tokenChar(61), this.space(), this.print(s.value, s)), this.semicolon();
        }, r.ClassProperty = function(s) {
          var o;
          this.printJoin(s.decorators, s);
          const m = (o = s.key.loc) == null || (o = o.end) == null ? void 0 : o.line;
          m && this.catchUp(m), this.tsPrintClassMemberModifiers(s), s.computed ? (this.tokenChar(91), this.print(s.key, s), this.tokenChar(93)) : (this._variance(s), this.print(s.key, s)), s.optional && this.tokenChar(63), s.definite && this.tokenChar(33), this.print(s.typeAnnotation, s), s.value && (this.space(), this.tokenChar(61), this.space(), this.print(s.value, s)), this.semicolon();
        }, r.StaticBlock = function(s) {
          this.word("static"), this.space(), this.tokenChar(123), s.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(s.body, s, { indent: !0 }), this.rightBrace(s));
        }, r._classMethodHead = function(s) {
          var o;
          this.printJoin(s.decorators, s);
          const m = (o = s.key.loc) == null || (o = o.end) == null ? void 0 : o.line;
          m && this.catchUp(m), this.tsPrintClassMemberModifiers(s), this._methodHead(s);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { isExportDefaultDeclaration: f, isExportNamedDeclaration: d } = i;
      }, "./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/expressions.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.LogicalExpression = r.BinaryExpression = r.AssignmentExpression = function(y, b) {
          const E = this.inForStatementInitCounter && y.operator === "in" && !f.needsParens(y, b);
          E && this.tokenChar(40), this.print(y.left, y), this.space(), y.operator === "in" || y.operator === "instanceof" ? this.word(y.operator) : this.token(y.operator), this.space(), this.print(y.right, y), E && this.tokenChar(41);
        }, r.AssignmentPattern = function(y) {
          this.print(y.left, y), y.left.optional && this.tokenChar(63), this.print(y.left.typeAnnotation, y), this.space(), this.tokenChar(61), this.space(), this.print(y.right, y);
        }, r.AwaitExpression = function(y) {
          this.word("await"), y.argument && (this.space(), this.printTerminatorless(y.argument, y, !1));
        }, r.BindExpression = function(y) {
          this.print(y.object, y), this.token("::"), this.print(y.callee, y);
        }, r.CallExpression = function(y) {
          this.print(y.callee, y), this.print(y.typeArguments, y), this.print(y.typeParameters, y), this.tokenChar(40), this.printList(y.arguments, y), this.rightParens(y);
        }, r.ConditionalExpression = function(y) {
          this.print(y.test, y), this.space(), this.tokenChar(63), this.space(), this.print(y.consequent, y), this.space(), this.tokenChar(58), this.space(), this.print(y.alternate, y);
        }, r.Decorator = function(y) {
          this.tokenChar(64);
          const { expression: b } = y;
          (function(E) {
            return E.type === "ParenthesizedExpression" ? !1 : !h(E.type === "CallExpression" ? E.callee : E);
          })(b) ? (this.tokenChar(40), this.print(b, y), this.tokenChar(41)) : this.print(b, y), this.newline();
        }, r.DoExpression = function(y) {
          y.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(y.body, y);
        }, r.EmptyStatement = function() {
          this.semicolon(!0);
        }, r.ExpressionStatement = function(y) {
          this.print(y.expression, y), this.semicolon();
        }, r.Import = function() {
          this.word("import");
        }, r.MemberExpression = function(y) {
          if (this.print(y.object, y), !y.computed && o(y.property))
            throw new TypeError("Got a MemberExpression for MemberExpression property");
          let b = y.computed;
          s(y.property) && typeof y.property.value == "number" && (b = !0), b ? (this.tokenChar(91), this.print(y.property, y), this.tokenChar(93)) : (this.tokenChar(46), this.print(y.property, y));
        }, r.MetaProperty = function(y) {
          this.print(y.meta, y), this.tokenChar(46), this.print(y.property, y);
        }, r.ModuleExpression = function(y) {
          this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
          const { body: b } = y;
          (b.body.length || b.directives.length) && this.newline(), this.print(b, y), this.dedent(), this.rightBrace(y);
        }, r.NewExpression = function(y, b) {
          this.word("new"), this.space(), this.print(y.callee, y), !(this.format.minified && y.arguments.length === 0 && !y.optional && !d(b, { callee: y }) && !o(b) && !m(b)) && (this.print(y.typeArguments, y), this.print(y.typeParameters, y), y.optional && this.token("?."), this.tokenChar(40), this.printList(y.arguments, y), this.rightParens(y));
        }, r.OptionalCallExpression = function(y) {
          this.print(y.callee, y), this.print(y.typeParameters, y), y.optional && this.token("?."), this.print(y.typeArguments, y), this.tokenChar(40), this.printList(y.arguments, y), this.rightParens(y);
        }, r.OptionalMemberExpression = function(y) {
          let { computed: b } = y;
          const { optional: E, property: S } = y;
          if (this.print(y.object, y), !b && o(S))
            throw new TypeError("Got a MemberExpression for MemberExpression property");
          s(S) && typeof S.value == "number" && (b = !0), E && this.token("?."), b ? (this.tokenChar(91), this.print(S, y), this.tokenChar(93)) : (E || this.tokenChar(46), this.print(S, y));
        }, r.ParenthesizedExpression = function(y) {
          this.tokenChar(40), this.print(y.expression, y), this.rightParens(y);
        }, r.PrivateName = function(y) {
          this.tokenChar(35), this.print(y.id, y);
        }, r.SequenceExpression = function(y) {
          this.printList(y.expressions, y);
        }, r.Super = function() {
          this.word("super");
        }, r.ThisExpression = function() {
          this.word("this");
        }, r.UnaryExpression = function(y) {
          const { operator: b } = y;
          b === "void" || b === "delete" || b === "typeof" || b === "throw" ? (this.word(b), this.space()) : this.token(b), this.print(y.argument, y);
        }, r.UpdateExpression = function(y) {
          y.prefix ? (this.token(y.operator), this.print(y.argument, y)) : (this.printTerminatorless(y.argument, y, !0), this.token(y.operator));
        }, r.V8IntrinsicIdentifier = function(y) {
          this.tokenChar(37), this.word(y.name);
        }, r.YieldExpression = function(y) {
          this.word("yield", !0), y.delegate ? (this.tokenChar(42), y.argument && (this.space(), this.print(y.argument, y))) : y.argument && (this.space(), this.printTerminatorless(y.argument, y, !1));
        }, r._shouldPrintDecoratorsBeforeExport = function(y) {
          return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof y.start == "number" && y.start === y.declaration.start;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js"), f = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/node/index.js");
        const { isCallExpression: d, isLiteral: s, isMemberExpression: o, isNewExpression: m } = i;
        function h(y) {
          switch (y.type) {
            case "Identifier":
              return !0;
            case "MemberExpression":
              return !y.computed && y.property.type === "Identifier" && h(y.object);
            default:
              return !1;
          }
        }
      }, "./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/flow.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.AnyTypeAnnotation = function() {
          this.word("any");
        }, r.ArrayTypeAnnotation = function(g) {
          this.print(g.elementType, g, !0), this.tokenChar(91), this.tokenChar(93);
        }, r.BooleanLiteralTypeAnnotation = function(g) {
          this.word(g.value ? "true" : "false");
        }, r.BooleanTypeAnnotation = function() {
          this.word("boolean");
        }, r.DeclareClass = function(g, P) {
          s(P) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(g);
        }, r.DeclareExportAllDeclaration = function(g) {
          this.word("declare"), this.space(), f.ExportAllDeclaration.call(this, g);
        }, r.DeclareExportDeclaration = function(g) {
          this.word("declare"), this.space(), this.word("export"), this.space(), g.default && (this.word("default"), this.space()), b.call(this, g);
        }, r.DeclareFunction = function(g, P) {
          s(P) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(g.id, g), this.print(g.id.typeAnnotation.typeAnnotation, g), g.predicate && (this.space(), this.print(g.predicate, g)), this.semicolon();
        }, r.DeclareInterface = function(g) {
          this.word("declare"), this.space(), this.InterfaceDeclaration(g);
        }, r.DeclareModule = function(g) {
          this.word("declare"), this.space(), this.word("module"), this.space(), this.print(g.id, g), this.space(), this.print(g.body, g);
        }, r.DeclareModuleExports = function(g) {
          this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(g.typeAnnotation, g);
        }, r.DeclareOpaqueType = function(g, P) {
          s(P) || (this.word("declare"), this.space()), this.OpaqueType(g);
        }, r.DeclareTypeAlias = function(g) {
          this.word("declare"), this.space(), this.TypeAlias(g);
        }, r.DeclareVariable = function(g, P) {
          s(P) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(g.id, g), this.print(g.id.typeAnnotation, g), this.semicolon();
        }, r.DeclaredPredicate = function(g) {
          this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(g.value, g), this.tokenChar(41);
        }, r.EmptyTypeAnnotation = function() {
          this.word("empty");
        }, r.EnumBooleanBody = function(g) {
          const { explicitType: P } = g;
          m(this, "boolean", P), h(this, g);
        }, r.EnumBooleanMember = function(g) {
          y(this, g);
        }, r.EnumDeclaration = function(g) {
          const { id: P, body: R } = g;
          this.word("enum"), this.space(), this.print(P, g), this.print(R, g);
        }, r.EnumDefaultedMember = function(g) {
          const { id: P } = g;
          this.print(P, g), this.tokenChar(44);
        }, r.EnumNumberBody = function(g) {
          const { explicitType: P } = g;
          m(this, "number", P), h(this, g);
        }, r.EnumNumberMember = function(g) {
          y(this, g);
        }, r.EnumStringBody = function(g) {
          const { explicitType: P } = g;
          m(this, "string", P), h(this, g);
        }, r.EnumStringMember = function(g) {
          y(this, g);
        }, r.EnumSymbolBody = function(g) {
          m(this, "symbol", !0), h(this, g);
        }, r.ExistsTypeAnnotation = function() {
          this.tokenChar(42);
        }, r.FunctionTypeAnnotation = function(g, P) {
          this.print(g.typeParameters, g), this.tokenChar(40), g.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(g.this.typeAnnotation, g), (g.params.length || g.rest) && (this.tokenChar(44), this.space())), this.printList(g.params, g), g.rest && (g.params.length && (this.tokenChar(44), this.space()), this.token("..."), this.print(g.rest, g)), this.tokenChar(41);
          const R = P == null ? void 0 : P.type;
          R != null && (R === "ObjectTypeCallProperty" || R === "ObjectTypeInternalSlot" || R === "DeclareFunction" || R === "ObjectTypeProperty" && P.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(g.returnType, g);
        }, r.FunctionTypeParam = function(g) {
          this.print(g.name, g), g.optional && this.tokenChar(63), g.name && (this.tokenChar(58), this.space()), this.print(g.typeAnnotation, g);
        }, r.IndexedAccessType = function(g) {
          this.print(g.objectType, g, !0), this.tokenChar(91), this.print(g.indexType, g), this.tokenChar(93);
        }, r.InferredPredicate = function() {
          this.tokenChar(37), this.word("checks");
        }, r.InterfaceDeclaration = function(g) {
          this.word("interface"), this.space(), this._interfaceish(g);
        }, r.GenericTypeAnnotation = r.ClassImplements = r.InterfaceExtends = function(g) {
          this.print(g.id, g), this.print(g.typeParameters, g, !0);
        }, r.InterfaceTypeAnnotation = function(g) {
          var P;
          this.word("interface"), (P = g.extends) != null && P.length && (this.space(), this.word("extends"), this.space(), this.printList(g.extends, g)), this.space(), this.print(g.body, g);
        }, r.IntersectionTypeAnnotation = function(g) {
          this.printJoin(g.types, g, { separator: E });
        }, r.MixedTypeAnnotation = function() {
          this.word("mixed");
        }, r.NullLiteralTypeAnnotation = function() {
          this.word("null");
        }, r.NullableTypeAnnotation = function(g) {
          this.tokenChar(63), this.print(g.typeAnnotation, g);
        }, Object.defineProperty(r, "NumberLiteralTypeAnnotation", { enumerable: !0, get: function() {
          return d.NumericLiteral;
        } }), r.NumberTypeAnnotation = function() {
          this.word("number");
        }, r.ObjectTypeAnnotation = function(g) {
          g.exact ? this.token("{|") : this.tokenChar(123);
          const P = [...g.properties, ...g.callProperties || [], ...g.indexers || [], ...g.internalSlots || []];
          P.length && (this.newline(), this.space(), this.printJoin(P, g, { addNewlines(R) {
            if (R && !P[0])
              return 1;
          }, indent: !0, statement: !0, iterator: () => {
            (P.length !== 1 || g.inexact) && (this.tokenChar(44), this.space());
          } }), this.space()), g.inexact && (this.indent(), this.token("..."), P.length && this.newline(), this.dedent()), g.exact ? this.token("|}") : this.tokenChar(125);
        }, r.ObjectTypeCallProperty = function(g) {
          g.static && (this.word("static"), this.space()), this.print(g.value, g);
        }, r.ObjectTypeIndexer = function(g) {
          g.static && (this.word("static"), this.space()), this._variance(g), this.tokenChar(91), g.id && (this.print(g.id, g), this.tokenChar(58), this.space()), this.print(g.key, g), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(g.value, g);
        }, r.ObjectTypeInternalSlot = function(g) {
          g.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(g.id, g), this.tokenChar(93), this.tokenChar(93), g.optional && this.tokenChar(63), g.method || (this.tokenChar(58), this.space()), this.print(g.value, g);
        }, r.ObjectTypeProperty = function(g) {
          g.proto && (this.word("proto"), this.space()), g.static && (this.word("static"), this.space()), g.kind !== "get" && g.kind !== "set" || (this.word(g.kind), this.space()), this._variance(g), this.print(g.key, g), g.optional && this.tokenChar(63), g.method || (this.tokenChar(58), this.space()), this.print(g.value, g);
        }, r.ObjectTypeSpreadProperty = function(g) {
          this.token("..."), this.print(g.argument, g);
        }, r.OpaqueType = function(g) {
          this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(g.id, g), this.print(g.typeParameters, g), g.supertype && (this.tokenChar(58), this.space(), this.print(g.supertype, g)), g.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(g.impltype, g)), this.semicolon();
        }, r.OptionalIndexedAccessType = function(g) {
          this.print(g.objectType, g), g.optional && this.token("?."), this.tokenChar(91), this.print(g.indexType, g), this.tokenChar(93);
        }, r.QualifiedTypeIdentifier = function(g) {
          this.print(g.qualification, g), this.tokenChar(46), this.print(g.id, g);
        }, Object.defineProperty(r, "StringLiteralTypeAnnotation", { enumerable: !0, get: function() {
          return d.StringLiteral;
        } }), r.StringTypeAnnotation = function() {
          this.word("string");
        }, r.SymbolTypeAnnotation = function() {
          this.word("symbol");
        }, r.ThisTypeAnnotation = function() {
          this.word("this");
        }, r.TupleTypeAnnotation = function(g) {
          this.tokenChar(91), this.printList(g.types, g), this.tokenChar(93);
        }, r.TypeAlias = function(g) {
          this.word("type"), this.space(), this.print(g.id, g), this.print(g.typeParameters, g), this.space(), this.tokenChar(61), this.space(), this.print(g.right, g), this.semicolon();
        }, r.TypeAnnotation = function(g) {
          this.tokenChar(58), this.space(), g.optional && this.tokenChar(63), this.print(g.typeAnnotation, g);
        }, r.TypeCastExpression = function(g) {
          this.tokenChar(40), this.print(g.expression, g), this.print(g.typeAnnotation, g), this.tokenChar(41);
        }, r.TypeParameter = function(g) {
          this._variance(g), this.word(g.name), g.bound && this.print(g.bound, g), g.default && (this.space(), this.tokenChar(61), this.space(), this.print(g.default, g));
        }, r.TypeParameterDeclaration = r.TypeParameterInstantiation = function(g) {
          this.tokenChar(60), this.printList(g.params, g, {}), this.tokenChar(62);
        }, r.TypeofTypeAnnotation = function(g) {
          this.word("typeof"), this.space(), this.print(g.argument, g);
        }, r.UnionTypeAnnotation = function(g) {
          this.printJoin(g.types, g, { separator: S });
        }, r.Variance = function(g) {
          g.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
        }, r.VoidTypeAnnotation = function() {
          this.word("void");
        }, r._interfaceish = function(g) {
          var P;
          if (this.print(g.id, g), this.print(g.typeParameters, g), (P = g.extends) != null && P.length && (this.space(), this.word("extends"), this.space(), this.printList(g.extends, g)), g.type === "DeclareClass") {
            var R, N;
            (R = g.mixins) != null && R.length && (this.space(), this.word("mixins"), this.space(), this.printList(g.mixins, g)), (N = g.implements) != null && N.length && (this.space(), this.word("implements"), this.space(), this.printList(g.implements, g));
          }
          this.space(), this.print(g.body, g);
        }, r._variance = function(g) {
          var P;
          const R = (P = g.variance) == null ? void 0 : P.kind;
          R != null && (R === "plus" ? this.tokenChar(43) : R === "minus" && this.tokenChar(45));
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js"), f = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/modules.js"), d = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/types.js");
        const { isDeclareExportDeclaration: s, isStatement: o } = i;
        function m(g, P, R) {
          R && (g.space(), g.word("of"), g.space(), g.word(P)), g.space();
        }
        function h(g, P) {
          const { members: R } = P;
          g.token("{"), g.indent(), g.newline();
          for (const N of R)
            g.print(N, P), g.newline();
          P.hasUnknownMembers && (g.token("..."), g.newline()), g.dedent(), g.token("}");
        }
        function y(g, P) {
          const { id: R, init: N } = P;
          g.print(R, P), g.space(), g.token("="), g.space(), g.print(N, P), g.token(",");
        }
        function b(g) {
          if (g.declaration) {
            const P = g.declaration;
            this.print(P, g), o(P) || this.semicolon();
          } else
            this.tokenChar(123), g.specifiers.length && (this.space(), this.printList(g.specifiers, g), this.space()), this.tokenChar(125), g.source && (this.space(), this.word("from"), this.space(), this.print(g.source, g)), this.semicolon();
        }
        function E() {
          this.space(), this.tokenChar(38), this.space();
        }
        function S() {
          this.space(), this.tokenChar(124), this.space();
        }
      }, "./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 });
        var i = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/template-literals.js");
        Object.keys(i).forEach(function(g) {
          g !== "default" && g !== "__esModule" && (g in r && r[g] === i[g] || Object.defineProperty(r, g, { enumerable: !0, get: function() {
            return i[g];
          } }));
        });
        var f = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/expressions.js");
        Object.keys(f).forEach(function(g) {
          g !== "default" && g !== "__esModule" && (g in r && r[g] === f[g] || Object.defineProperty(r, g, { enumerable: !0, get: function() {
            return f[g];
          } }));
        });
        var d = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/statements.js");
        Object.keys(d).forEach(function(g) {
          g !== "default" && g !== "__esModule" && (g in r && r[g] === d[g] || Object.defineProperty(r, g, { enumerable: !0, get: function() {
            return d[g];
          } }));
        });
        var s = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/classes.js");
        Object.keys(s).forEach(function(g) {
          g !== "default" && g !== "__esModule" && (g in r && r[g] === s[g] || Object.defineProperty(r, g, { enumerable: !0, get: function() {
            return s[g];
          } }));
        });
        var o = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/methods.js");
        Object.keys(o).forEach(function(g) {
          g !== "default" && g !== "__esModule" && (g in r && r[g] === o[g] || Object.defineProperty(r, g, { enumerable: !0, get: function() {
            return o[g];
          } }));
        });
        var m = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/modules.js");
        Object.keys(m).forEach(function(g) {
          g !== "default" && g !== "__esModule" && (g in r && r[g] === m[g] || Object.defineProperty(r, g, { enumerable: !0, get: function() {
            return m[g];
          } }));
        });
        var h = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/types.js");
        Object.keys(h).forEach(function(g) {
          g !== "default" && g !== "__esModule" && (g in r && r[g] === h[g] || Object.defineProperty(r, g, { enumerable: !0, get: function() {
            return h[g];
          } }));
        });
        var y = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/flow.js");
        Object.keys(y).forEach(function(g) {
          g !== "default" && g !== "__esModule" && (g in r && r[g] === y[g] || Object.defineProperty(r, g, { enumerable: !0, get: function() {
            return y[g];
          } }));
        });
        var b = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/base.js");
        Object.keys(b).forEach(function(g) {
          g !== "default" && g !== "__esModule" && (g in r && r[g] === b[g] || Object.defineProperty(r, g, { enumerable: !0, get: function() {
            return b[g];
          } }));
        });
        var E = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/jsx.js");
        Object.keys(E).forEach(function(g) {
          g !== "default" && g !== "__esModule" && (g in r && r[g] === E[g] || Object.defineProperty(r, g, { enumerable: !0, get: function() {
            return E[g];
          } }));
        });
        var S = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/typescript.js");
        Object.keys(S).forEach(function(g) {
          g !== "default" && g !== "__esModule" && (g in r && r[g] === S[g] || Object.defineProperty(r, g, { enumerable: !0, get: function() {
            return S[g];
          } }));
        });
      }, "./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/jsx.js": (u, r) => {
        function l() {
          this.space();
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.JSXAttribute = function(i) {
          this.print(i.name, i), i.value && (this.tokenChar(61), this.print(i.value, i));
        }, r.JSXClosingElement = function(i) {
          this.token("</"), this.print(i.name, i), this.tokenChar(62);
        }, r.JSXClosingFragment = function() {
          this.token("</"), this.tokenChar(62);
        }, r.JSXElement = function(i) {
          const f = i.openingElement;
          if (this.print(f, i), !f.selfClosing) {
            this.indent();
            for (const d of i.children)
              this.print(d, i);
            this.dedent(), this.print(i.closingElement, i);
          }
        }, r.JSXEmptyExpression = function() {
          this.printInnerComments();
        }, r.JSXExpressionContainer = function(i) {
          this.tokenChar(123), this.print(i.expression, i), this.tokenChar(125);
        }, r.JSXFragment = function(i) {
          this.print(i.openingFragment, i), this.indent();
          for (const f of i.children)
            this.print(f, i);
          this.dedent(), this.print(i.closingFragment, i);
        }, r.JSXIdentifier = function(i) {
          this.word(i.name);
        }, r.JSXMemberExpression = function(i) {
          this.print(i.object, i), this.tokenChar(46), this.print(i.property, i);
        }, r.JSXNamespacedName = function(i) {
          this.print(i.namespace, i), this.tokenChar(58), this.print(i.name, i);
        }, r.JSXOpeningElement = function(i) {
          this.tokenChar(60), this.print(i.name, i), this.print(i.typeParameters, i), i.attributes.length > 0 && (this.space(), this.printJoin(i.attributes, i, { separator: l })), i.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
        }, r.JSXOpeningFragment = function() {
          this.tokenChar(60), this.tokenChar(62);
        }, r.JSXSpreadAttribute = function(i) {
          this.tokenChar(123), this.token("..."), this.print(i.argument, i), this.tokenChar(125);
        }, r.JSXSpreadChild = function(i) {
          this.tokenChar(123), this.token("..."), this.print(i.expression, i), this.tokenChar(125);
        }, r.JSXText = function(i) {
          const f = this.getPossibleRaw(i);
          f !== void 0 ? this.token(f, !0) : this.token(i.value, !0);
        };
      }, "./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/methods.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.ArrowFunctionExpression = function(s, o) {
          s.async && (this.word("async", !0), this.space());
          let m;
          this.format.retainLines || s.params.length !== 1 || !f(m = s.params[0]) || function(h, y) {
            var b, E;
            return !!(h.typeParameters || h.returnType || h.predicate || y.typeAnnotation || y.optional || (b = y.leadingComments) != null && b.length || (E = y.trailingComments) != null && E.length);
          }(s, m) ? this._params(s, void 0, o) : this.print(m, s, !0), this._predicate(s, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.print(s.body, s);
        }, r.FunctionDeclaration = r.FunctionExpression = function(s, o) {
          this._functionHead(s, o), this.space(), this.print(s.body, s);
        }, r._functionHead = function(s, o) {
          s.async && (this.word("async"), this._endsWithInnerRaw = !1, this.space()), this.word("function"), s.generator && (this._endsWithInnerRaw = !1, this.tokenChar(42)), this.space(), s.id && this.print(s.id, s), this._params(s, s.id, o), s.type !== "TSDeclareFunction" && this._predicate(s);
        }, r._methodHead = function(s) {
          const o = s.kind, m = s.key;
          o !== "get" && o !== "set" || (this.word(o), this.space()), s.async && (this.word("async", !0), this.space()), o !== "method" && o !== "init" || s.generator && this.tokenChar(42), s.computed ? (this.tokenChar(91), this.print(m, s), this.tokenChar(93)) : this.print(m, s), s.optional && this.tokenChar(63), this._params(s, s.computed && s.key.type !== "StringLiteral" ? void 0 : s.key, void 0);
        }, r._param = function(s, o) {
          this.printJoin(s.decorators, s), this.print(s, o), s.optional && this.tokenChar(63), this.print(s.typeAnnotation, s);
        }, r._parameters = function(s, o) {
          const m = s.length;
          for (let h = 0; h < m; h++)
            this._param(s[h], o), h < s.length - 1 && (this.tokenChar(44), this.space());
        }, r._params = function(s, o, m) {
          this.print(s.typeParameters, s);
          const h = d.call(this, o, m);
          h && this.sourceIdentifierName(h.name, h.pos), this.tokenChar(40), this._parameters(s.params, s), this.tokenChar(41);
          const y = s.type === "ArrowFunctionExpression";
          this.print(s.returnType, s, y), this._noLineTerminator = y;
        }, r._predicate = function(s, o) {
          s.predicate && (s.returnType || this.tokenChar(58), this.space(), this.print(s.predicate, s, o));
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { isIdentifier: f } = i;
        function d(s, o) {
          let m, h = s;
          if (!h && o) {
            const g = o.type;
            g === "VariableDeclarator" ? h = o.id : g === "AssignmentExpression" || g === "AssignmentPattern" ? h = o.left : g === "ObjectProperty" || g === "ClassProperty" ? o.computed && o.key.type !== "StringLiteral" || (h = o.key) : g !== "ClassPrivateProperty" && g !== "ClassAccessorProperty" || (h = o.key);
          }
          if (h) {
            var y, b;
            if (h.type === "Identifier")
              m = { pos: (y = h.loc) == null ? void 0 : y.start, name: ((b = h.loc) == null ? void 0 : b.identifierName) || h.name };
            else if (h.type === "PrivateName") {
              var E;
              m = { pos: (E = h.loc) == null ? void 0 : E.start, name: "#" + h.id.name };
            } else if (h.type === "StringLiteral") {
              var S;
              m = { pos: (S = h.loc) == null ? void 0 : S.start, name: h.value };
            }
            return m;
          }
        }
      }, "./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/modules.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.ExportAllDeclaration = function(E) {
          var S, g;
          this.word("export"), this.space(), E.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.word("from"), this.space(), (S = E.attributes) != null && S.length || (g = E.assertions) != null && g.length ? (this.print(E.source, E, !0), this.space(), this._printAttributes(E)) : this.print(E.source, E), this.semicolon();
        }, r.ExportDefaultDeclaration = function(E) {
          b(this, E), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space();
          const S = E.declaration;
          this.print(S, E), h(S) || this.semicolon();
        }, r.ExportDefaultSpecifier = function(E) {
          this.print(E.exported, E);
        }, r.ExportNamedDeclaration = function(E) {
          if (b(this, E), this.word("export"), this.space(), E.declaration) {
            const P = E.declaration;
            this.print(P, E), h(P) || this.semicolon();
          } else {
            E.exportKind === "type" && (this.word("type"), this.space());
            const P = E.specifiers.slice(0);
            let R = !1;
            for (; ; ) {
              const N = P[0];
              if (!d(N) && !s(N))
                break;
              R = !0, this.print(P.shift(), E), P.length && (this.tokenChar(44), this.space());
            }
            var S, g;
            (P.length || !P.length && !R) && (this.tokenChar(123), P.length && (this.space(), this.printList(P, E), this.space()), this.tokenChar(125)), E.source && (this.space(), this.word("from"), this.space(), (S = E.attributes) != null && S.length || (g = E.assertions) != null && g.length ? (this.print(E.source, E, !0), this.space(), this._printAttributes(E)) : this.print(E.source, E)), this.semicolon();
          }
        }, r.ExportNamespaceSpecifier = function(E) {
          this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(E.exported, E);
        }, r.ExportSpecifier = function(E) {
          E.exportKind === "type" && (this.word("type"), this.space()), this.print(E.local, E), E.exported && E.local.name !== E.exported.name && (this.space(), this.word("as"), this.space(), this.print(E.exported, E));
        }, r.ImportAttribute = function(E) {
          this.print(E.key), this.tokenChar(58), this.space(), this.print(E.value);
        }, r.ImportDeclaration = function(E) {
          var S, g;
          this.word("import"), this.space();
          const P = E.importKind === "type" || E.importKind === "typeof";
          P ? (this.noIndentInnerCommentsHere(), this.word(E.importKind), this.space()) : E.module && (this.noIndentInnerCommentsHere(), this.word("module"), this.space());
          const R = E.specifiers.slice(0), N = !!R.length;
          for (; N; ) {
            const C = R[0];
            if (!o(C) && !m(C))
              break;
            this.print(R.shift(), E), R.length && (this.tokenChar(44), this.space());
          }
          R.length ? (this.tokenChar(123), this.space(), this.printList(R, E), this.space(), this.tokenChar(125)) : P && !N && (this.tokenChar(123), this.tokenChar(125)), (N || P) && (this.space(), this.word("from"), this.space()), (S = E.attributes) != null && S.length || (g = E.assertions) != null && g.length ? (this.print(E.source, E, !0), this.space(), this._printAttributes(E)) : this.print(E.source, E), this.semicolon();
        }, r.ImportDefaultSpecifier = function(E) {
          this.print(E.local, E);
        }, r.ImportNamespaceSpecifier = function(E) {
          this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(E.local, E);
        }, r.ImportSpecifier = function(E) {
          E.importKind !== "type" && E.importKind !== "typeof" || (this.word(E.importKind), this.space()), this.print(E.imported, E), E.local && E.local.name !== E.imported.name && (this.space(), this.word("as"), this.space(), this.print(E.local, E));
        }, r._printAttributes = function(E) {
          const { importAttributesKeyword: S } = this.format, { attributes: g, assertions: P } = E;
          !g || S || y || (y = !0, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
          const R = S === "assert" || !S && P;
          if (this.word(R ? "assert" : "with"), this.space(), !R && S !== "with")
            return void this.printList(g || P, E);
          this.tokenChar(123), this.space(), this.printList(g || P, E), this.space(), this.tokenChar(125);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { isClassDeclaration: f, isExportDefaultSpecifier: d, isExportNamespaceSpecifier: s, isImportDefaultSpecifier: o, isImportNamespaceSpecifier: m, isStatement: h } = i;
        let y = !1;
        function b(E, S) {
          f(S.declaration) && E._shouldPrintDecoratorsBeforeExport(S) && E.printJoin(S.declaration.decorators, S);
        }
      }, "./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/statements.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.BreakStatement = function(S) {
          this.word("break"), E(this, S.label, S, !0);
        }, r.CatchClause = function(S) {
          this.word("catch"), this.space(), S.param && (this.tokenChar(40), this.print(S.param, S), this.print(S.param.typeAnnotation, S), this.tokenChar(41), this.space()), this.print(S.body, S);
        }, r.ContinueStatement = function(S) {
          this.word("continue"), E(this, S.label, S, !0);
        }, r.DebuggerStatement = function() {
          this.word("debugger"), this.semicolon();
        }, r.DoWhileStatement = function(S) {
          this.word("do"), this.space(), this.print(S.body, S), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(S.test, S), this.tokenChar(41), this.semicolon();
        }, r.ForOfStatement = r.ForInStatement = void 0, r.ForStatement = function(S) {
          this.word("for"), this.space(), this.tokenChar(40), this.inForStatementInitCounter++, this.print(S.init, S), this.inForStatementInitCounter--, this.tokenChar(59), S.test && (this.space(), this.print(S.test, S)), this.tokenChar(59), S.update && (this.space(), this.print(S.update, S)), this.tokenChar(41), this.printBlock(S);
        }, r.IfStatement = function(S) {
          this.word("if"), this.space(), this.tokenChar(40), this.print(S.test, S), this.tokenChar(41), this.space();
          const g = S.alternate && s(m(S.consequent));
          g && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(S.consequent, S), g && (this.dedent(), this.newline(), this.tokenChar(125)), S.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(S.alternate, S));
        }, r.LabeledStatement = function(S) {
          this.print(S.label, S), this.tokenChar(58), this.space(), this.print(S.body, S);
        }, r.ReturnStatement = function(S) {
          this.word("return"), E(this, S.argument, S, !1);
        }, r.SwitchCase = function(S) {
          S.test ? (this.word("case"), this.space(), this.print(S.test, S), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), S.consequent.length && (this.newline(), this.printSequence(S.consequent, S, { indent: !0 }));
        }, r.SwitchStatement = function(S) {
          this.word("switch"), this.space(), this.tokenChar(40), this.print(S.discriminant, S), this.tokenChar(41), this.space(), this.tokenChar(123), this.printSequence(S.cases, S, { indent: !0, addNewlines(g, P) {
            if (!g && S.cases[S.cases.length - 1] === P)
              return -1;
          } }), this.rightBrace(S);
        }, r.ThrowStatement = function(S) {
          this.word("throw"), E(this, S.argument, S, !1);
        }, r.TryStatement = function(S) {
          this.word("try"), this.space(), this.print(S.block, S), this.space(), S.handlers ? this.print(S.handlers[0], S) : this.print(S.handler, S), S.finalizer && (this.space(), this.word("finally"), this.space(), this.print(S.finalizer, S));
        }, r.VariableDeclaration = function(S, g) {
          S.declare && (this.word("declare"), this.space());
          const { kind: P } = S;
          this.word(P, P === "using" || P === "await using"), this.space();
          let R = !1;
          if (!f(g))
            for (const N of S.declarations)
              N.init && (R = !0);
          if (this.printList(S.declarations, S, { separator: R ? function() {
            this.tokenChar(44), this.newline();
          } : void 0, indent: S.declarations.length > 1 }), f(g)) {
            if (d(g)) {
              if (g.init === S)
                return;
            } else if (g.left === S)
              return;
          }
          this.semicolon();
        }, r.VariableDeclarator = function(S) {
          this.print(S.id, S), S.definite && this.tokenChar(33), this.print(S.id.typeAnnotation, S), S.init && (this.space(), this.tokenChar(61), this.space(), this.print(S.init, S));
        }, r.WhileStatement = function(S) {
          this.word("while"), this.space(), this.tokenChar(40), this.print(S.test, S), this.tokenChar(41), this.printBlock(S);
        }, r.WithStatement = function(S) {
          this.word("with"), this.space(), this.tokenChar(40), this.print(S.object, S), this.tokenChar(41), this.printBlock(S);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { isFor: f, isForStatement: d, isIfStatement: s, isStatement: o } = i;
        function m(S) {
          const { body: g } = S;
          return o(g) === !1 ? S : m(g);
        }
        function h(S) {
          this.word("for"), this.space();
          const g = S.type === "ForOfStatement";
          g && S.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40), this.print(S.left, S), this.space(), this.word(g ? "of" : "in"), this.space(), this.print(S.right, S), this.tokenChar(41), this.printBlock(S);
        }
        const y = h;
        r.ForInStatement = y;
        const b = h;
        function E(S, g, P, R) {
          g && (S.space(), S.printTerminatorless(g, P, R)), S.semicolon();
        }
        r.ForOfStatement = b;
      }, "./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/template-literals.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.TaggedTemplateExpression = function(l) {
          this.print(l.tag, l), this.print(l.typeParameters, l), this.print(l.quasi, l);
        }, r.TemplateElement = function(l, i) {
          const f = i.quasis[0] === l, d = i.quasis[i.quasis.length - 1] === l, s = (f ? "`" : "}") + l.value.raw + (d ? "`" : "${");
          this.token(s, !0);
        }, r.TemplateLiteral = function(l) {
          const i = l.quasis;
          for (let f = 0; f < i.length; f++)
            this.print(i[f], l), f + 1 < i.length && this.print(l.expressions[f], l);
        };
      }, "./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/types.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.ArgumentPlaceholder = function() {
          this.tokenChar(63);
        }, r.ArrayPattern = r.ArrayExpression = function(m) {
          const h = m.elements, y = h.length;
          this.tokenChar(91);
          for (let b = 0; b < h.length; b++) {
            const E = h[b];
            E ? (b > 0 && this.space(), this.print(E, m), b < y - 1 && this.tokenChar(44)) : this.tokenChar(44);
          }
          this.tokenChar(93);
        }, r.BigIntLiteral = function(m) {
          const h = this.getPossibleRaw(m);
          if (!this.format.minified && h !== void 0)
            return void this.word(h);
          this.word(m.value + "n");
        }, r.BooleanLiteral = function(m) {
          this.word(m.value ? "true" : "false");
        }, r.DecimalLiteral = function(m) {
          const h = this.getPossibleRaw(m);
          if (!this.format.minified && h !== void 0)
            return void this.word(h);
          this.word(m.value + "m");
        }, r.Identifier = function(m) {
          var h;
          this.sourceIdentifierName(((h = m.loc) == null ? void 0 : h.identifierName) || m.name), this.word(m.name);
        }, r.NullLiteral = function() {
          this.word("null");
        }, r.NumericLiteral = function(m) {
          const h = this.getPossibleRaw(m), y = this.format.jsescOption, b = m.value + "";
          y.numbers ? this.number(f(m.value, y)) : h == null ? this.number(b) : this.format.minified ? this.number(h.length < b.length ? h : b) : this.number(h);
        }, r.ObjectPattern = r.ObjectExpression = function(m) {
          const h = m.properties;
          this.tokenChar(123), h.length && (this.space(), this.printList(h, m, { indent: !0, statement: !0 }), this.space()), this.sourceWithOffset("end", m.loc, -1), this.tokenChar(125);
        }, r.ObjectMethod = function(m) {
          this.printJoin(m.decorators, m), this._methodHead(m), this.space(), this.print(m.body, m);
        }, r.ObjectProperty = function(m) {
          if (this.printJoin(m.decorators, m), m.computed)
            this.tokenChar(91), this.print(m.key, m), this.tokenChar(93);
          else {
            if (d(m.value) && s(m.key) && m.key.name === m.value.left.name)
              return void this.print(m.value, m);
            if (this.print(m.key, m), m.shorthand && s(m.key) && s(m.value) && m.key.name === m.value.name)
              return;
          }
          this.tokenChar(58), this.space(), this.print(m.value, m);
        }, r.PipelineBareFunction = function(m) {
          this.print(m.callee, m);
        }, r.PipelinePrimaryTopicReference = function() {
          this.tokenChar(35);
        }, r.PipelineTopicExpression = function(m) {
          this.print(m.expression, m);
        }, r.RecordExpression = function(m) {
          const h = m.properties;
          let y, b;
          if (this.format.recordAndTupleSyntaxType === "bar")
            y = "{|", b = "|}";
          else {
            if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
              throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
            y = "#{", b = "}";
          }
          this.token(y), h.length && (this.space(), this.printList(h, m, { indent: !0, statement: !0 }), this.space()), this.token(b);
        }, r.RegExpLiteral = function(m) {
          this.word(`/${m.pattern}/${m.flags}`);
        }, r.SpreadElement = r.RestElement = function(m) {
          this.token("..."), this.print(m.argument, m);
        }, r.StringLiteral = function(m) {
          const h = this.getPossibleRaw(m);
          if (!this.format.minified && h !== void 0)
            return void this.token(h);
          const y = f(m.value, this.format.jsescOption);
          this.token(y);
        }, r.TopicReference = function() {
          const { topicToken: m } = this.format;
          if (!o.has(m)) {
            const h = JSON.stringify(m), y = Array.from(o, (b) => JSON.stringify(b));
            throw new Error(`The "topicToken" generator option must be one of ${y.join(", ")} (${h} received instead).`);
          }
          this.token(m);
        }, r.TupleExpression = function(m) {
          const h = m.elements, y = h.length;
          let b, E;
          if (this.format.recordAndTupleSyntaxType === "bar")
            b = "[|", E = "|]";
          else {
            if (this.format.recordAndTupleSyntaxType !== "hash")
              throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
            b = "#[", E = "]";
          }
          this.token(b);
          for (let S = 0; S < h.length; S++) {
            const g = h[S];
            g && (S > 0 && this.space(), this.print(g, m), S < y - 1 && this.tokenChar(44));
          }
          this.token(E);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js"), f = l("./node_modules/.pnpm/jsesc@2.5.2/node_modules/jsesc/jsesc.js");
        const { isAssignmentPattern: d, isIdentifier: s } = i, o = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
      }, "./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/typescript.js": (u, r) => {
        function l(d, s, o) {
          if (d.token("{"), s.length) {
            d.indent(), d.newline();
            for (const m of s)
              d.print(m, o), d.newline();
            d.dedent();
          }
          d.rightBrace(o);
        }
        function i(d, s, o) {
          d.printJoin(s.types, s, { separator() {
            this.space(), this.token(o), this.space();
          } });
        }
        function f(d, s) {
          s !== !0 && d.token(s);
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.TSAnyKeyword = function() {
          this.word("any");
        }, r.TSArrayType = function(d) {
          this.print(d.elementType, d, !0), this.token("[]");
        }, r.TSSatisfiesExpression = r.TSAsExpression = function(d) {
          var s;
          const { type: o, expression: m, typeAnnotation: h } = d, y = !((s = m.trailingComments) == null || !s.length);
          this.print(m, d, !0, void 0, y), this.space(), this.word(o === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(h, d);
        }, r.TSBigIntKeyword = function() {
          this.word("bigint");
        }, r.TSBooleanKeyword = function() {
          this.word("boolean");
        }, r.TSCallSignatureDeclaration = function(d) {
          this.tsPrintSignatureDeclarationBase(d), this.tokenChar(59);
        }, r.TSConditionalType = function(d) {
          this.print(d.checkType), this.space(), this.word("extends"), this.space(), this.print(d.extendsType), this.space(), this.tokenChar(63), this.space(), this.print(d.trueType), this.space(), this.tokenChar(58), this.space(), this.print(d.falseType);
        }, r.TSConstructSignatureDeclaration = function(d) {
          this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(d), this.tokenChar(59);
        }, r.TSConstructorType = function(d) {
          d.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(d);
        }, r.TSDeclareFunction = function(d, s) {
          d.declare && (this.word("declare"), this.space()), this._functionHead(d, s), this.tokenChar(59);
        }, r.TSDeclareMethod = function(d) {
          this._classMethodHead(d), this.tokenChar(59);
        }, r.TSEnumDeclaration = function(d) {
          const { declare: s, const: o, id: m, members: h } = d;
          s && (this.word("declare"), this.space()), o && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(m, d), this.space(), l(this, h, d);
        }, r.TSEnumMember = function(d) {
          const { id: s, initializer: o } = d;
          this.print(s, d), o && (this.space(), this.tokenChar(61), this.space(), this.print(o, d)), this.tokenChar(44);
        }, r.TSExportAssignment = function(d) {
          this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(d.expression, d), this.tokenChar(59);
        }, r.TSExpressionWithTypeArguments = function(d) {
          this.print(d.expression, d), this.print(d.typeParameters, d);
        }, r.TSExternalModuleReference = function(d) {
          this.token("require("), this.print(d.expression, d), this.tokenChar(41);
        }, r.TSFunctionType = function(d) {
          this.tsPrintFunctionOrConstructorType(d);
        }, r.TSImportEqualsDeclaration = function(d) {
          const { isExport: s, id: o, moduleReference: m } = d;
          s && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(o, d), this.space(), this.tokenChar(61), this.space(), this.print(m, d), this.tokenChar(59);
        }, r.TSImportType = function(d) {
          const { argument: s, qualifier: o, typeParameters: m } = d;
          this.word("import"), this.tokenChar(40), this.print(s, d), this.tokenChar(41), o && (this.tokenChar(46), this.print(o, d)), m && this.print(m, d);
        }, r.TSIndexSignature = function(d) {
          const { readonly: s, static: o } = d;
          o && (this.word("static"), this.space()), s && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(d.parameters, d), this.tokenChar(93), this.print(d.typeAnnotation, d), this.tokenChar(59);
        }, r.TSIndexedAccessType = function(d) {
          this.print(d.objectType, d, !0), this.tokenChar(91), this.print(d.indexType, d), this.tokenChar(93);
        }, r.TSInferType = function(d) {
          this.token("infer"), this.space(), this.print(d.typeParameter);
        }, r.TSInstantiationExpression = function(d) {
          this.print(d.expression, d), this.print(d.typeParameters, d);
        }, r.TSInterfaceBody = function(d) {
          this.tsPrintTypeLiteralOrInterfaceBody(d.body, d);
        }, r.TSInterfaceDeclaration = function(d) {
          const { declare: s, id: o, typeParameters: m, extends: h, body: y } = d;
          s && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(o, d), this.print(m, d), h != null && h.length && (this.space(), this.word("extends"), this.space(), this.printList(h, d)), this.space(), this.print(y, d);
        }, r.TSIntersectionType = function(d) {
          i(this, d, "&");
        }, r.TSIntrinsicKeyword = function() {
          this.word("intrinsic");
        }, r.TSLiteralType = function(d) {
          this.print(d.literal, d);
        }, r.TSMappedType = function(d) {
          const { nameType: s, optional: o, readonly: m, typeParameter: h } = d;
          this.tokenChar(123), this.space(), m && (f(this, m), this.word("readonly"), this.space()), this.tokenChar(91), this.word(h.name), this.space(), this.word("in"), this.space(), this.print(h.constraint, h), s && (this.space(), this.word("as"), this.space(), this.print(s, d)), this.tokenChar(93), o && (f(this, o), this.tokenChar(63)), this.tokenChar(58), this.space(), this.print(d.typeAnnotation, d), this.space(), this.tokenChar(125);
        }, r.TSMethodSignature = function(d) {
          const { kind: s } = d;
          s !== "set" && s !== "get" || (this.word(s), this.space()), this.tsPrintPropertyOrMethodName(d), this.tsPrintSignatureDeclarationBase(d), this.tokenChar(59);
        }, r.TSModuleBlock = function(d) {
          l(this, d.body, d);
        }, r.TSModuleDeclaration = function(d) {
          const { declare: s, id: o } = d;
          if (s && (this.word("declare"), this.space()), d.global || (this.word(o.type === "Identifier" ? "namespace" : "module"), this.space()), this.print(o, d), !d.body)
            return void this.tokenChar(59);
          let m = d.body;
          for (; m.type === "TSModuleDeclaration"; )
            this.tokenChar(46), this.print(m.id, m), m = m.body;
          this.space(), this.print(m, d);
        }, r.TSNamedTupleMember = function(d) {
          this.print(d.label, d), d.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(d.elementType, d);
        }, r.TSNamespaceExportDeclaration = function(d) {
          this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(d.id, d);
        }, r.TSNeverKeyword = function() {
          this.word("never");
        }, r.TSNonNullExpression = function(d) {
          this.print(d.expression, d), this.tokenChar(33);
        }, r.TSNullKeyword = function() {
          this.word("null");
        }, r.TSNumberKeyword = function() {
          this.word("number");
        }, r.TSObjectKeyword = function() {
          this.word("object");
        }, r.TSOptionalType = function(d) {
          this.print(d.typeAnnotation, d), this.tokenChar(63);
        }, r.TSParameterProperty = function(d) {
          d.accessibility && (this.word(d.accessibility), this.space()), d.readonly && (this.word("readonly"), this.space()), this._param(d.parameter);
        }, r.TSParenthesizedType = function(d) {
          this.tokenChar(40), this.print(d.typeAnnotation, d), this.tokenChar(41);
        }, r.TSPropertySignature = function(d) {
          const { readonly: s, initializer: o } = d;
          s && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(d), this.print(d.typeAnnotation, d), o && (this.space(), this.tokenChar(61), this.space(), this.print(o, d)), this.tokenChar(59);
        }, r.TSQualifiedName = function(d) {
          this.print(d.left, d), this.tokenChar(46), this.print(d.right, d);
        }, r.TSRestType = function(d) {
          this.token("..."), this.print(d.typeAnnotation, d);
        }, r.TSStringKeyword = function() {
          this.word("string");
        }, r.TSSymbolKeyword = function() {
          this.word("symbol");
        }, r.TSThisType = function() {
          this.word("this");
        }, r.TSTupleType = function(d) {
          this.tokenChar(91), this.printList(d.elementTypes, d), this.tokenChar(93);
        }, r.TSTypeAliasDeclaration = function(d) {
          const { declare: s, id: o, typeParameters: m, typeAnnotation: h } = d;
          s && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(o, d), this.print(m, d), this.space(), this.tokenChar(61), this.space(), this.print(h, d), this.tokenChar(59);
        }, r.TSTypeAnnotation = function(d) {
          this.tokenChar(58), this.space(), d.optional && this.tokenChar(63), this.print(d.typeAnnotation, d);
        }, r.TSTypeAssertion = function(d) {
          const { typeAnnotation: s, expression: o } = d;
          this.tokenChar(60), this.print(s, d), this.tokenChar(62), this.space(), this.print(o, d);
        }, r.TSTypeLiteral = function(d) {
          this.tsPrintTypeLiteralOrInterfaceBody(d.members, d);
        }, r.TSTypeOperator = function(d) {
          this.word(d.operator), this.space(), this.print(d.typeAnnotation, d);
        }, r.TSTypeParameter = function(d) {
          d.in && (this.word("in"), this.space()), d.out && (this.word("out"), this.space()), this.word(d.name), d.constraint && (this.space(), this.word("extends"), this.space(), this.print(d.constraint, d)), d.default && (this.space(), this.tokenChar(61), this.space(), this.print(d.default, d));
        }, r.TSTypeParameterDeclaration = r.TSTypeParameterInstantiation = function(d, s) {
          this.tokenChar(60), this.printList(d.params, d, {}), s.type === "ArrowFunctionExpression" && d.params.length === 1 && this.tokenChar(44), this.tokenChar(62);
        }, r.TSTypePredicate = function(d) {
          d.asserts && (this.word("asserts"), this.space()), this.print(d.parameterName), d.typeAnnotation && (this.space(), this.word("is"), this.space(), this.print(d.typeAnnotation.typeAnnotation));
        }, r.TSTypeQuery = function(d) {
          this.word("typeof"), this.space(), this.print(d.exprName), d.typeParameters && this.print(d.typeParameters, d);
        }, r.TSTypeReference = function(d) {
          this.print(d.typeName, d, !0), this.print(d.typeParameters, d, !0);
        }, r.TSUndefinedKeyword = function() {
          this.word("undefined");
        }, r.TSUnionType = function(d) {
          i(this, d, "|");
        }, r.TSUnknownKeyword = function() {
          this.word("unknown");
        }, r.TSVoidKeyword = function() {
          this.word("void");
        }, r.tsPrintClassMemberModifiers = function(d) {
          const s = d.type === "ClassAccessorProperty" || d.type === "ClassProperty";
          s && d.declare && (this.word("declare"), this.space()), d.accessibility && (this.word(d.accessibility), this.space()), d.static && (this.word("static"), this.space()), d.override && (this.word("override"), this.space()), d.abstract && (this.word("abstract"), this.space()), s && d.readonly && (this.word("readonly"), this.space());
        }, r.tsPrintFunctionOrConstructorType = function(d) {
          const { typeParameters: s } = d, o = d.parameters;
          this.print(s, d), this.tokenChar(40), this._parameters(o, d), this.tokenChar(41), this.space(), this.token("=>"), this.space();
          const m = d.typeAnnotation;
          this.print(m.typeAnnotation, d);
        }, r.tsPrintPropertyOrMethodName = function(d) {
          d.computed && this.tokenChar(91), this.print(d.key, d), d.computed && this.tokenChar(93), d.optional && this.tokenChar(63);
        }, r.tsPrintSignatureDeclarationBase = function(d) {
          const { typeParameters: s } = d, o = d.parameters;
          this.print(s, d), this.tokenChar(40), this._parameters(o, d), this.tokenChar(41);
          const m = d.typeAnnotation;
          this.print(m, d);
        }, r.tsPrintTypeLiteralOrInterfaceBody = function(d, s) {
          l(this, d, s);
        };
      }, "./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.CodeGenerator = void 0, r.default = function(s, o, m) {
          return new d(s, o, m).generate();
        };
        var i = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/source-map.js"), f = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/printer.js");
        class d extends f.default {
          constructor(o, m = {}, h) {
            const y = function(b, E) {
              var S;
              const g = { auxiliaryCommentBefore: E.auxiliaryCommentBefore, auxiliaryCommentAfter: E.auxiliaryCommentAfter, shouldPrintComment: E.shouldPrintComment, retainLines: E.retainLines, retainFunctionParens: E.retainFunctionParens, comments: E.comments == null || E.comments, compact: E.compact, minified: E.minified, concise: E.concise, indent: { adjustMultilineComment: !0, style: "  " }, jsescOption: Object.assign({ quotes: "double", wrap: !0, minimal: !1 }, E.jsescOption), recordAndTupleSyntaxType: (S = E.recordAndTupleSyntaxType) != null ? S : "hash", topicToken: E.topicToken, importAttributesKeyword: E.importAttributesKeyword };
              g.decoratorsBeforeExport = E.decoratorsBeforeExport, g.jsescOption.json = E.jsonCompatibleStrings, g.minified ? (g.compact = !0, g.shouldPrintComment = g.shouldPrintComment || (() => g.comments)) : g.shouldPrintComment = g.shouldPrintComment || ((C) => g.comments || C.includes("@license") || C.includes("@preserve")), g.compact === "auto" && (g.compact = typeof b == "string" && b.length > 5e5, g.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${E.filename} as it exceeds the max of 500KB.`)), g.compact && (g.indent.adjustMultilineComment = !1);
              const { auxiliaryCommentBefore: P, auxiliaryCommentAfter: R, shouldPrintComment: N } = g;
              return P && !N(P) && (g.auxiliaryCommentBefore = void 0), R && !N(R) && (g.auxiliaryCommentAfter = void 0), g;
            }(h, m);
            super(y, m.sourceMaps ? new i.default(m, h) : null), this.ast = void 0, this.ast = o;
          }
          generate() {
            return super.generate(this.ast);
          }
        }
        r.CodeGenerator = class {
          constructor(s, o, m) {
            this._generator = void 0, this._generator = new d(s, o, m);
          }
          generate() {
            return this._generator.generate();
          }
        };
      }, "./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/node/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.needsParens = function(N, C, I) {
          return C ? y(C) && C.callee === N && P(N) ? !0 : g(E, N, C, I) : !1;
        }, r.needsWhitespace = R, r.needsWhitespaceAfter = function(N, C) {
          return R(N, C, 2);
        }, r.needsWhitespaceBefore = function(N, C) {
          return R(N, C, 1);
        };
        var i = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/node/whitespace.js"), f = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/node/parentheses.js"), d = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { FLIPPED_ALIAS_KEYS: s, isCallExpression: o, isExpressionStatement: m, isMemberExpression: h, isNewExpression: y } = d;
        function b(N) {
          const C = {};
          function I(D, j) {
            const F = C[D];
            C[D] = F ? function(_, T, v) {
              const w = F(_, T, v);
              return w ?? j(_, T, v);
            } : j;
          }
          for (const D of Object.keys(N)) {
            const j = s[D];
            if (j)
              for (const F of j)
                I(F, N[D]);
            else
              I(D, N[D]);
          }
          return C;
        }
        const E = b(f), S = b(i.nodes);
        function g(N, C, I, D) {
          const j = N[C.type];
          return j ? j(C, I, D) : null;
        }
        function P(N) {
          return !!o(N) || h(N) && P(N.object);
        }
        function R(N, C, I) {
          if (!N)
            return !1;
          m(N) && (N = N.expression);
          const D = g(S, N, C);
          return typeof D == "number" && (D & I) != 0;
        }
      }, "./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/node/parentheses.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.ArrowFunctionExpression = function(be, _e) {
          return R(_e) || Z(be, _e);
        }, r.AssignmentExpression = function(be, _e) {
          return !!M(be.left) || Z(be, _e);
        }, r.Binary = function(be, _e) {
          if (be.operator === "**" && h(_e, { operator: "**" }))
            return _e.left === be;
          if (Me(be, _e) || me(be, _e) || ae(_e) || o(_e))
            return !0;
          if (m(_e)) {
            const Ie = _e.operator, We = Ee[Ie], tt = be.operator, Ye = Ee[tt];
            if (We === Ye && _e.right === be && !O(_e) || We > Ye)
              return !0;
          }
        }, r.BinaryExpression = function(be, _e) {
          return be.operator === "in" && (ue(_e) || I(_e));
        }, r.ClassExpression = function(be, _e, Ie) {
          return pe(Ie, 5);
        }, r.ConditionalExpression = Z, r.DoExpression = function(be, _e, Ie) {
          return !be.async && pe(Ie, 1);
        }, r.FunctionExpression = function(be, _e, Ie) {
          return pe(Ie, 5);
        }, r.FunctionTypeAnnotation = function(be, _e, Ie) {
          if (!(Ie.length < 3))
            return le(_e) || w(_e) || f(_e) || re(_e) && d(Ie[Ie.length - 3]);
        }, r.Identifier = function(be, _e, Ie) {
          var We;
          return (We = be.extra) != null && We.parenthesized && s(_e, { left: be }) && (_(_e.right) || S(_e.right)) && _e.right.id == null ? !0 : be.name === "let" ? pe(Ie, G(_e, { object: be, computed: !0 }) || k(_e, { object: be, computed: !0, optional: !1 }) ? 57 : 32) : be.name === "async" && j(_e) && be === _e.left;
        }, r.LogicalExpression = function(be, _e) {
          if (Ae(_e))
            return !0;
          switch (be.operator) {
            case "||":
              return !!O(_e) && (_e.operator === "??" || _e.operator === "&&");
            case "&&":
              return O(_e, { operator: "??" });
            case "??":
              return O(_e) && _e.operator !== "??";
          }
        }, r.NullableTypeAnnotation = function(be, _e) {
          return f(_e);
        }, r.ObjectExpression = function(be, _e, Ie) {
          return pe(Ie, 3);
        }, r.OptionalIndexedAccessType = function(be, _e) {
          return v(_e, { objectType: be });
        }, r.OptionalCallExpression = r.OptionalMemberExpression = function(be, _e) {
          return b(_e, { callee: be }) || G(_e, { object: be });
        }, r.SequenceExpression = function(be, _e) {
          return !(F(_e) || oe(_e) || K(_e) || T(_e) && _e.test === be || ie(_e) && _e.test === be || D(_e) && _e.right === be || z(_e) && _e.discriminant === be || C(_e) && _e.expression === be);
        }, r.TSTypeAssertion = r.TSSatisfiesExpression = r.TSAsExpression = function() {
          return !0;
        }, r.TSInferType = function(be, _e) {
          return q(_e) || X(_e);
        }, r.TSInstantiationExpression = function(be, _e) {
          return (b(_e) || B(_e) || W(_e) || Y(_e)) && !!_e.typeParameters;
        }, r.TSIntersectionType = r.TSUnionType = function(be, _e) {
          return q(_e) || X(_e) || H(_e) || ve(_e) || ne(_e);
        }, r.UnaryLike = se, r.IntersectionTypeAnnotation = r.UnionTypeAnnotation = function(be, _e) {
          return f(_e) || U(_e) || w(_e) || le(_e);
        }, r.UpdateExpression = function(be, _e) {
          return me(be, _e) || Me(be, _e);
        }, r.AwaitExpression = r.YieldExpression = function(be, _e) {
          return m(_e) || ae(_e) || me(be, _e) || o(_e) && we(be) || P(_e) && be === _e.test || Me(be, _e);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { isArrayTypeAnnotation: f, isArrowFunctionExpression: d, isAssignmentExpression: s, isAwaitExpression: o, isBinary: m, isBinaryExpression: h, isUpdateExpression: y, isCallExpression: b, isClass: E, isClassExpression: S, isConditional: g, isConditionalExpression: P, isExportDeclaration: R, isExportDefaultDeclaration: N, isExpressionStatement: C, isFor: I, isForInStatement: D, isForOfStatement: j, isForStatement: F, isFunctionExpression: _, isIfStatement: T, isIndexedAccessType: v, isIntersectionTypeAnnotation: w, isLogicalExpression: O, isMemberExpression: G, isNewExpression: W, isNullableTypeAnnotation: U, isObjectPattern: M, isOptionalCallExpression: B, isOptionalMemberExpression: k, isReturnStatement: K, isSequenceExpression: te, isSwitchStatement: z, isTSArrayType: q, isTSAsExpression: $, isTSInstantiationExpression: Y, isTSIntersectionType: H, isTSNonNullExpression: Q, isTSOptionalType: X, isTSRestType: ne, isTSTypeAssertion: ye, isTSUnionType: ve, isTaggedTemplateExpression: de, isThrowStatement: oe, isTypeAnnotation: re, isUnaryLike: ae, isUnionTypeAnnotation: le, isVariableDeclarator: ue, isWhileStatement: ie, isYieldExpression: we, isTSSatisfiesExpression: De } = i, Ee = { "||": 0, "??": 0, "|>": 0, "&&": 1, "|": 2, "^": 3, "&": 4, "==": 5, "===": 5, "!=": 5, "!==": 5, "<": 6, ">": 6, "<=": 6, ">=": 6, in: 6, instanceof: 6, ">>": 7, "<<": 7, ">>>": 7, "+": 8, "-": 8, "*": 9, "/": 9, "%": 9, "**": 10 };
        function Ae(be) {
          return $(be) || De(be) || ye(be);
        }
        const Me = (be, _e) => E(_e, { superClass: be }), me = (be, _e) => (G(_e) || k(_e)) && _e.object === be || (b(_e) || B(_e) || W(_e)) && _e.callee === be || de(_e) && _e.tag === be || Q(_e);
        function se(be, _e) {
          return me(be, _e) || h(_e, { operator: "**", left: be }) || Me(be, _e);
        }
        function Z(be, _e) {
          return !!(ae(_e) || m(_e) || P(_e, { test: be }) || o(_e) || Ae(_e)) || se(be, _e);
        }
        function pe(be, _e) {
          const Ie = 1 & _e, We = 2 & _e, tt = 4 & _e, Ye = 8 & _e, ht = 16 & _e, ct = 32 & _e;
          let st = be.length - 1;
          if (st <= 0)
            return;
          let Xe = be[st];
          st--;
          let Ke = be[st];
          for (; st >= 0; ) {
            if (Ie && C(Ke, { expression: Xe }) || tt && N(Ke, { declaration: Xe }) || We && d(Ke, { body: Xe }) || Ye && F(Ke, { init: Xe }) || ht && D(Ke, { left: Xe }) || ct && j(Ke, { left: Xe }))
              return !0;
            if (!(st > 0 && (me(Xe, Ke) && !W(Ke) || te(Ke) && Ke.expressions[0] === Xe || y(Ke) && !Ke.prefix || g(Ke, { test: Xe }) || m(Ke, { left: Xe }) || s(Ke, { left: Xe }))))
              return !1;
            Xe = Ke, st--, Ke = be[st];
          }
          return !1;
        }
      }, "./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/node/whitespace.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.nodes = void 0;
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { FLIPPED_ALIAS_KEYS: f, isArrayExpression: d, isAssignmentExpression: s, isBinary: o, isBlockStatement: m, isCallExpression: h, isFunction: y, isIdentifier: b, isLiteral: E, isMemberExpression: S, isObjectExpression: g, isOptionalCallExpression: P, isOptionalMemberExpression: R, isStringLiteral: N } = i;
        function C(_, T) {
          return _ && (S(_) || R(_) ? (C(_.object, T), _.computed && C(_.property, T)) : o(_) || s(_) ? (C(_.left, T), C(_.right, T)) : h(_) || P(_) ? (T.hasCall = !0, C(_.callee, T)) : y(_) ? T.hasFunction = !0 : b(_) && (T.hasHelper = T.hasHelper || _.callee && D(_.callee))), T;
        }
        function I(_) {
          return C(_, { hasCall: !1, hasFunction: !1, hasHelper: !1 });
        }
        function D(_) {
          return !!_ && (S(_) ? D(_.object) || D(_.property) : b(_) ? _.name === "require" || _.name.charCodeAt(0) === 95 : h(_) ? D(_.callee) : !(!o(_) && !s(_)) && (b(_.left) && D(_.left) || D(_.right)));
        }
        function j(_) {
          return E(_) || g(_) || d(_) || b(_) || S(_);
        }
        const F = { AssignmentExpression(_) {
          const T = I(_.right);
          if (T.hasCall && T.hasHelper || T.hasFunction)
            return T.hasFunction ? 3 : 2;
        }, SwitchCase: (_, T) => (_.consequent.length || T.cases[0] === _ ? 1 : 0) | (_.consequent.length || T.cases[T.cases.length - 1] !== _ ? 0 : 2), LogicalExpression(_) {
          if (y(_.left) || y(_.right))
            return 2;
        }, Literal(_) {
          if (N(_) && _.value === "use strict")
            return 2;
        }, CallExpression(_) {
          if (y(_.callee) || D(_))
            return 3;
        }, OptionalCallExpression(_) {
          if (y(_.callee))
            return 3;
        }, VariableDeclaration(_) {
          for (let T = 0; T < _.declarations.length; T++) {
            const v = _.declarations[T];
            let w = D(v.id) && !j(v.init);
            if (!w && v.init) {
              const O = I(v.init);
              w = D(v.init) && O.hasCall || O.hasFunction;
            }
            if (w)
              return 3;
          }
        }, IfStatement(_) {
          if (m(_.consequent))
            return 3;
        } };
        r.nodes = F, F.ObjectProperty = F.ObjectTypeProperty = F.ObjectMethod = function(_, T) {
          if (T.properties[0] === _)
            return 1;
        }, F.ObjectTypeCallProperty = function(_, T) {
          var v;
          if (T.callProperties[0] === _ && ((v = T.properties) == null || !v.length))
            return 1;
        }, F.ObjectTypeIndexer = function(_, T) {
          var v, w;
          if (!(T.indexers[0] !== _ || (v = T.properties) != null && v.length || (w = T.callProperties) != null && w.length))
            return 1;
        }, F.ObjectTypeInternalSlot = function(_, T) {
          var v, w, O;
          if (!(T.internalSlots[0] !== _ || (v = T.properties) != null && v.length || (w = T.callProperties) != null && w.length || (O = T.indexers) != null && O.length))
            return 1;
        }, [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([_, T]) {
          [_].concat(f[_] || []).forEach(function(v) {
            const w = T ? 3 : 0;
            F[v] = () => w;
          });
        });
      }, "./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/printer.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/buffer.js"), f = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/node/index.js"), d = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js"), s = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/generators/index.js");
        const { isFunction: o, isStatement: m, isClassBody: h, isTSInterfaceBody: y, isTSEnumDeclaration: b } = d, E = /e/i, S = /\.0+$/, g = /^0[box]/, P = /^\s*[@#]__PURE__\s*$/, R = /[\n\r\u2028\u2029]/, N = /\*\//, { needsParens: C } = f;
        class I {
          constructor(_, T) {
            this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._indentChar = 0, this._indentRepeat = 0, this._insideAux = !1, this._parenPushNewlineState = null, this._noLineTerminator = !1, this._printAuxAfterOnNextUserNode = !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = !1, this._endsWithWord = !1, this._lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.format = _, this._buf = new i.default(T), this._indentChar = _.indent.style.charCodeAt(0), this._indentRepeat = _.indent.style.length, this._inputMap = T == null ? void 0 : T._inputMap;
          }
          generate(_) {
            return this.print(_), this._maybeAddAuxComment(), this._buf.get();
          }
          indent() {
            this.format.compact || this.format.concise || this._indent++;
          }
          dedent() {
            this.format.compact || this.format.concise || this._indent--;
          }
          semicolon(_ = !1) {
            this._maybeAddAuxComment(), _ ? this._appendChar(59) : this._queue(59), this._noLineTerminator = !1;
          }
          rightBrace(_) {
            this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", _.loc, -1), this.tokenChar(125);
          }
          rightParens(_) {
            this.sourceWithOffset("end", _.loc, -1), this.tokenChar(41);
          }
          space(_ = !1) {
            if (!this.format.compact) {
              if (_)
                this._space();
              else if (this._buf.hasContent()) {
                const T = this.getLastChar();
                T !== 32 && T !== 10 && this._space();
              }
            }
          }
          word(_, T = !1) {
            this._maybePrintInnerComments(), (this._endsWithWord || _.charCodeAt(0) === 47 && this.endsWith(47)) && this._space(), this._maybeAddAuxComment(), this._append(_, !1), this._endsWithWord = !0, this._noLineTerminator = T;
          }
          number(_) {
            this.word(_), this._endsWithInteger = Number.isInteger(+_) && !g.test(_) && !E.test(_) && !S.test(_) && _.charCodeAt(_.length - 1) !== 46;
          }
          token(_, T = !1) {
            this._maybePrintInnerComments();
            const v = this.getLastChar(), w = _.charCodeAt(0);
            (v === 33 && (_ === "--" || w === 61) || w === 43 && v === 43 || w === 45 && v === 45 || w === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._append(_, T), this._noLineTerminator = !1;
          }
          tokenChar(_) {
            this._maybePrintInnerComments();
            const T = this.getLastChar();
            (_ === 43 && T === 43 || _ === 45 && T === 45 || _ === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._appendChar(_), this._noLineTerminator = !1;
          }
          newline(_ = 1, T) {
            if (!(_ <= 0)) {
              if (!T) {
                if (this.format.retainLines || this.format.compact)
                  return;
                if (this.format.concise)
                  return void this.space();
              }
              _ > 2 && (_ = 2), _ -= this._buf.getNewlineCount();
              for (let v = 0; v < _; v++)
                this._newline();
            }
          }
          endsWith(_) {
            return this.getLastChar() === _;
          }
          getLastChar() {
            return this._buf.getLastChar();
          }
          endsWithCharAndNewline() {
            return this._buf.endsWithCharAndNewline();
          }
          removeTrailingNewline() {
            this._buf.removeTrailingNewline();
          }
          exactSource(_, T) {
            _ ? (this._catchUp("start", _), this._buf.exactSource(_, T)) : T();
          }
          source(_, T) {
            T && (this._catchUp(_, T), this._buf.source(_, T));
          }
          sourceWithOffset(_, T, v) {
            T && (this._catchUp(_, T), this._buf.sourceWithOffset(_, T, v));
          }
          withSource(_, T, v) {
            T ? (this._catchUp(_, T), this._buf.withSource(_, T, v)) : v();
          }
          sourceIdentifierName(_, T) {
            if (!this._buf._canMarkIdName)
              return;
            const v = this._buf._sourcePosition;
            v.identifierNamePos = T, v.identifierName = _;
          }
          _space() {
            this._queue(32);
          }
          _newline() {
            this._queue(10);
          }
          _append(_, T) {
            this._maybeAddParen(_), this._maybeIndent(_.charCodeAt(0)), this._buf.append(_, T), this._endsWithWord = !1, this._endsWithInteger = !1;
          }
          _appendChar(_) {
            this._maybeAddParenChar(_), this._maybeIndent(_), this._buf.appendChar(_), this._endsWithWord = !1, this._endsWithInteger = !1;
          }
          _queue(_) {
            this._maybeAddParenChar(_), this._maybeIndent(_), this._buf.queue(_), this._endsWithWord = !1, this._endsWithInteger = !1;
          }
          _maybeIndent(_) {
            this._indent && _ !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._indentChar, this._getIndent());
          }
          _shouldIndent(_) {
            if (this._indent && _ !== 10 && this.endsWith(10))
              return !0;
          }
          _maybeAddParenChar(_) {
            const T = this._parenPushNewlineState;
            T && _ !== 32 && (_ === 10 ? (this.tokenChar(40), this.indent(), T.printed = !0) : this._parenPushNewlineState = null);
          }
          _maybeAddParen(_) {
            const T = this._parenPushNewlineState;
            if (!T)
              return;
            const v = _.length;
            let w;
            for (w = 0; w < v && _.charCodeAt(w) === 32; w++)
              ;
            if (w === v)
              return;
            const O = _.charCodeAt(w);
            if (O !== 10) {
              if (O !== 47 || w + 1 === v)
                return void (this._parenPushNewlineState = null);
              const G = _.charCodeAt(w + 1);
              if (G === 42) {
                if (P.test(_.slice(w + 2, v - 2)))
                  return;
              } else if (G !== 47)
                return void (this._parenPushNewlineState = null);
            }
            this.tokenChar(40), this.indent(), T.printed = !0;
          }
          catchUp(_) {
            if (!this.format.retainLines)
              return;
            const T = _ - this._buf.getCurrentLine();
            for (let v = 0; v < T; v++)
              this._newline();
          }
          _catchUp(_, T) {
            var v;
            if (!this.format.retainLines)
              return;
            const w = T == null || (v = T[_]) == null ? void 0 : v.line;
            if (w != null) {
              const O = w - this._buf.getCurrentLine();
              for (let G = 0; G < O; G++)
                this._newline();
            }
          }
          _getIndent() {
            return this._indentRepeat * this._indent;
          }
          printTerminatorless(_, T, v) {
            if (v)
              this._noLineTerminator = !0, this.print(_, T);
            else {
              const w = { printed: !1 };
              this._parenPushNewlineState = w, this.print(_, T), w.printed && (this.dedent(), this.newline(), this.tokenChar(41));
            }
          }
          print(_, T, v, w, O) {
            var G;
            if (!_)
              return;
            this._endsWithInnerRaw = !1;
            const W = _.type, U = this.format, M = U.concise;
            _._compact && (U.concise = !0);
            const B = this[W];
            if (B === void 0)
              throw new ReferenceError(`unknown node of type ${JSON.stringify(W)} with constructor ${JSON.stringify(_.constructor.name)}`);
            this._printStack.push(_);
            const k = this._insideAux;
            this._insideAux = _.loc == null, this._maybeAddAuxComment(this._insideAux && !k);
            const K = O || U.retainFunctionParens && W === "FunctionExpression" && ((G = _.extra) == null ? void 0 : G.parenthesized) || C(_, T, this._printStack);
            K && (this.tokenChar(40), this._endsWithInnerRaw = !1), this._lastCommentLine = 0, this._printLeadingComments(_, T);
            const te = W === "Program" || W === "File" ? null : _.loc;
            this.exactSource(te, B.bind(this, _, T)), K ? (this._printTrailingComments(_, T), this.tokenChar(41), this._noLineTerminator = v) : v && !this._noLineTerminator ? (this._noLineTerminator = !0, this._printTrailingComments(_, T)) : this._printTrailingComments(_, T, w), this._printStack.pop(), U.concise = M, this._insideAux = k, this._endsWithInnerRaw = !1;
          }
          _maybeAddAuxComment(_) {
            _ && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
          }
          _printAuxBeforeComment() {
            if (this._printAuxAfterOnNextUserNode)
              return;
            this._printAuxAfterOnNextUserNode = !0;
            const _ = this.format.auxiliaryCommentBefore;
            _ && this._printComment({ type: "CommentBlock", value: _ }, 0);
          }
          _printAuxAfterComment() {
            if (!this._printAuxAfterOnNextUserNode)
              return;
            this._printAuxAfterOnNextUserNode = !1;
            const _ = this.format.auxiliaryCommentAfter;
            _ && this._printComment({ type: "CommentBlock", value: _ }, 0);
          }
          getPossibleRaw(_) {
            const T = _.extra;
            if ((T == null ? void 0 : T.raw) != null && T.rawValue != null && _.value === T.rawValue)
              return T.raw;
          }
          printJoin(_, T, v = {}) {
            if (_ == null || !_.length)
              return;
            let { indent: w } = v;
            if (w == null && this.format.retainLines) {
              var O;
              const B = (O = _[0].loc) == null ? void 0 : O.start.line;
              B != null && B !== this._buf.getCurrentLine() && (w = !0);
            }
            w && this.indent();
            const G = { addNewlines: v.addNewlines, nextNodeStartLine: 0 }, W = v.separator ? v.separator.bind(this) : null, U = _.length;
            for (let B = 0; B < U; B++) {
              const k = _[B];
              if (k && (v.statement && this._printNewline(B === 0, G), this.print(k, T, void 0, v.trailingCommentsLineOffset || 0), v.iterator == null || v.iterator(k, B), B < U - 1 && (W == null || W()), v.statement))
                if (B + 1 === U)
                  this.newline(1);
                else {
                  var M;
                  const K = _[B + 1];
                  G.nextNodeStartLine = ((M = K.loc) == null ? void 0 : M.start.line) || 0, this._printNewline(!0, G);
                }
            }
            w && this.dedent();
          }
          printAndIndentOnComments(_, T) {
            const v = _.leadingComments && _.leadingComments.length > 0;
            v && this.indent(), this.print(_, T), v && this.dedent();
          }
          printBlock(_) {
            const T = _.body;
            T.type !== "EmptyStatement" && this.space(), this.print(T, _);
          }
          _printTrailingComments(_, T, v) {
            const { innerComments: w, trailingComments: O } = _;
            w != null && w.length && this._printComments(2, w, _, T, v), O != null && O.length && this._printComments(2, O, _, T, v);
          }
          _printLeadingComments(_, T) {
            const v = _.leadingComments;
            v != null && v.length && this._printComments(0, v, _, T);
          }
          _maybePrintInnerComments() {
            this._endsWithInnerRaw && this.printInnerComments(), this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
          }
          printInnerComments() {
            const _ = this._printStack[this._printStack.length - 1], T = _.innerComments;
            if (T == null || !T.length)
              return;
            const v = this.endsWith(32), w = this._indentInnerComments, O = this._printedComments.size;
            w && this.indent(), this._printComments(1, T, _), v && O !== this._printedComments.size && this.space(), w && this.dedent();
          }
          noIndentInnerCommentsHere() {
            this._indentInnerComments = !1;
          }
          printSequence(_, T, v = {}) {
            v.statement = !0, v.indent != null || (v.indent = !1), this.printJoin(_, T, v);
          }
          printList(_, T, v = {}) {
            v.separator == null && (v.separator = j), this.printJoin(_, T, v);
          }
          _printNewline(_, T) {
            const v = this.format;
            if (v.retainLines || v.compact)
              return;
            if (v.concise)
              return void this.space();
            if (!_)
              return;
            const w = T.nextNodeStartLine, O = this._lastCommentLine;
            if (w > 0 && O > 0) {
              const G = w - O;
              if (G >= 0)
                return void this.newline(G || 1);
            }
            this._buf.hasContent() && this.newline(1);
          }
          _shouldPrintComment(_) {
            return _.ignore || this._printedComments.has(_) ? 0 : this._noLineTerminator && (R.test(_.value) || N.test(_.value)) ? 2 : (this._printedComments.add(_), this.format.shouldPrintComment(_.value) ? 1 : 0);
          }
          _printComment(_, T) {
            const v = this._noLineTerminator, w = _.type === "CommentBlock", O = w && T !== 1 && !this._noLineTerminator;
            O && this._buf.hasContent() && T !== 2 && this.newline(1);
            const G = this.getLastChar();
            let W;
            if (G !== 91 && G !== 123 && this.space(), w) {
              if (W = `/*${_.value}*/`, this.format.indent.adjustMultilineComment) {
                var U;
                const M = (U = _.loc) == null ? void 0 : U.start.column;
                if (M) {
                  const k = new RegExp("\\n\\s{1," + M + "}", "g");
                  W = W.replace(k, `
`);
                }
                let B = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
                (this._shouldIndent(47) || this.format.retainLines) && (B += this._getIndent()), W = W.replace(/\n(?!$)/g, `
${" ".repeat(B)}`);
              }
            } else
              W = v ? `/*${_.value}*/` : `//${_.value}`;
            this.endsWith(47) && this._space(), this.source("start", _.loc), this._append(W, w), w || v || this.newline(1, !0), O && T !== 3 && this.newline(1);
          }
          _printComments(_, T, v, w, O = 0) {
            const G = v.loc, W = T.length;
            let U = !!G;
            const M = U ? G.start.line : 0, B = U ? G.end.line : 0;
            let k = 0, K = 0;
            const te = this._noLineTerminator ? function() {
            } : this.newline.bind(this);
            for (let z = 0; z < W; z++) {
              const q = T[z], $ = this._shouldPrintComment(q);
              if ($ === 2) {
                U = !1;
                break;
              }
              if (U && q.loc && $ === 1) {
                const Y = q.loc.start.line, H = q.loc.end.line;
                if (_ === 0) {
                  let Q = 0;
                  z === 0 ? !this._buf.hasContent() || q.type !== "CommentLine" && Y == H || (Q = K = 1) : Q = Y - k, k = H, te(Q), this._printComment(q, 1), z + 1 === W && (te(Math.max(M - k, K)), k = M);
                } else if (_ === 1) {
                  const Q = Y - (z === 0 ? M : k);
                  k = H, te(Q), this._printComment(q, 1), z + 1 === W && (te(Math.min(1, B - k)), k = B);
                } else {
                  const Q = Y - (z === 0 ? B - O : k);
                  k = H, te(Q), this._printComment(q, 1);
                }
              } else {
                if (U = !1, $ !== 1)
                  continue;
                if (W === 1) {
                  const Y = q.loc ? q.loc.start.line === q.loc.end.line : !R.test(q.value), H = Y && !m(v) && !h(w) && !y(w) && !b(w);
                  _ === 0 ? this._printComment(q, H && v.type !== "ObjectExpression" || Y && o(w, { body: v }) ? 1 : 0) : H && _ === 2 ? this._printComment(q, 1) : this._printComment(q, 0);
                } else
                  _ !== 1 || v.type === "ObjectExpression" && v.properties.length > 1 || v.type === "ClassBody" || v.type === "TSInterfaceBody" ? this._printComment(q, 0) : this._printComment(q, z === 0 ? 2 : z === W - 1 ? 3 : 0);
              }
            }
            _ === 2 && U && k && (this._lastCommentLine = k);
          }
        }
        Object.assign(I.prototype, s), I.prototype.Noop = function() {
        };
        var D = I;
        function j() {
          this.tokenChar(44), this.space();
        }
        r.default = D;
      }, "./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/source-map.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@jridgewell+gen-mapping@0.3.3/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"), f = l("./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.19/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js");
        r.default = class {
          constructor(d, s) {
            var o;
            this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn = 0, this._inputMap = void 0;
            const m = this._map = new i.GenMapping({ sourceRoot: d.sourceRoot });
            if (this._sourceFileName = (o = d.sourceFileName) == null ? void 0 : o.replace(/\\/g, "/"), this._rawMappings = void 0, d.inputSourceMap) {
              this._inputMap = new f.TraceMap(d.inputSourceMap);
              const y = this._inputMap.resolvedSources;
              if (y.length)
                for (let b = 0; b < y.length; b++) {
                  var h;
                  (0, i.setSourceContent)(m, y[b], (h = this._inputMap.sourcesContent) == null ? void 0 : h[b]);
                }
            }
            if (typeof s != "string" || d.inputSourceMap) {
              if (typeof s == "object")
                for (const y of Object.keys(s))
                  (0, i.setSourceContent)(m, y.replace(/\\/g, "/"), s[y]);
            } else
              (0, i.setSourceContent)(m, this._sourceFileName, s);
          }
          get() {
            return (0, i.toEncodedMap)(this._map);
          }
          getDecoded() {
            return (0, i.toDecodedMap)(this._map);
          }
          getRawMappings() {
            return this._rawMappings || (this._rawMappings = (0, i.allMappings)(this._map));
          }
          mark(d, s, o, m, h, y) {
            var b;
            let E;
            if (this._rawMappings = void 0, s != null)
              if (this._inputMap) {
                if (E = (0, f.originalPositionFor)(this._inputMap, { line: s, column: o }), !E.name && h) {
                  const S = (0, f.originalPositionFor)(this._inputMap, h);
                  S.name && (m = S.name);
                }
              } else
                E = { source: (y == null ? void 0 : y.replace(/\\/g, "/")) || this._sourceFileName, line: s, column: o };
            (0, i.maybeAddMapping)(this._map, { name: m, generated: d, source: (b = E) == null ? void 0 : b.source, original: E });
          }
        };
      }, "./node_modules/.pnpm/@babel+helper-annotate-as-pure@7.22.5/node_modules/@babel/helper-annotate-as-pure/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(o) {
          const m = o.node || o;
          s(m) || f(m, "leading", d);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { addComment: f } = i, d = "#__PURE__", s = ({ leadingComments: o }) => !!o && o.some((m) => /[@#]__PURE__/.test(m.value));
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.buildDecoratedClass = function(y, b, E, S) {
          const { node: g, scope: P } = b, R = P.generateUidIdentifier("initialize"), N = g.id && b.isDeclaration(), C = b.isInStrictMode(), { superClass: I } = g;
          g.type = "ClassDeclaration", g.id || (g.id = i.types.cloneNode(y));
          let D;
          I && (D = P.generateUidIdentifierBasedOnNode(g.superClass, "super"), g.superClass = D);
          const j = m(g), F = i.types.arrayExpression(E.filter((w) => !w.node.abstract && w.node.type !== "TSIndexSignature").map((w) => function(O, G, W, U) {
            const M = U.isClassMethod();
            if (U.isPrivate())
              throw U.buildCodeFrameError(`Private ${M ? "methods" : "fields"} in decorated classes are not supported yet.`);
            if (U.node.type === "ClassAccessorProperty")
              throw U.buildCodeFrameError('Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');
            if (U.node.type === "StaticBlock")
              throw U.buildCodeFrameError('Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');
            const { node: B, scope: k } = U;
            U.isTSDeclareMethod() || new f.default({ methodPath: U, objectRef: G, superRef: W, file: O, refToPreserve: G }).replace();
            const K = [o("kind", i.types.stringLiteral(i.types.isClassMethod(B) ? B.kind : "field")), o("decorators", m(B)), o("static", B.static && i.types.booleanLiteral(!0)), o("key", h(B))].filter(Boolean);
            if (i.types.isClassMethod(B)) {
              const q = B.computed ? null : B.key, $ = i.types.toExpression(B);
              K.push(o("value", (0, d.default)({ node: $, id: q, scope: k }) || $));
            } else
              i.types.isClassProperty(B) && B.value ? K.push((te = "value", z = i.template.statements.ast`return ${B.value}`, i.types.objectMethod("method", i.types.identifier(te), [], i.types.blockStatement(z)))) : K.push(o("value", k.buildUndefinedNode()));
            var te, z;
            return U.remove(), i.types.objectExpression(K);
          }(S, g.id, D, w))), _ = i.template.expression.ast`
    ${function(w) {
            return w.addHelper("decorate");
          }(S)}(
      ${j || i.types.nullLiteral()},
      function (${R}, ${I ? i.types.cloneNode(D) : null}) {
        ${g}
        return { F: ${i.types.cloneNode(g.id)}, d: ${F} };
      },
      ${I}
    )
  `;
          C || _.arguments[1].body.directives.push(i.types.directive(i.types.directiveLiteral("use strict")));
          let T = _, v = "arguments.1.body.body.0";
          return N && (T = i.template.statement.ast`let ${y} = ${_}`, v = "declarations.0.init." + v), { instanceNodes: [i.template.statement.ast`${i.types.cloneNode(R)}(this)`], wrapClass: (w) => (w.replaceWith(T), w.get(v)) };
        }, r.hasDecorators = function(y) {
          return s(y) || y.body.body.some(s);
        }, r.hasOwnDecorators = s;
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js"), f = l("./node_modules/.pnpm/@babel+helper-replace-supers@7.22.9_@babel+core@7.22.15/node_modules/@babel/helper-replace-supers/lib/index.js"), d = l("./node_modules/.pnpm/@babel+helper-function-name@7.22.5/node_modules/@babel/helper-function-name/lib/index.js");
        function s(y) {
          var b;
          return !((b = y.decorators) == null || !b.length);
        }
        function o(y, b) {
          return b ? i.types.objectProperty(i.types.identifier(y), b) : null;
        }
        function m(y) {
          let b;
          return y.decorators && y.decorators.length > 0 && (b = i.types.arrayExpression(y.decorators.map((E) => E.expression))), y.decorators = void 0, b;
        }
        function h(y) {
          return y.computed ? y.key : i.types.isIdentifier(y.key) ? i.types.stringLiteral(y.key.name) : i.types.stringLiteral(String(y.key.value));
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-create-class-features-plugin/lib/features.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.FEATURES = void 0, r.enableFeature = function(S, g, P) {
          h(S, g) && !E(S, g) || (S.set(s, S.get(s) | g), P === "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" ? (b(S, g, !0), S.set(m, S.get(m) | g)) : P === "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error" ? (b(S, g, !1), S.set(m, S.get(m) | g)) : b(S, g, P));
          let R, N;
          for (const [C, I] of d) {
            if (!h(S, C))
              continue;
            const D = y(S, C);
            if (!E(S, C)) {
              if (R === !D)
                throw new Error("'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled).");
              R = D, N = I;
            }
          }
          if (R !== void 0)
            for (const [C, I] of d)
              h(S, C) && y(S, C) !== R && (b(S, C, R), console.warn(`Though the "loose" option was set to "${!R}" in your @babel/preset-env config, it will not be used for ${I} since the "loose" mode option was set to "${R}" for ${N}.
The "loose" option must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding
	["${I}", { "loose": ${R} }]
to the "plugins" section of your Babel config.`));
        }, r.isLoose = y, r.shouldTransform = function(S, g) {
          let P = null, R = null, N = null, C = null, I = null;
          (0, i.hasOwnDecorators)(S.node) && (P = S.get("decorators.0"));
          for (const D of S.get("body.body"))
            !P && (0, i.hasOwnDecorators)(D.node) && (P = D.get("decorators.0")), !R && D.isClassProperty() && (R = D), !N && D.isClassPrivateProperty() && (N = D), !C && D.isClassPrivateMethod != null && D.isClassPrivateMethod() && (C = D), !I && D.isStaticBlock != null && D.isStaticBlock() && (I = D);
          if (P && N)
            throw N.buildCodeFrameError("Private fields in decorated classes are not supported yet.");
          if (P && C)
            throw C.buildCodeFrameError("Private methods in decorated classes are not supported yet.");
          if (P && !h(g, f.decorators))
            throw S.buildCodeFrameError(`Decorators are not enabled.
If you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-transform-class-properties" and enable loose mode, like so:
	["@babel/plugin-proposal-decorators", { "version": "legacy" }]
	["@babel/plugin-transform-class-properties", { "loose": true }]`);
          if (C && !h(g, f.privateMethods))
            throw C.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-transform-private-methods` to your configuration.");
          if ((R || N) && !h(g, f.fields) && !h(g, f.privateMethods))
            throw S.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-transform-class-properties` to your configuration.");
          if (I && !h(g, f.staticBlocks))
            throw S.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-transform-class-static-block` to your configuration.");
          return !!(P || C || I || (R || N) && h(g, f.fields));
        };
        var i = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js");
        const f = Object.freeze({ fields: 2, privateMethods: 4, decorators: 8, privateIn: 16, staticBlocks: 32 });
        r.FEATURES = f;
        const d = /* @__PURE__ */ new Map([[f.fields, "@babel/plugin-transform-class-properties"], [f.privateMethods, "@babel/plugin-transform-private-methods"], [f.privateIn, "@babel/plugin-transform-private-property-in-object"]]), s = "@babel/plugin-class-features/featuresKey", o = "@babel/plugin-class-features/looseKey", m = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
        function h(S, g) {
          return !!(S.get(s) & g);
        }
        function y(S, g) {
          return !!(S.get(o) & g);
        }
        function b(S, g, P) {
          P ? S.set(o, S.get(o) | g) : S.set(o, S.get(o) & ~g), S.set(m, S.get(m) & ~g);
        }
        function E(S, g) {
          return !!(S.get(m) & g);
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-create-class-features-plugin/lib/fields.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.buildCheckInRHS = g, r.buildFieldsInitNodes = function(B, k, K, te, z, q, $, Y, H) {
          var Q;
          let X, ne = 0;
          const ye = [], ve = [], de = [];
          let oe = null;
          const re = i.types.isIdentifier(k) ? () => k : () => (X != null || (X = K[0].scope.generateUidIdentifierBasedOnNode(k)), X), ae = (Q = B) != null ? Q : K[0].scope.generateUidIdentifier("class");
          B != null || (B = i.types.cloneNode(H));
          for (const le of K) {
            le.isClassProperty() && y.assertFieldTransformed(le);
            const ue = !(i.types.isStaticBlock != null && i.types.isStaticBlock(le.node)) && le.node.static, ie = !ue, we = le.isPrivate(), De = !we, Ee = le.isProperty(), Ae = !Ee, Me = le.isStaticBlock == null ? void 0 : le.isStaticBlock();
            switch (ue && (ne |= 1), (ue || Ae && we || Me) && (new f.default({ methodPath: le, constantSuper: Y, file: z, refToPreserve: H, getSuperRef: re, getObjectRef: () => (ne |= 2, ue || Me ? ae : i.types.memberExpression(ae, i.types.identifier("prototype"))) }).replace(), W(le, ae, H) && (ne |= 2)), !0) {
              case Me: {
                const me = le.node.body;
                me.length === 1 && i.types.isExpressionStatement(me[0]) ? ye.push(M(me[0], le)) : ye.push(i.types.inheritsComments(i.template.statement.ast`(() => { ${me} })()`, le.node));
                break;
              }
              case (ue && we && Ee && $):
                ye.push(C(i.types.cloneNode(B), le, te));
                break;
              case (ue && we && Ee && !$):
                ye.push(D(le, te));
                break;
              case (ue && De && Ee && q):
                if (!U(le.node)) {
                  ye.push(_(i.types.cloneNode(B), le));
                  break;
                }
              case (ue && De && Ee && !q):
                ye.push(T(i.types.cloneNode(B), le, z));
                break;
              case (ie && we && Ee && $):
                ve.push(C(i.types.thisExpression(), le, te));
                break;
              case (ie && we && Ee && !$):
                ve.push(I(i.types.thisExpression(), le, te, z));
                break;
              case (ie && we && Ae && $):
                ve.unshift(j(i.types.thisExpression(), le, te)), de.push(w(le, te, $));
                break;
              case (ie && we && Ae && !$):
                ve.unshift(F(i.types.thisExpression(), le, te, z)), de.push(w(le, te, $));
                break;
              case (ue && we && Ae && !$):
                ye.unshift(D(le, te)), de.push(w(le, te, $));
                break;
              case (ue && we && Ae && $):
                ye.unshift(v(i.types.cloneNode(B), le, z, te)), de.push(w(le, te, $));
                break;
              case (ie && De && Ee && q):
                ve.push(_(i.types.thisExpression(), le));
                break;
              case (ie && De && Ee && !q):
                ve.push(T(i.types.thisExpression(), le, z));
                break;
              default:
                throw new Error("Unreachable.");
            }
          }
          return 2 & ne && H != null && (oe = i.types.expressionStatement(i.types.assignmentExpression("=", i.types.cloneNode(ae), i.types.cloneNode(H)))), { staticNodes: ye.filter(Boolean), instanceNodes: ve.filter(Boolean), pureStaticNodes: de.filter(Boolean), classBindingNode: oe, wrapClass(le) {
            for (const ue of K)
              ue.node.leadingComments = null, ue.remove();
            return X && (le.scope.push({ id: i.types.cloneNode(X) }), le.set("superClass", i.types.assignmentExpression("=", X, le.node.superClass))), ne !== 0 && (le.isClassExpression() ? (le.scope.push({ id: B }), le.replaceWith(i.types.assignmentExpression("=", i.types.cloneNode(B), le.node))) : (H == null && (le.node.id = B), oe != null && le.scope.push({ id: ae }))), le;
          } };
        }, r.buildPrivateNamesMap = function(B) {
          const k = /* @__PURE__ */ new Map();
          for (const K of B)
            if (K.isPrivate()) {
              const { name: te } = K.node.key.id, z = k.has(te) ? k.get(te) : { id: K.scope.generateUidIdentifier(te), static: K.node.static, method: !K.isProperty() };
              K.isClassPrivateMethod() && (K.node.kind === "get" ? z.getId = K.scope.generateUidIdentifier(`get_${te}`) : K.node.kind === "set" ? z.setId = K.scope.generateUidIdentifier(`set_${te}`) : K.node.kind === "method" && (z.methodId = K.scope.generateUidIdentifier(te))), k.set(te, z);
            }
          return k;
        }, r.buildPrivateNamesNodes = function(B, k, K, te) {
          const z = [];
          for (const [q, $] of B) {
            const { static: Y, method: H, getId: Q, setId: X } = $, ne = Q || X, ye = i.types.cloneNode($.id);
            let ve;
            k ? ve = i.types.callExpression(te.addHelper("classPrivateFieldLooseKey"), [i.types.stringLiteral(q)]) : K ? ve = i.types.callExpression(i.types.identifier("Symbol"), [i.types.stringLiteral(q)]) : Y || (ve = i.types.newExpression(i.types.identifier(!H || ne ? "WeakMap" : "WeakSet"), [])), ve && ((0, m.default)(ve), z.push(i.template.statement.ast`var ${ye} = ${ve}`));
          }
          return z;
        }, r.transformPrivateNamesUsage = function(B, k, K, { privateFieldsAsProperties: te, noDocumentAll: z, innerBinding: q }, $) {
          if (!K.size)
            return;
          const Y = k.get("body"), H = te ? N : R;
          (0, s.default)(Y, E, Object.assign({ privateNamesMap: K, classRef: B, file: $ }, H, { noDocumentAll: z, innerBinding: q })), Y.traverse(P, { privateNamesMap: K, classRef: B, file: $, privateFieldsAsProperties: te, innerBinding: q });
        };
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js"), f = l("./node_modules/.pnpm/@babel+helper-replace-supers@7.22.9_@babel+core@7.22.15/node_modules/@babel/helper-replace-supers/lib/index.js"), d = l("./node_modules/.pnpm/@babel+helper-environment-visitor@7.22.5/node_modules/@babel/helper-environment-visitor/lib/index.js"), s = l("./node_modules/.pnpm/@babel+helper-member-expression-to-functions@7.22.15/node_modules/@babel/helper-member-expression-to-functions/lib/index.js"), o = l("./node_modules/.pnpm/@babel+helper-optimise-call-expression@7.22.5/node_modules/@babel/helper-optimise-call-expression/lib/index.js"), m = l("./node_modules/.pnpm/@babel+helper-annotate-as-pure@7.22.5/node_modules/@babel/helper-annotate-as-pure/lib/index.js"), h = l("./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.22.5/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js"), y = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js");
        function b(B) {
          const k = i.traverse.visitors.merge([Object.assign({}, B), d.default]), K = Object.assign({}, B, { Class(te) {
            const { privateNamesMap: z } = this, q = te.get("body.body"), $ = new Map(z), Y = [];
            for (const H of q) {
              if (!H.isPrivate())
                continue;
              const { name: Q } = H.node.key.id;
              $.delete(Q), Y.push(Q);
            }
            Y.length && (te.get("body").traverse(k, Object.assign({}, this, { redeclared: Y })), te.traverse(K, Object.assign({}, this, { privateNamesMap: $ })), te.skipKey("body"));
          } });
          return K;
        }
        const E = b({ PrivateName(B, { noDocumentAll: k }) {
          const { privateNamesMap: K, redeclared: te } = this, { node: z, parentPath: q } = B;
          if (!q.isMemberExpression({ property: z }) && !q.isOptionalMemberExpression({ property: z }))
            return;
          const { name: $ } = z.id;
          K.has($) && (te && te.includes($) || this.handle(q, k));
        } });
        function S(B, k, K) {
          for (; (te = k) != null && te.hasBinding(B) && !k.bindingIdentifierEquals(B, K); ) {
            var te;
            k.rename(B), k = k.parent;
          }
        }
        function g(B, k, K) {
          return K || k.availableHelper == null || !k.availableHelper("checkInRHS") ? B : i.types.callExpression(k.addHelper("checkInRHS"), [B]);
        }
        const P = b({ BinaryExpression(B, { file: k }) {
          const { operator: K, left: te, right: z } = B.node;
          if (K !== "in" || !i.types.isPrivateName(te))
            return;
          const { privateFieldsAsProperties: q, privateNamesMap: $, redeclared: Y } = this, { name: H } = te.id;
          if (!$.has(H) || Y && Y.includes(H))
            return;
          if (S(this.classRef.name, B.scope, this.innerBinding), q) {
            const { id: ne } = $.get(H);
            return void B.replaceWith(i.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${g(z, k)}, ${i.types.cloneNode(ne)})
      `);
          }
          const { id: Q, static: X } = $.get(H);
          X ? B.replaceWith(i.template.expression.ast`${g(z, k)} === ${i.types.cloneNode(this.classRef)}`) : B.replaceWith(i.template.expression.ast`${i.types.cloneNode(Q)}.has(${g(z, k)})`);
        } }), R = { memoise(B, k) {
          const { scope: K } = B, { object: te } = B.node, z = K.maybeGenerateMemoised(te);
          z && this.memoiser.set(te, z, k);
        }, receiver(B) {
          const { object: k } = B.node;
          return this.memoiser.has(k) ? i.types.cloneNode(this.memoiser.get(k)) : i.types.cloneNode(k);
        }, get(B) {
          const { classRef: k, privateNamesMap: K, file: te, innerBinding: z } = this, { name: q } = B.node.property.id, { id: $, static: Y, method: H, methodId: Q, getId: X, setId: ne } = K.get(q), ye = X || ne;
          if (Y) {
            const ve = H && !ye ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
            return S(k.name, B.scope, z), i.types.callExpression(te.addHelper(ve), [this.receiver(B), i.types.cloneNode(k), i.types.cloneNode($)]);
          }
          if (H) {
            if (ye) {
              if (!X && ne) {
                if (te.availableHelper("writeOnlyError"))
                  return i.types.sequenceExpression([this.receiver(B), i.types.callExpression(te.addHelper("writeOnlyError"), [i.types.stringLiteral(`#${q}`)])]);
                console.warn("@babel/helpers is outdated, update it to silence this warning.");
              }
              return i.types.callExpression(te.addHelper("classPrivateFieldGet"), [this.receiver(B), i.types.cloneNode($)]);
            }
            return i.types.callExpression(te.addHelper("classPrivateMethodGet"), [this.receiver(B), i.types.cloneNode($), i.types.cloneNode(Q)]);
          }
          return i.types.callExpression(te.addHelper("classPrivateFieldGet"), [this.receiver(B), i.types.cloneNode($)]);
        }, boundGet(B) {
          return this.memoise(B, 1), i.types.callExpression(i.types.memberExpression(this.get(B), i.types.identifier("bind")), [this.receiver(B)]);
        }, set(B, k) {
          const { classRef: K, privateNamesMap: te, file: z } = this, { name: q } = B.node.property.id, { id: $, static: Y, method: H, setId: Q, getId: X } = te.get(q);
          if (Y) {
            const ne = H && !(X || Q) ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
            return i.types.callExpression(z.addHelper(ne), [this.receiver(B), i.types.cloneNode(K), i.types.cloneNode($), k]);
          }
          return H ? Q ? i.types.callExpression(z.addHelper("classPrivateFieldSet"), [this.receiver(B), i.types.cloneNode($), k]) : i.types.sequenceExpression([this.receiver(B), k, i.types.callExpression(z.addHelper("readOnlyError"), [i.types.stringLiteral(`#${q}`)])]) : i.types.callExpression(z.addHelper("classPrivateFieldSet"), [this.receiver(B), i.types.cloneNode($), k]);
        }, destructureSet(B) {
          const { classRef: k, privateNamesMap: K, file: te } = this, { name: z } = B.node.property.id, { id: q, static: $ } = K.get(z);
          if ($) {
            try {
              var Y = te.addHelper("classStaticPrivateFieldDestructureSet");
            } catch {
              throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.");
            }
            return i.types.memberExpression(i.types.callExpression(Y, [this.receiver(B), i.types.cloneNode(k), i.types.cloneNode(q)]), i.types.identifier("value"));
          }
          return i.types.memberExpression(i.types.callExpression(te.addHelper("classPrivateFieldDestructureSet"), [this.receiver(B), i.types.cloneNode(q)]), i.types.identifier("value"));
        }, call(B, k) {
          return this.memoise(B, 1), (0, o.default)(this.get(B), this.receiver(B), k, !1);
        }, optionalCall(B, k) {
          return this.memoise(B, 1), (0, o.default)(this.get(B), this.receiver(B), k, !0);
        }, delete() {
          throw new Error("Internal Babel error: deleting private elements is a parsing error.");
        } }, N = { get(B) {
          const { privateNamesMap: k, file: K } = this, { object: te } = B.node, { name: z } = B.node.property.id;
          return i.template.expression`BASE(REF, PROP)[PROP]`({ BASE: K.addHelper("classPrivateFieldLooseBase"), REF: i.types.cloneNode(te), PROP: i.types.cloneNode(k.get(z).id) });
        }, set() {
          throw new Error("private name handler with loose = true don't need set()");
        }, boundGet(B) {
          return i.types.callExpression(i.types.memberExpression(this.get(B), i.types.identifier("bind")), [i.types.cloneNode(B.node.object)]);
        }, simpleSet(B) {
          return this.get(B);
        }, destructureSet(B) {
          return this.get(B);
        }, call(B, k) {
          return i.types.callExpression(this.get(B), k);
        }, optionalCall(B, k) {
          return i.types.optionalCallExpression(this.get(B), k, !0);
        }, delete() {
          throw new Error("Internal Babel error: deleting private elements is a parsing error.");
        } };
        function C(B, k, K) {
          const { id: te } = K.get(k.node.key.id.name), z = k.node.value || k.scope.buildUndefinedNode();
          return M(i.template.statement.ast`
      Object.defineProperty(${B}, ${i.types.cloneNode(te)}, {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${z}
      });
    `, k);
        }
        function I(B, k, K, te) {
          const { id: z } = K.get(k.node.key.id.name), q = k.node.value || k.scope.buildUndefinedNode();
          if (!te.availableHelper("classPrivateFieldInitSpec"))
            return M(i.template.statement.ast`${i.types.cloneNode(z)}.set(${B}, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${q},
        })`, k);
          const $ = te.addHelper("classPrivateFieldInitSpec");
          return M(i.template.statement.ast`${$}(
      ${i.types.thisExpression()},
      ${i.types.cloneNode(z)},
      {
        writable: true,
        value: ${q}
      },
    )`, k);
        }
        function D(B, k) {
          const K = k.get(B.node.key.id.name), { id: te, getId: z, setId: q, initAdded: $ } = K, Y = z || q;
          if (!B.isProperty() && ($ || !Y))
            return;
          if (Y)
            return k.set(B.node.key.id.name, Object.assign({}, K, { initAdded: !0 })), M(i.template.statement.ast`
        var ${i.types.cloneNode(te)} = {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${z ? z.name : B.scope.buildUndefinedNode()},
          set: ${q ? q.name : B.scope.buildUndefinedNode()}
        }
      `, B);
          const H = B.node.value || B.scope.buildUndefinedNode();
          return M(i.template.statement.ast`
      var ${i.types.cloneNode(te)} = {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${H}
      };
    `, B);
        }
        function j(B, k, K) {
          const te = K.get(k.node.key.id.name), { methodId: z, id: q, getId: $, setId: Y, initAdded: H } = te;
          if (!H)
            return z ? M(i.template.statement.ast`
        Object.defineProperty(${B}, ${q}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${z.name}
        });
      `, k) : $ || Y ? (K.set(k.node.key.id.name, Object.assign({}, te, { initAdded: !0 })), M(i.template.statement.ast`
        Object.defineProperty(${B}, ${q}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${$ ? $.name : k.scope.buildUndefinedNode()},
          set: ${Y ? Y.name : k.scope.buildUndefinedNode()}
        });
      `, k)) : void 0;
        }
        function F(B, k, K, te) {
          const z = K.get(k.node.key.id.name), { getId: q, setId: $, initAdded: Y } = z;
          if (!Y)
            return q || $ ? function(H, Q, X, ne) {
              const ye = X.get(Q.node.key.id.name), { id: ve, getId: de, setId: oe } = ye;
              if (X.set(Q.node.key.id.name, Object.assign({}, ye, { initAdded: !0 })), !ne.availableHelper("classPrivateFieldInitSpec"))
                return M(i.template.statement.ast`
          ${ve}.set(${H}, {
            get: ${de ? de.name : Q.scope.buildUndefinedNode()},
            set: ${oe ? oe.name : Q.scope.buildUndefinedNode()}
          });
        `, Q);
              const re = ne.addHelper("classPrivateFieldInitSpec");
              return M(i.template.statement.ast`${re}(
      ${i.types.thisExpression()},
      ${i.types.cloneNode(ve)},
      {
        get: ${de ? de.name : Q.scope.buildUndefinedNode()},
        set: ${oe ? oe.name : Q.scope.buildUndefinedNode()}
      },
    )`, Q);
            }(B, k, K, te) : function(H, Q, X, ne) {
              const ye = X.get(Q.node.key.id.name), { id: ve } = ye;
              if (!ne.availableHelper("classPrivateMethodInitSpec"))
                return M(i.template.statement.ast`${ve}.add(${H})`, Q);
              const de = ne.addHelper("classPrivateMethodInitSpec");
              return M(i.template.statement.ast`${de}(
      ${i.types.thisExpression()},
      ${i.types.cloneNode(ve)}
    )`, Q);
            }(B, k, K, te);
        }
        function _(B, k) {
          const { key: K, computed: te } = k.node, z = k.node.value || k.scope.buildUndefinedNode();
          return M(i.types.expressionStatement(i.types.assignmentExpression("=", i.types.memberExpression(B, K, te || i.types.isLiteral(K)), z)), k);
        }
        function T(B, k, K) {
          const { key: te, computed: z } = k.node, q = k.node.value || k.scope.buildUndefinedNode();
          return M(i.types.expressionStatement(i.types.callExpression(K.addHelper("defineProperty"), [B, z || i.types.isLiteral(te) ? te : i.types.stringLiteral(te.name), q])), k);
        }
        function v(B, k, K, te) {
          const z = te.get(k.node.key.id.name), { id: q, methodId: $, getId: Y, setId: H, initAdded: Q } = z;
          if (!Q)
            return Y || H ? (te.set(k.node.key.id.name, Object.assign({}, z, { initAdded: !0 })), M(i.template.statement.ast`
        Object.defineProperty(${B}, ${q}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${Y ? Y.name : k.scope.buildUndefinedNode()},
          set: ${H ? H.name : k.scope.buildUndefinedNode()}
        })
      `, k)) : M(i.template.statement.ast`
      Object.defineProperty(${B}, ${q}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        value: ${$.name}
      });
    `, k);
        }
        function w(B, k, K = !1) {
          const te = k.get(B.node.key.id.name), { id: z, methodId: q, getId: $, setId: Y, getterDeclared: H, setterDeclared: Q, static: X } = te, { params: ne, body: ye, generator: ve, async: de } = B.node, oe = $ && !H && ne.length === 0, re = Y && !Q && ne.length > 0;
          let ae = q;
          return oe ? (k.set(B.node.key.id.name, Object.assign({}, te, { getterDeclared: !0 })), ae = $) : re ? (k.set(B.node.key.id.name, Object.assign({}, te, { setterDeclared: !0 })), ae = Y) : X && !K && (ae = z), M(i.types.functionDeclaration(i.types.cloneNode(ae), ne, ye, ve, de), B);
        }
        const O = i.traverse.visitors.merge([{ UnaryExpression(B) {
          const { node: k } = B;
          if (k.operator === "delete") {
            const K = (0, h.skipTransparentExprWrapperNodes)(k.argument);
            i.types.isThisExpression(K) && B.replaceWith(i.types.booleanLiteral(!0));
          }
        }, ThisExpression(B, k) {
          k.needsClassRef = !0, B.replaceWith(i.types.cloneNode(k.classRef));
        }, MetaProperty(B) {
          const { node: k, scope: K } = B;
          k.meta.name === "new" && k.property.name === "target" && B.replaceWith(K.buildUndefinedNode());
        } }, d.default]), G = { ReferencedIdentifier(B, k) {
          B.scope.bindingIdentifierEquals(B.node.name, k.innerBinding) && (k.needsClassRef = !0, B.node.name = k.classRef.name);
        } };
        function W(B, k, K) {
          var te;
          const z = { classRef: k, needsClassRef: !1, innerBinding: K };
          return B.isMethod() || B.traverse(O, z), K != null && (te = z.classRef) != null && te.name && z.classRef.name !== K.name && B.traverse(G, z), z.needsClassRef;
        }
        function U({ key: B, computed: k }) {
          return B.type === "Identifier" ? !k && (B.name === "name" || B.name === "length") : B.type === "StringLiteral" && (B.value === "name" || B.value === "length");
        }
        function M(B, k) {
          return i.types.inheritLeadingComments(B, k.node), i.types.inheritInnerComments(B, k.node), B;
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-create-class-features-plugin/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), Object.defineProperty(r, "FEATURES", { enumerable: !0, get: function() {
          return y.FEATURES;
        } }), Object.defineProperty(r, "buildCheckInRHS", { enumerable: !0, get: function() {
          return o.buildCheckInRHS;
        } }), r.createClassFeaturePlugin = function({ name: S, feature: g, loose: P, manipulateOptions: R, api: N, inherits: C }) {
          N != null || (N = { assumption: () => {
          } });
          const I = N.assumption("setPublicClassFields"), D = N.assumption("privateFieldsAsSymbols"), j = N.assumption("privateFieldsAsProperties"), F = N.assumption("constantSuper"), _ = N.assumption("noDocumentAll");
          if (j && D)
            throw new Error('Cannot enable both the "privateFieldsAsProperties" and "privateFieldsAsSymbols" assumptions as the same time.');
          const T = j || D;
          if (P === !0) {
            const v = [];
            I !== void 0 && v.push('"setPublicClassFields"'), j !== void 0 && v.push('"privateFieldsAsProperties"'), D !== void 0 && v.push('"privateFieldsAsSymbols"'), v.length !== 0 && console.warn(`[${S}]: You are using the "loose: true" option and you are explicitly setting a value for the ${v.join(" and ")} assumption${v.length > 1 ? "s" : ""}. The "loose" option can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:
	"assumptions": {
		"setPublicClassFields": true,
		"privateFieldsAsSymbols": true
	}`);
          }
          return { name: S, manipulateOptions: R, inherits: C, pre(v) {
            (0, y.enableFeature)(v, g, P), typeof v.get(E) != "number" && v.get(E) && !s.lt(v.get(E), "7.22.15") || v.set(E, "7.22.15");
          }, visitor: { Class(v, { file: w }) {
            var O;
            if (w.get(E) !== "7.22.15" || !(0, y.shouldTransform)(v, w))
              return;
            const G = v.isClassDeclaration();
            G && (0, b.assertFieldTransformed)(v);
            const W = (0, y.isLoose)(w, g);
            let U;
            const M = (0, m.hasDecorators)(v.node), B = [], k = [], K = [], te = /* @__PURE__ */ new Set(), z = v.get("body");
            for (const ae of z.get("body")) {
              if ((ae.isClassProperty() || ae.isClassMethod()) && ae.node.computed && K.push(ae), ae.isPrivate()) {
                const { name: le } = ae.node.key.id, ue = `get ${le}`, ie = `set ${le}`;
                if (ae.isClassPrivateMethod()) {
                  if (ae.node.kind === "get") {
                    if (te.has(ue) || te.has(le) && !te.has(ie))
                      throw ae.buildCodeFrameError("Duplicate private field");
                    te.add(ue).add(le);
                  } else if (ae.node.kind === "set") {
                    if (te.has(ie) || te.has(le) && !te.has(ue))
                      throw ae.buildCodeFrameError("Duplicate private field");
                    te.add(ie).add(le);
                  }
                } else {
                  if (te.has(le) && !te.has(ue) && !te.has(ie) || te.has(le) && (te.has(ue) || te.has(ie)))
                    throw ae.buildCodeFrameError("Duplicate private field");
                  te.add(le);
                }
              }
              ae.isClassMethod({ kind: "constructor" }) ? U = ae : (k.push(ae), (ae.isProperty() || ae.isPrivate() || ae.isStaticBlock != null && ae.isStaticBlock()) && B.push(ae));
            }
            if (!B.length && !M)
              return;
            const q = v.node.id;
            let $;
            q && G || ((0, f.default)(v), $ = v.scope.generateUidIdentifier("class"));
            const Y = (O = $) != null ? O : i.types.cloneNode(q), H = (0, o.buildPrivateNamesMap)(B), Q = (0, o.buildPrivateNamesNodes)(H, j ?? W, D != null && D, w);
            let X, ne, ye, ve, de, oe;
            (0, o.transformPrivateNamesUsage)(Y, v, H, { privateFieldsAsProperties: T ?? W, noDocumentAll: _, innerBinding: q }, w), M ? (ne = ve = X = [], { instanceNodes: ye, wrapClass: oe } = (0, m.buildDecoratedClass)(Y, v, k, w)) : (X = (0, h.extractComputedKeys)(v, K, w), { staticNodes: ne, pureStaticNodes: ve, instanceNodes: ye, classBindingNode: de, wrapClass: oe } = (0, o.buildFieldsInitNodes)($, v.node.superClass, B, H, w, I ?? W, T ?? W, F ?? W, q)), ye.length > 0 && (0, h.injectInitialization)(v, U, ye, (ae, le) => {
              if (!M)
                for (const ue of B)
                  i.types.isStaticBlock != null && i.types.isStaticBlock(ue.node) || ue.node.static || ue.traverse(ae, le);
            });
            const re = oe(v);
            re.insertBefore([...Q, ...X]), ne.length > 0 && re.insertAfter(ne), ve.length > 0 && re.find((ae) => ae.isStatement() || ae.isDeclaration()).insertAfter(ve), de != null && G && re.insertAfter(de);
          }, ExportDefaultDeclaration(v, { file: w }) {
            {
              if (w.get(E) !== "7.22.15")
                return;
              const O = v.get("declaration");
              O.isClassDeclaration() && (0, m.hasDecorators)(O.node) && (O.node.id ? (0, d.default)(v) : O.node.type = "ClassExpression");
            }
          } } };
        }, Object.defineProperty(r, "enableFeature", { enumerable: !0, get: function() {
          return y.enableFeature;
        } }), Object.defineProperty(r, "injectInitialization", { enumerable: !0, get: function() {
          return h.injectInitialization;
        } });
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js"), f = l("./node_modules/.pnpm/@babel+helper-function-name@7.22.5/node_modules/@babel/helper-function-name/lib/index.js"), d = l("./node_modules/.pnpm/@babel+helper-split-export-declaration@7.22.6/node_modules/@babel/helper-split-export-declaration/lib/index.js"), s = l("./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js"), o = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-create-class-features-plugin/lib/fields.js"), m = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js"), h = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-create-class-features-plugin/lib/misc.js"), y = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-create-class-features-plugin/lib/features.js"), b = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js");
        const E = "@babel/plugin-class-features/version";
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-create-class-features-plugin/lib/misc.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.extractComputedKeys = function(h, y, b) {
          const E = [], S = { classBinding: h.node.id && h.scope.getBinding(h.node.id.name), file: b };
          for (const g of y) {
            const P = g.get("key");
            P.isReferencedIdentifier() ? o(P, S) : P.traverse(m, S);
            const R = g.node;
            if (!P.isConstantExpression()) {
              const N = h.scope.generateUidIdentifierBasedOnNode(R.key);
              h.scope.push({ id: N, kind: "let" }), E.push(i.types.expressionStatement(i.types.assignmentExpression("=", i.types.cloneNode(N), R.key))), R.key = i.types.cloneNode(N);
            }
          }
          return E;
        }, r.injectInitialization = function(h, y, b, E) {
          if (!b.length)
            return;
          const S = !!h.node.superClass;
          if (!y) {
            const g = i.types.classMethod("constructor", i.types.identifier("constructor"), [], i.types.blockStatement([]));
            S && (g.params = [i.types.restElement(i.types.identifier("args"))], g.body.body.push(i.template.statement.ast`super(...args)`)), [y] = h.get("body").unshiftContainer("body", g);
          }
          if (E && E(s, { scope: y.scope }), S) {
            const g = [];
            y.traverse(d, g);
            let P = !0;
            for (const R of g)
              P ? (R.insertAfter(b), P = !1) : R.insertAfter(b.map((N) => i.types.cloneNode(N)));
          } else
            y.get("body").unshiftContainer("body", b);
        };
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js"), f = l("./node_modules/.pnpm/@babel+helper-environment-visitor@7.22.5/node_modules/@babel/helper-environment-visitor/lib/index.js");
        const d = i.traverse.visitors.merge([{ Super(h) {
          const { node: y, parentPath: b } = h;
          b.isCallExpression({ callee: y }) && this.push(b);
        } }, f.default]), s = { "TSTypeAnnotation|TypeAnnotation"(h) {
          h.skip();
        }, ReferencedIdentifier(h, { scope: y }) {
          y.hasOwnBinding(h.node.name) && (y.rename(h.node.name), h.skip());
        } };
        function o(h, y) {
          if (y.classBinding && y.classBinding === h.scope.getBinding(h.node.name)) {
            const b = y.file.addHelper("classNameTDZError"), E = i.types.callExpression(b, [i.types.stringLiteral(h.node.name)]);
            h.replaceWith(i.types.sequenceExpression([E, h.node])), h.skip();
          }
        }
        const m = { ReferencedIdentifier: o };
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.assertFieldTransformed = function(l) {
          if (l.node.declare)
            throw l.buildCodeFrameError(`TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.
If you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:
 - @babel/plugin-transform-class-properties
 - @babel/plugin-transform-private-methods
 - @babel/plugin-proposal-decorators`);
        };
      }, "./node_modules/.pnpm/@babel+helper-environment-visitor@7.22.5/node_modules/@babel/helper-environment-visitor/lib/index.js": (u, r) => {
        function l(f) {
          const { context: d, node: s } = f;
          if (s.computed && d.maybeQueue(f.get("key")), s.decorators)
            for (const o of f.get("decorators"))
              d.maybeQueue(o);
        }
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0, r.requeueComputedKeyAndDecorators = l, r.skipAllButComputedKey = function(f) {
          f.skip(), f.node.computed && f.context.maybeQueue(f.get("key"));
        };
        var i = { FunctionParent(f) {
          f.isArrowFunctionExpression() || (f.skip(), f.isMethod() && l(f));
        }, Property(f) {
          f.isObjectProperty() || (f.skip(), l(f));
        } };
        r.default = i;
      }, "./node_modules/.pnpm/@babel+helper-function-name@7.22.5/node_modules/@babel/helper-function-name/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function({ node: T, parent: v, scope: w, id: O }, G = !1, W = !1) {
          if (T.id)
            return;
          if (!P(v) && !g(v, { kind: "method" }) || v.computed && !E(v.key)) {
            if (I(v)) {
              if (O = v.id, b(O) && !G) {
                const B = w.parent.getBinding(O.name);
                if (B && B.constant && w.getBinding(O.name) === B)
                  return T.id = s(O), void (T.id[d] = !0);
              }
            } else if (m(v, { operator: "=" }))
              O = v.left;
            else if (!O)
              return;
          } else
            O = v.key;
          let U;
          if (O && E(O) ? U = function(B) {
            return S(B) ? "null" : R(B) ? `_${B.pattern}_${B.flags}` : C(B) ? B.quasis.map((k) => k.value.raw).join("") : B.value !== void 0 ? B.value + "" : "";
          }(O) : O && b(O) && (U = O.name), U === void 0 || !W && y(T) && /[\uD800-\uDFFF]/.test(U))
            return;
          U = D(U);
          const M = o(U);
          return M[d] = !0, function(B, k, K, te) {
            if (B.selfReference) {
              if (!te.hasBinding(K.name) || te.hasGlobal(K.name)) {
                if (!y(k))
                  return;
                let z = j;
                k.generator && (z = F);
                const q = z({ FUNCTION: k, FUNCTION_ID: K, FUNCTION_KEY: te.generateUidIdentifier(K.name) }).expression, $ = q.callee.body.body[0].params;
                for (let Y = 0, H = function(Q) {
                  const X = Q.params.findIndex((ne) => h(ne) || N(ne));
                  return X === -1 ? Q.params.length : X;
                }(k); Y < H; Y++)
                  $.push(te.generateUidIdentifier("x"));
                return q;
              }
              te.rename(K.name);
            }
            k.id = K, te.getProgramParent().references[K.name] = !0;
          }(function(B, k, K) {
            const te = { selfAssignment: !1, selfReference: !1, outerDeclar: K.getBindingIdentifier(k), name: k }, z = K.getOwnBinding(k);
            return z ? z.kind === "param" && (te.selfReference = !0) : (te.outerDeclar || K.hasGlobal(k)) && K.traverse(B, _, te), te;
          }(T, U, w), T, M, w) || T;
        };
        var i = l("./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/index.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { NOT_LOCAL_BINDING: d, cloneNode: s, identifier: o, isAssignmentExpression: m, isAssignmentPattern: h, isFunction: y, isIdentifier: b, isLiteral: E, isNullLiteral: S, isObjectMethod: g, isObjectProperty: P, isRegExpLiteral: R, isRestElement: N, isTemplateLiteral: C, isVariableDeclarator: I, toBindingIdentifierName: D } = f, j = i.default.statement(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`), F = i.default.statement(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`), _ = { "ReferencedIdentifier|BindingIdentifier"(T, v) {
          T.node.name === v.name && T.scope.getBindingIdentifier(v.name) === v.outerDeclar && (v.selfReference = !0, T.stop());
        } };
      }, "./node_modules/.pnpm/@babel+helper-hoist-variables@7.22.5/node_modules/@babel/helper-hoist-variables/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(m, h, y = "var") {
          m.traverse(o, { kind: y, emit: h });
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { assignmentExpression: f, expressionStatement: d, identifier: s } = i, o = { Scope(m, h) {
          h.kind === "let" && m.skip();
        }, FunctionParent(m) {
          m.skip();
        }, VariableDeclaration(m, h) {
          if (h.kind && m.node.kind !== h.kind)
            return;
          const y = [], b = m.get("declarations");
          let E;
          for (const S of b) {
            E = S.node.id, S.node.init && y.push(d(f("=", S.node.id, S.node.init)));
            for (const g of Object.keys(S.getBindingIdentifiers()))
              h.emit(s(g), g, S.node.init !== null);
          }
          m.parentPath.isFor({ left: m.node }) ? m.replaceWith(E) : m.replaceWithMultiple(y);
        } };
      }, "./node_modules/.pnpm/@babel+helper-member-expression-to-functions@7.22.15/node_modules/@babel/helper-member-expression-to-functions/lib/index.js": (u, r, l) => {
        function i(W) {
          if (W && W.__esModule)
            return W;
          var U = /* @__PURE__ */ Object.create(null);
          return W && Object.keys(W).forEach(function(M) {
            if (M !== "default") {
              var B = Object.getOwnPropertyDescriptor(W, M);
              Object.defineProperty(U, M, B.get ? B : { enumerable: !0, get: function() {
                return W[M];
              } });
            }
          }), U.default = W, Object.freeze(U);
        }
        Object.defineProperty(r, "__esModule", { value: !0 });
        var f = i(l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js"));
        function d(W) {
          const U = W, { node: M, parentPath: B } = U;
          if (B.isLogicalExpression()) {
            const { operator: k, right: K } = B.node;
            if (k === "&&" || k === "||" || k === "??" && M === K)
              return d(B);
          }
          if (B.isSequenceExpression()) {
            const { expressions: k } = B.node;
            return k[k.length - 1] !== M || d(B);
          }
          return B.isConditional({ test: M }) || B.isUnaryExpression({ operator: "!" }) || B.isLoop({ test: M });
        }
        const { LOGICAL_OPERATORS: s, arrowFunctionExpression: o, assignmentExpression: m, binaryExpression: h, booleanLiteral: y, callExpression: b, cloneNode: E, conditionalExpression: S, identifier: g, isMemberExpression: P, isOptionalCallExpression: R, isOptionalMemberExpression: N, isUpdateExpression: C, logicalExpression: I, memberExpression: D, nullLiteral: j, optionalCallExpression: F, optionalMemberExpression: _, sequenceExpression: T, updateExpression: v } = f;
        class w {
          constructor() {
            this._map = void 0, this._map = /* @__PURE__ */ new WeakMap();
          }
          has(U) {
            return this._map.has(U);
          }
          get(U) {
            if (!this.has(U))
              return;
            const M = this._map.get(U), { value: B } = M;
            return M.count--, M.count === 0 ? m("=", B, U) : B;
          }
          set(U, M, B) {
            return this._map.set(U, { count: B, value: M });
          }
        }
        function O(W, U) {
          const { node: M } = W;
          if (N(M))
            return D(U, M.property, M.computed);
          if (W.isOptionalCallExpression()) {
            const B = W.get("callee");
            if (W.node.optional && B.isOptionalMemberExpression()) {
              const k = B.node.object, K = W.scope.maybeGenerateMemoised(k);
              return B.get("object").replaceWith(m("=", K, k)), b(D(U, g("call")), [K, ...W.node.arguments]);
            }
            return b(U, W.node.arguments);
          }
          return W.node;
        }
        const G = { memoise() {
        }, handle(W, U) {
          const { node: M, parent: B, parentPath: k, scope: K } = W;
          if (W.isOptionalMemberExpression()) {
            if (function(ue) {
              for (; ue && !ue.isProgram(); ) {
                const { parentPath: ie, container: we, listKey: De } = ue, Ee = ie.node;
                if (De) {
                  if (we !== Ee[De])
                    return !0;
                } else if (we !== Ee)
                  return !0;
                ue = ie;
              }
              return !1;
            }(W))
              return;
            const te = W.find(({ node: ue, parent: ie }) => N(ie) ? ie.optional || ie.object !== ue : !R(ie) || ue !== W.node && ie.optional || ie.callee !== ue);
            if (K.path.isPattern())
              return void te.replaceWith(b(o([], te.node), []));
            const z = d(te), q = te.parentPath;
            if (q.isUpdateExpression({ argument: M }) || q.isAssignmentExpression({ left: M }))
              throw W.buildCodeFrameError("can't handle assignment");
            const $ = q.isUnaryExpression({ operator: "delete" });
            if ($ && te.isOptionalMemberExpression() && te.get("property").isPrivateName())
              throw W.buildCodeFrameError("can't delete a private class element");
            let Y = W;
            for (; ; )
              if (Y.isOptionalMemberExpression()) {
                if (Y.node.optional)
                  break;
                Y = Y.get("object");
              } else {
                if (!Y.isOptionalCallExpression())
                  throw new Error(`Internal error: unexpected ${Y.node.type}`);
                if (Y.node.optional)
                  break;
                Y = Y.get("callee");
              }
            const H = Y.isOptionalMemberExpression() ? Y.node.object : Y.node.callee, Q = K.maybeGenerateMemoised(H), X = Q ?? H, ne = k.isOptionalCallExpression({ callee: M }), ye = (ue) => ne, ve = k.isCallExpression({ callee: M });
            Y.replaceWith(O(Y, X)), ye() ? B.optional ? k.replaceWith(this.optionalCall(W, B.arguments)) : k.replaceWith(this.call(W, B.arguments)) : ve ? W.replaceWith(this.boundGet(W)) : this.delete && k.isUnaryExpression({ operator: "delete" }) ? k.replaceWith(this.delete(W)) : W.replaceWith(this.get(W));
            let de, oe = W.node;
            for (let ue = W; ue !== te; ) {
              const ie = ue.parentPath;
              if (ie === te && ye() && B.optional) {
                oe = ie.node;
                break;
              }
              oe = O(ie, oe), ue = ie;
            }
            const re = te.parentPath;
            if (P(oe) && re.isOptionalCallExpression({ callee: te.node, optional: !0 })) {
              const { object: ue } = oe;
              de = W.scope.maybeGenerateMemoised(ue), de && (oe.object = m("=", de, ue));
            }
            let ae = te;
            $ && (ae = re, oe = re.node);
            const le = Q ? m("=", E(X), E(H)) : E(X);
            if (z) {
              let ue;
              ue = U ? h("!=", le, j()) : I("&&", h("!==", le, j()), h("!==", E(X), K.buildUndefinedNode())), ae.replaceWith(I("&&", ue, oe));
            } else {
              let ue;
              ue = U ? h("==", le, j()) : I("||", h("===", le, j()), h("===", E(X), K.buildUndefinedNode())), ae.replaceWith(S(ue, $ ? y(!0) : K.buildUndefinedNode(), oe));
            }
            if (de) {
              const ue = re.node;
              re.replaceWith(F(_(ue.callee, g("call"), !1, !0), [E(de), ...ue.arguments], !1));
            }
          } else {
            if (C(B, { argument: M })) {
              if (this.simpleSet)
                return void W.replaceWith(this.simpleSet(W));
              const { operator: te, prefix: z } = B;
              this.memoise(W, 2);
              const q = K.generateUidIdentifierBasedOnNode(M);
              K.push({ id: q });
              const $ = [m("=", E(q), this.get(W))];
              if (z) {
                $.push(v(te, E(q), z));
                const Y = T($);
                return void k.replaceWith(this.set(W, Y));
              }
              {
                const Y = K.generateUidIdentifierBasedOnNode(M);
                K.push({ id: Y }), $.push(m("=", E(Y), v(te, E(q), z)), E(q));
                const H = T($);
                return void k.replaceWith(T([this.set(W, H), E(Y)]));
              }
            }
            if (k.isAssignmentExpression({ left: M })) {
              if (this.simpleSet)
                return void W.replaceWith(this.simpleSet(W));
              const { operator: te, right: z } = k.node;
              if (te === "=")
                k.replaceWith(this.set(W, z));
              else {
                const q = te.slice(0, -1);
                s.includes(q) ? (this.memoise(W, 1), k.replaceWith(I(q, this.get(W), this.set(W, z)))) : (this.memoise(W, 2), k.replaceWith(this.set(W, h(q, this.get(W), z))));
              }
            } else {
              if (!k.isCallExpression({ callee: M }))
                return k.isOptionalCallExpression({ callee: M }) ? K.path.isPattern() ? void k.replaceWith(b(o([], k.node), [])) : void k.replaceWith(this.optionalCall(W, k.node.arguments)) : void (this.delete && k.isUnaryExpression({ operator: "delete" }) ? k.replaceWith(this.delete(W)) : k.isForXStatement({ left: M }) || k.isObjectProperty({ value: M }) && k.parentPath.isObjectPattern() || k.isAssignmentPattern({ left: M }) && k.parentPath.isObjectProperty({ value: B }) && k.parentPath.parentPath.isObjectPattern() || k.isArrayPattern() || k.isAssignmentPattern({ left: M }) && k.parentPath.isArrayPattern() || k.isRestElement() ? W.replaceWith(this.destructureSet(W)) : k.isTaggedTemplateExpression() ? W.replaceWith(this.boundGet(W)) : W.replaceWith(this.get(W)));
              k.replaceWith(this.call(W, k.node.arguments));
            }
          }
        } };
        r.default = function(W, U, M) {
          W.traverse(U, Object.assign({}, G, M, { memoiser: new w() }));
        };
      }, "./node_modules/.pnpm/@babel+helper-module-imports@7.22.15/node_modules/@babel/helper-module-imports/lib/import-builder.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("assert"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { callExpression: d, cloneNode: s, expressionStatement: o, identifier: m, importDeclaration: h, importDefaultSpecifier: y, importNamespaceSpecifier: b, importSpecifier: E, memberExpression: S, stringLiteral: g, variableDeclaration: P, variableDeclarator: R } = f;
        r.default = class {
          constructor(N, C, I) {
            this._statements = [], this._resultName = null, this._importedSource = void 0, this._scope = C, this._hub = I, this._importedSource = N;
          }
          done() {
            return { statements: this._statements, resultName: this._resultName };
          }
          import() {
            return this._statements.push(h([], g(this._importedSource))), this;
          }
          require() {
            return this._statements.push(o(d(m("require"), [g(this._importedSource)]))), this;
          }
          namespace(N = "namespace") {
            const C = this._scope.generateUidIdentifier(N), I = this._statements[this._statements.length - 1];
            return i(I.type === "ImportDeclaration"), i(I.specifiers.length === 0), I.specifiers = [b(C)], this._resultName = s(C), this;
          }
          default(N) {
            const C = this._scope.generateUidIdentifier(N), I = this._statements[this._statements.length - 1];
            return i(I.type === "ImportDeclaration"), i(I.specifiers.length === 0), I.specifiers = [y(C)], this._resultName = s(C), this;
          }
          named(N, C) {
            if (C === "default")
              return this.default(N);
            const I = this._scope.generateUidIdentifier(N), D = this._statements[this._statements.length - 1];
            return i(D.type === "ImportDeclaration"), i(D.specifiers.length === 0), D.specifiers = [E(I, m(C))], this._resultName = s(I), this;
          }
          var(N) {
            const C = this._scope.generateUidIdentifier(N);
            let I = this._statements[this._statements.length - 1];
            return I.type !== "ExpressionStatement" && (i(this._resultName), I = o(this._resultName), this._statements.push(I)), this._statements[this._statements.length - 1] = P("var", [R(C, I.expression)]), this._resultName = s(C), this;
          }
          defaultInterop() {
            return this._interop(this._hub.addHelper("interopRequireDefault"));
          }
          wildcardInterop() {
            return this._interop(this._hub.addHelper("interopRequireWildcard"));
          }
          _interop(N) {
            const C = this._statements[this._statements.length - 1];
            return C.type === "ExpressionStatement" ? C.expression = d(N, [C.expression]) : C.type === "VariableDeclaration" ? (i(C.declarations.length === 1), C.declarations[0].init = d(N, [C.declarations[0].init])) : i.fail("Unexpected type."), this;
          }
          prop(N) {
            const C = this._statements[this._statements.length - 1];
            return C.type === "ExpressionStatement" ? C.expression = S(C.expression, m(N)) : C.type === "VariableDeclaration" ? (i(C.declarations.length === 1), C.declarations[0].init = S(C.declarations[0].init, m(N))) : i.fail("Unexpected type:" + C.type), this;
          }
          read(N) {
            this._resultName = S(this._resultName, m(N));
          }
        };
      }, "./node_modules/.pnpm/@babel+helper-module-imports@7.22.15/node_modules/@babel/helper-module-imports/lib/import-injector.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("assert"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js"), d = l("./node_modules/.pnpm/@babel+helper-module-imports@7.22.15/node_modules/@babel/helper-module-imports/lib/import-builder.js"), s = l("./node_modules/.pnpm/@babel+helper-module-imports@7.22.15/node_modules/@babel/helper-module-imports/lib/is-module.js");
        const { numericLiteral: o, sequenceExpression: m } = f;
        r.default = class {
          constructor(h, y, b) {
            this._defaultOpts = { importedSource: null, importedType: "commonjs", importedInterop: "babel", importingInterop: "babel", ensureLiveReference: !1, ensureNoContext: !1, importPosition: "before" };
            const E = h.find((S) => S.isProgram());
            this._programPath = E, this._programScope = E.scope, this._hub = E.hub, this._defaultOpts = this._applyDefaults(y, b, !0);
          }
          addDefault(h, y) {
            return this.addNamed("default", h, y);
          }
          addNamed(h, y, b) {
            return i(typeof h == "string"), this._generateImport(this._applyDefaults(y, b), h);
          }
          addNamespace(h, y) {
            return this._generateImport(this._applyDefaults(h, y), null);
          }
          addSideEffect(h, y) {
            return this._generateImport(this._applyDefaults(h, y), void 0);
          }
          _applyDefaults(h, y, b = !1) {
            let E;
            return typeof h == "string" ? E = Object.assign({}, this._defaultOpts, { importedSource: h }, y) : (i(!y, "Unexpected secondary arguments."), E = Object.assign({}, this._defaultOpts, h)), !b && y && (y.nameHint !== void 0 && (E.nameHint = y.nameHint), y.blockHoist !== void 0 && (E.blockHoist = y.blockHoist)), E;
          }
          _generateImport(h, y) {
            const b = y === "default", E = !!y && !b, S = y === null, { importedSource: g, importedType: P, importedInterop: R, importingInterop: N, ensureLiveReference: C, ensureNoContext: I, nameHint: D, importPosition: j, blockHoist: F } = h;
            let _ = D || y;
            const T = (0, s.default)(this._programPath), v = T && N === "node", w = T && N === "babel";
            if (j === "after" && !T)
              throw new Error('"importPosition": "after" is only supported in modules');
            const O = new d.default(g, this._programScope, this._hub);
            if (P === "es6") {
              if (!v && !w)
                throw new Error("Cannot import an ES6 module from CommonJS");
              O.import(), S ? O.namespace(D || g) : (b || E) && O.named(_, y);
            } else {
              if (P !== "commonjs")
                throw new Error(`Unexpected interopType "${P}"`);
              if (R === "babel")
                if (v) {
                  _ = _ !== "default" ? _ : g;
                  const U = `${g}$es6Default`;
                  O.import(), S ? O.default(U).var(_ || g).wildcardInterop() : b ? C ? O.default(U).var(_ || g).defaultInterop().read("default") : O.default(U).var(_).defaultInterop().prop(y) : E && O.default(U).read(y);
                } else
                  w ? (O.import(), S ? O.namespace(_ || g) : (b || E) && O.named(_, y)) : (O.require(), S ? O.var(_ || g).wildcardInterop() : (b || E) && C ? b ? (_ = _ !== "default" ? _ : g, O.var(_).read(y), O.defaultInterop()) : O.var(g).read(y) : b ? O.var(_).defaultInterop().prop(y) : E && O.var(_).prop(y));
              else if (R === "compiled")
                v ? (O.import(), S ? O.default(_ || g) : (b || E) && O.default(g).read(_)) : w ? (O.import(), S ? O.namespace(_ || g) : (b || E) && O.named(_, y)) : (O.require(), S ? O.var(_ || g) : (b || E) && (C ? O.var(g).read(_) : O.prop(y).var(_)));
              else {
                if (R !== "uncompiled")
                  throw new Error(`Unknown importedInterop "${R}".`);
                if (b && C)
                  throw new Error("No live reference for commonjs default");
                v ? (O.import(), S ? O.default(_ || g) : b ? O.default(_) : E && O.default(g).read(_)) : w ? (O.import(), S ? O.default(_ || g) : b ? O.default(_) : E && O.named(_, y)) : (O.require(), S ? O.var(_ || g) : b ? O.var(_) : E && (C ? O.var(g).read(_) : O.var(_).prop(y)));
              }
            }
            const { statements: G, resultName: W } = O.done();
            return this._insertStatements(G, j, F), (b || E) && I && W.type !== "Identifier" ? m([o(0), W]) : W;
          }
          _insertStatements(h, y = "before", b = 3) {
            const E = this._programPath.get("body");
            if (y === "after") {
              for (let S = E.length - 1; S >= 0; S--)
                if (E[S].isImportDeclaration())
                  return void E[S].insertAfter(h);
            } else {
              h.forEach((g) => {
                g._blockHoist = b;
              });
              const S = E.find((g) => {
                const P = g.node._blockHoist;
                return Number.isFinite(P) && P < 4;
              });
              if (S)
                return void S.insertBefore(h);
            }
            this._programPath.unshiftContainer("body", h);
          }
        };
      }, "./node_modules/.pnpm/@babel+helper-module-imports@7.22.15/node_modules/@babel/helper-module-imports/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), Object.defineProperty(r, "ImportInjector", { enumerable: !0, get: function() {
          return i.default;
        } }), r.addDefault = function(d, s, o) {
          return new i.default(d).addDefault(s, o);
        }, r.addNamed = function(d, s, o, m) {
          return new i.default(d).addNamed(s, o, m);
        }, r.addNamespace = function(d, s, o) {
          return new i.default(d).addNamespace(s, o);
        }, r.addSideEffect = function(d, s, o) {
          return new i.default(d).addSideEffect(s, o);
        }, Object.defineProperty(r, "isModule", { enumerable: !0, get: function() {
          return f.default;
        } });
        var i = l("./node_modules/.pnpm/@babel+helper-module-imports@7.22.15/node_modules/@babel/helper-module-imports/lib/import-injector.js"), f = l("./node_modules/.pnpm/@babel+helper-module-imports@7.22.15/node_modules/@babel/helper-module-imports/lib/is-module.js");
      }, "./node_modules/.pnpm/@babel+helper-module-imports@7.22.15/node_modules/@babel/helper-module-imports/lib/is-module.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(l) {
          return l.node.sourceType === "module";
        };
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.buildDynamicImport = function(f, d, s, o) {
          const [m] = f.arguments;
          if (i.types.isStringLiteral(m) || i.types.isTemplateLiteral(m) && m.quasis.length === 0)
            return d ? i.template.expression.ast`
        Promise.resolve().then(() => ${o(m)})
      ` : o(m);
          const h = i.types.isTemplateLiteral(m) ? i.types.identifier("specifier") : i.types.templateLiteral([i.types.templateElement({ raw: "" }), i.types.templateElement({ raw: "" })], [i.types.identifier("specifier")]);
          return d ? i.template.expression.ast`
      (specifier =>
        new Promise(r => r(${h}))
          .then(s => ${o(i.types.identifier("s"))})
      )(${m})
    ` : s ? i.template.expression.ast`
      (specifier =>
        new Promise(r => r(${o(h)}))
      )(${m})
    ` : i.template.expression.ast`
      (specifier => ${o(h)})(${m})
    `;
        };
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js");
        r.getDynamicImportSource = function(f) {
          const [d] = f.arguments;
          return i.types.isStringLiteral(d) || i.types.isTemplateLiteral(d) ? d : i.template.expression.ast`\`\${${d}}\``;
        };
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-module-transforms/lib/get-module-name.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = l;
        {
          const i = l;
          r.default = l = function(f, d) {
            var s, o, m, h;
            return i(f, { moduleId: (s = d.moduleId) != null ? s : f.moduleId, moduleIds: (o = d.moduleIds) != null ? o : f.moduleIds, getModuleId: (m = d.getModuleId) != null ? m : f.getModuleId, moduleRoot: (h = d.moduleRoot) != null ? h : f.moduleRoot });
          };
        }
        function l(i, f) {
          const { filename: d, filenameRelative: s = d, sourceRoot: o = f.moduleRoot } = i, { moduleId: m, moduleIds: h = !!m, getModuleId: y, moduleRoot: b = o } = f;
          if (!h)
            return null;
          if (m != null && !y)
            return m;
          let E = b != null ? b + "/" : "";
          if (s) {
            const S = o != null ? new RegExp("^" + o + "/?") : "";
            E += s.replace(S, "").replace(/\.(\w*?)$/, "");
          }
          return E = E.replace(/\\/g, "/"), y && y(E) || E;
        }
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-module-transforms/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), Object.defineProperty(r, "buildDynamicImport", { enumerable: !0, get: function() {
          return h.buildDynamicImport;
        } }), r.buildNamespaceInitStatements = function(G, W, U = !1) {
          const M = [];
          let B = N(W.name);
          W.lazy && (B = E(B, []));
          for (const k of W.importsNamespace)
            k !== W.name && M.push(f.template.statement`var NAME = SOURCE;`({ NAME: k, SOURCE: S(B) }));
          U && M.push(...v(G, W, !0));
          for (const k of W.reexportNamespace)
            M.push((W.lazy ? f.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          ` : f.template.statement`EXPORTS.NAME = NAMESPACE;`)({ EXPORTS: G.exportName, NAME: k, NAMESPACE: S(B) }));
          if (W.reexportAll) {
            const k = function(K, te, z) {
              return (z ? f.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : f.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({ NAMESPACE: te, EXPORTS: K.exportName, VERIFY_NAME_LIST: K.exportNameListName ? f.template`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({ EXPORTS_LIST: K.exportNameListName }) : null });
            }(G, S(B), U);
            k.loc = W.reexportAll.loc, M.push(k);
          }
          return M;
        }, r.ensureStatementsHoisted = function(G) {
          G.forEach((W) => {
            W._blockHoist = 3;
          });
        }, Object.defineProperty(r, "getModuleName", { enumerable: !0, get: function() {
          return y.default;
        } }), Object.defineProperty(r, "hasExports", { enumerable: !0, get: function() {
          return m.hasExports;
        } }), Object.defineProperty(r, "isModule", { enumerable: !0, get: function() {
          return d.isModule;
        } }), Object.defineProperty(r, "isSideEffectImport", { enumerable: !0, get: function() {
          return m.isSideEffectImport;
        } }), r.rewriteModuleStatementsAndPrepareHeader = function(G, { exportName: W, strict: U, allowTopLevelThis: M, strictMode: B, noInterop: k, importInterop: K = k ? "none" : "babel", lazy: te, esNamespaceOnly: z, filename: q, constantReexports: $ = arguments[1].loose, enumerableModuleMeta: Y = arguments[1].loose, noIncompleteNsImportDetection: H }) {
          (0, m.validateImportInteropOption)(K), i((0, d.isModule)(G), "Cannot process module statements in a script"), G.node.sourceType = "script";
          const Q = (0, m.default)(G, W, { importInterop: K, initializeReexports: $, lazy: te, esNamespaceOnly: z, filename: q });
          M || (0, s.default)(G), (0, o.default)(G, Q), B !== !1 && (G.node.directives.some((ve) => ve.value.value === "use strict") || G.unshiftContainer("directives", g(P("use strict"))));
          const X = [];
          (0, m.hasExports)(Q) && !U && X.push(function(ye, ve = !1) {
            return (ve ? f.template.statement`
        EXPORTS.__esModule = true;
      ` : f.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({ EXPORTS: ye.exportName });
          }(Q, Y));
          const ne = function(ye, ve) {
            const de = /* @__PURE__ */ Object.create(null);
            for (const ae of ve.local.values())
              for (const le of ae.names)
                de[le] = !0;
            let oe = !1;
            for (const ae of ve.source.values()) {
              for (const le of ae.reexports.keys())
                de[le] = !0;
              for (const le of ae.reexportNamespace)
                de[le] = !0;
              oe = oe || !!ae.reexportAll;
            }
            if (!oe || Object.keys(de).length === 0)
              return null;
            const re = ye.scope.generateUidIdentifier("exportNames");
            return delete de.default, { name: re.name, statement: F("var", [_(re, j(de))]) };
          }(G, Q);
          return ne && (Q.exportNameListName = ne.name, X.push(ne.statement)), X.push(...function(ye, ve, de = !1, oe = !1) {
            const re = [];
            for (const [le, ue] of ve.local)
              if (ue.kind !== "import") {
                if (ue.kind === "hoisted")
                  re.push([ue.names[0], O(ve, ue.names, N(le))]);
                else if (!oe)
                  for (const ie of ue.names)
                    re.push([ie, null]);
              }
            for (const le of ve.source.values()) {
              if (!de) {
                const ue = v(ve, le, !1), ie = [...le.reexports.keys()];
                for (let we = 0; we < ue.length; we++)
                  re.push([ie[we], ue[we]]);
              }
              if (!oe)
                for (const ue of le.reexportNamespace)
                  re.push([ue, null]);
            }
            re.sort(([le], [ue]) => le < ue ? -1 : ue < le ? 1 : 0);
            const ae = [];
            if (oe)
              for (const [, le] of re)
                ae.push(le);
            else
              for (let ue = 0; ue < re.length; ue += 100) {
                let ie = [];
                for (let we = 0; we < 100 && ue + we < re.length; we++) {
                  const [De, Ee] = re[ue + we];
                  Ee !== null ? (ie.length > 0 && (ae.push(O(ve, ie, ye.scope.buildUndefinedNode())), ie = []), ae.push(Ee)) : ie.push(De);
                }
                ie.length > 0 && ae.push(O(ve, ie, ye.scope.buildUndefinedNode()));
              }
            return ae;
          }(G, Q, $, H)), { meta: Q, headers: X };
        }, Object.defineProperty(r, "rewriteThis", { enumerable: !0, get: function() {
          return s.default;
        } }), r.wrapInterop = function(G, W, U) {
          if (U === "none")
            return null;
          if (U === "node-namespace")
            return E(G.hub.addHelper("interopRequireWildcard"), [W, b(!0)]);
          if (U === "node-default")
            return null;
          let M;
          if (U === "default")
            M = "interopRequireDefault";
          else {
            if (U !== "namespace")
              throw new Error(`Unknown interop: ${U}`);
            M = "interopRequireWildcard";
          }
          return E(G.hub.addHelper(M), [W]);
        };
        var i = l("assert"), f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js"), d = l("./node_modules/.pnpm/@babel+helper-module-imports@7.22.15/node_modules/@babel/helper-module-imports/lib/index.js"), s = l("./node_modules/.pnpm/@babel+helper-module-transforms@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-module-transforms/lib/rewrite-this.js"), o = l("./node_modules/.pnpm/@babel+helper-module-transforms@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js"), m = l("./node_modules/.pnpm/@babel+helper-module-transforms@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js"), h = l("./node_modules/.pnpm/@babel+helper-module-transforms@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js"), y = l("./node_modules/.pnpm/@babel+helper-module-transforms@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-module-transforms/lib/get-module-name.js");
        const { booleanLiteral: b, callExpression: E, cloneNode: S, directive: g, directiveLiteral: P, expressionStatement: R, identifier: N, isIdentifier: C, memberExpression: I, stringLiteral: D, valueToNode: j, variableDeclaration: F, variableDeclarator: _ } = f.types;
        r.getDynamicImportSource = l("./node_modules/.pnpm/@babel+helper-module-transforms@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js").getDynamicImportSource;
        const T = { constant: f.template.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`, constantComputed: f.template.statement`EXPORTS["EXPORT_NAME"] = NAMESPACE_IMPORT;`, spec: f.template.statement`
    Object.defineProperty(EXPORTS, "EXPORT_NAME", {
      enumerable: true,
      get: function() {
        return NAMESPACE_IMPORT;
      },
    });
    ` };
        function v(G, W, U) {
          const M = W.lazy ? E(N(W.name), []) : N(W.name), { stringSpecifiers: B } = G;
          return Array.from(W.reexports, ([k, K]) => {
            let te = S(M);
            K === "default" && W.interop === "node-default" || (te = B.has(K) ? I(te, D(K), !0) : I(te, N(K)));
            const z = { EXPORTS: G.exportName, EXPORT_NAME: k, NAMESPACE_IMPORT: te };
            return U || C(te) ? B.has(k) ? T.constantComputed(z) : T.constant(z) : T.spec(z);
          });
        }
        const w = { computed: f.template.expression`EXPORTS["NAME"] = VALUE`, default: f.template.expression`EXPORTS.NAME = VALUE` };
        function O(G, W, U) {
          const { stringSpecifiers: M, exportName: B } = G;
          return R(W.reduce((k, K) => {
            const te = { EXPORTS: B, NAME: K, VALUE: k };
            return M.has(K) ? w.computed(te) : w.default(te);
          }, U));
        }
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(b, E, { importInterop: S, initializeReexports: g = !1, lazy: P = !1, esNamespaceOnly: R = !1, filename: N }) {
          E || (E = b.scope.generateUidIdentifier("exports").name);
          const C = /* @__PURE__ */ new Set();
          (function(F) {
            F.get("body").forEach((_) => {
              _.isExportDefaultDeclaration() && (0, d.default)(_);
            });
          })(b);
          const { local: I, sources: D, hasExports: j } = function(F, { lazy: _, initializeReexports: T }, v) {
            const w = function(U, M, B) {
              const k = /* @__PURE__ */ new Map();
              U.get("body").forEach((z) => {
                let q;
                if (z.isImportDeclaration())
                  q = "import";
                else {
                  if (z.isExportDefaultDeclaration() && (z = z.get("declaration")), z.isExportNamedDeclaration()) {
                    if (z.node.declaration)
                      z = z.get("declaration");
                    else if (M && z.node.source && z.get("source").isStringLiteral())
                      return void z.get("specifiers").forEach(($) => {
                        y($), k.set($.get("local").node.name, "block");
                      });
                  }
                  if (z.isFunctionDeclaration())
                    q = "hoisted";
                  else if (z.isClassDeclaration())
                    q = "block";
                  else if (z.isVariableDeclaration({ kind: "var" }))
                    q = "var";
                  else {
                    if (!z.isVariableDeclaration())
                      return;
                    q = "block";
                  }
                }
                Object.keys(z.getOuterBindingIdentifiers()).forEach(($) => {
                  k.set($, q);
                });
              });
              const K = /* @__PURE__ */ new Map(), te = (z) => {
                const q = z.node.name;
                let $ = K.get(q);
                if (!$) {
                  const Y = k.get(q);
                  if (Y === void 0)
                    throw z.buildCodeFrameError(`Exporting local "${q}", which is not declared.`);
                  $ = { names: [], kind: Y }, K.set(q, $);
                }
                return $;
              };
              return U.get("body").forEach((z) => {
                if (!z.isExportNamedDeclaration() || !M && z.node.source) {
                  if (z.isExportDefaultDeclaration()) {
                    const q = z.get("declaration");
                    if (!q.isFunctionDeclaration() && !q.isClassDeclaration())
                      throw q.buildCodeFrameError("Unexpected default expression export.");
                    te(q.get("id")).names.push("default");
                  }
                } else if (z.node.declaration) {
                  const q = z.get("declaration"), $ = q.getOuterBindingIdentifierPaths();
                  Object.keys($).forEach((Y) => {
                    if (Y === "__esModule")
                      throw q.buildCodeFrameError('Illegal export "__esModule".');
                    te($[Y]).names.push(Y);
                  });
                } else
                  z.get("specifiers").forEach((q) => {
                    const $ = q.get("local"), Y = q.get("exported"), H = te($), Q = h(Y, B);
                    if (Q === "__esModule")
                      throw Y.buildCodeFrameError('Illegal export "__esModule".');
                    H.names.push(Q);
                  });
              }), K;
            }(F, T, v), O = /* @__PURE__ */ new Map(), G = (U) => {
              const M = U.value;
              let B = O.get(M);
              return B || (B = { name: F.scope.generateUidIdentifier((0, i.basename)(M, (0, i.extname)(M))).name, interop: "none", loc: null, imports: /* @__PURE__ */ new Map(), importsNamespace: /* @__PURE__ */ new Set(), reexports: /* @__PURE__ */ new Map(), reexportNamespace: /* @__PURE__ */ new Set(), reexportAll: null, lazy: !1, referenced: !1 }, O.set(M, B)), B;
            };
            let W = !1;
            F.get("body").forEach((U) => {
              if (U.isImportDeclaration()) {
                const M = G(U.node.source);
                M.loc || (M.loc = U.node.loc), U.get("specifiers").forEach((B) => {
                  if (B.isImportDefaultSpecifier()) {
                    const k = B.get("local").node.name;
                    M.imports.set(k, "default");
                    const K = w.get(k);
                    K && (w.delete(k), K.names.forEach((te) => {
                      M.reexports.set(te, "default");
                    }), M.referenced = !0);
                  } else if (B.isImportNamespaceSpecifier()) {
                    const k = B.get("local").node.name;
                    M.importsNamespace.add(k);
                    const K = w.get(k);
                    K && (w.delete(k), K.names.forEach((te) => {
                      M.reexportNamespace.add(te);
                    }), M.referenced = !0);
                  } else if (B.isImportSpecifier()) {
                    const k = h(B.get("imported"), v), K = B.get("local").node.name;
                    M.imports.set(K, k);
                    const te = w.get(K);
                    te && (w.delete(K), te.names.forEach((z) => {
                      M.reexports.set(z, k);
                    }), M.referenced = !0);
                  }
                });
              } else if (U.isExportAllDeclaration()) {
                W = !0;
                const M = G(U.node.source);
                M.loc || (M.loc = U.node.loc), M.reexportAll = { loc: U.node.loc }, M.referenced = !0;
              } else if (U.isExportNamedDeclaration() && U.node.source) {
                W = !0;
                const M = G(U.node.source);
                M.loc || (M.loc = U.node.loc), U.get("specifiers").forEach((B) => {
                  y(B);
                  const k = h(B.get("local"), v), K = h(B.get("exported"), v);
                  if (M.reexports.set(K, k), M.referenced = !0, K === "__esModule")
                    throw B.get("exported").buildCodeFrameError('Illegal export "__esModule".');
                });
              } else
                (U.isExportNamedDeclaration() || U.isExportDefaultDeclaration()) && (W = !0);
            });
            for (const U of O.values()) {
              let M = !1, B = !1;
              U.importsNamespace.size > 0 && (M = !0, B = !0), U.reexportAll && (B = !0);
              for (const k of U.imports.values())
                k === "default" ? M = !0 : B = !0;
              for (const k of U.reexports.values())
                k === "default" ? M = !0 : B = !0;
              M && B ? U.interop = "namespace" : M && (U.interop = "default");
            }
            for (const [U, M] of O)
              if (_ !== !1 && !s(M) && !M.reexportAll)
                if (_ === !0)
                  M.lazy = !/\./.test(U);
                else if (Array.isArray(_))
                  M.lazy = _.indexOf(U) !== -1;
                else {
                  if (typeof _ != "function")
                    throw new Error(".lazy must be a boolean, string array, or function");
                  M.lazy = _(U);
                }
            return { hasExports: W, local: w, sources: O };
          }(b, { initializeReexports: g, lazy: P }, C);
          (function(F) {
            F.get("body").forEach((_) => {
              if (_.isImportDeclaration())
                _.remove();
              else if (_.isExportNamedDeclaration())
                _.node.declaration ? (_.node.declaration._blockHoist = _.node._blockHoist, _.replaceWith(_.node.declaration)) : _.remove();
              else if (_.isExportDefaultDeclaration()) {
                const T = _.get("declaration");
                if (!T.isFunctionDeclaration() && !T.isClassDeclaration())
                  throw T.buildCodeFrameError("Unexpected default expression export.");
                T._blockHoist = _.node._blockHoist, _.replaceWith(T);
              } else
                _.isExportAllDeclaration() && _.remove();
            });
          })(b);
          for (const [F, _] of D) {
            _.importsNamespace.size > 0 && (_.name = _.importsNamespace.values().next().value);
            const T = m(S, F, N);
            T === "none" ? _.interop = "none" : T === "node" && _.interop === "namespace" ? _.interop = "node-namespace" : T === "node" && _.interop === "default" ? _.interop = "node-default" : R && _.interop === "namespace" && (_.interop = "default");
          }
          return { exportName: E, exportNameListName: null, hasExports: j, local: I, source: D, stringSpecifiers: C };
        }, r.hasExports = function(b) {
          return b.hasExports;
        }, r.isSideEffectImport = s, r.validateImportInteropOption = o;
        var i = l("path"), f = l("./node_modules/.pnpm/@babel+helper-validator-identifier@7.22.15/node_modules/@babel/helper-validator-identifier/lib/index.js"), d = l("./node_modules/.pnpm/@babel+helper-split-export-declaration@7.22.6/node_modules/@babel/helper-split-export-declaration/lib/index.js");
        function s(b) {
          return b.imports.size === 0 && b.importsNamespace.size === 0 && b.reexports.size === 0 && b.reexportNamespace.size === 0 && !b.reexportAll;
        }
        function o(b) {
          if (typeof b != "function" && b !== "none" && b !== "babel" && b !== "node")
            throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${b}).`);
          return b;
        }
        function m(b, E, S) {
          return typeof b == "function" ? o(b(E, S)) : b;
        }
        function h(b, E) {
          if (b.isIdentifier())
            return b.node.name;
          if (b.isStringLiteral()) {
            const S = b.node.value;
            return (0, f.isIdentifierName)(S) || E.add(S), S;
          }
          throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${b.node.type}`);
        }
        function y(b) {
          if (!b.isExportSpecifier())
            throw b.isExportNamespaceSpecifier() ? b.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.") : b.buildCodeFrameError("Unexpected export specifier type");
        }
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(w, O) {
          const G = /* @__PURE__ */ new Map(), W = /* @__PURE__ */ new Map(), U = (K) => {
            w.requeue(K);
          };
          for (const [K, te] of O.source) {
            for (const [z, q] of te.imports)
              G.set(z, [K, q, null]);
            for (const z of te.importsNamespace)
              G.set(z, [K, null, z]);
          }
          for (const [K, te] of O.local) {
            let z = W.get(K);
            z || (z = [], W.set(K, z)), z.push(...te.names);
          }
          const M = { metadata: O, requeueInParent: U, scope: w.scope, exported: W };
          w.traverse(F, M);
          const B = /* @__PURE__ */ new Set([...Array.from(G.keys()), ...Array.from(W.keys())]);
          (0, d.default)(w, B, !1);
          const k = { seen: /* @__PURE__ */ new WeakSet(), metadata: O, requeueInParent: U, scope: w.scope, imported: G, exported: W, buildImportReference: ([K, te, z], q) => {
            const $ = O.source.get(K);
            if ($.referenced = !0, z)
              return $.lazy && (q = o(q, [])), q;
            let Y = b($.name);
            if ($.lazy && (Y = o(Y, [])), te === "default" && $.interop === "node-default")
              return Y;
            const H = O.stringSpecifiers.has(te);
            return R(Y, H ? I(te) : b(te), H);
          } };
          w.traverse(v, k);
        };
        var i = l("assert"), f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js"), d = l("./node_modules/.pnpm/@babel+helper-simple-access@7.22.5/node_modules/@babel/helper-simple-access/lib/index.js");
        const { assignmentExpression: s, callExpression: o, cloneNode: m, expressionStatement: h, getOuterBindingIdentifiers: y, identifier: b, isMemberExpression: E, isVariableDeclaration: S, jsxIdentifier: g, jsxMemberExpression: P, memberExpression: R, numericLiteral: N, sequenceExpression: C, stringLiteral: I, variableDeclaration: D, variableDeclarator: j } = f.types, F = { Scope(w) {
          w.skip();
        }, ClassDeclaration(w) {
          const { requeueInParent: O, exported: G, metadata: W } = this, { id: U } = w.node;
          if (!U)
            throw new Error("Expected class to have a name");
          const M = U.name, B = G.get(M) || [];
          if (B.length > 0) {
            const k = h(_(W, B, b(M), w.scope));
            k._blockHoist = w.node._blockHoist, O(w.insertAfter(k)[0]);
          }
        }, VariableDeclaration(w) {
          const { requeueInParent: O, exported: G, metadata: W } = this;
          Object.keys(w.getOuterBindingIdentifiers()).forEach((U) => {
            const M = G.get(U) || [];
            if (M.length > 0) {
              const B = h(_(W, M, b(U), w.scope));
              B._blockHoist = w.node._blockHoist, O(w.insertAfter(B)[0]);
            }
          });
        } }, _ = (w, O, G, W) => {
          const U = w.exportName;
          for (let M = W; M != null; M = M.parent)
            M.hasOwnBinding(U) && M.rename(U);
          return (O || []).reduce((M, B) => {
            const { stringSpecifiers: k } = w, K = k.has(B);
            return s("=", R(b(U), K ? I(B) : b(B), K), M);
          }, G);
        }, T = (w) => f.template.expression.ast`
    (function() {
      throw new Error('"' + '${w}' + '" is read-only.');
    })()
  `, v = { ReferencedIdentifier(w) {
          const { seen: O, buildImportReference: G, scope: W, imported: U, requeueInParent: M } = this;
          if (O.has(w.node))
            return;
          O.add(w.node);
          const B = w.node.name, k = U.get(B);
          if (k) {
            if (function(z) {
              do
                switch (z.parent.type) {
                  case "TSTypeAnnotation":
                  case "TSTypeAliasDeclaration":
                  case "TSTypeReference":
                  case "TypeAnnotation":
                  case "TypeAlias":
                    return !0;
                  case "ExportSpecifier":
                    return z.parentPath.parent.exportKind === "type";
                  default:
                    if (z.parentPath.isStatement() || z.parentPath.isExpression())
                      return !1;
                }
              while (z = z.parentPath);
            }(w))
              throw w.buildCodeFrameError(`Cannot transform the imported binding "${B}" since it's also used in a type annotation. Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);
            const K = w.scope.getBinding(B);
            if (W.getBinding(B) !== K)
              return;
            const te = G(k, w.node);
            if (te.loc = w.node.loc, (w.parentPath.isCallExpression({ callee: w.node }) || w.parentPath.isOptionalCallExpression({ callee: w.node }) || w.parentPath.isTaggedTemplateExpression({ tag: w.node })) && E(te))
              w.replaceWith(C([N(0), te]));
            else if (w.isJSXIdentifier() && E(te)) {
              const { object: z, property: q } = te;
              w.replaceWith(P(g(z.name), g(q.name)));
            } else
              w.replaceWith(te);
            M(w), w.skip();
          }
        }, UpdateExpression(w) {
          const { scope: O, seen: G, imported: W, exported: U, requeueInParent: M, buildImportReference: B } = this;
          if (G.has(w.node))
            return;
          G.add(w.node);
          const k = w.get("argument");
          if (k.isMemberExpression())
            return;
          const K = w.node;
          if (k.isIdentifier()) {
            const te = k.node.name;
            if (O.getBinding(te) !== w.scope.getBinding(te))
              return;
            const z = U.get(te), q = W.get(te);
            if ((z == null ? void 0 : z.length) > 0 || q)
              if (q)
                w.replaceWith(s(K.operator[0] + "=", B(q, k.node), T(te)));
              else if (K.prefix)
                w.replaceWith(_(this.metadata, z, m(K), w.scope));
              else {
                const $ = O.generateDeclaredUidIdentifier(te);
                w.replaceWith(C([s("=", m($), m(K)), _(this.metadata, z, b(te), w.scope), m($)]));
              }
          }
          M(w), w.skip();
        }, AssignmentExpression: { exit(w) {
          const { scope: O, seen: G, imported: W, exported: U, requeueInParent: M, buildImportReference: B } = this;
          if (G.has(w.node))
            return;
          G.add(w.node);
          const k = w.get("left");
          if (!k.isMemberExpression())
            if (k.isIdentifier()) {
              const K = k.node.name;
              if (O.getBinding(K) !== w.scope.getBinding(K))
                return;
              const te = U.get(K), z = W.get(K);
              if ((te == null ? void 0 : te.length) > 0 || z) {
                i(w.node.operator === "=", "Path was not simplified");
                const q = w.node;
                z && (q.left = B(z, k.node), q.right = C([q.right, T(K)])), w.replaceWith(_(this.metadata, te, q, w.scope)), M(w);
              }
            } else {
              const K = k.getOuterBindingIdentifiers(), te = Object.keys(K).filter(($) => O.getBinding($) === w.scope.getBinding($)), z = te.find(($) => W.has($));
              z && (w.node.right = C([w.node.right, T(z)]));
              const q = [];
              if (te.forEach(($) => {
                const Y = U.get($) || [];
                Y.length > 0 && q.push(_(this.metadata, Y, b($), w.scope));
              }), q.length > 0) {
                let $ = C(q);
                w.parentPath.isExpressionStatement() && ($ = h($), $._blockHoist = w.parentPath.node._blockHoist), M(w.insertAfter($)[0]);
              }
            }
        } }, "ForOfStatement|ForInStatement"(w) {
          const { scope: O, node: G } = w, { left: W } = G, { exported: U, imported: M, scope: B } = this;
          if (!S(W)) {
            let k, K = !1;
            const te = w.get("body").scope;
            for (const $ of Object.keys(y(W)))
              B.getBinding($) === O.getBinding($) && (U.has($) && (K = !0, te.hasOwnBinding($) && te.rename($)), M.has($) && !k && (k = $));
            if (!K && !k)
              return;
            w.ensureBlock();
            const z = w.get("body"), q = O.generateUidIdentifierBasedOnNode(W);
            w.get("left").replaceWith(D("let", [j(m(q))])), O.registerDeclaration(w.get("left")), K && z.unshiftContainer("body", h(s("=", W, q))), k && z.unshiftContainer("body", h(T(k)));
          }
        } };
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-module-transforms/lib/rewrite-this.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(m) {
          (0, f.traverse)(m.node, Object.assign({}, o, { noScope: !0 }));
        };
        var i = l("./node_modules/.pnpm/@babel+helper-environment-visitor@7.22.5/node_modules/@babel/helper-environment-visitor/lib/index.js"), f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js");
        const { numericLiteral: d, unaryExpression: s } = f.types, o = f.traverse.visitors.merge([i.default, { ThisExpression(m) {
          m.replaceWith(s("void", d(0), !0));
        } }]);
      }, "./node_modules/.pnpm/@babel+helper-optimise-call-expression@7.22.5/node_modules/@babel/helper-optimise-call-expression/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(b, E, S, g) {
          return S.length === 1 && o(S[0]) && s(S[0].argument, { name: "arguments" }) ? g ? h(y(b, d("apply"), !1, !0), [E, S[0].argument], !1) : f(m(b, d("apply")), [E, S[0].argument]) : g ? h(y(b, d("call"), !1, !0), [E, ...S], !1) : f(m(b, d("call")), [E, ...S]);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { callExpression: f, identifier: d, isIdentifier: s, isSpreadElement: o, memberExpression: m, optionalCallExpression: h, optionalMemberExpression: y } = i;
      }, "./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.declare = i, r.declarePreset = void 0;
        const l = { assertVersion: (o) => (m) => {
          (function(h, y) {
            if (typeof h == "number") {
              if (!Number.isInteger(h))
                throw new Error("Expected string or integer value.");
              h = `^${h}.0.0-0`;
            }
            if (typeof h != "string")
              throw new Error("Expected string or integer value.");
            const b = Error.stackTraceLimit;
            typeof b == "number" && b < 25 && (Error.stackTraceLimit = 25);
            let E;
            throw E = y.slice(0, 2) === "7." ? new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${y}". You'll need to update your @babel/core version.`) : new Error(`Requires Babel "${h}", but was loaded with "${y}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`), typeof b == "number" && (Error.stackTraceLimit = b), Object.assign(E, { code: "BABEL_VERSION_UNSUPPORTED", version: y, range: h });
          })(m, o.version);
        } };
        function i(o) {
          return (m, h, y) => {
            var b;
            let E;
            for (const S of Object.keys(l))
              m[S] || (E != null || (E = d(m)), E[S] = l[S](E));
            return o((b = E) != null ? b : m, h || {}, y);
          };
        }
        Object.assign(l, { targets: () => () => ({}), assumption: () => () => {
        } });
        const f = i;
        function d(o) {
          let m = null;
          return typeof o.version == "string" && /^7\./.test(o.version) && (m = Object.getPrototypeOf(o), !m || s(m, "version") && s(m, "transform") && s(m, "template") && s(m, "types") || (m = null)), Object.assign({}, m, o);
        }
        function s(o, m) {
          return Object.prototype.hasOwnProperty.call(o, m);
        }
        r.declarePreset = f;
      }, "./node_modules/.pnpm/@babel+helper-replace-supers@7.22.9_@babel+core@7.22.15/node_modules/@babel/helper-replace-supers/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+helper-environment-visitor@7.22.5/node_modules/@babel/helper-environment-visitor/lib/index.js"), f = l("./node_modules/.pnpm/@babel+helper-member-expression-to-functions@7.22.15/node_modules/@babel/helper-member-expression-to-functions/lib/index.js"), d = l("./node_modules/.pnpm/@babel+helper-optimise-call-expression@7.22.5/node_modules/@babel/helper-optimise-call-expression/lib/index.js"), s = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js");
        const { assignmentExpression: o, booleanLiteral: m, callExpression: h, cloneNode: y, identifier: b, memberExpression: E, sequenceExpression: S, stringLiteral: g, thisExpression: P } = s.types;
        {
          const j = l("./node_modules/.pnpm/@babel+helper-environment-visitor@7.22.5/node_modules/@babel/helper-environment-visitor/lib/index.js");
          r.environmentVisitor = j.default, r.skipAllButComputedKey = j.skipAllButComputedKey;
        }
        function R(j, F, _, T) {
          j = y(j);
          const v = F || T ? j : E(j, b("prototype"));
          return h(_.addHelper("getPrototypeOf"), [v]);
        }
        const N = s.traverse.visitors.merge([i.default, { Super(j, F) {
          const { node: _, parentPath: T } = j;
          T.isMemberExpression({ object: _ }) && F.handle(T);
        } }]), C = s.traverse.visitors.merge([i.default, { Scopable(j, { refName: F }) {
          const _ = j.scope.getOwnBinding(F);
          _ && _.identifier.name === F && j.scope.rename(F);
        } }]), I = { memoise(j, F) {
          const { scope: _, node: T } = j, { computed: v, property: w } = T;
          if (!v)
            return;
          const O = _.maybeGenerateMemoised(w);
          O && this.memoiser.set(w, O, F);
        }, prop(j) {
          const { computed: F, property: _ } = j.node;
          return this.memoiser.has(_) ? y(this.memoiser.get(_)) : F ? y(_) : g(_.name);
        }, get(j) {
          return this._get(j, this._getThisRefs());
        }, _get(j, F) {
          const _ = R(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
          return h(this.file.addHelper("get"), [F.memo ? S([F.memo, _]) : _, this.prop(j), F.this]);
        }, _getThisRefs() {
          if (!this.isDerivedConstructor)
            return { this: P() };
          const j = this.scope.generateDeclaredUidIdentifier("thisSuper");
          return { memo: o("=", j, P()), this: y(j) };
        }, set(j, F) {
          const _ = this._getThisRefs(), T = R(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
          return h(this.file.addHelper("set"), [_.memo ? S([_.memo, T]) : T, this.prop(j), F, _.this, m(j.isInStrictMode())]);
        }, destructureSet(j) {
          throw j.buildCodeFrameError("Destructuring to a super field is not supported yet.");
        }, call(j, F) {
          const _ = this._getThisRefs();
          return (0, d.default)(this._get(j, _), y(_.this), F, !1);
        }, optionalCall(j, F) {
          const _ = this._getThisRefs();
          return (0, d.default)(this._get(j, _), y(_.this), F, !0);
        }, delete(j) {
          return j.node.computed ? S([h(this.file.addHelper("toPropertyKey"), [y(j.node.property)]), s.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]) : s.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
        } }, D = Object.assign({}, I, { prop(j) {
          const { property: F } = j.node;
          return this.memoiser.has(F) ? y(this.memoiser.get(F)) : y(F);
        }, get(j) {
          const { isStatic: F, getSuperRef: _ } = this, { computed: T } = j.node, v = this.prop(j);
          let w;
          var O, G;
          return F ? w = (O = _()) != null ? O : E(b("Function"), b("prototype")) : w = E((G = _()) != null ? G : b("Object"), b("prototype")), E(w, v, T);
        }, set(j, F) {
          const { computed: _ } = j.node, T = this.prop(j);
          return o("=", E(P(), T, _), F);
        }, destructureSet(j) {
          const { computed: F } = j.node, _ = this.prop(j);
          return E(P(), _, F);
        }, call(j, F) {
          return (0, d.default)(this.get(j), P(), F, !1);
        }, optionalCall(j, F) {
          return (0, d.default)(this.get(j), P(), F, !0);
        } });
        r.default = class {
          constructor(j) {
            var F;
            const _ = j.methodPath;
            this.methodPath = _, this.isDerivedConstructor = _.isClassMethod({ kind: "constructor" }) && !!j.superRef, this.isStatic = _.isObjectMethod() || _.node.static || (_.isStaticBlock == null ? void 0 : _.isStaticBlock()), this.isPrivateMethod = _.isPrivate() && _.isMethod(), this.file = j.file, this.constantSuper = (F = j.constantSuper) != null ? F : j.isLoose, this.opts = j;
          }
          getObjectRef() {
            return y(this.opts.objectRef || this.opts.getObjectRef());
          }
          getSuperRef() {
            return this.opts.superRef ? y(this.opts.superRef) : this.opts.getSuperRef ? y(this.opts.getSuperRef()) : void 0;
          }
          replace() {
            this.opts.refToPreserve && this.methodPath.traverse(C, { refName: this.opts.refToPreserve.name });
            const j = this.constantSuper ? D : I;
            (0, f.default)(this.methodPath, N, Object.assign({ file: this.file, scope: this.methodPath.scope, isDerivedConstructor: this.isDerivedConstructor, isStatic: this.isStatic, isPrivateMethod: this.isPrivateMethod, getObjectRef: this.getObjectRef.bind(this), getSuperRef: this.getSuperRef.bind(this), boundGet: j.get }, j));
          }
        };
      }, "./node_modules/.pnpm/@babel+helper-simple-access@7.22.5/node_modules/@babel/helper-simple-access/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(g, P) {
          var R;
          g.traverse(S, { scope: g.scope, bindingNames: P, seen: /* @__PURE__ */ new WeakSet(), includeUpdateExpression: (R = arguments[2]) == null || R });
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { LOGICAL_OPERATORS: f, assignmentExpression: d, binaryExpression: s, cloneNode: o, identifier: m, logicalExpression: h, numericLiteral: y, sequenceExpression: b, unaryExpression: E } = i, S = { AssignmentExpression: { exit(g) {
          const { scope: P, seen: R, bindingNames: N } = this;
          if (g.node.operator === "=" || R.has(g.node))
            return;
          R.add(g.node);
          const C = g.get("left");
          if (!C.isIdentifier())
            return;
          const I = C.node.name;
          if (!N.has(I) || P.getBinding(I) !== g.scope.getBinding(I))
            return;
          const D = g.node.operator.slice(0, -1);
          f.includes(D) ? g.replaceWith(h(D, g.node.left, d("=", o(g.node.left), g.node.right))) : (g.node.right = s(D, o(g.node.left), g.node.right), g.node.operator = "=");
        } } };
        S.UpdateExpression = { exit(g) {
          if (!this.includeUpdateExpression)
            return;
          const { scope: P, bindingNames: R } = this, N = g.get("argument");
          if (!N.isIdentifier())
            return;
          const C = N.node.name;
          if (R.has(C) && P.getBinding(C) === g.scope.getBinding(C))
            if (g.parentPath.isExpressionStatement() && !g.isCompletionRecord()) {
              const I = g.node.operator == "++" ? "+=" : "-=";
              g.replaceWith(d(I, N.node, y(1)));
            } else if (g.node.prefix)
              g.replaceWith(d("=", m(C), s(g.node.operator[0], E("+", N.node), y(1))));
            else {
              const I = g.scope.generateUidIdentifierBasedOnNode(N.node, "old"), D = I.name;
              g.scope.push({ id: I });
              const j = s(g.node.operator[0], m(D), y(1));
              g.replaceWith(b([d("=", m(D), E("+", N.node)), d("=", o(N.node), j), m(D)]));
            }
        } };
      }, "./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.22.5/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.isTransparentExprWrapper = y, r.skipTransparentExprWrapperNodes = function(b) {
          for (; y(b); )
            b = b.expression;
          return b;
        }, r.skipTransparentExprWrappers = function(b) {
          for (; y(b.node); )
            b = b.get("expression");
          return b;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { isParenthesizedExpression: f, isTSAsExpression: d, isTSNonNullExpression: s, isTSSatisfiesExpression: o, isTSTypeAssertion: m, isTypeCastExpression: h } = i;
        function y(b) {
          return d(b) || o(b) || m(b) || s(b) || h(b) || f(b);
        }
      }, "./node_modules/.pnpm/@babel+helper-split-export-declaration@7.22.6/node_modules/@babel/helper-split-export-declaration/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(y) {
          if (!y.isExportDeclaration() || y.isExportAllDeclaration())
            throw new Error("Only default and named export declarations can be split.");
          if (y.isExportDefaultDeclaration()) {
            const P = y.get("declaration"), R = P.isFunctionDeclaration() || P.isClassDeclaration(), N = P.isFunctionExpression() || P.isClassExpression(), C = P.isScope() ? P.scope.parent : P.scope;
            let I = P.node.id, D = !1;
            I ? N && C.hasBinding(I.name) && (D = !0, I = C.generateUidIdentifier(I.name)) : (D = !0, I = C.generateUidIdentifier("default"), (R || N) && (P.node.id = f(I)));
            const j = R ? P.node : m("var", [h(f(I), P.node)]), F = d(null, [s(f(I), o("default"))]);
            return y.insertAfter(F), y.replaceWith(j), D && C.registerDeclaration(y), y;
          }
          if (y.get("specifiers").length > 0)
            throw new Error("It doesn't make sense to split exported specifiers.");
          const b = y.get("declaration"), E = b.getOuterBindingIdentifiers(), S = Object.keys(E).map((P) => s(o(P), o(P))), g = d(null, S);
          return y.insertAfter(g), y.replaceWith(b.node), y;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { cloneNode: f, exportNamedDeclaration: d, exportSpecifier: s, identifier: o, variableDeclaration: m, variableDeclarator: h } = i;
      }, "./node_modules/.pnpm/@babel+helper-string-parser@7.22.5/node_modules/@babel/helper-string-parser/lib/index.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.readCodePoint = h, r.readInt = m, r.readStringContents = function(y, b, E, S, g, P) {
          const R = E, N = S, C = g;
          let I = "", D = null, j = E;
          const { length: F } = b;
          for (; ; ) {
            if (E >= F) {
              P.unterminated(R, N, C), I += b.slice(j, E);
              break;
            }
            const _ = b.charCodeAt(E);
            if (d(y, _, b, E)) {
              I += b.slice(j, E);
              break;
            }
            if (_ === 92) {
              I += b.slice(j, E);
              const T = s(b, E, S, g, y === "template", P);
              T.ch !== null || D ? I += T.ch : D = { pos: E, lineStart: S, curLine: g }, { pos: E, lineStart: S, curLine: g } = T, j = E;
            } else
              _ === 8232 || _ === 8233 ? (++g, S = ++E) : _ === 10 || _ === 13 ? y === "template" ? (I += b.slice(j, E) + `
`, ++E, _ === 13 && b.charCodeAt(E) === 10 && ++E, ++g, j = S = E) : P.unterminated(R, N, C) : ++E;
          }
          return { pos: E, str: I, firstInvalidLoc: D, lineStart: S, curLine: g, containsInvalid: !!D };
        };
        var l = function(y) {
          return y >= 48 && y <= 57;
        };
        const i = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, f = { bin: (y) => y === 48 || y === 49, oct: (y) => y >= 48 && y <= 55, dec: (y) => y >= 48 && y <= 57, hex: (y) => y >= 48 && y <= 57 || y >= 65 && y <= 70 || y >= 97 && y <= 102 };
        function d(y, b, E, S) {
          return y === "template" ? b === 96 || b === 36 && E.charCodeAt(S + 1) === 123 : b === (y === "double" ? 34 : 39);
        }
        function s(y, b, E, S, g, P) {
          const R = !g;
          b++;
          const N = (I) => ({ pos: b, ch: I, lineStart: E, curLine: S }), C = y.charCodeAt(b++);
          switch (C) {
            case 110:
              return N(`
`);
            case 114:
              return N("\r");
            case 120: {
              let I;
              return { code: I, pos: b } = o(y, b, E, S, 2, !1, R, P), N(I === null ? null : String.fromCharCode(I));
            }
            case 117: {
              let I;
              return { code: I, pos: b } = h(y, b, E, S, R, P), N(I === null ? null : String.fromCodePoint(I));
            }
            case 116:
              return N("	");
            case 98:
              return N("\b");
            case 118:
              return N("\v");
            case 102:
              return N("\f");
            case 13:
              y.charCodeAt(b) === 10 && ++b;
            case 10:
              E = b, ++S;
            case 8232:
            case 8233:
              return N("");
            case 56:
            case 57:
              if (g)
                return N(null);
              P.strictNumericEscape(b - 1, E, S);
            default:
              if (C >= 48 && C <= 55) {
                const I = b - 1;
                let D = y.slice(I, b + 2).match(/^[0-7]+/)[0], j = parseInt(D, 8);
                j > 255 && (D = D.slice(0, -1), j = parseInt(D, 8)), b += D.length - 1;
                const F = y.charCodeAt(b);
                if (D !== "0" || F === 56 || F === 57) {
                  if (g)
                    return N(null);
                  P.strictNumericEscape(I, E, S);
                }
                return N(String.fromCharCode(j));
              }
              return N(String.fromCharCode(C));
          }
        }
        function o(y, b, E, S, g, P, R, N) {
          const C = b;
          let I;
          return { n: I, pos: b } = m(y, b, E, S, 16, g, P, !1, N, !R), I === null && (R ? N.invalidEscapeSequence(C, E, S) : b = C - 1), { code: I, pos: b };
        }
        function m(y, b, E, S, g, P, R, N, C, I) {
          const D = b, j = g === 16 ? i.hex : i.decBinOct, F = g === 16 ? f.hex : g === 10 ? f.dec : g === 8 ? f.oct : f.bin;
          let _ = !1, T = 0;
          for (let v = 0, w = P ?? 1 / 0; v < w; ++v) {
            const O = y.charCodeAt(b);
            let G;
            if (O !== 95 || N === "bail") {
              if (G = O >= 97 ? O - 97 + 10 : O >= 65 ? O - 65 + 10 : l(O) ? O - 48 : 1 / 0, G >= g) {
                if (G <= 9 && I)
                  return { n: null, pos: b };
                if (G <= 9 && C.invalidDigit(b, E, S, g))
                  G = 0;
                else {
                  if (!R)
                    break;
                  G = 0, _ = !0;
                }
              }
              ++b, T = T * g + G;
            } else {
              const W = y.charCodeAt(b - 1), U = y.charCodeAt(b + 1);
              if (N) {
                if (Number.isNaN(U) || !F(U) || j.has(W) || j.has(U)) {
                  if (I)
                    return { n: null, pos: b };
                  C.unexpectedNumericSeparator(b, E, S);
                }
              } else {
                if (I)
                  return { n: null, pos: b };
                C.numericSeparatorInEscapeSequence(b, E, S);
              }
              ++b;
            }
          }
          return b === D || P != null && b - D !== P || _ ? { n: null, pos: b } : { n: T, pos: b };
        }
        function h(y, b, E, S, g, P) {
          let R;
          if (y.charCodeAt(b) === 123) {
            if (++b, { code: R, pos: b } = o(y, b, E, S, y.indexOf("}", b) - b, !0, g, P), ++b, R !== null && R > 1114111) {
              if (!g)
                return { code: null, pos: b };
              P.invalidCodePoint(b, E, S);
            }
          } else
            ({ code: R, pos: b } = o(y, b, E, S, 4, !1, g, P));
          return { code: R, pos: b };
        }
      }, "./node_modules/.pnpm/@babel+helper-validator-identifier@7.22.15/node_modules/@babel/helper-validator-identifier/lib/identifier.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.isIdentifierChar = y, r.isIdentifierName = function(b) {
          let E = !0;
          for (let S = 0; S < b.length; S++) {
            let g = b.charCodeAt(S);
            if ((64512 & g) == 55296 && S + 1 < b.length) {
              const P = b.charCodeAt(++S);
              (64512 & P) == 56320 && (g = 65536 + ((1023 & g) << 10) + (1023 & P));
            }
            if (E) {
              if (E = !1, !h(g))
                return !1;
            } else if (!y(g))
              return !1;
          }
          return !E;
        }, r.isIdentifierStart = h;
        let l = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", i = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
        const f = new RegExp("[" + l + "]"), d = new RegExp("[" + l + i + "]");
        l = i = null;
        const s = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191], o = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function m(b, E) {
          let S = 65536;
          for (let g = 0, P = E.length; g < P; g += 2) {
            if (S += E[g], S > b)
              return !1;
            if (S += E[g + 1], S >= b)
              return !0;
          }
          return !1;
        }
        function h(b) {
          return b < 65 ? b === 36 : b <= 90 || (b < 97 ? b === 95 : b <= 122 || (b <= 65535 ? b >= 170 && f.test(String.fromCharCode(b)) : m(b, s)));
        }
        function y(b) {
          return b < 48 ? b === 36 : b < 58 || !(b < 65) && (b <= 90 || (b < 97 ? b === 95 : b <= 122 || (b <= 65535 ? b >= 170 && d.test(String.fromCharCode(b)) : m(b, s) || m(b, o))));
        }
      }, "./node_modules/.pnpm/@babel+helper-validator-identifier@7.22.15/node_modules/@babel/helper-validator-identifier/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), Object.defineProperty(r, "isIdentifierChar", { enumerable: !0, get: function() {
          return i.isIdentifierChar;
        } }), Object.defineProperty(r, "isIdentifierName", { enumerable: !0, get: function() {
          return i.isIdentifierName;
        } }), Object.defineProperty(r, "isIdentifierStart", { enumerable: !0, get: function() {
          return i.isIdentifierStart;
        } }), Object.defineProperty(r, "isKeyword", { enumerable: !0, get: function() {
          return f.isKeyword;
        } }), Object.defineProperty(r, "isReservedWord", { enumerable: !0, get: function() {
          return f.isReservedWord;
        } }), Object.defineProperty(r, "isStrictBindOnlyReservedWord", { enumerable: !0, get: function() {
          return f.isStrictBindOnlyReservedWord;
        } }), Object.defineProperty(r, "isStrictBindReservedWord", { enumerable: !0, get: function() {
          return f.isStrictBindReservedWord;
        } }), Object.defineProperty(r, "isStrictReservedWord", { enumerable: !0, get: function() {
          return f.isStrictReservedWord;
        } });
        var i = l("./node_modules/.pnpm/@babel+helper-validator-identifier@7.22.15/node_modules/@babel/helper-validator-identifier/lib/identifier.js"), f = l("./node_modules/.pnpm/@babel+helper-validator-identifier@7.22.15/node_modules/@babel/helper-validator-identifier/lib/keyword.js");
      }, "./node_modules/.pnpm/@babel+helper-validator-identifier@7.22.15/node_modules/@babel/helper-validator-identifier/lib/keyword.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.isKeyword = function(y) {
          return f.has(y);
        }, r.isReservedWord = o, r.isStrictBindOnlyReservedWord = h, r.isStrictBindReservedWord = function(y, b) {
          return m(y, b) || h(y);
        }, r.isStrictReservedWord = m;
        const l = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], i = ["eval", "arguments"], f = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), d = new Set(l), s = new Set(i);
        function o(y, b) {
          return b && y === "await" || y === "enum";
        }
        function m(y, b) {
          return o(y, b) || d.has(y);
        }
        function h(y) {
          return s.has(y);
        }
      }, "./node_modules/.pnpm/@babel+helper-validator-option@7.22.15/node_modules/@babel/helper-validator-option/lib/find-suggestion.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.findSuggestion = function(i, f) {
          const d = f.map((s) => function(o, m) {
            let h, y, b = [], E = [];
            const S = o.length, g = m.length;
            if (!S)
              return g;
            if (!g)
              return S;
            for (y = 0; y <= g; y++)
              b[y] = y;
            for (h = 1; h <= S; h++) {
              for (E = [h], y = 1; y <= g; y++)
                E[y] = o[h - 1] === m[y - 1] ? b[y - 1] : l(b[y - 1], b[y], E[y - 1]) + 1;
              b = E;
            }
            return E[g];
          }(s, i));
          return f[d.indexOf(l(...d))];
        };
        const { min: l } = Math;
      }, "./node_modules/.pnpm/@babel+helper-validator-option@7.22.15/node_modules/@babel/helper-validator-option/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), Object.defineProperty(r, "OptionValidator", { enumerable: !0, get: function() {
          return i.OptionValidator;
        } }), Object.defineProperty(r, "findSuggestion", { enumerable: !0, get: function() {
          return f.findSuggestion;
        } });
        var i = l("./node_modules/.pnpm/@babel+helper-validator-option@7.22.15/node_modules/@babel/helper-validator-option/lib/validator.js"), f = l("./node_modules/.pnpm/@babel+helper-validator-option@7.22.15/node_modules/@babel/helper-validator-option/lib/find-suggestion.js");
      }, "./node_modules/.pnpm/@babel+helper-validator-option@7.22.15/node_modules/@babel/helper-validator-option/lib/validator.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.OptionValidator = void 0;
        var i = l("./node_modules/.pnpm/@babel+helper-validator-option@7.22.15/node_modules/@babel/helper-validator-option/lib/find-suggestion.js");
        r.OptionValidator = class {
          constructor(f) {
            this.descriptor = f;
          }
          validateTopLevelOptions(f, d) {
            const s = Object.keys(d);
            for (const o of Object.keys(f))
              if (!s.includes(o))
                throw new Error(this.formatMessage(`'${o}' is not a valid top-level option.
- Did you mean '${(0, i.findSuggestion)(o, s)}'?`));
          }
          validateBooleanOption(f, d, s) {
            return d === void 0 ? s : (this.invariant(typeof d == "boolean", `'${f}' option must be a boolean.`), d);
          }
          validateStringOption(f, d, s) {
            return d === void 0 ? s : (this.invariant(typeof d == "string", `'${f}' option must be a string.`), d);
          }
          invariant(f, d) {
            if (!f)
              throw new Error(this.formatMessage(d));
          }
          formatMessage(f) {
            return `${this.descriptor}: ${f}`;
          }
        };
      }, "./node_modules/.pnpm/@babel+helpers@7.22.15/node_modules/@babel/helpers/lib/helpers-generated.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/index.js");
        function f(s, o) {
          return Object.freeze({ minVersion: s, ast: () => i.default.program.ast(o, { preserveComments: !0 }) });
        }
        var d = Object.freeze({ AsyncGenerator: f("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function AsyncGenerator(e){var r,t;function resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v:o).then((function(t){if(u){var i="return"===r?"return":"next";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?"return":"normal",t)}),(function(e){resume("throw",e)}))}catch(e){settle("throw",e)}}function settle(e,n){switch(e){case"return":r.resolve({value:n,done:!0});break;case"throw":r.reject(n);break;default:r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e,n){return new Promise((function(o,u){var i={key:e,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))}))},"function"!=typeof e.return&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return this},AsyncGenerator.prototype.next=function(e){return this._invoke("next",e)},AsyncGenerator.prototype.throw=function(e){return this._invoke("throw",e)},AsyncGenerator.prototype.return=function(e){return this._invoke("return",e)};'), OverloadYield: f("7.18.14", "export default function _OverloadYield(t,e){this.v=t,this.k=e}"), applyDecs: f("7.17.8", 'function old_createMetadataMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,"getMetadata"),old_assertMetadataKey(o);var i=e[o];if(void 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.private;if(void 0!==l)return l.get(a)}else if(Object.hasOwnProperty.call(i,"constructor"))return i.constructor},setMetadata:function(o,i){old_assertNotFinished(r,"setMetadata"),old_assertMetadataKey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.public={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataMapToFinal(e,t){var a=e[Symbol.metadata||Symbol.for("Symbol.metadata")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.length;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.from(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metadata||Symbol.for("Symbol.metadata")]=t}}function old_createAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,"addInitializer"),old_assertCallable(a,"An initializer"),e.push(a)}}function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var d,u,f={kind:c,name:l?"#"+t:t,isStatic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializer=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get,v.set=a.set):2===i?v.get=function(){return a.value}:(1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=function(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.v=!0}}function old_assertNotFinished(e,t){if(e.v)throw new Error("attempted to call "+t+" after decoration was finished")}function old_assertMetadataKey(e){if("symbol"!=typeof e)throw new TypeError("Metadata keys must be symbols, received: "+e)}function old_assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if("object"!==a||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&old_assertCallable(t.get,"accessor.get"),void 0!==t.set&&old_assertCallable(t.set,"accessor.set"),void 0!==t.init&&old_assertCallable(t.init,"accessor.init"),void 0!==t.initializer&&old_assertCallable(t.initializer,"accessor.initializer")}else if("function"!==a){var r;throw r=0===e?"field":10===e?"class":"method",new TypeError(r+" decorators must return a function or void 0")}}function old_getInit(e){var t;return null==(t=e.init)&&(t=e.initializer)&&"undefined"!=typeof console&&console.warn(".initializer has been renamed to .init as of March 2022"),t}function old_applyMemberDec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,h=a[0];if(n?c=0===o||1===o?{get:a[3],set:a[4]}:3===o?{get:a[3]}:4===o?{set:a[3]}:{value:a[3]}:0!==o&&(c=Object.getOwnPropertyDescriptor(t,r)),1===o?u={get:c.get,set:c.set}:2===o?u=c.value:3===o?u=c.get:4===o&&(u=c.set),"function"==typeof h)void 0!==(f=old_memberDec(h,r,c,l,s,o,i,n,u))&&(old_assertValidReturnValue(o,f),0===o?d=f:1===o?(d=old_getInit(f),p=f.get||u.get,v=f.set||u.set,u={get:p,set:v}):u=f);else for(var y=h.length-1;y>=0;y--){var b;if(void 0!==(f=old_memberDec(h[y],r,c,l,s,o,i,n,u)))old_assertValidReturnValue(o,f),0===o?b=f:1===o?(b=old_getInit(f),p=f.get||u.get,v=f.set||u.set,u={get:p,set:v}):u=f,void 0!==b&&(void 0===d?d=b:"function"==typeof d?d=[d,b]:d.push(b))}if(0===o||1===o){if(void 0===d)d=function(e,t){return t};else if("function"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.length;r++)a=g[r].call(e,a);return a}}else{var m=d;d=function(e,t){return m.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=u.get,c.set=u.set):2===o?c.value=u:3===o?c.get=u:4===o&&(c.set=u),n?1===o?(e.push((function(e,t){return u.get.call(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===o?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(var i,n,l=new Map,s=new Map,c=0;c<o.length;c++){var d=o[c];if(Array.isArray(d)){var u,f,p,v=d[1],h=d[2],y=d.length>3,b=v>=5;if(b?(u=t,f=r,0!==(v-=5)&&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i||[])),0!==v&&!y){var g=b?s:l,m=g.get(h)||0;if(!0===m||3===m&&4!==v||4===m&&3!==v)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);!m&&v>2?g.set(h,v):g.set(h,!0)}old_applyMemberDec(e,u,d,h,v,b,y,f,p)}}old_pushInitializers(e,i),old_pushInitializers(e,n)}function old_pushInitializers(e,t){t&&e.push((function(e){for(var a=0;a<t.length;a++)t[a].call(e);return e}))}function old_applyClassDecs(e,t,a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{var c=Object.assign({kind:"class",name:n,addInitializer:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),d=r[l](i,c)}finally{s.v=!0}void 0!==d&&(old_assertValidReturnValue(10,d),i=d)}e.push(i,(function(){for(var e=0;e<o.length;e++)o[e].call(i)}))}}export default function applyDecs(e,t,a){var r=[],o={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_applyClassDecs(r,e,o,a),old_convertMetadataMapToFinal(e,o),r}'), applyDecs2203: f("7.19.0", 'function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw new Error("attempted to call "+t+" after decoration was finished")}(t,"addInitializer"),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p)),0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=function(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r){var a;throw a=0===e?"field":10===e?"class":"method",new TypeError(a+" decorators must return a function or void 0")}}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{get:r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.set}:2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;if(void 0!==(f=memberDec(h[v],a,c,o,n,i,s,u)))assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.push(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push((function(e,t){return u.get.call(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===n?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProperty(t,a,c))}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){var a=[];return function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(e,l,c,p,f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length-1;s>=0;s--){var o={v:!1};try{var c=r[s](n,{kind:"class",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&(assertValidReturnValue(10,c),n=c)}e.push(n,(function(){for(var e=0;e<a.length;e++)a[e].call(n)}))}}(a,e,r),a}}var applyDecs2203Impl;export default function applyDecs2203(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}'), applyDecs2203R: f("7.20.0", 'function applyDecs2203RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw new Error("attempted to call "+t+" after decoration was finished")}(t,"addInitializer"),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,n,a,i,s,o){var c;switch(a){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==a&&(f.addInitializer=createAddInitializerMethod(n,p)),0===a?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!==a&&3!==a||(l=function(){return r.get.call(this)}),1!==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r){var n;throw n=0===e?"field":10===e?"class":"method",new TypeError(n+" decorators must return a function or void 0")}}function applyMemberDec(e,t,r,n,a,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===a||1===a?{get:r[3],set:r[4]}:3===a?{get:r[3]}:4===a?{set:r[3]}:{value:r[3]}:0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?u={get:c.get,set:c.set}:2===a?u=c.value:3===a?u=c.get:4===a&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,n,c,o,a,i,s,u))&&(assertValidReturnValue(a,f),0===a?l=f:1===a?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;if(void 0!==(f=memberDec(h[v],n,c,o,a,i,s,u)))assertValidReturnValue(a,f),0===a?g=f:1===a?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var y=l;l=function(e,t){for(var r=t,n=0;n<y.length;n++)r=y[n].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.push(l)}0!==a&&(1===a?(c.get=u.get,c.set=u.set):2===a?c.value=u:3===a?c.get=u:4===a&&(c.set=u),s?1===a?(e.push((function(e,t){return u.get.call(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===a?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProperty(t,n,c))}function applyMemberDecs(e,t){for(var r,n,a=[],i=new Map,s=new Map,o=0;o<t.length;o++){var c=t[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=e,0!==(f-=5)&&(u=n=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(a,l,c,p,f,h,d,u)}}return pushInitializers(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}export default function applyDecs2203R(e,t,r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}'), applyDecs2301: f("7.21.0", 'import checkInRHS from"checkInRHS";function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw new Error("attempted to call "+t+" after decoration was finished")}(t,"addInitializer"),assertCallable(r,"An initializer"),e.push(r)}}function assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,n,a,i,s,o,c){var u;switch(a){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="field"}var l,f,p={kind:u,name:s?"#"+t:t,static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n,d)),s||0!==a&&2!==a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e){return assertInstanceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPrivate(c,e),r.set.call(e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():function(e){return t in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r){var n;throw n=0===e?"field":10===e?"class":"method",new TypeError(n+" decorators must return a function or void 0")}}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,g=r[0];if(s?u=0===a||1===a?{get:(p=r[3],function(){return p(this)}),set:curryThis2(r[4])}:3===a?{get:r[3]}:4===a?{set:r[3]}:{value:r[3]}:0!==a&&(u=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:u.get,set:u.set}:2===a?f=u.value:3===a?f=u.get:4===a&&(f=u.set),"function"==typeof g)void 0!==(d=memberDec(g,n,u,o,a,i,s,f,c))&&(assertValidReturnValue(a,d),0===a?l=d:1===a?(l=d.init,h=d.get||f.get,v=d.set||f.set,f={get:h,set:v}):f=d);else for(var y=g.length-1;y>=0;y--){var m;if(void 0!==(d=memberDec(g[y],n,u,o,a,i,s,f,c)))assertValidReturnValue(a,d),0===a?m=d:1===a?(m=d.init,h=d.get||f.get,v=d.set||f.set,f={get:h,set:v}):f=d,void 0!==m&&(void 0===l?l=m:"function"==typeof l?l=[l,m]:l.push(m))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var b=l;l=function(e,t){for(var r=t,n=0;n<b.length;n++)r=b[n].call(e,r);return r}}else{var I=l;l=function(e,t){return I.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=f.get,u.set=f.set):2===a?u.value=f:3===a?u.get=f:4===a&&(u.set=f),s?1===a?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===a?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<t.length;u++){var l=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,g=d>=5,y=r;if(g?(f=e,0!==(d-=5)&&(p=a=a||[]),v&&!i&&(i=function(t){return checkInRHS(t)===e}),y=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=g?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===b&&3!==d)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,g,v,p,y)}}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}export default function applyDecs2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}'), applyDecs2305: f("7.21.0", 'import checkInRHS from"checkInRHS";function createAddInitializerMethod(e,t){return function(r){assertNotFinished(t,"addInitializer"),assertCallable(r,"An initializer"),e.push(r)}}function assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,n,a,i,s,o,c,l){var u;switch(i){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="field"}var f,d,p={kind:u,name:o?"#"+r:r,static:s,private:o},h={v:!1};if(0!==i&&(p.addInitializer=createAddInitializerMethod(a,h)),o||0!==i&&2!==i)if(2===i)f=function(e){return assertInstanceIfPrivate(l,e),n.value};else{var v=0===i||1===i;(v||3===i)&&(f=o?function(e){return assertInstanceIfPrivate(l,e),n.get.call(e)}:function(e){return n.get.call(e)}),(v||4===i)&&(d=o?function(e,t){assertInstanceIfPrivate(l,e),n.set.call(e,t)}:function(e,t){n.set.call(e,t)})}else f=function(e){return e[r]},0===i&&(d=function(e,t){e[r]=t});var y=o?l.bind():function(e){return r in e};p.access=f&&d?{get:f,set:d,has:y}:f?{get:f,has:y}:{set:d,has:y};try{return e.call(t,c,p)}finally{h.v=!0}}function assertNotFinished(e,t){if(e.v)throw new Error("attempted to call "+t+" after decoration was finished")}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r){var n;throw n=0===e?"field":5===e?"class":"method",new TypeError(n+" decorators must return a function or void 0")}}function curryThis1(e){return function(){return e(this)}}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c,l){var u,f,d,p,h,v,y=r[0];n||Array.isArray(y)||(y=[y]),o?u=0===i||1===i?{get:curryThis1(r[3]),set:curryThis2(r[4])}:3===i?{get:r[3]}:4===i?{set:r[3]}:{value:r[3]}:0!==i&&(u=Object.getOwnPropertyDescriptor(t,a)),1===i?d={get:u.get,set:u.set}:2===i?d=u.value:3===i?d=u.get:4===i&&(d=u.set);for(var g=n?2:1,m=y.length-1;m>=0;m-=g){var b;if(void 0!==(p=memberDec(y[m],n?y[m-1]:void 0,a,u,c,i,s,o,d,l)))assertValidReturnValue(i,p),0===i?b=p:1===i?(b=p.init,h=p.get||d.get,v=p.set||d.set,d={get:h,set:v}):d=p,void 0!==b&&(void 0===f?f=b:"function"==typeof f?f=[f,b]:f.push(b))}if(0===i||1===i){if(void 0===f)f=function(e,t){return t};else if("function"!=typeof f){var I=f;f=function(e,t){for(var r=t,n=I.length-1;n>=0;n--)r=I[n].call(e,r);return r}}else{var w=f;f=function(e,t){return w.call(e,t)}}e.push(f)}0!==i&&(1===i?(u.get=d.get,u.set=d.set):2===i?u.value=d:3===i?u.get=d:4===i&&(u.set=d),o?1===i?(e.push((function(e,t){return d.get.call(e,t)})),e.push((function(e,t){return d.set.call(e,t)}))):2===i?e.push(d):e.push((function(e,t){return d.call(e,t)})):Object.defineProperty(t,a,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,l=0;l<t.length;l++){var u=t[l];if(Array.isArray(u)){var f,d,p=u[1],h=u[2],v=u.length>3,y=16&p,g=!!(8&p),m=r;if(p&=7,g?(f=e,0!==p&&(d=a=a||[]),v&&!i&&(i=function(t){return checkInRHS(t)===e}),m=i):(f=e.prototype,0!==p&&(d=n=n||[])),0!==p&&!v){var b=g?c:o,I=b.get(h)||0;if(!0===I||3===I&&4!==p||4===I&&3!==p)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);b.set(h,!(!I&&p>2)||p)}applyMemberDec(s,f,u,y,h,p,g,v,d,m)}}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}function applyClassDecs(e,t,r){if(t.length){for(var n=[],a=e,i=e.name,s=r?2:1,o=t.length-1;o>=0;o-=s){var c={v:!1};try{var l=t[o].call(r?t[o-1]:void 0,a,{kind:"class",name:i,addInitializer:createAddInitializerMethod(n,c)})}finally{c.v=!0}void 0!==l&&(assertValidReturnValue(5,l),a=l)}return[a,function(){for(var e=0;e<n.length;e++)n[e].call(a)}]}}export default function applyDecs2305(e,t,r,n,a){return{e:applyMemberDecs(e,t,a),get c(){return applyClassDecs(e,r,n)}}}'), asyncGeneratorDelegate: f("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function _asyncGeneratorDelegate(t){var e={},n=!1;function pump(e,r){return n=!0,r=new Promise((function(n){n(t[e](r))})),{done:!1,value:new OverloadYield(r,1)}}return e["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=function(){return this},e.next=function(t){return n?(n=!1,t):pump("next",t)},"function"==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t;return pump("throw",t)}),"function"==typeof t.return&&(e.return=function(t){return n?(n=!1,t):pump("return",t)}),e}'), asyncIterator: f("7.15.9", 'export default function _asyncIterator(r){var n,t,o,e=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,o=Symbol.iterator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t="@@asyncIterator",o="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(r){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var n=r.done;return Promise.resolve(r.value).then((function(r){return{value:r,done:n}}))}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s.return;return void 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r){var n=this.s.return;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIterator(r)}'), awaitAsyncGenerator: f("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function _awaitAsyncGenerator(e){return new OverloadYield(e,0)}'), checkInRHS: f("7.20.5", `export default function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of 'in' should be an object, got "+(null!==e?typeof e:"null"));return e}`), defineAccessor: f("7.20.7", "export default function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Object.defineProperty(r,n,c)}"), dispose: f("7.22.0", 'function dispose_SuppressedError(r,e){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=SuppressedError:(dispose_SuppressedError=function(r,e){this.suppressed=r,this.error=e,this.stack=(new Error).stack},dispose_SuppressedError.prototype=Object.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}export default function _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then(next,err)}catch(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(r,e):r,s=!0,next()}return next()}'), iterableToArrayLimit: f("7.0.0-beta.0", 'export default function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return}finally{if(o)throw n}}return a}}'), iterableToArrayLimitLoose: f("7.0.0-beta.0", 'export default function _iterableToArrayLimitLoose(e,r){var t=e&&("undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"]);if(null!=t){var o,l=[];for(t=t.call(e);e.length<r&&!(o=t.next()).done;)l.push(o.value);return l}}'), jsx: f("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;export default function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n||(r={children:void 0}),1===n)r.children=l;else if(n>1){for(var t=new Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in o)void 0===r[i]&&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:""+E,ref:null,props:r,_owner:null}}'), objectSpread2: f("7.5.0", 'import defineProperty from"defineProperty";function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,o)}return t}export default function _objectSpread2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach((function(r){defineProperty(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}'), regeneratorRuntime: f("7.18.0", `export default function _regeneratorRuntime(){"use strict";
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime=function(){return e};var t,e={},r=Object.prototype,n=r.hasOwnProperty,o=Object.defineProperty||function(t,e,r){t[e]=r.value},i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function define(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{define({},"")}catch(t){define=function(t,e,r){return t[e]=r}}function wrap(t,e,r,n){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(i.prototype),c=new Context(n||[]);return o(a,"_invoke",{value:makeInvokeMethod(t,r,c)}),a}function tryCatch(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}e.wrap=wrap;var h="suspendedStart",l="suspendedYield",f="executing",s="completed",y={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var p={};define(p,a,(function(){return this}));var d=Object.getPrototypeOf,v=d&&d(d(values([])));v&&v!==r&&n.call(v,a)&&(p=v);var g=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(p);function defineIteratorMethods(t){["next","throw","return"].forEach((function(e){define(t,e,(function(t){return this._invoke(e,t)}))}))}function AsyncIterator(t,e){function invoke(r,o,i,a){var c=tryCatch(t[r],t,o);if("throw"!==c.type){var u=c.arg,h=u.value;return h&&"object"==typeof h&&n.call(h,"__await")?e.resolve(h.__await).then((function(t){invoke("next",t,i,a)}),(function(t){invoke("throw",t,i,a)})):e.resolve(h).then((function(t){u.value=t,i(u)}),(function(t){return invoke("throw",t,i,a)}))}a(c.arg)}var r;o(this,"_invoke",{value:function(t,n){function callInvokeWithMethodAndArg(){return new e((function(e,r){invoke(t,n,e,r)}))}return r=r?r.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(e,r,n){var o=h;return function(i,a){if(o===f)throw new Error("Generator is already running");if(o===s){if("throw"===i)throw a;return{value:t,done:!0}}for(n.method=i,n.arg=a;;){var c=n.delegate;if(c){var u=maybeInvokeDelegate(c,n);if(u){if(u===y)continue;return u}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(o===h)throw o=s,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);o=f;var p=tryCatch(e,r,n);if("normal"===p.type){if(o=n.done?s:l,p.arg===y)continue;return{value:p.arg,done:n.done}}"throw"===p.type&&(o=s,n.method="throw",n.arg=p.arg)}}}function maybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator.return&&(r.method="return",r.arg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a '"+n+"' method")),y;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,y;var a=i.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,y):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function resetTryEntry(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0)}function values(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function next(){for(;++o<e.length;)if(n.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next};return i.next=i}}throw new TypeError(typeof e+" is not iterable")}return GeneratorFunction.prototype=GeneratorFunctionPrototype,o(g,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),o(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,u,"GeneratorFunction")),t.prototype=Object.create(g),t},e.awrap=function(t){return{__await:t}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,(function(){return this})),e.AsyncIterator=AsyncIterator,e.async=function(t,r,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(wrap(t,r,n,o),i);return e.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},defineIteratorMethods(g),define(g,u,"Generator"),define(g,a,(function(){return this})),define(g,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),r=[];for(var n in e)r.push(n);return r.reverse(),function next(){for(;r.length;){var t=r.pop();if(t in e)return next.value=t,next.done=!1,next}return next.done=!0,next}},e.values=values,Context.prototype={constructor:Context,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function handle(n,o){return a.type="throw",a.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("root"===i.tryLoc)return handle("end");if(i.tryLoc<=this.prev){var c=n.call(i,"catchLoc"),u=n.call(i,"finallyLoc");if(c&&u){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0);if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}else if(c){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0)}else{if(!u)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),y}},e}`), typeof: f("7.0.0-beta.0", 'export default function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},_typeof(o)}'), using: f("7.22.0", 'export default function _using(o,e,n){if(null==e)return e;if("object"!=typeof e)throw new TypeError("using declarations can only be used with objects, null, or undefined.");if(n)var r=e[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==r&&(r=e[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof r)throw new TypeError("Property [Symbol.dispose] is not a function.");return o.push({v:e,d:r,a:n}),e}'), wrapRegExp: f("7.19.0", 'import setPrototypeOf from"setPrototypeOf";import inherits from"inherits";export default function _wrapRegExp(){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=new WeakMap;function BabelRegExp(e,t,p){var o=new RegExp(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function buildGroups(e,t){var p=r.get(t);return Object.keys(p).reduce((function(r,t){var o=p[t];if("number"==typeof o)r[t]=e[o];else{for(var i=0;void 0===e[o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(r){var t=e.exec.call(this,r);if(t){t.groups=buildGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.prototype[Symbol.replace]=function(t,p){if("string"==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)>/g,(function(e,r){var t=o[r];return"$"+(Array.isArray(t)?t.join("$"):t)})))}if("function"==typeof p){var i=this;return e[Symbol.replace].call(this,t,(function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.call(e)).push(buildGroups(e,i)),p.apply(this,e)}))}return e[Symbol.replace].call(this,t,p)},_wrapRegExp.apply(this,arguments)}') });
        r.default = d;
      }, "./node_modules/.pnpm/@babel+helpers@7.22.15/node_modules/@babel/helpers/lib/helpers.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/index.js"), f = l("./node_modules/.pnpm/@babel+helpers@7.22.15/node_modules/@babel/helpers/lib/helpers-generated.js");
        const d = Object.assign({ __proto__: null }, f.default);
        var s = d;
        r.default = s;
        const o = (m) => (h) => ({ minVersion: m, ast: () => i.default.program.ast(h) });
        d.AwaitValue = o("7.0.0-beta.0")`
    export default function _AwaitValue(value) {
      this.wrapped = value;
    }
  `, d.wrapAsyncGenerator = o("7.0.0-beta.0")`
  import AsyncGenerator from "AsyncGenerator";

  export default function _wrapAsyncGenerator(fn) {
    return function () {
      return new AsyncGenerator(fn.apply(this, arguments));
    };
  }
`, d.asyncToGenerator = o("7.0.0-beta.0")`
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  export default function _asyncToGenerator(fn) {
    return function () {
      var self = this, args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }
`, d.classCallCheck = o("7.0.0-beta.0")`
  export default function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
`, d.createClass = o("7.0.0-beta.0")`
  import toPropertyKey from "toPropertyKey";
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i ++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
    }
  }

  export default function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
`, d.defineEnumerableProperties = o("7.0.0-beta.0")`
  export default function _defineEnumerableProperties(obj, descs) {
    for (var key in descs) {
      var desc = descs[key];
      desc.configurable = desc.enumerable = true;
      if ("value" in desc) desc.writable = true;
      Object.defineProperty(obj, key, desc);
    }

    // Symbols are not enumerated over by for-in loops. If native
    // Symbols are available, fetch all of the descs object's own
    // symbol properties and define them on our target object too.
    if (Object.getOwnPropertySymbols) {
      var objectSymbols = Object.getOwnPropertySymbols(descs);
      for (var i = 0; i < objectSymbols.length; i++) {
        var sym = objectSymbols[i];
        var desc = descs[sym];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, sym, desc);
      }
    }
    return obj;
  }
`, d.defaults = o("7.0.0-beta.0")`
  export default function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);
      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }
    return obj;
  }
`, d.defineProperty = o("7.0.0-beta.0")`
  import toPropertyKey from "toPropertyKey";
  export default function _defineProperty(obj, key, value) {
    key = toPropertyKey(key);
    // Shortcircuit the slow defineProperty path when possible.
    // We are trying to avoid issues where setters defined on the
    // prototype cause side effects under the fast path of simple
    // assignment. By checking for existence of the property with
    // the in operator, we can optimize most of this overhead away.
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
`, d.extends = o("7.0.0-beta.0")`
  export default function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };

    return _extends.apply(this, arguments);
  }
`, d.objectSpread = o("7.0.0-beta.0")`
    import defineProperty from "defineProperty";

    export default function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = (arguments[i] != null) ? Object(arguments[i]) : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys.forEach(function(key) {
          defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
  `, d.inherits = o("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    // We can't use defineProperty to set the prototype in a single step because it
    // doesn't work in Chrome <= 36. https://github.com/babel/babel/issues/14056
    // V8 bug: https://bugs.chromium.org/p/v8/issues/detail?id=3334
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", { writable: false });
    if (superClass) setPrototypeOf(subClass, superClass);
  }
`, d.inheritsLoose = o("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    setPrototypeOf(subClass, superClass);
  }
`, d.getPrototypeOf = o("7.0.0-beta.0")`
  export default function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
    return _getPrototypeOf(o);
  }
`, d.setPrototypeOf = o("7.0.0-beta.0")`
  export default function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };
    return _setPrototypeOf(o, p);
  }
`, d.isNativeReflectConstruct = o("7.9.0")`
  export default function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;

    // core-js@3
    if (Reflect.construct.sham) return false;

    // Proxy can't be polyfilled. Every browser implemented
    // proxies before or at the same time as Reflect.construct,
    // so if they support Proxy they also support Reflect.construct.
    if (typeof Proxy === "function") return true;

    // Since Reflect.construct can't be properly polyfilled, some
    // implementations (e.g. core-js@2) don't set the correct internal slots.
    // Those polyfills don't allow us to subclass built-ins, so we need to
    // use our fallback implementation.
    try {
      // If the internal slots aren't set, this throws an error similar to
      //   TypeError: this is not a Boolean object.

      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
      return true;
    } catch (e) {
      return false;
    }
  }
`, d.construct = o("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";
  import isNativeReflectConstruct from "isNativeReflectConstruct";

  export default function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      // NOTE: If Parent !== Class, the correct __proto__ is set *after*
      //       calling the constructor.
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }
    // Avoid issues with Class being present but undefined when it wasn't
    // present in the original call.
    return _construct.apply(null, arguments);
  }
`, d.isNativeFunction = o("7.0.0-beta.0")`
  export default function _isNativeFunction(fn) {
    // Note: This function returns "true" for core-js functions.
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
`, d.wrapNativeSuper = o("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";
  import setPrototypeOf from "setPrototypeOf";
  import isNativeFunction from "isNativeFunction";
  import construct from "construct";

  export default function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !isNativeFunction(Class)) return Class;
      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return construct(Class, arguments, getPrototypeOf(this).constructor)
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true,
        }
      });

      return setPrototypeOf(Wrapper, Class);
    }

    return _wrapNativeSuper(Class)
  }
`, d.instanceof = o("7.0.0-beta.0")`
  export default function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
`, d.interopRequireDefault = o("7.0.0-beta.0")`
  export default function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
`, d.interopRequireWildcard = o("7.14.0")`
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;

    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function (nodeInterop) {
      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }

  export default function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }

    if (obj === null || (typeof obj !== "object" && typeof obj !== "function")) {
      return { default: obj }
    }

    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
`, d.newArrowCheck = o("7.0.0-beta.0")`
  export default function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  }
`, d.objectDestructuringEmpty = o("7.0.0-beta.0")`
  export default function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure " + obj);
  }
`, d.objectWithoutPropertiesLoose = o("7.0.0-beta.0")`
  export default function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};

    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }
`, d.objectWithoutProperties = o("7.0.0-beta.0")`
  import objectWithoutPropertiesLoose from "objectWithoutPropertiesLoose";

  export default function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }
`, d.assertThisInitialized = o("7.0.0-beta.0")`
  export default function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
`, d.possibleConstructorReturn = o("7.0.0-beta.0")`
  import assertThisInitialized from "assertThisInitialized";

  export default function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return assertThisInitialized(self);
  }
`, d.createSuper = o("7.9.0")`
  import getPrototypeOf from "getPrototypeOf";
  import isNativeReflectConstruct from "isNativeReflectConstruct";
  import possibleConstructorReturn from "possibleConstructorReturn";

  export default function _createSuper(Derived) {
    var hasNativeReflectConstruct = isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        // NOTE: This doesn't work if this.__proto__.constructor has been modified.
        var NewTarget = getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return possibleConstructorReturn(this, result);
    }
  }
 `, d.superPropBase = o("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";

  export default function _superPropBase(object, property) {
    // Yes, this throws if object is null to being with, that's on purpose.
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
`, d.get = o("7.0.0-beta.0")`
  import superPropBase from "superPropBase";

  export default function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);

        if (!base) return;

        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          // STEP 3. If receiver is not present, then set receiver to target.
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }
`, d.set = o("7.0.0-beta.0")`
  import superPropBase from "superPropBase";
  import defineProperty from "defineProperty";

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = superPropBase(target, property);
        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            // Both getter and non-writable fall into this.
            return false;
          }
        }

        // Without a super that defines the property, spec boils down to
        // "define on receiver" for some reason.
        desc = Object.getOwnPropertyDescriptor(receiver, property);
        if (desc) {
          if (!desc.writable) {
            // Setter, getter, and non-writable fall into this.
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          // Avoid setters that may be defined on Sub's prototype, but not on
          // the instance.
          defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  export default function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s && isStrict) {
      throw new TypeError('failed to set property');
    }

    return value;
  }
`, d.taggedTemplateLiteral = o("7.0.0-beta.0")`
  export default function _taggedTemplateLiteral(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    return Object.freeze(Object.defineProperties(strings, {
        raw: { value: Object.freeze(raw) }
    }));
  }
`, d.taggedTemplateLiteralLoose = o("7.0.0-beta.0")`
  export default function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    strings.raw = raw;
    return strings;
  }
`, d.readOnlyError = o("7.0.0-beta.0")`
  export default function _readOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is read-only");
  }
`, d.writeOnlyError = o("7.12.13")`
  export default function _writeOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is write-only");
  }
`, d.classNameTDZError = o("7.0.0-beta.0")`
  export default function _classNameTDZError(name) {
    throw new ReferenceError("Class \\"" + name + "\\" cannot be referenced in computed property keys.");
  }
`, d.temporalUndefined = o("7.0.0-beta.0")`
  // This function isn't mean to be called, but to be used as a reference.
  // We can't use a normal object because it isn't hoisted.
  export default function _temporalUndefined() {}
`, d.tdz = o("7.5.5")`
  export default function _tdzError(name) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  }
`, d.temporalRef = o("7.0.0-beta.0")`
  import undef from "temporalUndefined";
  import err from "tdz";

  export default function _temporalRef(val, name) {
    return val === undef ? err(name) : val;
  }
`, d.slicedToArray = o("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimit from "iterableToArrayLimit";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArray(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimit(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`, d.slicedToArrayLoose = o("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimitLoose from "iterableToArrayLimitLoose";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArrayLoose(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimitLoose(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`, d.toArray = o("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _toArray(arr) {
    return (
      arrayWithHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableRest()
    );
  }
`, d.toConsumableArray = o("7.0.0-beta.0")`
  import arrayWithoutHoles from "arrayWithoutHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableSpread from "nonIterableSpread";

  export default function _toConsumableArray(arr) {
    return (
      arrayWithoutHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableSpread()
    );
  }
`, d.arrayWithoutHoles = o("7.0.0-beta.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }
`, d.arrayWithHoles = o("7.0.0-beta.0")`
  export default function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
`, d.maybeArrayLike = o("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _maybeArrayLike(next, arr, i) {
    if (arr && !Array.isArray(arr) && typeof arr.length === "number") {
      var len = arr.length;
      return arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);
    }
    return next(arr, i);
  }
`, d.iterableToArray = o("7.0.0-beta.0")`
  export default function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
`, d.unsupportedIterableToArray = o("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return arrayLikeToArray(o, minLen);
  }
`, d.arrayLikeToArray = o("7.9.0")`
  export default function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
`, d.nonIterableSpread = o("7.0.0-beta.0")`
  export default function _nonIterableSpread() {
    throw new TypeError(
      "Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`, d.nonIterableRest = o("7.0.0-beta.0")`
  export default function _nonIterableRest() {
    throw new TypeError(
      "Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`, d.createForOfIteratorHelper = o("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  // s: start (create the iterator)
  // n: next
  // e: error (called whenever something throws)
  // f: finish (always called at the end)

  export default function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      // Fallback for engines without symbol support
      if (
        Array.isArray(o) ||
        (it = unsupportedIterableToArray(o)) ||
        (allowArrayLike && o && typeof o.length === "number")
      ) {
        if (it) o = it;
        var i = 0;
        var F = function(){};
        return {
          s: F,
          n: function() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          },
          e: function(e) { throw e; },
          f: F,
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true, didErr = false, err;

    return {
      s: function() {
        it = it.call(o);
      },
      n: function() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function(e) {
        didErr = true;
        err = e;
      },
      f: function() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
`, d.createForOfIteratorHelperLoose = o("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);

    // Fallback for engines without symbol support
    if (
      Array.isArray(o) ||
      (it = unsupportedIterableToArray(o)) ||
      (allowArrayLike && o && typeof o.length === "number")
    ) {
      if (it) o = it;
      var i = 0;
      return function() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
`, d.skipFirstGeneratorNext = o("7.0.0-beta.0")`
  export default function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    }
  }
`, d.toPrimitive = o("7.1.5")`
  export default function _toPrimitive(
    input,
    hint /*: "default" | "string" | "number" | void */
  ) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
`, d.toPropertyKey = o("7.1.5")`
  import toPrimitive from "toPrimitive";

  export default function _toPropertyKey(arg) {
    var key = toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
`, d.initializerWarningHelper = o("7.0.0-beta.0")`
    export default function _initializerWarningHelper(descriptor, context){
        throw new Error(
          'Decorating class property failed. Please ensure that ' +
          'transform-class-properties is enabled and runs after the decorators transform.'
        );
    }
`, d.initializerDefineProperty = o("7.0.0-beta.0")`
    export default function _initializerDefineProperty(target, property, descriptor, context){
        if (!descriptor) return;

        Object.defineProperty(target, property, {
            enumerable: descriptor.enumerable,
            configurable: descriptor.configurable,
            writable: descriptor.writable,
            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,
        });
    }
`, d.applyDecoratedDescriptor = o("7.0.0-beta.0")`
    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){
        var desc = {};
        Object.keys(descriptor).forEach(function(key){
            desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;
        if ('value' in desc || desc.initializer){
            desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function(desc, decorator){
            return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0){
            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
            desc.initializer = undefined;
        }

        if (desc.initializer === void 0){
            Object.defineProperty(target, property, desc);
            desc = null;
        }

        return desc;
    }
`, d.classPrivateFieldLooseKey = o("7.0.0-beta.0")`
  var id = 0;
  export default function _classPrivateFieldKey(name) {
    return "__private_" + (id++) + "_" + name;
  }
`, d.classPrivateFieldLooseBase = o("7.0.0-beta.0")`
  export default function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
`, d.classPrivateFieldGet = o("7.0.0-beta.0")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`, d.classPrivateFieldSet = o("7.0.0-beta.0")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`, d.classPrivateFieldDestructureSet = o("7.4.4")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`, d.classExtractFieldDescriptor = o("7.13.10")`
  export default function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
  }
`, d.classStaticPrivateFieldSpecGet = o("7.0.2")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`, d.classStaticPrivateFieldSpecSet = o("7.0.2")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`, d.classStaticPrivateMethodGet = o("7.3.2")`
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    return method;
  }
`, d.classStaticPrivateMethodSet = o("7.3.2")`
  export default function _classStaticPrivateMethodSet() {
    throw new TypeError("attempted to set read only static private field");
  }
`, d.classApplyDescriptorGet = o("7.13.10")`
  export default function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }
    return descriptor.value;
  }
`, d.classApplyDescriptorSet = o("7.13.10")`
  export default function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }
      descriptor.value = value;
    }
  }
`, d.classApplyDescriptorDestructureSet = o("7.13.10")`
  export default function _classApplyDescriptorDestructureSet(receiver, descriptor) {
    if (descriptor.set) {
      if (!("__destrObj" in descriptor)) {
        descriptor.__destrObj = {
          set value(v) {
            descriptor.set.call(receiver, v)
          },
        };
      }
      return descriptor.__destrObj;
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }

      return descriptor;
    }
  }
`, d.classStaticPrivateFieldDestructureSet = o("7.13.10")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`, d.classCheckPrivateStaticAccess = o("7.13.10")`
  export default function _classCheckPrivateStaticAccess(receiver, classConstructor) {
    if (receiver !== classConstructor) {
      throw new TypeError("Private static access of wrong provenance");
    }
  }
`, d.classCheckPrivateStaticFieldDescriptor = o("7.13.10")`
  export default function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
    if (descriptor === undefined) {
      throw new TypeError("attempted to " + action + " private static field before its declaration");
    }
  }
`, d.decorate = o("7.1.5")`
  import toArray from "toArray";
  import toPropertyKey from "toPropertyKey";

  // These comments are stripped by @babel/template
  /*::
  type PropertyDescriptor =
    | {
        value: any,
        writable: boolean,
        configurable: boolean,
        enumerable: boolean,
      }
    | {
        get?: () => any,
        set?: (v: any) => void,
        configurable: boolean,
        enumerable: boolean,
      };

  type FieldDescriptor ={
    writable: boolean,
    configurable: boolean,
    enumerable: boolean,
  };

  type Placement = "static" | "prototype" | "own";
  type Key = string | symbol; // PrivateName is not supported yet.

  type ElementDescriptor =
    | {
        kind: "method",
        key: Key,
        placement: Placement,
        descriptor: PropertyDescriptor
      }
    | {
        kind: "field",
        key: Key,
        placement: Placement,
        descriptor: FieldDescriptor,
        initializer?: () => any,
      };

  // This is exposed to the user code
  type ElementObjectInput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
  };

  // This is exposed to the user code
  type ElementObjectOutput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
    extras?: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  // This is exposed to the user code
  type ClassObject = {
    [@@toStringTag]?: "Descriptor",
    kind: "class",
    elements: ElementDescriptor[],
  };

  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;
  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;
  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;

  // Only used by Babel in the transform output, not part of the spec.
  type ElementDefinition =
    | {
        kind: "method",
        value: any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
      }
    | {
        kind: "field",
        value: () => any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
    };

  declare function ClassFactory<C>(initialize: (instance: C) => void): {
    F: Class<C>,
    d: ElementDefinition[]
  }

  */

  /*::
  // Various combinations with/without extras and with one or many finishers

  type ElementFinisherExtras = {
    element: ElementDescriptor,
    finisher?: ClassFinisher,
    extras?: ElementDescriptor[],
  };

  type ElementFinishersExtras = {
    element: ElementDescriptor,
    finishers: ClassFinisher[],
    extras: ElementDescriptor[],
  };

  type ElementsFinisher = {
    elements: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  type ElementsFinishers = {
    elements: ElementDescriptor[],
    finishers: ClassFinisher[],
  };

  */

  /*::

  type Placements = {
    static: Key[],
    prototype: Key[],
    own: Key[],
  };

  */

  // ClassDefinitionEvaluation (Steps 26-*)
  export default function _decorate(
    decorators /*: ClassDecorator[] */,
    factory /*: ClassFactory */,
    superClass /*: ?Class<*> */,
    mixins /*: ?Array<Function> */,
  ) /*: Class<*> */ {
    var api = _getDecoratorsApi();
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        api = mixins[i](api);
      }
    }

    var r = factory(function initialize(O) {
      api.initializeInstanceElements(O, decorated.elements);
    }, superClass);
    var decorated = api.decorateClass(
      _coalesceClassElements(r.d.map(_createElementDescriptor)),
      decorators,
    );

    api.initializeClassElements(r.F, decorated.elements);

    return api.runClassFinishers(r.F, decorated.finishers);
  }

  function _getDecoratorsApi() {
    _getDecoratorsApi = function() {
      return api;
    };

    var api = {
      elementsDefinitionOrder: [["method"], ["field"]],

      // InitializeInstanceElements
      initializeInstanceElements: function(
        /*::<C>*/ O /*: C */,
        elements /*: ElementDescriptor[] */,
      ) {
        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            if (element.kind === kind && element.placement === "own") {
              this.defineClassElement(O, element);
            }
          }, this);
        }, this);
      },

      // InitializeClassElements
      initializeClassElements: function(
        /*::<C>*/ F /*: Class<C> */,
        elements /*: ElementDescriptor[] */,
      ) {
        var proto = F.prototype;

        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            var placement = element.placement;
            if (
              element.kind === kind &&
              (placement === "static" || placement === "prototype")
            ) {
              var receiver = placement === "static" ? F : proto;
              this.defineClassElement(receiver, element);
            }
          }, this);
        }, this);
      },

      // DefineClassElement
      defineClassElement: function(
        /*::<C>*/ receiver /*: C | Class<C> */,
        element /*: ElementDescriptor */,
      ) {
        var descriptor /*: PropertyDescriptor */ = element.descriptor;
        if (element.kind === "field") {
          var initializer = element.initializer;
          descriptor = {
            enumerable: descriptor.enumerable,
            writable: descriptor.writable,
            configurable: descriptor.configurable,
            value: initializer === void 0 ? void 0 : initializer.call(receiver),
          };
        }
        Object.defineProperty(receiver, element.key, descriptor);
      },

      // DecorateClass
      decorateClass: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var newElements /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];
        var placements /*: Placements */ = {
          static: [],
          prototype: [],
          own: [],
        };

        elements.forEach(function(element /*: ElementDescriptor */) {
          this.addElementPlacement(element, placements);
        }, this);

        elements.forEach(function(element /*: ElementDescriptor */) {
          if (!_hasDecorators(element)) return newElements.push(element);

          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(
            element,
            placements,
          );
          newElements.push(elementFinishersExtras.element);
          newElements.push.apply(newElements, elementFinishersExtras.extras);
          finishers.push.apply(finishers, elementFinishersExtras.finishers);
        }, this);

        if (!decorators) {
          return { elements: newElements, finishers: finishers };
        }

        var result /*: ElementsFinishers */ = this.decorateConstructor(
          newElements,
          decorators,
        );
        finishers.push.apply(finishers, result.finishers);
        result.finishers = finishers;

        return result;
      },

      // AddElementPlacement
      addElementPlacement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
        silent /*: boolean */,
      ) {
        var keys = placements[element.placement];
        if (!silent && keys.indexOf(element.key) !== -1) {
          throw new TypeError("Duplicated element (" + element.key + ")");
        }
        keys.push(element.key);
      },

      // DecorateElement
      decorateElement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
      ) /*: ElementFinishersExtras */ {
        var extras /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];

        for (
          var decorators = element.decorators, i = decorators.length - 1;
          i >= 0;
          i--
        ) {
          // (inlined) RemoveElementPlacement
          var keys = placements[element.placement];
          keys.splice(keys.indexOf(element.key), 1);

          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(
            element,
          );
          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(
            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||
              elementObject,
          );

          element = elementFinisherExtras.element;
          this.addElementPlacement(element, placements);

          if (elementFinisherExtras.finisher) {
            finishers.push(elementFinisherExtras.finisher);
          }

          var newExtras /*: ElementDescriptor[] | void */ =
            elementFinisherExtras.extras;
          if (newExtras) {
            for (var j = 0; j < newExtras.length; j++) {
              this.addElementPlacement(newExtras[j], placements);
            }
            extras.push.apply(extras, newExtras);
          }
        }

        return { element: element, finishers: finishers, extras: extras };
      },

      // DecorateConstructor
      decorateConstructor: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var finishers /*: ClassFinisher[] */ = [];

        for (var i = decorators.length - 1; i >= 0; i--) {
          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);
          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(
            (0, decorators[i])(obj) /*: ClassObject */ || obj,
          );

          if (elementsAndFinisher.finisher !== undefined) {
            finishers.push(elementsAndFinisher.finisher);
          }

          if (elementsAndFinisher.elements !== undefined) {
            elements = elementsAndFinisher.elements;

            for (var j = 0; j < elements.length - 1; j++) {
              for (var k = j + 1; k < elements.length; k++) {
                if (
                  elements[j].key === elements[k].key &&
                  elements[j].placement === elements[k].placement
                ) {
                  throw new TypeError(
                    "Duplicated element (" + elements[j].key + ")",
                  );
                }
              }
            }
          }
        }

        return { elements: elements, finishers: finishers };
      },

      // FromElementDescriptor
      fromElementDescriptor: function(
        element /*: ElementDescriptor */,
      ) /*: ElementObject */ {
        var obj /*: ElementObject */ = {
          kind: element.kind,
          key: element.key,
          placement: element.placement,
          descriptor: element.descriptor,
        };

        var desc = {
          value: "Descriptor",
          configurable: true,
        };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        if (element.kind === "field") obj.initializer = element.initializer;

        return obj;
      },

      // ToElementDescriptors
      toElementDescriptors: function(
        elementObjects /*: ElementObject[] */,
      ) /*: ElementDescriptor[] */ {
        if (elementObjects === undefined) return;
        return toArray(elementObjects).map(function(elementObject) {
          var element = this.toElementDescriptor(elementObject);
          this.disallowProperty(elementObject, "finisher", "An element descriptor");
          this.disallowProperty(elementObject, "extras", "An element descriptor");
          return element;
        }, this);
      },

      // ToElementDescriptor
      toElementDescriptor: function(
        elementObject /*: ElementObject */,
      ) /*: ElementDescriptor */ {
        var kind = String(elementObject.kind);
        if (kind !== "method" && kind !== "field") {
          throw new TypeError(
            'An element descriptor\\'s .kind property must be either "method" or' +
              ' "field", but a decorator created an element descriptor with' +
              ' .kind "' +
              kind +
              '"',
          );
        }

        var key = toPropertyKey(elementObject.key);

        var placement = String(elementObject.placement);
        if (
          placement !== "static" &&
          placement !== "prototype" &&
          placement !== "own"
        ) {
          throw new TypeError(
            'An element descriptor\\'s .placement property must be one of "static",' +
              ' "prototype" or "own", but a decorator created an element descriptor' +
              ' with .placement "' +
              placement +
              '"',
          );
        }

        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;

        this.disallowProperty(elementObject, "elements", "An element descriptor");

        var element /*: ElementDescriptor */ = {
          kind: kind,
          key: key,
          placement: placement,
          descriptor: Object.assign({}, descriptor),
        };

        if (kind !== "field") {
          this.disallowProperty(elementObject, "initializer", "A method descriptor");
        } else {
          this.disallowProperty(
            descriptor,
            "get",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "set",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "value",
            "The property descriptor of a field descriptor",
          );

          element.initializer = elementObject.initializer;
        }

        return element;
      },

      toElementFinisherExtras: function(
        elementObject /*: ElementObject */,
      ) /*: ElementFinisherExtras */ {
        var element /*: ElementDescriptor */ = this.toElementDescriptor(
          elementObject,
        );
        var finisher /*: ClassFinisher */ = _optionalCallableProperty(
          elementObject,
          "finisher",
        );
        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(
          elementObject.extras,
        );

        return { element: element, finisher: finisher, extras: extras };
      },

      // FromClassDescriptor
      fromClassDescriptor: function(
        elements /*: ElementDescriptor[] */,
      ) /*: ClassObject */ {
        var obj = {
          kind: "class",
          elements: elements.map(this.fromElementDescriptor, this),
        };

        var desc = { value: "Descriptor", configurable: true };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        return obj;
      },

      // ToClassDescriptor
      toClassDescriptor: function(
        obj /*: ClassObject */,
      ) /*: ElementsFinisher */ {
        var kind = String(obj.kind);
        if (kind !== "class") {
          throw new TypeError(
            'A class descriptor\\'s .kind property must be "class", but a decorator' +
              ' created a class descriptor with .kind "' +
              kind +
              '"',
          );
        }

        this.disallowProperty(obj, "key", "A class descriptor");
        this.disallowProperty(obj, "placement", "A class descriptor");
        this.disallowProperty(obj, "descriptor", "A class descriptor");
        this.disallowProperty(obj, "initializer", "A class descriptor");
        this.disallowProperty(obj, "extras", "A class descriptor");

        var finisher = _optionalCallableProperty(obj, "finisher");
        var elements = this.toElementDescriptors(obj.elements);

        return { elements: elements, finisher: finisher };
      },

      // RunClassFinishers
      runClassFinishers: function(
        constructor /*: Class<*> */,
        finishers /*: ClassFinisher[] */,
      ) /*: Class<*> */ {
        for (var i = 0; i < finishers.length; i++) {
          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);
          if (newConstructor !== undefined) {
            // NOTE: This should check if IsConstructor(newConstructor) is false.
            if (typeof newConstructor !== "function") {
              throw new TypeError("Finishers must return a constructor.");
            }
            constructor = newConstructor;
          }
        }
        return constructor;
      },

      disallowProperty: function(obj, name, objectType) {
        if (obj[name] !== undefined) {
          throw new TypeError(objectType + " can't have a ." + name + " property.");
        }
      }
    };

    return api;
  }

  // ClassElementEvaluation
  function _createElementDescriptor(
    def /*: ElementDefinition */,
  ) /*: ElementDescriptor */ {
    var key = toPropertyKey(def.key);

    var descriptor /*: PropertyDescriptor */;
    if (def.kind === "method") {
      descriptor = {
        value: def.value,
        writable: true,
        configurable: true,
        enumerable: false,
      };
    } else if (def.kind === "get") {
      descriptor = { get: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "set") {
      descriptor = { set: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "field") {
      descriptor = { configurable: true, writable: true, enumerable: true };
    }

    var element /*: ElementDescriptor */ = {
      kind: def.kind === "field" ? "field" : "method",
      key: key,
      placement: def.static
        ? "static"
        : def.kind === "field"
        ? "own"
        : "prototype",
      descriptor: descriptor,
    };
    if (def.decorators) element.decorators = def.decorators;
    if (def.kind === "field") element.initializer = def.value;

    return element;
  }

  // CoalesceGetterSetter
  function _coalesceGetterSetter(
    element /*: ElementDescriptor */,
    other /*: ElementDescriptor */,
  ) {
    if (element.descriptor.get !== undefined) {
      other.descriptor.get = element.descriptor.get;
    } else {
      other.descriptor.set = element.descriptor.set;
    }
  }

  // CoalesceClassElements
  function _coalesceClassElements(
    elements /*: ElementDescriptor[] */,
  ) /*: ElementDescriptor[] */ {
    var newElements /*: ElementDescriptor[] */ = [];

    var isSameElement = function(
      other /*: ElementDescriptor */,
    ) /*: boolean */ {
      return (
        other.kind === "method" &&
        other.key === element.key &&
        other.placement === element.placement
      );
    };

    for (var i = 0; i < elements.length; i++) {
      var element /*: ElementDescriptor */ = elements[i];
      var other /*: ElementDescriptor */;

      if (
        element.kind === "method" &&
        (other = newElements.find(isSameElement))
      ) {
        if (
          _isDataDescriptor(element.descriptor) ||
          _isDataDescriptor(other.descriptor)
        ) {
          if (_hasDecorators(element) || _hasDecorators(other)) {
            throw new ReferenceError(
              "Duplicated methods (" + element.key + ") can't be decorated.",
            );
          }
          other.descriptor = element.descriptor;
        } else {
          if (_hasDecorators(element)) {
            if (_hasDecorators(other)) {
              throw new ReferenceError(
                "Decorators can't be placed on different accessors with for " +
                  "the same property (" +
                  element.key +
                  ").",
              );
            }
            other.decorators = element.decorators;
          }
          _coalesceGetterSetter(element, other);
        }
      } else {
        newElements.push(element);
      }
    }

    return newElements;
  }

  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {
    return element.decorators && element.decorators.length;
  }

  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {
    return (
      desc !== undefined &&
      !(desc.value === undefined && desc.writable === undefined)
    );
  }

  function _optionalCallableProperty /*::<T>*/(
    obj /*: T */,
    name /*: $Keys<T> */,
  ) /*: ?Function */ {
    var value = obj[name];
    if (value !== undefined && typeof value !== "function") {
      throw new TypeError("Expected '" + name + "' to be a function");
    }
    return value;
  }

`, d.classPrivateMethodGet = o("7.1.6")`
  export default function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
  }
`, d.checkPrivateRedeclaration = o("7.14.1")`
  export default function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
      throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
  }
`, d.classPrivateFieldInitSpec = o("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateFieldInitSpec(obj, privateMap, value) {
    checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
  }
`, d.classPrivateMethodInitSpec = o("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateMethodInitSpec(obj, privateSet) {
    checkPrivateRedeclaration(obj, privateSet);
    privateSet.add(obj);
  }
`, d.classPrivateMethodSet = o("7.1.6")`
    export default function _classPrivateMethodSet() {
      throw new TypeError("attempted to reassign private method");
    }
  `, d.identity = o("7.17.0")`
  export default function _identity(x) {
    return x;
  }
`;
      }, "./node_modules/.pnpm/@babel+helpers@7.22.15/node_modules/@babel/helpers/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0, r.ensure = function(I, D) {
          E || (E = D), P(I);
        }, r.get = R, r.getDependencies = function(I) {
          return P(I).getDependencies();
        }, r.list = void 0, r.minVersion = function(I) {
          return P(I).minVersion;
        };
        var i = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/index.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js"), d = l("./node_modules/.pnpm/@babel+helpers@7.22.15/node_modules/@babel/helpers/lib/helpers.js");
        const { assignmentExpression: s, cloneNode: o, expressionStatement: m, file: h, identifier: y } = f;
        function b(I) {
          const D = [];
          for (; I.parentPath; I = I.parentPath)
            D.push(I.key), I.inList && D.push(I.listKey);
          return D.reverse().join(".");
        }
        let E;
        function S(I) {
          const D = /* @__PURE__ */ new Set(), j = /* @__PURE__ */ new Set(), F = /* @__PURE__ */ new Map();
          let _, T;
          const v = [], w = [], O = [], G = { ImportDeclaration(U) {
            const M = U.node.source.value;
            if (!d.default[M])
              throw U.buildCodeFrameError(`Unknown helper ${M}`);
            if (U.get("specifiers").length !== 1 || !U.get("specifiers.0").isImportDefaultSpecifier())
              throw U.buildCodeFrameError("Helpers can only import a default value");
            const B = U.node.specifiers[0].local;
            F.set(B, M), w.push(b(U));
          }, ExportDefaultDeclaration(U) {
            const M = U.get("declaration");
            if (!M.isFunctionDeclaration() || !M.node.id)
              throw M.buildCodeFrameError("Helpers can only export named function declarations");
            _ = M.node.id.name, T = b(U);
          }, ExportAllDeclaration(U) {
            throw U.buildCodeFrameError("Helpers can only export default");
          }, ExportNamedDeclaration(U) {
            throw U.buildCodeFrameError("Helpers can only export default");
          }, Statement(U) {
            U.isImportDeclaration() || U.isExportDeclaration() || U.skip();
          } }, W = { Program(U) {
            const M = U.scope.getAllBindings();
            Object.keys(M).forEach((B) => {
              B !== _ && (F.has(M[B].identifier) || j.add(B));
            });
          }, ReferencedIdentifier(U) {
            const M = U.node.name, B = U.scope.getBinding(M);
            B ? F.has(B.identifier) && O.push(b(U)) : D.add(M);
          }, AssignmentExpression(U) {
            const M = U.get("left");
            if (!(_ in M.getBindingIdentifiers()))
              return;
            if (!M.isIdentifier())
              throw M.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");
            const B = U.scope.getBinding(_);
            B != null && B.scope.path.isProgram() && v.push(b(U));
          } };
          if ((0, i.default)(I.ast, G, I.scope), (0, i.default)(I.ast, W, I.scope), !T)
            throw new Error("Helpers must have a default export.");
          return v.reverse(), { globals: Array.from(D), localBindingNames: Array.from(j), dependencies: F, exportBindingAssignments: v, exportPath: T, exportName: _, importBindingsReferences: O, importPaths: w };
        }
        const g = /* @__PURE__ */ Object.create(null);
        function P(I) {
          if (!g[I]) {
            const D = d.default[I];
            if (!D)
              throw Object.assign(new ReferenceError(`Unknown helper ${I}`), { code: "BABEL_HELPER_UNKNOWN", helper: I });
            const j = () => {
              if (!E) {
                const _ = { ast: h(D.ast()), path: null };
                return (0, i.default)(_.ast, { Program: (T) => (_.path = T).stop() }), _;
              }
              return new E({ filename: `babel-helper://${I}` }, { ast: h(D.ast()), code: "[internal Babel helper code]", inputMap: null });
            };
            let F = null;
            g[I] = { minVersion: D.minVersion, build(_, T, v) {
              const w = j();
              return F || (F = S(w)), function(O, G, W, U, M) {
                if (U && !W)
                  throw new Error("Unexpected local bindings for module-based helpers.");
                if (!W)
                  return;
                const { localBindingNames: B, dependencies: k, exportBindingAssignments: K, exportPath: te, exportName: z, importBindingsReferences: q, importPaths: $ } = G, Y = {};
                k.forEach((oe, re) => {
                  Y[re.name] = typeof M == "function" && M(oe) || re;
                });
                const H = {}, Q = new Set(U || []);
                B.forEach((oe) => {
                  let re = oe;
                  for (; Q.has(re); )
                    re = "_" + re;
                  re !== oe && (H[oe] = re);
                }), W.type === "Identifier" && z !== W.name && (H[z] = W.name);
                const { path: X } = O, ne = X.get(te), ye = $.map((oe) => X.get(oe)), ve = q.map((oe) => X.get(oe)), de = ne.get("declaration");
                if (W.type === "Identifier")
                  ne.replaceWith(de);
                else {
                  if (W.type !== "MemberExpression")
                    throw new Error("Unexpected helper format.");
                  K.forEach((oe) => {
                    const re = X.get(oe);
                    re.replaceWith(s("=", W, re.node));
                  }), ne.replaceWith(de), X.pushContainer("body", m(s("=", W, y(z))));
                }
                Object.keys(H).forEach((oe) => {
                  X.scope.rename(oe, H[oe]);
                });
                for (const oe of ye)
                  oe.remove();
                for (const oe of ve) {
                  const re = o(Y[oe.node.name]);
                  oe.replaceWith(re);
                }
              }(w, F, T, v, _), { nodes: w.ast.program.body, globals: F.globals };
            }, getDependencies: () => (F || (F = S(j())), Array.from(F.dependencies.values())) };
          }
          return g[I];
        }
        function R(I, D, j, F) {
          return P(I).build(D, j, F);
        }
        const N = Object.keys(d.default).map((I) => I.replace(/^_/, ""));
        r.list = N;
        var C = R;
        r.default = C;
      }, "./node_modules/.pnpm/@babel+parser@7.22.16/node_modules/@babel/parser/lib/index.js": (u, r) => {
        function l(Te, p) {
          if (Te == null)
            return {};
          var A, V, ee = {}, fe = Object.keys(Te);
          for (V = 0; V < fe.length; V++)
            A = fe[V], p.indexOf(A) >= 0 || (ee[A] = Te[A]);
          return ee;
        }
        Object.defineProperty(r, "__esModule", { value: !0 });
        class i {
          constructor(p, A, V) {
            this.line = void 0, this.column = void 0, this.index = void 0, this.line = p, this.column = A, this.index = V;
          }
        }
        class f {
          constructor(p, A) {
            this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = p, this.end = A;
          }
        }
        function d(Te, p) {
          const { line: A, column: V, index: ee } = Te;
          return new i(A, V + p, ee + p);
        }
        const s = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
        var o = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: s }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: s } };
        const m = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, h = ({ type: Te, prefix: p }) => Te === "UpdateExpression" ? m.UpdateExpression[String(p)] : m[Te];
        var y = { AccessorIsGenerator: ({ kind: Te }) => `A ${Te}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: Te }) => `Missing initializer in ${Te} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: ({ exportName: Te }) => `\`${Te}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: ({ localName: Te, exportName: p }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${Te}' as '${p}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: Te }) => `'${Te === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: ({ type: Te }) => `Unsyntactic ${Te === "BreakStatement" ? "break" : "continue"}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.", ImportBindingIsString: ({ importName: Te }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${Te}" as foo }\`?`, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: ({ maxArgumentCount: Te }) => `\`import()\` requires exactly ${Te === 1 ? "one argument" : "one or two arguments"}.`, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: ({ radix: Te }) => `Expected number in radix ${Te}.`, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: ({ reservedWord: Te }) => `Escape sequence in keyword ${Te}.`, InvalidIdentifier: ({ identifierName: Te }) => `Invalid identifier ${Te}.`, InvalidLhs: ({ ancestor: Te }) => `Invalid left-hand side in ${h(Te)}.`, InvalidLhsBinding: ({ ancestor: Te }) => `Binding invalid left-hand side in ${h(Te)}.`, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: Te }) => `Unexpected character '${Te}'.`, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: ({ identifierName: Te }) => `Private name #${Te} is not defined.`, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: Te }) => `Label '${Te}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: ({ missingPlugin: Te }) => `This experimental syntax requires enabling the parser plugin: ${Te.map((p) => JSON.stringify(p)).join(", ")}.`, MissingOneOfPlugins: ({ missingPlugin: Te }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${Te.map((p) => JSON.stringify(p)).join(", ")}.`, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: ({ key: Te }) => `Duplicate key "${Te}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: Te }) => `An export name cannot include a lone surrogate, found '\\u${Te.toString(16)}'.`, ModuleExportUndefined: ({ localName: Te }) => `Export '${Te}' is not defined.`, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: Te }) => `Private names are only allowed in property accesses (\`obj.#${Te}\`) or in \`in\` expressions (\`#${Te} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: Te }) => `Duplicate private name #${Te}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: Te }) => `Unexpected keyword '${Te}'.`, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: ({ reservedWord: Te }) => `Unexpected reserved word '${Te}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: Te, unexpected: p }) => `Unexpected token${p ? ` '${p}'.` : ""}${Te ? `, expected "${Te}"` : ""}`, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: ({ target: Te, onlyValidPropertyName: p }) => `The only valid meta property for ${Te} is ${Te}.${p}.`, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: ({ identifierName: Te }) => `Identifier '${Te}' has already been declared.`, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." };
        const b = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
        var E = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: ({ token: Te }) => `Invalid topic token ${Te}. In order to use ${Te} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${Te}" }.`, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: ({ type: Te }) => `Hack-style pipe body cannot be an unparenthesized ${h({ type: Te })}; please wrap it in parentheses.`, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' };
        const S = ["toMessage"], g = ["message"];
        function P(Te, p, A) {
          Object.defineProperty(Te, p, { enumerable: !1, configurable: !0, value: A });
        }
        function R(Te) {
          let { toMessage: p } = Te, A = l(Te, S);
          return function V({ loc: ee, details: fe }) {
            const Se = new SyntaxError();
            return Object.assign(Se, A, { loc: ee, pos: ee.index }), "missingPlugin" in fe && Object.assign(Se, { missingPlugin: fe.missingPlugin }), P(Se, "clone", function(Pe = {}) {
              var Re;
              const { line: je, column: ze, index: mt } = (Re = Pe.loc) != null ? Re : ee;
              return V({ loc: new i(je, ze, mt), details: Object.assign({}, fe, Pe.details) });
            }), P(Se, "details", fe), Object.defineProperty(Se, "message", { configurable: !0, get() {
              const Pe = `${p(fe)} (${ee.line}:${ee.column})`;
              return this.message = Pe, Pe;
            }, set(Pe) {
              Object.defineProperty(this, "message", { value: Pe, writable: !0 });
            } }), Se;
          };
        }
        function N(Te, p) {
          if (Array.isArray(Te))
            return (V) => N(V, Te[0]);
          const A = {};
          for (const V of Object.keys(Te)) {
            const ee = Te[V], fe = typeof ee == "string" ? { message: () => ee } : typeof ee == "function" ? { message: ee } : ee, { message: Se } = fe, Pe = l(fe, g), Re = typeof Se == "string" ? () => Se : Se;
            A[V] = R(Object.assign({ code: "BABEL_PARSER_SYNTAX_ERROR", reasonCode: V, toMessage: Re }, p ? { syntaxPlugin: p } : {}, Pe));
          }
          return A;
        }
        const C = Object.assign({}, N(o), N(y), N({ StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: ({ referenceName: Te }) => `Assigning to '${Te}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: Te }) => `Binding '${Te}' in strict mode.`, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }), N`pipelineOperator`(E)), { defineProperty: I } = Object, D = (Te, p) => I(Te, p, { enumerable: !1, value: Te[p] });
        function j(Te) {
          return Te.loc.start && D(Te.loc.start, "index"), Te.loc.end && D(Te.loc.end, "index"), Te;
        }
        class F {
          constructor(p, A) {
            this.token = void 0, this.preserveSpace = void 0, this.token = p, this.preserveSpace = !!A;
          }
        }
        const _ = { brace: new F("{"), j_oTag: new F("<tag"), j_cTag: new F("</tag"), j_expr: new F("<tag>...</tag>", !0) };
        _.template = new F("`", !0);
        class T {
          constructor(p, A = {}) {
            this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = p, this.keyword = A.keyword, this.beforeExpr = !!A.beforeExpr, this.startsExpr = !!A.startsExpr, this.rightAssociative = !!A.rightAssociative, this.isLoop = !!A.isLoop, this.isAssign = !!A.isAssign, this.prefix = !!A.prefix, this.postfix = !!A.postfix, this.binop = A.binop != null ? A.binop : null, this.updateContext = null;
          }
        }
        const v = /* @__PURE__ */ new Map();
        function w(Te, p = {}) {
          p.keyword = Te;
          const A = te(Te, p);
          return v.set(Te, A), A;
        }
        function O(Te, p) {
          return te(Te, { beforeExpr: !0, binop: p });
        }
        let G = -1;
        const W = [], U = [], M = [], B = [], k = [], K = [];
        function te(Te, p = {}) {
          var A, V, ee, fe;
          return ++G, U.push(Te), M.push((A = p.binop) != null ? A : -1), B.push((V = p.beforeExpr) != null && V), k.push((ee = p.startsExpr) != null && ee), K.push((fe = p.prefix) != null && fe), W.push(new T(Te, p)), G;
        }
        function z(Te, p = {}) {
          var A, V, ee, fe;
          return ++G, v.set(Te, G), U.push(Te), M.push((A = p.binop) != null ? A : -1), B.push((V = p.beforeExpr) != null && V), k.push((ee = p.startsExpr) != null && ee), K.push((fe = p.prefix) != null && fe), W.push(new T("name", p)), G;
        }
        const q = { bracketL: te("[", { beforeExpr: !0, startsExpr: !0 }), bracketHashL: te("#[", { beforeExpr: !0, startsExpr: !0 }), bracketBarL: te("[|", { beforeExpr: !0, startsExpr: !0 }), bracketR: te("]"), bracketBarR: te("|]"), braceL: te("{", { beforeExpr: !0, startsExpr: !0 }), braceBarL: te("{|", { beforeExpr: !0, startsExpr: !0 }), braceHashL: te("#{", { beforeExpr: !0, startsExpr: !0 }), braceR: te("}"), braceBarR: te("|}"), parenL: te("(", { beforeExpr: !0, startsExpr: !0 }), parenR: te(")"), comma: te(",", { beforeExpr: !0 }), semi: te(";", { beforeExpr: !0 }), colon: te(":", { beforeExpr: !0 }), doubleColon: te("::", { beforeExpr: !0 }), dot: te("."), question: te("?", { beforeExpr: !0 }), questionDot: te("?."), arrow: te("=>", { beforeExpr: !0 }), template: te("template"), ellipsis: te("...", { beforeExpr: !0 }), backQuote: te("`", { startsExpr: !0 }), dollarBraceL: te("${", { beforeExpr: !0, startsExpr: !0 }), templateTail: te("...`", { startsExpr: !0 }), templateNonTail: te("...${", { beforeExpr: !0, startsExpr: !0 }), at: te("@"), hash: te("#", { startsExpr: !0 }), interpreterDirective: te("#!..."), eq: te("=", { beforeExpr: !0, isAssign: !0 }), assign: te("_=", { beforeExpr: !0, isAssign: !0 }), slashAssign: te("_=", { beforeExpr: !0, isAssign: !0 }), xorAssign: te("_=", { beforeExpr: !0, isAssign: !0 }), moduloAssign: te("_=", { beforeExpr: !0, isAssign: !0 }), incDec: te("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }), bang: te("!", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), tilde: te("~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), doubleCaret: te("^^", { startsExpr: !0 }), doubleAt: te("@@", { startsExpr: !0 }), pipeline: O("|>", 0), nullishCoalescing: O("??", 1), logicalOR: O("||", 1), logicalAND: O("&&", 2), bitwiseOR: O("|", 3), bitwiseXOR: O("^", 4), bitwiseAND: O("&", 5), equality: O("==/!=/===/!==", 6), lt: O("</>/<=/>=", 7), gt: O("</>/<=/>=", 7), relational: O("</>/<=/>=", 7), bitShift: O("<</>>/>>>", 8), bitShiftL: O("<</>>/>>>", 8), bitShiftR: O("<</>>/>>>", 8), plusMin: te("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }), modulo: te("%", { binop: 10, startsExpr: !0 }), star: te("*", { binop: 10 }), slash: O("/", 10), exponent: te("**", { beforeExpr: !0, binop: 11, rightAssociative: !0 }), _in: w("in", { beforeExpr: !0, binop: 7 }), _instanceof: w("instanceof", { beforeExpr: !0, binop: 7 }), _break: w("break"), _case: w("case", { beforeExpr: !0 }), _catch: w("catch"), _continue: w("continue"), _debugger: w("debugger"), _default: w("default", { beforeExpr: !0 }), _else: w("else", { beforeExpr: !0 }), _finally: w("finally"), _function: w("function", { startsExpr: !0 }), _if: w("if"), _return: w("return", { beforeExpr: !0 }), _switch: w("switch"), _throw: w("throw", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _try: w("try"), _var: w("var"), _const: w("const"), _with: w("with"), _new: w("new", { beforeExpr: !0, startsExpr: !0 }), _this: w("this", { startsExpr: !0 }), _super: w("super", { startsExpr: !0 }), _class: w("class", { startsExpr: !0 }), _extends: w("extends", { beforeExpr: !0 }), _export: w("export"), _import: w("import", { startsExpr: !0 }), _null: w("null", { startsExpr: !0 }), _true: w("true", { startsExpr: !0 }), _false: w("false", { startsExpr: !0 }), _typeof: w("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _void: w("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _delete: w("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _do: w("do", { isLoop: !0, beforeExpr: !0 }), _for: w("for", { isLoop: !0 }), _while: w("while", { isLoop: !0 }), _as: z("as", { startsExpr: !0 }), _assert: z("assert", { startsExpr: !0 }), _async: z("async", { startsExpr: !0 }), _await: z("await", { startsExpr: !0 }), _from: z("from", { startsExpr: !0 }), _get: z("get", { startsExpr: !0 }), _let: z("let", { startsExpr: !0 }), _meta: z("meta", { startsExpr: !0 }), _of: z("of", { startsExpr: !0 }), _sent: z("sent", { startsExpr: !0 }), _set: z("set", { startsExpr: !0 }), _static: z("static", { startsExpr: !0 }), _using: z("using", { startsExpr: !0 }), _yield: z("yield", { startsExpr: !0 }), _asserts: z("asserts", { startsExpr: !0 }), _checks: z("checks", { startsExpr: !0 }), _exports: z("exports", { startsExpr: !0 }), _global: z("global", { startsExpr: !0 }), _implements: z("implements", { startsExpr: !0 }), _intrinsic: z("intrinsic", { startsExpr: !0 }), _infer: z("infer", { startsExpr: !0 }), _is: z("is", { startsExpr: !0 }), _mixins: z("mixins", { startsExpr: !0 }), _proto: z("proto", { startsExpr: !0 }), _require: z("require", { startsExpr: !0 }), _satisfies: z("satisfies", { startsExpr: !0 }), _keyof: z("keyof", { startsExpr: !0 }), _readonly: z("readonly", { startsExpr: !0 }), _unique: z("unique", { startsExpr: !0 }), _abstract: z("abstract", { startsExpr: !0 }), _declare: z("declare", { startsExpr: !0 }), _enum: z("enum", { startsExpr: !0 }), _module: z("module", { startsExpr: !0 }), _namespace: z("namespace", { startsExpr: !0 }), _interface: z("interface", { startsExpr: !0 }), _type: z("type", { startsExpr: !0 }), _opaque: z("opaque", { startsExpr: !0 }), name: te("name", { startsExpr: !0 }), string: te("string", { startsExpr: !0 }), num: te("num", { startsExpr: !0 }), bigint: te("bigint", { startsExpr: !0 }), decimal: te("decimal", { startsExpr: !0 }), regexp: te("regexp", { startsExpr: !0 }), privateName: te("#name", { startsExpr: !0 }), eof: te("eof"), jsxName: te("jsxName"), jsxText: te("jsxText", { beforeExpr: !0 }), jsxTagStart: te("jsxTagStart", { startsExpr: !0 }), jsxTagEnd: te("jsxTagEnd"), placeholder: te("%%", { startsExpr: !0 }) };
        function $(Te) {
          return Te >= 93 && Te <= 130;
        }
        function Y(Te) {
          return Te >= 58 && Te <= 130;
        }
        function H(Te) {
          return Te >= 58 && Te <= 134;
        }
        function Q(Te) {
          return k[Te];
        }
        function X(Te) {
          return Te >= 127 && Te <= 129;
        }
        function ne(Te) {
          return Te >= 58 && Te <= 92;
        }
        function ye(Te) {
          return U[Te];
        }
        function ve(Te) {
          return M[Te];
        }
        function de(Te) {
          return Te >= 24 && Te <= 25;
        }
        function oe(Te) {
          return W[Te];
        }
        W[8].updateContext = (Te) => {
          Te.pop();
        }, W[5].updateContext = W[7].updateContext = W[23].updateContext = (Te) => {
          Te.push(_.brace);
        }, W[22].updateContext = (Te) => {
          Te[Te.length - 1] === _.template ? Te.pop() : Te.push(_.template);
        }, W[140].updateContext = (Te) => {
          Te.push(_.j_expr, _.j_oTag);
        };
        let re = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", ae = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
        const le = new RegExp("[" + re + "]"), ue = new RegExp("[" + re + ae + "]");
        re = ae = null;
        const ie = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191], we = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function De(Te, p) {
          let A = 65536;
          for (let V = 0, ee = p.length; V < ee; V += 2) {
            if (A += p[V], A > Te)
              return !1;
            if (A += p[V + 1], A >= Te)
              return !0;
          }
          return !1;
        }
        function Ee(Te) {
          return Te < 65 ? Te === 36 : Te <= 90 || (Te < 97 ? Te === 95 : Te <= 122 || (Te <= 65535 ? Te >= 170 && le.test(String.fromCharCode(Te)) : De(Te, ie)));
        }
        function Ae(Te) {
          return Te < 48 ? Te === 36 : Te < 58 || !(Te < 65) && (Te <= 90 || (Te < 97 ? Te === 95 : Te <= 122 || (Te <= 65535 ? Te >= 170 && ue.test(String.fromCharCode(Te)) : De(Te, ie) || De(Te, we))));
        }
        const Me = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], me = ["eval", "arguments"], se = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), Z = new Set(Me), pe = new Set(me);
        function be(Te, p) {
          return p && Te === "await" || Te === "enum";
        }
        function _e(Te, p) {
          return be(Te, p) || Z.has(Te);
        }
        function Ie(Te) {
          return pe.has(Te);
        }
        function We(Te, p) {
          return _e(Te, p) || Ie(Te);
        }
        const tt = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
        class Ye {
          constructor(p) {
            this.var = /* @__PURE__ */ new Set(), this.lexical = /* @__PURE__ */ new Set(), this.functions = /* @__PURE__ */ new Set(), this.flags = p;
          }
        }
        class ht {
          constructor(p, A) {
            this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = p, this.inModule = A;
          }
          get inTopLevel() {
            return (1 & this.currentScope().flags) > 0;
          }
          get inFunction() {
            return (2 & this.currentVarScopeFlags()) > 0;
          }
          get allowSuper() {
            return (16 & this.currentThisScopeFlags()) > 0;
          }
          get allowDirectSuper() {
            return (32 & this.currentThisScopeFlags()) > 0;
          }
          get inClass() {
            return (64 & this.currentThisScopeFlags()) > 0;
          }
          get inClassAndNotInNonArrowFunction() {
            const p = this.currentThisScopeFlags();
            return (64 & p) > 0 && (2 & p) == 0;
          }
          get inStaticBlock() {
            for (let p = this.scopeStack.length - 1; ; p--) {
              const { flags: A } = this.scopeStack[p];
              if (128 & A)
                return !0;
              if (451 & A)
                return !1;
            }
          }
          get inNonArrowFunction() {
            return (2 & this.currentThisScopeFlags()) > 0;
          }
          get treatFunctionsAsVar() {
            return this.treatFunctionsAsVarInScope(this.currentScope());
          }
          createScope(p) {
            return new Ye(p);
          }
          enter(p) {
            this.scopeStack.push(this.createScope(p));
          }
          exit() {
            return this.scopeStack.pop().flags;
          }
          treatFunctionsAsVarInScope(p) {
            return !!(130 & p.flags || !this.parser.inModule && 1 & p.flags);
          }
          declareName(p, A, V) {
            let ee = this.currentScope();
            if (8 & A || 16 & A)
              this.checkRedeclarationInScope(ee, p, A, V), 16 & A ? ee.functions.add(p) : ee.lexical.add(p), 8 & A && this.maybeExportDefined(ee, p);
            else if (4 & A)
              for (let fe = this.scopeStack.length - 1; fe >= 0 && (ee = this.scopeStack[fe], this.checkRedeclarationInScope(ee, p, A, V), ee.var.add(p), this.maybeExportDefined(ee, p), !(387 & ee.flags)); --fe)
                ;
            this.parser.inModule && 1 & ee.flags && this.undefinedExports.delete(p);
          }
          maybeExportDefined(p, A) {
            this.parser.inModule && 1 & p.flags && this.undefinedExports.delete(A);
          }
          checkRedeclarationInScope(p, A, V, ee) {
            this.isRedeclaredInScope(p, A, V) && this.parser.raise(C.VarRedeclaration, { at: ee, identifierName: A });
          }
          isRedeclaredInScope(p, A, V) {
            return !!(1 & V) && (8 & V ? p.lexical.has(A) || p.functions.has(A) || p.var.has(A) : 16 & V ? p.lexical.has(A) || !this.treatFunctionsAsVarInScope(p) && p.var.has(A) : p.lexical.has(A) && !(8 & p.flags && p.lexical.values().next().value === A) || !this.treatFunctionsAsVarInScope(p) && p.functions.has(A));
          }
          checkLocalExport(p) {
            const { name: A } = p, V = this.scopeStack[0];
            V.lexical.has(A) || V.var.has(A) || V.functions.has(A) || this.undefinedExports.set(A, p.loc.start);
          }
          currentScope() {
            return this.scopeStack[this.scopeStack.length - 1];
          }
          currentVarScopeFlags() {
            for (let p = this.scopeStack.length - 1; ; p--) {
              const { flags: A } = this.scopeStack[p];
              if (387 & A)
                return A;
            }
          }
          currentThisScopeFlags() {
            for (let p = this.scopeStack.length - 1; ; p--) {
              const { flags: A } = this.scopeStack[p];
              if (451 & A && !(4 & A))
                return A;
            }
          }
        }
        class ct extends Ye {
          constructor(...p) {
            super(...p), this.declareFunctions = /* @__PURE__ */ new Set();
          }
        }
        class st extends ht {
          createScope(p) {
            return new ct(p);
          }
          declareName(p, A, V) {
            const ee = this.currentScope();
            if (2048 & A)
              return this.checkRedeclarationInScope(ee, p, A, V), this.maybeExportDefined(ee, p), void ee.declareFunctions.add(p);
            super.declareName(p, A, V);
          }
          isRedeclaredInScope(p, A, V) {
            return !!super.isRedeclaredInScope(p, A, V) || !!(2048 & V) && !p.declareFunctions.has(A) && (p.lexical.has(A) || p.functions.has(A));
          }
          checkLocalExport(p) {
            this.scopeStack[0].declareFunctions.has(p.name) || super.checkLocalExport(p);
          }
        }
        class Xe {
          constructor() {
            this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
          }
          hasPlugin(p) {
            if (typeof p == "string")
              return this.plugins.has(p);
            {
              const [A, V] = p;
              if (!this.hasPlugin(A))
                return !1;
              const ee = this.plugins.get(A);
              for (const fe of Object.keys(V))
                if ((ee == null ? void 0 : ee[fe]) !== V[fe])
                  return !1;
              return !0;
            }
          }
          getPluginOption(p, A) {
            var V;
            return (V = this.plugins.get(p)) == null ? void 0 : V[A];
          }
        }
        function Ke(Te, p) {
          Te.trailingComments === void 0 ? Te.trailingComments = p : Te.trailingComments.unshift(...p);
        }
        function Ce(Te, p) {
          Te.innerComments === void 0 ? Te.innerComments = p : Te.innerComments.unshift(...p);
        }
        function xe(Te, p, A) {
          let V = null, ee = p.length;
          for (; V === null && ee > 0; )
            V = p[--ee];
          V === null || V.start > A.start ? Ce(Te, A.comments) : Ke(V, A.comments);
        }
        class He extends Xe {
          addComment(p) {
            this.filename && (p.loc.filename = this.filename), this.state.comments.push(p);
          }
          processComment(p) {
            const { commentStack: A } = this.state, V = A.length;
            if (V === 0)
              return;
            let ee = V - 1;
            const fe = A[ee];
            fe.start === p.end && (fe.leadingNode = p, ee--);
            const { start: Se } = p;
            for (; ee >= 0; ee--) {
              const Pe = A[ee], Re = Pe.end;
              if (!(Re > Se)) {
                Re === Se && (Pe.trailingNode = p);
                break;
              }
              Pe.containingNode = p, this.finalizeComment(Pe), A.splice(ee, 1);
            }
          }
          finalizeComment(p) {
            const { comments: A } = p;
            if (p.leadingNode !== null || p.trailingNode !== null)
              p.leadingNode !== null && Ke(p.leadingNode, A), p.trailingNode !== null && function(V, ee) {
                V.leadingComments === void 0 ? V.leadingComments = ee : V.leadingComments.unshift(...ee);
              }(p.trailingNode, A);
            else {
              const { containingNode: V, start: ee } = p;
              if (this.input.charCodeAt(ee - 1) === 44)
                switch (V.type) {
                  case "ObjectExpression":
                  case "ObjectPattern":
                  case "RecordExpression":
                    xe(V, V.properties, p);
                    break;
                  case "CallExpression":
                  case "OptionalCallExpression":
                    xe(V, V.arguments, p);
                    break;
                  case "FunctionDeclaration":
                  case "FunctionExpression":
                  case "ArrowFunctionExpression":
                  case "ObjectMethod":
                  case "ClassMethod":
                  case "ClassPrivateMethod":
                    xe(V, V.params, p);
                    break;
                  case "ArrayExpression":
                  case "ArrayPattern":
                  case "TupleExpression":
                    xe(V, V.elements, p);
                    break;
                  case "ExportNamedDeclaration":
                  case "ImportDeclaration":
                    xe(V, V.specifiers, p);
                    break;
                  default:
                    Ce(V, A);
                }
              else
                Ce(V, A);
            }
          }
          finalizeRemainingComments() {
            const { commentStack: p } = this.state;
            for (let A = p.length - 1; A >= 0; A--)
              this.finalizeComment(p[A]);
            this.state.commentStack = [];
          }
          resetPreviousNodeTrailingComments(p) {
            const { commentStack: A } = this.state, { length: V } = A;
            if (V === 0)
              return;
            const ee = A[V - 1];
            ee.leadingNode === p && (ee.leadingNode = null);
          }
          resetPreviousIdentifierLeadingComments(p) {
            const { commentStack: A } = this.state, { length: V } = A;
            V !== 0 && (A[V - 1].trailingNode === p ? A[V - 1].trailingNode = null : V >= 2 && A[V - 2].trailingNode === p && (A[V - 2].trailingNode = null));
          }
          takeSurroundingComments(p, A, V) {
            const { commentStack: ee } = this.state, fe = ee.length;
            if (fe === 0)
              return;
            let Se = fe - 1;
            for (; Se >= 0; Se--) {
              const Pe = ee[Se], Re = Pe.end;
              if (Pe.start === V)
                Pe.leadingNode = p;
              else if (Re === A)
                Pe.trailingNode = p;
              else if (Re < A)
                break;
            }
          }
        }
        const Be = /\r\n?|[\n\u2028\u2029]/, Ze = new RegExp(Be.source, "g");
        function nt(Te) {
          switch (Te) {
            case 10:
            case 13:
            case 8232:
            case 8233:
              return !0;
            default:
              return !1;
          }
        }
        const $e = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, ut = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, vt = new RegExp("(?=(" + ut.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
        function yt(Te) {
          switch (Te) {
            case 9:
            case 11:
            case 12:
            case 32:
            case 160:
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
              return !0;
            default:
              return !1;
          }
        }
        class et {
          constructor() {
            this.strict = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = !1, this.inType = !1, this.noAnonFunctionType = !1, this.hasFlowComment = !1, this.isAmbientContext = !1, this.inAbstractClass = !1, this.inDisallowConditionalTypesContext = !1, this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.soloAwait = !1, this.inFSharpPipelineDirectBody = !1, this.labels = [], this.comments = [], this.commentStack = [], this.pos = 0, this.type = 137, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.context = [_.brace], this.canStartJSXElement = !0, this.containsEsc = !1, this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
          }
          init({ strictMode: p, sourceType: A, startLine: V, startColumn: ee }) {
            this.strict = p !== !1 && (p === !0 || A === "module"), this.curLine = V, this.lineStart = -ee, this.startLoc = this.endLoc = new i(V, ee, 0);
          }
          curPosition() {
            return new i(this.curLine, this.pos - this.lineStart, this.pos);
          }
          clone(p) {
            const A = new et(), V = Object.keys(this);
            for (let ee = 0, fe = V.length; ee < fe; ee++) {
              const Se = V[ee];
              let Pe = this[Se];
              !p && Array.isArray(Pe) && (Pe = Pe.slice()), A[Se] = Pe;
            }
            return A;
          }
        }
        var bt = function(Te) {
          return Te >= 48 && Te <= 57;
        };
        const lt = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, Et = { bin: (Te) => Te === 48 || Te === 49, oct: (Te) => Te >= 48 && Te <= 55, dec: (Te) => Te >= 48 && Te <= 57, hex: (Te) => Te >= 48 && Te <= 57 || Te >= 65 && Te <= 70 || Te >= 97 && Te <= 102 };
        function wt(Te, p, A, V, ee, fe) {
          const Se = A, Pe = V, Re = ee;
          let je = "", ze = null, mt = A;
          const { length: Mt } = p;
          for (; ; ) {
            if (A >= Mt) {
              fe.unterminated(Se, Pe, Re), je += p.slice(mt, A);
              break;
            }
            const St = p.charCodeAt(A);
            if (Ne(Te, St, p, A)) {
              je += p.slice(mt, A);
              break;
            }
            if (St === 92) {
              je += p.slice(mt, A);
              const Ut = Je(p, A, V, ee, Te === "template", fe);
              Ut.ch !== null || ze ? je += Ut.ch : ze = { pos: A, lineStart: V, curLine: ee }, { pos: A, lineStart: V, curLine: ee } = Ut, mt = A;
            } else
              St === 8232 || St === 8233 ? (++ee, V = ++A) : St === 10 || St === 13 ? Te === "template" ? (je += p.slice(mt, A) + `
`, ++A, St === 13 && p.charCodeAt(A) === 10 && ++A, ++ee, mt = V = A) : fe.unterminated(Se, Pe, Re) : ++A;
          }
          return { pos: A, str: je, firstInvalidLoc: ze, lineStart: V, curLine: ee, containsInvalid: !!ze };
        }
        function Ne(Te, p, A, V) {
          return Te === "template" ? p === 96 || p === 36 && A.charCodeAt(V + 1) === 123 : p === (Te === "double" ? 34 : 39);
        }
        function Je(Te, p, A, V, ee, fe) {
          const Se = !ee;
          p++;
          const Pe = (je) => ({ pos: p, ch: je, lineStart: A, curLine: V }), Re = Te.charCodeAt(p++);
          switch (Re) {
            case 110:
              return Pe(`
`);
            case 114:
              return Pe("\r");
            case 120: {
              let je;
              return { code: je, pos: p } = ft(Te, p, A, V, 2, !1, Se, fe), Pe(je === null ? null : String.fromCharCode(je));
            }
            case 117: {
              let je;
              return { code: je, pos: p } = At(Te, p, A, V, Se, fe), Pe(je === null ? null : String.fromCodePoint(je));
            }
            case 116:
              return Pe("	");
            case 98:
              return Pe("\b");
            case 118:
              return Pe("\v");
            case 102:
              return Pe("\f");
            case 13:
              Te.charCodeAt(p) === 10 && ++p;
            case 10:
              A = p, ++V;
            case 8232:
            case 8233:
              return Pe("");
            case 56:
            case 57:
              if (ee)
                return Pe(null);
              fe.strictNumericEscape(p - 1, A, V);
            default:
              if (Re >= 48 && Re <= 55) {
                const je = p - 1;
                let ze = Te.slice(je, p + 2).match(/^[0-7]+/)[0], mt = parseInt(ze, 8);
                mt > 255 && (ze = ze.slice(0, -1), mt = parseInt(ze, 8)), p += ze.length - 1;
                const Mt = Te.charCodeAt(p);
                if (ze !== "0" || Mt === 56 || Mt === 57) {
                  if (ee)
                    return Pe(null);
                  fe.strictNumericEscape(je, A, V);
                }
                return Pe(String.fromCharCode(mt));
              }
              return Pe(String.fromCharCode(Re));
          }
        }
        function ft(Te, p, A, V, ee, fe, Se, Pe) {
          const Re = p;
          let je;
          return { n: je, pos: p } = rt(Te, p, A, V, 16, ee, fe, !1, Pe, !Se), je === null && (Se ? Pe.invalidEscapeSequence(Re, A, V) : p = Re - 1), { code: je, pos: p };
        }
        function rt(Te, p, A, V, ee, fe, Se, Pe, Re, je) {
          const ze = p, mt = ee === 16 ? lt.hex : lt.decBinOct, Mt = ee === 16 ? Et.hex : ee === 10 ? Et.dec : ee === 8 ? Et.oct : Et.bin;
          let St = !1, Ut = 0;
          for (let Cr = 0, nr = fe ?? 1 / 0; Cr < nr; ++Cr) {
            const hr = Te.charCodeAt(p);
            let nn;
            if (hr !== 95 || Pe === "bail") {
              if (nn = hr >= 97 ? hr - 97 + 10 : hr >= 65 ? hr - 65 + 10 : bt(hr) ? hr - 48 : 1 / 0, nn >= ee) {
                if (nn <= 9 && je)
                  return { n: null, pos: p };
                if (nn <= 9 && Re.invalidDigit(p, A, V, ee))
                  nn = 0;
                else {
                  if (!Se)
                    break;
                  nn = 0, St = !0;
                }
              }
              ++p, Ut = Ut * ee + nn;
            } else {
              const Mp = Te.charCodeAt(p - 1), El = Te.charCodeAt(p + 1);
              if (Pe) {
                if (Number.isNaN(El) || !Mt(El) || mt.has(Mp) || mt.has(El)) {
                  if (je)
                    return { n: null, pos: p };
                  Re.unexpectedNumericSeparator(p, A, V);
                }
              } else {
                if (je)
                  return { n: null, pos: p };
                Re.numericSeparatorInEscapeSequence(p, A, V);
              }
              ++p;
            }
          }
          return p === ze || fe != null && p - ze !== fe || St ? { n: null, pos: p } : { n: Ut, pos: p };
        }
        function At(Te, p, A, V, ee, fe) {
          let Se;
          if (Te.charCodeAt(p) === 123) {
            if (++p, { code: Se, pos: p } = ft(Te, p, A, V, Te.indexOf("}", p) - p, !0, ee, fe), ++p, Se !== null && Se > 1114111) {
              if (!ee)
                return { code: null, pos: p };
              fe.invalidCodePoint(p, A, V);
            }
          } else
            ({ code: Se, pos: p } = ft(Te, p, A, V, 4, !1, ee, fe));
          return { code: Se, pos: p };
        }
        const Nt = ["at"], Tt = ["at"];
        function Ot(Te, p, A) {
          return new i(A, Te - p, Te);
        }
        const cr = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
        class Wt {
          constructor(p) {
            this.type = p.type, this.value = p.value, this.start = p.start, this.end = p.end, this.loc = new f(p.startLoc, p.endLoc);
          }
        }
        class Jt extends He {
          constructor(p, A) {
            super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (V, ee, fe, Se) => !!this.options.errorRecovery && (this.raise(C.InvalidDigit, { at: Ot(V, ee, fe), radix: Se }), !0), numericSeparatorInEscapeSequence: this.errorBuilder(C.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(C.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(C.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(C.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (V, ee, fe) => {
              this.recordStrictModeErrors(C.StrictNumericEscape, { at: Ot(V, ee, fe) });
            }, unterminated: (V, ee, fe) => {
              throw this.raise(C.UnterminatedString, { at: Ot(V - 1, ee, fe) });
            } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(C.StrictNumericEscape), unterminated: (V, ee, fe) => {
              throw this.raise(C.UnterminatedTemplate, { at: Ot(V, ee, fe) });
            } }), this.state = new et(), this.state.init(p), this.input = A, this.length = A.length, this.isLookahead = !1;
          }
          pushToken(p) {
            this.tokens.length = this.state.tokensLength, this.tokens.push(p), ++this.state.tokensLength;
          }
          next() {
            this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Wt(this.state)), this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
          }
          eat(p) {
            return !!this.match(p) && (this.next(), !0);
          }
          match(p) {
            return this.state.type === p;
          }
          createLookaheadState(p) {
            return { pos: p.pos, value: null, type: p.type, start: p.start, end: p.end, context: [this.curContext()], inType: p.inType, startLoc: p.startLoc, lastTokEndLoc: p.lastTokEndLoc, curLine: p.curLine, lineStart: p.lineStart, curPosition: p.curPosition };
          }
          lookahead() {
            const p = this.state;
            this.state = this.createLookaheadState(p), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
            const A = this.state;
            return this.state = p, A;
          }
          nextTokenStart() {
            return this.nextTokenStartSince(this.state.pos);
          }
          nextTokenStartSince(p) {
            return $e.lastIndex = p, $e.test(this.input) ? $e.lastIndex : p;
          }
          lookaheadCharCode() {
            return this.input.charCodeAt(this.nextTokenStart());
          }
          nextTokenInLineStart() {
            return this.nextTokenInLineStartSince(this.state.pos);
          }
          nextTokenInLineStartSince(p) {
            return ut.lastIndex = p, ut.test(this.input) ? ut.lastIndex : p;
          }
          lookaheadInLineCharCode() {
            return this.input.charCodeAt(this.nextTokenInLineStart());
          }
          codePointAtPos(p) {
            let A = this.input.charCodeAt(p);
            if ((64512 & A) == 55296 && ++p < this.input.length) {
              const V = this.input.charCodeAt(p);
              (64512 & V) == 56320 && (A = 65536 + ((1023 & A) << 10) + (1023 & V));
            }
            return A;
          }
          setStrict(p) {
            this.state.strict = p, p && (this.state.strictErrors.forEach(([A, V]) => this.raise(A, { at: V })), this.state.strictErrors.clear());
          }
          curContext() {
            return this.state.context[this.state.context.length - 1];
          }
          nextToken() {
            this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(137) : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
          }
          skipBlockComment(p) {
            let A;
            this.isLookahead || (A = this.state.curPosition());
            const V = this.state.pos, ee = this.input.indexOf(p, V + 2);
            if (ee === -1)
              throw this.raise(C.UnterminatedComment, { at: this.state.curPosition() });
            for (this.state.pos = ee + p.length, Ze.lastIndex = V + 2; Ze.test(this.input) && Ze.lastIndex <= ee; )
              ++this.state.curLine, this.state.lineStart = Ze.lastIndex;
            if (this.isLookahead)
              return;
            const fe = { type: "CommentBlock", value: this.input.slice(V + 2, ee), start: V, end: ee + p.length, loc: new f(A, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(fe), fe;
          }
          skipLineComment(p) {
            const A = this.state.pos;
            let V;
            this.isLookahead || (V = this.state.curPosition());
            let ee = this.input.charCodeAt(this.state.pos += p);
            if (this.state.pos < this.length)
              for (; !nt(ee) && ++this.state.pos < this.length; )
                ee = this.input.charCodeAt(this.state.pos);
            if (this.isLookahead)
              return;
            const fe = this.state.pos, Se = { type: "CommentLine", value: this.input.slice(A + p, fe), start: A, end: fe, loc: new f(V, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(Se), Se;
          }
          skipSpace() {
            const p = this.state.pos, A = [];
            e:
              for (; this.state.pos < this.length; ) {
                const V = this.input.charCodeAt(this.state.pos);
                switch (V) {
                  case 32:
                  case 160:
                  case 9:
                    ++this.state.pos;
                    break;
                  case 13:
                    this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
                  case 10:
                  case 8232:
                  case 8233:
                    ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                    break;
                  case 47:
                    switch (this.input.charCodeAt(this.state.pos + 1)) {
                      case 42: {
                        const ee = this.skipBlockComment("*/");
                        ee !== void 0 && (this.addComment(ee), this.options.attachComment && A.push(ee));
                        break;
                      }
                      case 47: {
                        const ee = this.skipLineComment(2);
                        ee !== void 0 && (this.addComment(ee), this.options.attachComment && A.push(ee));
                        break;
                      }
                      default:
                        break e;
                    }
                    break;
                  default:
                    if (yt(V))
                      ++this.state.pos;
                    else if (V === 45 && !this.inModule && this.options.annexB) {
                      const ee = this.state.pos;
                      if (this.input.charCodeAt(ee + 1) !== 45 || this.input.charCodeAt(ee + 2) !== 62 || !(p === 0 || this.state.lineStart > p))
                        break e;
                      {
                        const fe = this.skipLineComment(3);
                        fe !== void 0 && (this.addComment(fe), this.options.attachComment && A.push(fe));
                      }
                    } else {
                      if (V !== 60 || this.inModule || !this.options.annexB)
                        break e;
                      {
                        const ee = this.state.pos;
                        if (this.input.charCodeAt(ee + 1) !== 33 || this.input.charCodeAt(ee + 2) !== 45 || this.input.charCodeAt(ee + 3) !== 45)
                          break e;
                        {
                          const fe = this.skipLineComment(4);
                          fe !== void 0 && (this.addComment(fe), this.options.attachComment && A.push(fe));
                        }
                      }
                    }
                }
              }
            if (A.length > 0) {
              const V = { start: p, end: this.state.pos, comments: A, leadingNode: null, trailingNode: null, containingNode: null };
              this.state.commentStack.push(V);
            }
          }
          finishToken(p, A) {
            this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
            const V = this.state.type;
            this.state.type = p, this.state.value = A, this.isLookahead || this.updateContext(V);
          }
          replaceToken(p) {
            this.state.type = p, this.updateContext();
          }
          readToken_numberSign() {
            if (this.state.pos === 0 && this.readToken_interpreter())
              return;
            const p = this.state.pos + 1, A = this.codePointAtPos(p);
            if (A >= 48 && A <= 57)
              throw this.raise(C.UnexpectedDigitAfterHash, { at: this.state.curPosition() });
            if (A === 123 || A === 91 && this.hasPlugin("recordAndTuple")) {
              if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
                throw this.raise(A === 123 ? C.RecordExpressionHashIncorrectStartSyntaxType : C.TupleExpressionHashIncorrectStartSyntaxType, { at: this.state.curPosition() });
              this.state.pos += 2, A === 123 ? this.finishToken(7) : this.finishToken(1);
            } else
              Ee(A) ? (++this.state.pos, this.finishToken(136, this.readWord1(A))) : A === 92 ? (++this.state.pos, this.finishToken(136, this.readWord1())) : this.finishOp(27, 1);
          }
          readToken_dot() {
            const p = this.input.charCodeAt(this.state.pos + 1);
            p >= 48 && p <= 57 ? this.readNumber(!0) : p === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
          }
          readToken_slash() {
            this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
          }
          readToken_interpreter() {
            if (this.state.pos !== 0 || this.length < 2)
              return !1;
            let p = this.input.charCodeAt(this.state.pos + 1);
            if (p !== 33)
              return !1;
            const A = this.state.pos;
            for (this.state.pos += 1; !nt(p) && ++this.state.pos < this.length; )
              p = this.input.charCodeAt(this.state.pos);
            const V = this.input.slice(A + 2, this.state.pos);
            return this.finishToken(28, V), !0;
          }
          readToken_mult_modulo(p) {
            let A = p === 42 ? 55 : 54, V = 1, ee = this.input.charCodeAt(this.state.pos + 1);
            p === 42 && ee === 42 && (V++, ee = this.input.charCodeAt(this.state.pos + 2), A = 57), ee !== 61 || this.state.inType || (V++, A = p === 37 ? 33 : 30), this.finishOp(A, V);
          }
          readToken_pipe_amp(p) {
            const A = this.input.charCodeAt(this.state.pos + 1);
            if (A !== p) {
              if (p === 124) {
                if (A === 62)
                  return void this.finishOp(39, 2);
                if (this.hasPlugin("recordAndTuple") && A === 125) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(C.RecordExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
                  return this.state.pos += 2, void this.finishToken(9);
                }
                if (this.hasPlugin("recordAndTuple") && A === 93) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(C.TupleExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
                  return this.state.pos += 2, void this.finishToken(4);
                }
              }
              A !== 61 ? this.finishOp(p === 124 ? 43 : 45, 1) : this.finishOp(30, 2);
            } else
              this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(p === 124 ? 41 : 42, 2);
          }
          readToken_caret() {
            const p = this.input.charCodeAt(this.state.pos + 1);
            p !== 61 || this.state.inType ? p === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1) : this.finishOp(32, 2);
          }
          readToken_atSign() {
            this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
          }
          readToken_plus_min(p) {
            const A = this.input.charCodeAt(this.state.pos + 1);
            A !== p ? A === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1) : this.finishOp(34, 2);
          }
          readToken_lt() {
            const { pos: p } = this.state, A = this.input.charCodeAt(p + 1);
            if (A === 60)
              return this.input.charCodeAt(p + 2) === 61 ? void this.finishOp(30, 3) : void this.finishOp(51, 2);
            A !== 61 ? this.finishOp(47, 1) : this.finishOp(49, 2);
          }
          readToken_gt() {
            const { pos: p } = this.state, A = this.input.charCodeAt(p + 1);
            if (A === 62) {
              const V = this.input.charCodeAt(p + 2) === 62 ? 3 : 2;
              return this.input.charCodeAt(p + V) === 61 ? void this.finishOp(30, V + 1) : void this.finishOp(52, V);
            }
            A !== 61 ? this.finishOp(48, 1) : this.finishOp(49, 2);
          }
          readToken_eq_excl(p) {
            const A = this.input.charCodeAt(this.state.pos + 1);
            if (A !== 61)
              return p === 61 && A === 62 ? (this.state.pos += 2, void this.finishToken(19)) : void this.finishOp(p === 61 ? 29 : 35, 1);
            this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
          }
          readToken_question() {
            const p = this.input.charCodeAt(this.state.pos + 1), A = this.input.charCodeAt(this.state.pos + 2);
            p === 63 ? A === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : p !== 46 || A >= 48 && A <= 57 ? (++this.state.pos, this.finishToken(17)) : (this.state.pos += 2, this.finishToken(18));
          }
          getTokenFromCode(p) {
            switch (p) {
              case 46:
                return void this.readToken_dot();
              case 40:
                return ++this.state.pos, void this.finishToken(10);
              case 41:
                return ++this.state.pos, void this.finishToken(11);
              case 59:
                return ++this.state.pos, void this.finishToken(13);
              case 44:
                return ++this.state.pos, void this.finishToken(12);
              case 91:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(C.TupleExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                  this.state.pos += 2, this.finishToken(2);
                } else
                  ++this.state.pos, this.finishToken(0);
                return;
              case 93:
                return ++this.state.pos, void this.finishToken(3);
              case 123:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(C.RecordExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                  this.state.pos += 2, this.finishToken(6);
                } else
                  ++this.state.pos, this.finishToken(5);
                return;
              case 125:
                return ++this.state.pos, void this.finishToken(8);
              case 58:
                return void (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14)));
              case 63:
                return void this.readToken_question();
              case 96:
                return void this.readTemplateToken();
              case 48: {
                const A = this.input.charCodeAt(this.state.pos + 1);
                if (A === 120 || A === 88)
                  return void this.readRadixNumber(16);
                if (A === 111 || A === 79)
                  return void this.readRadixNumber(8);
                if (A === 98 || A === 66)
                  return void this.readRadixNumber(2);
              }
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                return void this.readNumber(!1);
              case 34:
              case 39:
                return void this.readString(p);
              case 47:
                return void this.readToken_slash();
              case 37:
              case 42:
                return void this.readToken_mult_modulo(p);
              case 124:
              case 38:
                return void this.readToken_pipe_amp(p);
              case 94:
                return void this.readToken_caret();
              case 43:
              case 45:
                return void this.readToken_plus_min(p);
              case 60:
                return void this.readToken_lt();
              case 62:
                return void this.readToken_gt();
              case 61:
              case 33:
                return void this.readToken_eq_excl(p);
              case 126:
                return void this.finishOp(36, 1);
              case 64:
                return void this.readToken_atSign();
              case 35:
                return void this.readToken_numberSign();
              case 92:
                return void this.readWord();
              default:
                if (Ee(p))
                  return void this.readWord(p);
            }
            throw this.raise(C.InvalidOrUnexpectedToken, { at: this.state.curPosition(), unexpected: String.fromCodePoint(p) });
          }
          finishOp(p, A) {
            const V = this.input.slice(this.state.pos, this.state.pos + A);
            this.state.pos += A, this.finishToken(p, V);
          }
          readRegexp() {
            const p = this.state.startLoc, A = this.state.start + 1;
            let V, ee, { pos: fe } = this.state;
            for (; ; ++fe) {
              if (fe >= this.length)
                throw this.raise(C.UnterminatedRegExp, { at: d(p, 1) });
              const je = this.input.charCodeAt(fe);
              if (nt(je))
                throw this.raise(C.UnterminatedRegExp, { at: d(p, 1) });
              if (V)
                V = !1;
              else {
                if (je === 91)
                  ee = !0;
                else if (je === 93 && ee)
                  ee = !1;
                else if (je === 47 && !ee)
                  break;
                V = je === 92;
              }
            }
            const Se = this.input.slice(A, fe);
            ++fe;
            let Pe = "";
            const Re = () => d(p, fe + 2 - A);
            for (; fe < this.length; ) {
              const je = this.codePointAtPos(fe), ze = String.fromCharCode(je);
              if (cr.has(je))
                je === 118 ? Pe.includes("u") && this.raise(C.IncompatibleRegExpUVFlags, { at: Re() }) : je === 117 && Pe.includes("v") && this.raise(C.IncompatibleRegExpUVFlags, { at: Re() }), Pe.includes(ze) && this.raise(C.DuplicateRegExpFlags, { at: Re() });
              else {
                if (!Ae(je) && je !== 92)
                  break;
                this.raise(C.MalformedRegExpFlags, { at: Re() });
              }
              ++fe, Pe += ze;
            }
            this.state.pos = fe, this.finishToken(135, { pattern: Se, flags: Pe });
          }
          readInt(p, A, V = !1, ee = !0) {
            const { n: fe, pos: Se } = rt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, p, A, V, ee, this.errorHandlers_readInt, !1);
            return this.state.pos = Se, fe;
          }
          readRadixNumber(p) {
            const A = this.state.curPosition();
            let V = !1;
            this.state.pos += 2;
            const ee = this.readInt(p);
            ee == null && this.raise(C.InvalidDigit, { at: d(A, 2), radix: p });
            const fe = this.input.charCodeAt(this.state.pos);
            if (fe === 110)
              ++this.state.pos, V = !0;
            else if (fe === 109)
              throw this.raise(C.InvalidDecimal, { at: A });
            if (Ee(this.codePointAtPos(this.state.pos)))
              throw this.raise(C.NumberIdentifier, { at: this.state.curPosition() });
            if (V) {
              const Se = this.input.slice(A.index, this.state.pos).replace(/[_n]/g, "");
              this.finishToken(133, Se);
            } else
              this.finishToken(132, ee);
          }
          readNumber(p) {
            const A = this.state.pos, V = this.state.curPosition();
            let ee = !1, fe = !1, Se = !1, Pe = !1, Re = !1;
            p || this.readInt(10) !== null || this.raise(C.InvalidNumber, { at: this.state.curPosition() });
            const je = this.state.pos - A >= 2 && this.input.charCodeAt(A) === 48;
            if (je) {
              const St = this.input.slice(A, this.state.pos);
              if (this.recordStrictModeErrors(C.StrictOctalLiteral, { at: V }), !this.state.strict) {
                const Ut = St.indexOf("_");
                Ut > 0 && this.raise(C.ZeroDigitNumericSeparator, { at: d(V, Ut) });
              }
              Re = je && !/[89]/.test(St);
            }
            let ze = this.input.charCodeAt(this.state.pos);
            if (ze !== 46 || Re || (++this.state.pos, this.readInt(10), ee = !0, ze = this.input.charCodeAt(this.state.pos)), ze !== 69 && ze !== 101 || Re || (ze = this.input.charCodeAt(++this.state.pos), ze !== 43 && ze !== 45 || ++this.state.pos, this.readInt(10) === null && this.raise(C.InvalidOrMissingExponent, { at: V }), ee = !0, Pe = !0, ze = this.input.charCodeAt(this.state.pos)), ze === 110 && ((ee || je) && this.raise(C.InvalidBigIntLiteral, { at: V }), ++this.state.pos, fe = !0), ze === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (Pe || je) && this.raise(C.InvalidDecimal, { at: V }), ++this.state.pos, Se = !0), Ee(this.codePointAtPos(this.state.pos)))
              throw this.raise(C.NumberIdentifier, { at: this.state.curPosition() });
            const mt = this.input.slice(A, this.state.pos).replace(/[_mn]/g, "");
            if (fe)
              return void this.finishToken(133, mt);
            if (Se)
              return void this.finishToken(134, mt);
            const Mt = Re ? parseInt(mt, 8) : parseFloat(mt);
            this.finishToken(132, Mt);
          }
          readCodePoint(p) {
            const { code: A, pos: V } = At(this.input, this.state.pos, this.state.lineStart, this.state.curLine, p, this.errorHandlers_readCodePoint);
            return this.state.pos = V, A;
          }
          readString(p) {
            const { str: A, pos: V, curLine: ee, lineStart: fe } = wt(p === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
            this.state.pos = V + 1, this.state.lineStart = fe, this.state.curLine = ee, this.finishToken(131, A);
          }
          readTemplateContinuation() {
            this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
          }
          readTemplateToken() {
            const p = this.input[this.state.pos], { str: A, firstInvalidLoc: V, pos: ee, curLine: fe, lineStart: Se } = wt("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
            this.state.pos = ee + 1, this.state.lineStart = Se, this.state.curLine = fe, V && (this.state.firstInvalidTemplateEscapePos = new i(V.curLine, V.pos - V.lineStart, V.pos)), this.input.codePointAt(ee) === 96 ? this.finishToken(24, V ? null : p + A + "`") : (this.state.pos++, this.finishToken(25, V ? null : p + A + "${"));
          }
          recordStrictModeErrors(p, { at: A }) {
            const V = A.index;
            this.state.strict && !this.state.strictErrors.has(V) ? this.raise(p, { at: A }) : this.state.strictErrors.set(V, [p, A]);
          }
          readWord1(p) {
            this.state.containsEsc = !1;
            let A = "";
            const V = this.state.pos;
            let ee = this.state.pos;
            for (p !== void 0 && (this.state.pos += p <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
              const fe = this.codePointAtPos(this.state.pos);
              if (Ae(fe))
                this.state.pos += fe <= 65535 ? 1 : 2;
              else {
                if (fe !== 92)
                  break;
                {
                  this.state.containsEsc = !0, A += this.input.slice(ee, this.state.pos);
                  const Se = this.state.curPosition(), Pe = this.state.pos === V ? Ee : Ae;
                  if (this.input.charCodeAt(++this.state.pos) !== 117) {
                    this.raise(C.MissingUnicodeEscape, { at: this.state.curPosition() }), ee = this.state.pos - 1;
                    continue;
                  }
                  ++this.state.pos;
                  const Re = this.readCodePoint(!0);
                  Re !== null && (Pe(Re) || this.raise(C.EscapedCharNotAnIdentifier, { at: Se }), A += String.fromCodePoint(Re)), ee = this.state.pos;
                }
              }
            }
            return A + this.input.slice(ee, this.state.pos);
          }
          readWord(p) {
            const A = this.readWord1(p), V = v.get(A);
            V !== void 0 ? this.finishToken(V, ye(V)) : this.finishToken(130, A);
          }
          checkKeywordEscapes() {
            const { type: p } = this.state;
            ne(p) && this.state.containsEsc && this.raise(C.InvalidEscapedReservedWord, { at: this.state.startLoc, reservedWord: ye(p) });
          }
          raise(p, A) {
            const { at: V } = A, ee = l(A, Nt), fe = p({ loc: V instanceof i ? V : V.loc.start, details: ee });
            if (!this.options.errorRecovery)
              throw fe;
            return this.isLookahead || this.state.errors.push(fe), fe;
          }
          raiseOverwrite(p, A) {
            const { at: V } = A, ee = l(A, Tt), fe = V instanceof i ? V : V.loc.start, Se = fe.index, Pe = this.state.errors;
            for (let Re = Pe.length - 1; Re >= 0; Re--) {
              const je = Pe[Re];
              if (je.loc.index === Se)
                return Pe[Re] = p({ loc: fe, details: ee });
              if (je.loc.index < Se)
                break;
            }
            return this.raise(p, A);
          }
          updateContext(p) {
          }
          unexpected(p, A) {
            throw this.raise(C.UnexpectedToken, { expected: A ? ye(A) : null, at: p ?? this.state.startLoc });
          }
          expectPlugin(p, A) {
            if (this.hasPlugin(p))
              return !0;
            throw this.raise(C.MissingPlugin, { at: A ?? this.state.startLoc, missingPlugin: [p] });
          }
          expectOnePlugin(p) {
            if (!p.some((A) => this.hasPlugin(A)))
              throw this.raise(C.MissingOneOfPlugins, { at: this.state.startLoc, missingPlugin: p });
          }
          errorBuilder(p) {
            return (A, V, ee) => {
              this.raise(p, { at: Ot(A, V, ee) });
            };
          }
        }
        class pr {
          constructor() {
            this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
          }
        }
        class $r {
          constructor(p) {
            this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = p;
          }
          current() {
            return this.stack[this.stack.length - 1];
          }
          enter() {
            this.stack.push(new pr());
          }
          exit() {
            const p = this.stack.pop(), A = this.current();
            for (const [V, ee] of Array.from(p.undefinedPrivateNames))
              A ? A.undefinedPrivateNames.has(V) || A.undefinedPrivateNames.set(V, ee) : this.parser.raise(C.InvalidPrivateFieldResolution, { at: ee, identifierName: V });
          }
          declarePrivateName(p, A, V) {
            const { privateNames: ee, loneAccessors: fe, undefinedPrivateNames: Se } = this.current();
            let Pe = ee.has(p);
            if (3 & A) {
              const Re = Pe && fe.get(p);
              Re ? (Pe = (3 & Re) === (3 & A) || (4 & Re) !== (4 & A), Pe || fe.delete(p)) : Pe || fe.set(p, A);
            }
            Pe && this.parser.raise(C.PrivateNameRedeclaration, { at: V, identifierName: p }), ee.add(p), Se.delete(p);
          }
          usePrivateName(p, A) {
            let V;
            for (V of this.stack)
              if (V.privateNames.has(p))
                return;
            V ? V.undefinedPrivateNames.set(p, A) : this.parser.raise(C.InvalidPrivateFieldResolution, { at: A, identifierName: p });
          }
        }
        class Ur {
          constructor(p = 0) {
            this.type = p;
          }
          canBeArrowParameterDeclaration() {
            return this.type === 2 || this.type === 1;
          }
          isCertainlyParameterDeclaration() {
            return this.type === 3;
          }
        }
        class _r extends Ur {
          constructor(p) {
            super(p), this.declarationErrors = /* @__PURE__ */ new Map();
          }
          recordDeclarationError(p, { at: A }) {
            const V = A.index;
            this.declarationErrors.set(V, [p, A]);
          }
          clearDeclarationError(p) {
            this.declarationErrors.delete(p);
          }
          iterateErrors(p) {
            this.declarationErrors.forEach(p);
          }
        }
        class qn {
          constructor(p) {
            this.parser = void 0, this.stack = [new Ur()], this.parser = p;
          }
          enter(p) {
            this.stack.push(p);
          }
          exit() {
            this.stack.pop();
          }
          recordParameterInitializerError(p, { at: A }) {
            const V = { at: A.loc.start }, { stack: ee } = this;
            let fe = ee.length - 1, Se = ee[fe];
            for (; !Se.isCertainlyParameterDeclaration(); ) {
              if (!Se.canBeArrowParameterDeclaration())
                return;
              Se.recordDeclarationError(p, V), Se = ee[--fe];
            }
            this.parser.raise(p, V);
          }
          recordArrowParameterBindingError(p, { at: A }) {
            const { stack: V } = this, ee = V[V.length - 1], fe = { at: A.loc.start };
            if (ee.isCertainlyParameterDeclaration())
              this.parser.raise(p, fe);
            else {
              if (!ee.canBeArrowParameterDeclaration())
                return;
              ee.recordDeclarationError(p, fe);
            }
          }
          recordAsyncArrowParametersError({ at: p }) {
            const { stack: A } = this;
            let V = A.length - 1, ee = A[V];
            for (; ee.canBeArrowParameterDeclaration(); )
              ee.type === 2 && ee.recordDeclarationError(C.AwaitBindingIdentifier, { at: p }), ee = A[--V];
          }
          validateAsPattern() {
            const { stack: p } = this, A = p[p.length - 1];
            A.canBeArrowParameterDeclaration() && A.iterateErrors(([V, ee]) => {
              this.parser.raise(V, { at: ee });
              let fe = p.length - 2, Se = p[fe];
              for (; Se.canBeArrowParameterDeclaration(); )
                Se.clearDeclarationError(ee.index), Se = p[--fe];
            });
          }
        }
        function Mn() {
          return new Ur();
        }
        class Ln {
          constructor() {
            this.stacks = [];
          }
          enter(p) {
            this.stacks.push(p);
          }
          exit() {
            this.stacks.pop();
          }
          currentFlags() {
            return this.stacks[this.stacks.length - 1];
          }
          get hasAwait() {
            return (2 & this.currentFlags()) > 0;
          }
          get hasYield() {
            return (1 & this.currentFlags()) > 0;
          }
          get hasReturn() {
            return (4 & this.currentFlags()) > 0;
          }
          get hasIn() {
            return (8 & this.currentFlags()) > 0;
          }
        }
        function mn(Te, p) {
          return (Te ? 2 : 0) | (p ? 1 : 0);
        }
        class jn extends Jt {
          addExtra(p, A, V, ee = !0) {
            if (!p)
              return;
            const fe = p.extra = p.extra || {};
            ee ? fe[A] = V : Object.defineProperty(fe, A, { enumerable: ee, value: V });
          }
          isContextual(p) {
            return this.state.type === p && !this.state.containsEsc;
          }
          isUnparsedContextual(p, A) {
            const V = p + A.length;
            if (this.input.slice(p, V) === A) {
              const ee = this.input.charCodeAt(V);
              return !(Ae(ee) || (64512 & ee) == 55296);
            }
            return !1;
          }
          isLookaheadContextual(p) {
            const A = this.nextTokenStart();
            return this.isUnparsedContextual(A, p);
          }
          eatContextual(p) {
            return !!this.isContextual(p) && (this.next(), !0);
          }
          expectContextual(p, A) {
            if (!this.eatContextual(p)) {
              if (A != null)
                throw this.raise(A, { at: this.state.startLoc });
              this.unexpected(null, p);
            }
          }
          canInsertSemicolon() {
            return this.match(137) || this.match(8) || this.hasPrecedingLineBreak();
          }
          hasPrecedingLineBreak() {
            return Be.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
          }
          hasFollowingLineBreak() {
            return vt.lastIndex = this.state.end, vt.test(this.input);
          }
          isLineTerminator() {
            return this.eat(13) || this.canInsertSemicolon();
          }
          semicolon(p = !0) {
            (p ? this.isLineTerminator() : this.eat(13)) || this.raise(C.MissingSemicolon, { at: this.state.lastTokEndLoc });
          }
          expect(p, A) {
            this.eat(p) || this.unexpected(A, p);
          }
          tryParse(p, A = this.state.clone()) {
            const V = { node: null };
            try {
              const ee = p((fe = null) => {
                throw V.node = fe, V;
              });
              if (this.state.errors.length > A.errors.length) {
                const fe = this.state;
                return this.state = A, this.state.tokensLength = fe.tokensLength, { node: ee, error: fe.errors[A.errors.length], thrown: !1, aborted: !1, failState: fe };
              }
              return { node: ee, error: null, thrown: !1, aborted: !1, failState: null };
            } catch (ee) {
              const fe = this.state;
              if (this.state = A, ee instanceof SyntaxError)
                return { node: null, error: ee, thrown: !0, aborted: !1, failState: fe };
              if (ee === V)
                return { node: V.node, error: null, thrown: !1, aborted: !0, failState: fe };
              throw ee;
            }
          }
          checkExpressionErrors(p, A) {
            if (!p)
              return !1;
            const { shorthandAssignLoc: V, doubleProtoLoc: ee, privateKeyLoc: fe, optionalParametersLoc: Se } = p;
            if (!A)
              return !!(V || ee || Se || fe);
            V != null && this.raise(C.InvalidCoverInitializedName, { at: V }), ee != null && this.raise(C.DuplicateProto, { at: ee }), fe != null && this.raise(C.UnexpectedPrivateField, { at: fe }), Se != null && this.unexpected(Se);
          }
          isLiteralPropertyName() {
            return H(this.state.type);
          }
          isPrivateName(p) {
            return p.type === "PrivateName";
          }
          getPrivateNameSV(p) {
            return p.id.name;
          }
          hasPropertyAsPrivateName(p) {
            return (p.type === "MemberExpression" || p.type === "OptionalMemberExpression") && this.isPrivateName(p.property);
          }
          isObjectProperty(p) {
            return p.type === "ObjectProperty";
          }
          isObjectMethod(p) {
            return p.type === "ObjectMethod";
          }
          initializeScopes(p = this.options.sourceType === "module") {
            const A = this.state.labels;
            this.state.labels = [];
            const V = this.exportedIdentifiers;
            this.exportedIdentifiers = /* @__PURE__ */ new Set();
            const ee = this.inModule;
            this.inModule = p;
            const fe = this.scope, Se = this.getScopeHandler();
            this.scope = new Se(this, p);
            const Pe = this.prodParam;
            this.prodParam = new Ln();
            const Re = this.classScope;
            this.classScope = new $r(this);
            const je = this.expressionScope;
            return this.expressionScope = new qn(this), () => {
              this.state.labels = A, this.exportedIdentifiers = V, this.inModule = ee, this.scope = fe, this.prodParam = Pe, this.classScope = Re, this.expressionScope = je;
            };
          }
          enterInitialScopes() {
            let p = 0;
            this.inModule && (p |= 2), this.scope.enter(1), this.prodParam.enter(p);
          }
          checkDestructuringPrivate(p) {
            const { privateKeyLoc: A } = p;
            A !== null && this.expectPlugin("destructuringPrivate", A);
          }
        }
        class yn {
          constructor() {
            this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
          }
        }
        class bn {
          constructor(p, A, V) {
            this.type = "", this.start = A, this.end = 0, this.loc = new f(V), p != null && p.options.ranges && (this.range = [A, 0]), p != null && p.filename && (this.loc.filename = p.filename);
          }
        }
        const En = bn.prototype;
        function Vr(Te) {
          const { type: p, start: A, end: V, loc: ee, range: fe, extra: Se, name: Pe } = Te, Re = Object.create(En);
          return Re.type = p, Re.start = A, Re.end = V, Re.loc = ee, Re.range = fe, Re.extra = Se, Re.name = Pe, p === "Placeholder" && (Re.expectedNode = Te.expectedNode), Re;
        }
        function zi(Te) {
          const { type: p, start: A, end: V, loc: ee, range: fe, extra: Se } = Te;
          if (p === "Placeholder")
            return function(Re) {
              return Vr(Re);
            }(Te);
          const Pe = Object.create(En);
          return Pe.type = p, Pe.start = A, Pe.end = V, Pe.loc = ee, Pe.range = fe, Te.raw !== void 0 ? Pe.raw = Te.raw : Pe.extra = Se, Pe.value = Te.value, Pe;
        }
        En.__clone = function() {
          const Te = new bn(void 0, this.start, this.loc.start), p = Object.keys(this);
          for (let A = 0, V = p.length; A < V; A++) {
            const ee = p[A];
            ee !== "leadingComments" && ee !== "trailingComments" && ee !== "innerComments" && (Te[ee] = this[ee]);
          }
          return Te;
        };
        class As extends jn {
          startNode() {
            return new bn(this, this.state.start, this.state.startLoc);
          }
          startNodeAt(p) {
            return new bn(this, p.index, p);
          }
          startNodeAtNode(p) {
            return this.startNodeAt(p.loc.start);
          }
          finishNode(p, A) {
            return this.finishNodeAt(p, A, this.state.lastTokEndLoc);
          }
          finishNodeAt(p, A, V) {
            return p.type = A, p.end = V.index, p.loc.end = V, this.options.ranges && (p.range[1] = V.index), this.options.attachComment && this.processComment(p), p;
          }
          resetStartLocation(p, A) {
            p.start = A.index, p.loc.start = A, this.options.ranges && (p.range[0] = A.index);
          }
          resetEndLocation(p, A = this.state.lastTokEndLoc) {
            p.end = A.index, p.loc.end = A, this.options.ranges && (p.range[1] = A.index);
          }
          resetStartLocationFromNode(p, A) {
            this.resetStartLocation(p, A.loc.start);
          }
        }
        const ga = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), Rt = N`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: ({ reservedType: Te }) => `Cannot overwrite reserved type ${Te}.`, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: ({ memberName: Te, enumName: p }) => `Boolean enum members need to be initialized. Use either \`${Te} = true,\` or \`${Te} = false,\` in enum \`${p}\`.`, EnumDuplicateMemberName: ({ memberName: Te, enumName: p }) => `Enum member names need to be unique, but the name \`${Te}\` has already been used before in enum \`${p}\`.`, EnumInconsistentMemberValues: ({ enumName: Te }) => `Enum \`${Te}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: Te, enumName: p }) => `Enum type \`${Te}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${p}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: Te }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${Te}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: Te, memberName: p, explicitType: A }) => `Enum \`${Te}\` has type \`${A}\`, so the initializer of \`${p}\` needs to be a ${A} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: Te, memberName: p }) => `Symbol enum members cannot be initialized. Use \`${p},\` in enum \`${Te}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: Te, memberName: p }) => `The enum member initializer for \`${p}\` needs to be a literal (either a boolean, number, or string) in enum \`${Te}\`.`, EnumInvalidMemberName: ({ enumName: Te, memberName: p, suggestion: A }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${p}\`, consider using \`${A}\`, in enum \`${Te}\`.`, EnumNumberMemberNotInitialized: ({ enumName: Te, memberName: p }) => `Number enum members need to be initialized, e.g. \`${p} = 1\` in enum \`${Te}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: Te }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${Te}\`.`, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: ({ reservedType: Te }) => `Unexpected reserved type ${Te}.`, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: ({ unsupportedExportKind: Te, suggestion: p }) => `\`declare export ${Te}\` is not supported. Use \`${p}\` instead.`, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
        function Pt(Te) {
          return Te.importKind === "type" || Te.importKind === "typeof";
        }
        const ni = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" }, sc = /\*?\s*@((?:no)?flow)\b/, ac = { __proto__: null, quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "", iexcl: "", cent: "", pound: "", curren: "", yen: "", brvbar: "", sect: "", uml: "", copy: "", ordf: "", laquo: "", not: "", shy: "", reg: "", macr: "", deg: "", plusmn: "", sup2: "", sup3: "", acute: "", micro: "", para: "", middot: "", cedil: "", sup1: "", ordm: "", raquo: "", frac14: "", frac12: "", frac34: "", iquest: "", Agrave: "", Aacute: "", Acirc: "", Atilde: "", Auml: "", Aring: "", AElig: "", Ccedil: "", Egrave: "", Eacute: "", Ecirc: "", Euml: "", Igrave: "", Iacute: "", Icirc: "", Iuml: "", ETH: "", Ntilde: "", Ograve: "", Oacute: "", Ocirc: "", Otilde: "", Ouml: "", times: "", Oslash: "", Ugrave: "", Uacute: "", Ucirc: "", Uuml: "", Yacute: "", THORN: "", szlig: "", agrave: "", aacute: "", acirc: "", atilde: "", auml: "", aring: "", aelig: "", ccedil: "", egrave: "", eacute: "", ecirc: "", euml: "", igrave: "", iacute: "", icirc: "", iuml: "", eth: "", ntilde: "", ograve: "", oacute: "", ocirc: "", otilde: "", ouml: "", divide: "", oslash: "", ugrave: "", uacute: "", ucirc: "", uuml: "", yacute: "", thorn: "", yuml: "", OElig: "", oelig: "", Scaron: "", scaron: "", Yuml: "", fnof: "", circ: "", tilde: "", Alpha: "", Beta: "", Gamma: "", Delta: "", Epsilon: "", Zeta: "", Eta: "", Theta: "", Iota: "", Kappa: "", Lambda: "", Mu: "", Nu: "", Xi: "", Omicron: "", Pi: "", Rho: "", Sigma: "", Tau: "", Upsilon: "", Phi: "", Chi: "", Psi: "", Omega: "", alpha: "", beta: "", gamma: "", delta: "", epsilon: "", zeta: "", eta: "", theta: "", iota: "", kappa: "", lambda: "", mu: "", nu: "", xi: "", omicron: "", pi: "", rho: "", sigmaf: "", sigma: "", tau: "", upsilon: "", phi: "", chi: "", psi: "", omega: "", thetasym: "", upsih: "", piv: "", ensp: "", emsp: "", thinsp: "", zwnj: "", zwj: "", lrm: "", rlm: "", ndash: "", mdash: "", lsquo: "", rsquo: "", sbquo: "", ldquo: "", rdquo: "", bdquo: "", dagger: "", Dagger: "", bull: "", hellip: "", permil: "", prime: "", Prime: "", lsaquo: "", rsaquo: "", oline: "", frasl: "", euro: "", image: "", weierp: "", real: "", trade: "", alefsym: "", larr: "", uarr: "", rarr: "", darr: "", harr: "", crarr: "", lArr: "", uArr: "", rArr: "", dArr: "", hArr: "", forall: "", part: "", exist: "", empty: "", nabla: "", isin: "", notin: "", ni: "", prod: "", sum: "", minus: "", lowast: "", radic: "", prop: "", infin: "", ang: "", and: "", or: "", cap: "", cup: "", int: "", there4: "", sim: "", cong: "", asymp: "", ne: "", equiv: "", le: "", ge: "", sub: "", sup: "", nsub: "", sube: "", supe: "", oplus: "", otimes: "", perp: "", sdot: "", lceil: "", rceil: "", lfloor: "", rfloor: "", lang: "", rang: "", loz: "", spades: "", clubs: "", hearts: "", diams: "" }, Ki = N`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: ({ openingTagName: Te }) => `Expected corresponding JSX closing tag for <${Te}>.`, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: ({ unexpected: Te, HTMLEntity: p }) => `Unexpected token \`${Te}\`. Did you mean \`${p}\` or \`{'${Te}'}\`?`, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
        function Yi(Te) {
          return !!Te && (Te.type === "JSXOpeningFragment" || Te.type === "JSXClosingFragment");
        }
        function Ci(Te) {
          if (Te.type === "JSXIdentifier")
            return Te.name;
          if (Te.type === "JSXNamespacedName")
            return Te.namespace.name + ":" + Te.name.name;
          if (Te.type === "JSXMemberExpression")
            return Ci(Te.object) + "." + Ci(Te.property);
          throw new Error("Node had unexpected type: " + Te.type);
        }
        class oc extends Ye {
          constructor(...p) {
            super(...p), this.types = /* @__PURE__ */ new Set(), this.enums = /* @__PURE__ */ new Set(), this.constEnums = /* @__PURE__ */ new Set(), this.classes = /* @__PURE__ */ new Set(), this.exportOnlyBindings = /* @__PURE__ */ new Set();
          }
        }
        class lc extends ht {
          constructor(...p) {
            super(...p), this.importsStack = [];
          }
          createScope(p) {
            return this.importsStack.push(/* @__PURE__ */ new Set()), new oc(p);
          }
          enter(p) {
            p == 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(p);
          }
          exit() {
            const p = super.exit();
            return p == 256 && this.importsStack.pop(), p;
          }
          hasImport(p, A) {
            const V = this.importsStack.length;
            if (this.importsStack[V - 1].has(p))
              return !0;
            if (!A && V > 1) {
              for (let ee = 0; ee < V - 1; ee++)
                if (this.importsStack[ee].has(p))
                  return !0;
            }
            return !1;
          }
          declareName(p, A, V) {
            if (4096 & A)
              return this.hasImport(p, !0) && this.parser.raise(C.VarRedeclaration, { at: V, identifierName: p }), void this.importsStack[this.importsStack.length - 1].add(p);
            const ee = this.currentScope();
            if (1024 & A)
              return this.maybeExportDefined(ee, p), void ee.exportOnlyBindings.add(p);
            super.declareName(p, A, V), 2 & A && (1 & A || (this.checkRedeclarationInScope(ee, p, A, V), this.maybeExportDefined(ee, p)), ee.types.add(p)), 256 & A && ee.enums.add(p), 512 & A && ee.constEnums.add(p), 128 & A && ee.classes.add(p);
          }
          isRedeclaredInScope(p, A, V) {
            return p.enums.has(A) ? 256 & V ? !!(512 & V) !== p.constEnums.has(A) : !0 : 128 & V && p.classes.has(A) ? !!p.lexical.has(A) && !!(1 & V) : !!(2 & V && p.types.has(A)) || super.isRedeclaredInScope(p, A, V);
          }
          checkLocalExport(p) {
            const { name: A } = p;
            if (!this.hasImport(A)) {
              for (let V = this.scopeStack.length - 1; V >= 0; V--) {
                const ee = this.scopeStack[V];
                if (ee.types.has(A) || ee.exportOnlyBindings.has(A))
                  return;
              }
              super.checkLocalExport(p);
            }
          }
        }
        const ml = (Te) => Te.type === "ParenthesizedExpression" ? ml(Te.expression) : Te;
        class yl extends As {
          toAssignable(p, A = !1) {
            var V, ee;
            let fe;
            switch ((p.type === "ParenthesizedExpression" || (V = p.extra) != null && V.parenthesized) && (fe = ml(p), A ? fe.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(C.InvalidParenthesizedAssignment, { at: p }) : fe.type !== "MemberExpression" && this.raise(C.InvalidParenthesizedAssignment, { at: p }) : this.raise(C.InvalidParenthesizedAssignment, { at: p })), p.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                break;
              case "ObjectExpression":
                p.type = "ObjectPattern";
                for (let Pe = 0, Re = p.properties.length, je = Re - 1; Pe < Re; Pe++) {
                  var Se;
                  const ze = p.properties[Pe], mt = Pe === je;
                  this.toAssignableObjectExpressionProp(ze, mt, A), mt && ze.type === "RestElement" && (Se = p.extra) != null && Se.trailingCommaLoc && this.raise(C.RestTrailingComma, { at: p.extra.trailingCommaLoc });
                }
                break;
              case "ObjectProperty": {
                const { key: Pe, value: Re } = p;
                this.isPrivateName(Pe) && this.classScope.usePrivateName(this.getPrivateNameSV(Pe), Pe.loc.start), this.toAssignable(Re, A);
                break;
              }
              case "SpreadElement":
                throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
              case "ArrayExpression":
                p.type = "ArrayPattern", this.toAssignableList(p.elements, (ee = p.extra) == null ? void 0 : ee.trailingCommaLoc, A);
                break;
              case "AssignmentExpression":
                p.operator !== "=" && this.raise(C.MissingEqInAssignment, { at: p.left.loc.end }), p.type = "AssignmentPattern", delete p.operator, this.toAssignable(p.left, A);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(fe, A);
            }
          }
          toAssignableObjectExpressionProp(p, A, V) {
            if (p.type === "ObjectMethod")
              this.raise(p.kind === "get" || p.kind === "set" ? C.PatternHasAccessor : C.PatternHasMethod, { at: p.key });
            else if (p.type === "SpreadElement") {
              p.type = "RestElement";
              const ee = p.argument;
              this.checkToRestConversion(ee, !1), this.toAssignable(ee, V), A || this.raise(C.RestTrailingComma, { at: p });
            } else
              this.toAssignable(p, V);
          }
          toAssignableList(p, A, V) {
            const ee = p.length - 1;
            for (let fe = 0; fe <= ee; fe++) {
              const Se = p[fe];
              if (Se) {
                if (Se.type === "SpreadElement") {
                  Se.type = "RestElement";
                  const Pe = Se.argument;
                  this.checkToRestConversion(Pe, !0), this.toAssignable(Pe, V);
                } else
                  this.toAssignable(Se, V);
                Se.type === "RestElement" && (fe < ee ? this.raise(C.RestTrailingComma, { at: Se }) : A && this.raise(C.RestTrailingComma, { at: A }));
              }
            }
          }
          isAssignable(p, A) {
            switch (p.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                return !0;
              case "ObjectExpression": {
                const V = p.properties.length - 1;
                return p.properties.every((ee, fe) => ee.type !== "ObjectMethod" && (fe === V || ee.type !== "SpreadElement") && this.isAssignable(ee));
              }
              case "ObjectProperty":
                return this.isAssignable(p.value);
              case "SpreadElement":
                return this.isAssignable(p.argument);
              case "ArrayExpression":
                return p.elements.every((V) => V === null || this.isAssignable(V));
              case "AssignmentExpression":
                return p.operator === "=";
              case "ParenthesizedExpression":
                return this.isAssignable(p.expression);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return !A;
              default:
                return !1;
            }
          }
          toReferencedList(p, A) {
            return p;
          }
          toReferencedListDeep(p, A) {
            this.toReferencedList(p, A);
            for (const V of p)
              (V == null ? void 0 : V.type) === "ArrayExpression" && this.toReferencedListDeep(V.elements);
          }
          parseSpread(p) {
            const A = this.startNode();
            return this.next(), A.argument = this.parseMaybeAssignAllowIn(p, void 0), this.finishNode(A, "SpreadElement");
          }
          parseRestBinding() {
            const p = this.startNode();
            return this.next(), p.argument = this.parseBindingAtom(), this.finishNode(p, "RestElement");
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 0: {
                const p = this.startNode();
                return this.next(), p.elements = this.parseBindingList(3, 93, 1), this.finishNode(p, "ArrayPattern");
              }
              case 5:
                return this.parseObjectLike(8, !0);
            }
            return this.parseIdentifier();
          }
          parseBindingList(p, A, V) {
            const ee = 1 & V, fe = [];
            let Se = !0;
            for (; !this.eat(p); )
              if (Se ? Se = !1 : this.expect(12), ee && this.match(12))
                fe.push(null);
              else {
                if (this.eat(p))
                  break;
                if (this.match(21)) {
                  if (fe.push(this.parseAssignableListItemTypes(this.parseRestBinding(), V)), !this.checkCommaAfterRest(A)) {
                    this.expect(p);
                    break;
                  }
                } else {
                  const Pe = [];
                  for (this.match(26) && this.hasPlugin("decorators") && this.raise(C.UnsupportedParameterDecorator, { at: this.state.startLoc }); this.match(26); )
                    Pe.push(this.parseDecorator());
                  fe.push(this.parseAssignableListItem(V, Pe));
                }
              }
            return fe;
          }
          parseBindingRestProperty(p) {
            return this.next(), p.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(p, "RestElement");
          }
          parseBindingProperty() {
            const p = this.startNode(), { type: A, startLoc: V } = this.state;
            return A === 21 ? this.parseBindingRestProperty(p) : (A === 136 ? (this.expectPlugin("destructuringPrivate", V), this.classScope.usePrivateName(this.state.value, V), p.key = this.parsePrivateName()) : this.parsePropertyName(p), p.method = !1, this.parseObjPropValue(p, V, !1, !1, !0, !1));
          }
          parseAssignableListItem(p, A) {
            const V = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(V, p);
            const ee = this.parseMaybeDefault(V.loc.start, V);
            return A.length && (V.decorators = A), ee;
          }
          parseAssignableListItemTypes(p, A) {
            return p;
          }
          parseMaybeDefault(p, A) {
            var V;
            if (p != null || (p = this.state.startLoc), A = (V = A) != null ? V : this.parseBindingAtom(), !this.eat(29))
              return A;
            const ee = this.startNodeAt(p);
            return ee.left = A, ee.right = this.parseMaybeAssignAllowIn(), this.finishNode(ee, "AssignmentPattern");
          }
          isValidLVal(p, A, V) {
            return ee = { AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, fe = p, Object.hasOwnProperty.call(ee, fe) && ee[fe];
            var ee, fe;
          }
          checkLVal(p, { in: A, binding: V = 64, checkClashes: ee = !1, strictModeChanged: fe = !1, hasParenthesizedAncestor: Se = !1 }) {
            var Pe;
            const Re = p.type;
            if (this.isObjectMethod(p))
              return;
            if (Re === "MemberExpression")
              return void (V !== 64 && this.raise(C.InvalidPropertyBindingPattern, { at: p }));
            if (Re === "Identifier") {
              this.checkIdentifier(p, V, fe);
              const { name: St } = p;
              return void (ee && (ee.has(St) ? this.raise(C.ParamDupe, { at: p }) : ee.add(St)));
            }
            const je = this.isValidLVal(Re, !(Se || (Pe = p.extra) != null && Pe.parenthesized) && A.type === "AssignmentExpression", V);
            if (je === !0)
              return;
            if (je === !1) {
              const St = V === 64 ? C.InvalidLhs : C.InvalidLhsBinding;
              return void this.raise(St, { at: p, ancestor: A });
            }
            const [ze, mt] = Array.isArray(je) ? je : [je, Re === "ParenthesizedExpression"], Mt = Re === "ArrayPattern" || Re === "ObjectPattern" || Re === "ParenthesizedExpression" ? { type: Re } : A;
            for (const St of [].concat(p[ze]))
              St && this.checkLVal(St, { in: Mt, binding: V, checkClashes: ee, strictModeChanged: fe, hasParenthesizedAncestor: mt });
          }
          checkIdentifier(p, A, V = !1) {
            this.state.strict && (V ? We(p.name, this.inModule) : Ie(p.name)) && (A === 64 ? this.raise(C.StrictEvalArguments, { at: p, referenceName: p.name }) : this.raise(C.StrictEvalArgumentsBinding, { at: p, bindingName: p.name })), 8192 & A && p.name === "let" && this.raise(C.LetInLexicalBinding, { at: p }), 64 & A || this.declareNameFromIdentifier(p, A);
          }
          declareNameFromIdentifier(p, A) {
            this.scope.declareName(p.name, A, p.loc.start);
          }
          checkToRestConversion(p, A) {
            switch (p.type) {
              case "ParenthesizedExpression":
                this.checkToRestConversion(p.expression, A);
                break;
              case "Identifier":
              case "MemberExpression":
                break;
              case "ArrayExpression":
              case "ObjectExpression":
                if (A)
                  break;
              default:
                this.raise(C.InvalidRestAssignmentPattern, { at: p });
            }
          }
          checkCommaAfterRest(p) {
            return !!this.match(12) && (this.raise(this.lookaheadCharCode() === p ? C.RestTrailingComma : C.ElementAfterRest, { at: this.state.startLoc }), !0);
          }
        }
        function Qt(Te) {
          if (!Te)
            throw new Error("Assert fail");
        }
        const xt = N`typescript`({ AbstractMethodHasImplementation: ({ methodName: Te }) => `Method '${Te}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: Te }) => `Property '${Te}' cannot have an initializer because it is marked abstract.`, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: ({ kind: Te }) => `'declare' is not allowed in ${Te}ters.`, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: ({ modifier: Te }) => "Accessibility modifier already seen.", DuplicateModifier: ({ modifier: Te }) => `Duplicate modifier: '${Te}'.`, EmptyHeritageClauseType: ({ token: Te }) => `'${Te}' list cannot be empty.`, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: ({ modifiers: Te }) => `'${Te[0]}' modifier cannot be used with '${Te[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: Te }) => `Index signatures cannot have an accessibility modifier ('${Te}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: ({ modifier: Te }) => `'${Te}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: Te }) => `'${Te}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: Te }) => `'${Te}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifiersOrder: ({ orderedModifiers: Te }) => `'${Te[0]}' modifier must precede '${Te[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: Te }) => `Private elements cannot have an accessibility modifier ('${Te}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: Te }) => `Single type parameter ${Te} should have a trailing comma. Example usage: <${Te},>.`, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: ({ type: Te }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${Te}.` });
        function bl(Te) {
          return Te === "private" || Te === "public" || Te === "protected";
        }
        function uc(Te) {
          return Te === "in" || Te === "out";
        }
        function Xi(Te) {
          if (Te.type !== "MemberExpression")
            return !1;
          const { computed: p, property: A } = Te;
          return (!p || A.type === "StringLiteral" || !(A.type !== "TemplateLiteral" || A.expressions.length > 0)) && fc(Te.object);
        }
        function kt(Te, p) {
          var A;
          const { type: V } = Te;
          if ((A = Te.extra) != null && A.parenthesized)
            return !1;
          if (p) {
            if (V === "Literal") {
              const { value: ee } = Te;
              if (typeof ee == "string" || typeof ee == "boolean")
                return !0;
            }
          } else if (V === "StringLiteral" || V === "BooleanLiteral")
            return !0;
          return !(!cc(Te, p) && !function(ee, fe) {
            if (ee.type === "UnaryExpression") {
              const { operator: Se, argument: Pe } = ee;
              if (Se === "-" && cc(Pe, fe))
                return !0;
            }
            return !1;
          }(Te, p)) || V === "TemplateLiteral" && Te.expressions.length === 0 || !!Xi(Te);
        }
        function cc(Te, p) {
          return p ? Te.type === "Literal" && (typeof Te.value == "number" || "bigint" in Te) : Te.type === "NumericLiteral" || Te.type === "BigIntLiteral";
        }
        function fc(Te) {
          return Te.type === "Identifier" || Te.type === "MemberExpression" && !Te.computed && fc(Te.object);
        }
        const dc = N`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." });
        function Wr(Te, p) {
          const [A, V] = typeof p == "string" ? [p, {}] : p, ee = Object.keys(V), fe = ee.length === 0;
          return Te.some((Se) => {
            if (typeof Se == "string")
              return fe && Se === A;
            {
              const [Pe, Re] = Se;
              if (Pe !== A)
                return !1;
              for (const je of ee)
                if (Re[je] !== V[je])
                  return !1;
              return !0;
            }
          });
        }
        function xs(Te, p, A) {
          const V = Te.find((ee) => Array.isArray(ee) ? ee[0] === p : ee === p);
          return V && Array.isArray(V) && V.length > 1 ? V[1][A] : null;
        }
        const pc = ["minimal", "fsharp", "hack", "smart"], Ii = ["^^", "@@", "^", "%", "#"], Hs = ["hash", "bar"], va = { estree: (Te) => class extends Te {
          parse() {
            const p = j(super.parse());
            return this.options.tokens && (p.tokens = p.tokens.map(j)), p;
          }
          parseRegExpLiteral({ pattern: p, flags: A }) {
            let V = null;
            try {
              V = new RegExp(p, A);
            } catch {
            }
            const ee = this.estreeParseLiteral(V);
            return ee.regex = { pattern: p, flags: A }, ee;
          }
          parseBigIntLiteral(p) {
            let A;
            try {
              A = BigInt(p);
            } catch {
              A = null;
            }
            const V = this.estreeParseLiteral(A);
            return V.bigint = String(V.value || p), V;
          }
          parseDecimalLiteral(p) {
            const A = this.estreeParseLiteral(null);
            return A.decimal = String(A.value || p), A;
          }
          estreeParseLiteral(p) {
            return this.parseLiteral(p, "Literal");
          }
          parseStringLiteral(p) {
            return this.estreeParseLiteral(p);
          }
          parseNumericLiteral(p) {
            return this.estreeParseLiteral(p);
          }
          parseNullLiteral() {
            return this.estreeParseLiteral(null);
          }
          parseBooleanLiteral(p) {
            return this.estreeParseLiteral(p);
          }
          directiveToStmt(p) {
            const A = p.value;
            delete p.value, A.type = "Literal", A.raw = A.extra.raw, A.value = A.extra.expressionValue;
            const V = p;
            return V.type = "ExpressionStatement", V.expression = A, V.directive = A.extra.rawValue, delete A.extra, V;
          }
          initFunction(p, A) {
            super.initFunction(p, A), p.expression = !1;
          }
          checkDeclaration(p) {
            p != null && this.isObjectProperty(p) ? this.checkDeclaration(p.value) : super.checkDeclaration(p);
          }
          getObjectOrClassMethodParams(p) {
            return p.value.params;
          }
          isValidDirective(p) {
            var A;
            return p.type === "ExpressionStatement" && p.expression.type === "Literal" && typeof p.expression.value == "string" && !((A = p.expression.extra) != null && A.parenthesized);
          }
          parseBlockBody(p, A, V, ee, fe) {
            super.parseBlockBody(p, A, V, ee, fe);
            const Se = p.directives.map((Pe) => this.directiveToStmt(Pe));
            p.body = Se.concat(p.body), delete p.directives;
          }
          pushClassMethod(p, A, V, ee, fe, Se) {
            this.parseMethod(A, V, ee, fe, Se, "ClassMethod", !0), A.typeParameters && (A.value.typeParameters = A.typeParameters, delete A.typeParameters), p.body.push(A);
          }
          parsePrivateName() {
            const p = super.parsePrivateName();
            return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(p) : p;
          }
          convertPrivateNameToPrivateIdentifier(p) {
            const A = super.getPrivateNameSV(p);
            return delete p.id, p.name = A, p.type = "PrivateIdentifier", p;
          }
          isPrivateName(p) {
            return this.getPluginOption("estree", "classFeatures") ? p.type === "PrivateIdentifier" : super.isPrivateName(p);
          }
          getPrivateNameSV(p) {
            return this.getPluginOption("estree", "classFeatures") ? p.name : super.getPrivateNameSV(p);
          }
          parseLiteral(p, A) {
            const V = super.parseLiteral(p, A);
            return V.raw = V.extra.raw, delete V.extra, V;
          }
          parseFunctionBody(p, A, V = !1) {
            super.parseFunctionBody(p, A, V), p.expression = p.body.type !== "BlockStatement";
          }
          parseMethod(p, A, V, ee, fe, Se, Pe = !1) {
            let Re = this.startNode();
            return Re.kind = p.kind, Re = super.parseMethod(Re, A, V, ee, fe, Se, Pe), Re.type = "FunctionExpression", delete Re.kind, p.value = Re, Se === "ClassPrivateMethod" && (p.computed = !1), this.finishNode(p, "MethodDefinition");
          }
          parseClassProperty(...p) {
            const A = super.parseClassProperty(...p);
            return this.getPluginOption("estree", "classFeatures") && (A.type = "PropertyDefinition"), A;
          }
          parseClassPrivateProperty(...p) {
            const A = super.parseClassPrivateProperty(...p);
            return this.getPluginOption("estree", "classFeatures") && (A.type = "PropertyDefinition", A.computed = !1), A;
          }
          parseObjectMethod(p, A, V, ee, fe) {
            const Se = super.parseObjectMethod(p, A, V, ee, fe);
            return Se && (Se.type = "Property", Se.kind === "method" && (Se.kind = "init"), Se.shorthand = !1), Se;
          }
          parseObjectProperty(p, A, V, ee) {
            const fe = super.parseObjectProperty(p, A, V, ee);
            return fe && (fe.kind = "init", fe.type = "Property"), fe;
          }
          isValidLVal(p, A, V) {
            return p === "Property" ? "value" : super.isValidLVal(p, A, V);
          }
          isAssignable(p, A) {
            return p != null && this.isObjectProperty(p) ? this.isAssignable(p.value, A) : super.isAssignable(p, A);
          }
          toAssignable(p, A = !1) {
            if (p != null && this.isObjectProperty(p)) {
              const { key: V, value: ee } = p;
              this.isPrivateName(V) && this.classScope.usePrivateName(this.getPrivateNameSV(V), V.loc.start), this.toAssignable(ee, A);
            } else
              super.toAssignable(p, A);
          }
          toAssignableObjectExpressionProp(p, A, V) {
            p.kind === "get" || p.kind === "set" ? this.raise(C.PatternHasAccessor, { at: p.key }) : p.method ? this.raise(C.PatternHasMethod, { at: p.key }) : super.toAssignableObjectExpressionProp(p, A, V);
          }
          finishCallExpression(p, A) {
            const V = super.finishCallExpression(p, A);
            if (V.callee.type === "Import") {
              var ee;
              V.type = "ImportExpression", V.source = V.arguments[0], (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (V.attributes = (ee = V.arguments[1]) != null ? ee : null), delete V.arguments, delete V.callee;
            }
            return V;
          }
          toReferencedArguments(p) {
            p.type !== "ImportExpression" && super.toReferencedArguments(p);
          }
          parseExport(p, A) {
            const V = this.state.lastTokStartLoc, ee = super.parseExport(p, A);
            switch (ee.type) {
              case "ExportAllDeclaration":
                ee.exported = null;
                break;
              case "ExportNamedDeclaration":
                ee.specifiers.length === 1 && ee.specifiers[0].type === "ExportNamespaceSpecifier" && (ee.type = "ExportAllDeclaration", ee.exported = ee.specifiers[0].exported, delete ee.specifiers);
              case "ExportDefaultDeclaration": {
                var fe;
                const { declaration: Se } = ee;
                (Se == null ? void 0 : Se.type) === "ClassDeclaration" && ((fe = Se.decorators) == null ? void 0 : fe.length) > 0 && Se.start === ee.start && this.resetStartLocation(ee, V);
              }
            }
            return ee;
          }
          parseSubscript(p, A, V, ee) {
            const fe = super.parseSubscript(p, A, V, ee);
            if (ee.optionalChainMember) {
              if (fe.type !== "OptionalMemberExpression" && fe.type !== "OptionalCallExpression" || (fe.type = fe.type.substring(8)), ee.stop) {
                const Se = this.startNodeAtNode(fe);
                return Se.expression = fe, this.finishNode(Se, "ChainExpression");
              }
            } else
              fe.type !== "MemberExpression" && fe.type !== "CallExpression" || (fe.optional = !1);
            return fe;
          }
          hasPropertyAsPrivateName(p) {
            return p.type === "ChainExpression" && (p = p.expression), super.hasPropertyAsPrivateName(p);
          }
          isObjectProperty(p) {
            return p.type === "Property" && p.kind === "init" && !p.method;
          }
          isObjectMethod(p) {
            return p.method || p.kind === "get" || p.kind === "set";
          }
          finishNodeAt(p, A, V) {
            return j(super.finishNodeAt(p, A, V));
          }
          resetStartLocation(p, A) {
            super.resetStartLocation(p, A), j(p);
          }
          resetEndLocation(p, A = this.state.lastTokEndLoc) {
            super.resetEndLocation(p, A), j(p);
          }
        }, jsx: (Te) => class extends Te {
          jsxReadToken() {
            let p = "", A = this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(Ki.UnterminatedJsxContent, { at: this.state.startLoc });
              const V = this.input.charCodeAt(this.state.pos);
              switch (V) {
                case 60:
                case 123:
                  return this.state.pos === this.state.start ? void (V === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(140)) : super.getTokenFromCode(V)) : (p += this.input.slice(A, this.state.pos), void this.finishToken(139, p));
                case 38:
                  p += this.input.slice(A, this.state.pos), p += this.jsxReadEntity(), A = this.state.pos;
                  break;
                default:
                  nt(V) ? (p += this.input.slice(A, this.state.pos), p += this.jsxReadNewLine(!0), A = this.state.pos) : ++this.state.pos;
              }
            }
          }
          jsxReadNewLine(p) {
            const A = this.input.charCodeAt(this.state.pos);
            let V;
            return ++this.state.pos, A === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, V = p ? `
` : `\r
`) : V = String.fromCharCode(A), ++this.state.curLine, this.state.lineStart = this.state.pos, V;
          }
          jsxReadString(p) {
            let A = "", V = ++this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(C.UnterminatedString, { at: this.state.startLoc });
              const ee = this.input.charCodeAt(this.state.pos);
              if (ee === p)
                break;
              ee === 38 ? (A += this.input.slice(V, this.state.pos), A += this.jsxReadEntity(), V = this.state.pos) : nt(ee) ? (A += this.input.slice(V, this.state.pos), A += this.jsxReadNewLine(!1), V = this.state.pos) : ++this.state.pos;
            }
            A += this.input.slice(V, this.state.pos++), this.finishToken(131, A);
          }
          jsxReadEntity() {
            const p = ++this.state.pos;
            if (this.codePointAtPos(this.state.pos) === 35) {
              ++this.state.pos;
              let A = 10;
              this.codePointAtPos(this.state.pos) === 120 && (A = 16, ++this.state.pos);
              const V = this.readInt(A, void 0, !1, "bail");
              if (V !== null && this.codePointAtPos(this.state.pos) === 59)
                return ++this.state.pos, String.fromCodePoint(V);
            } else {
              let A = 0, V = !1;
              for (; A++ < 10 && this.state.pos < this.length && !(V = this.codePointAtPos(this.state.pos) == 59); )
                ++this.state.pos;
              if (V) {
                const ee = this.input.slice(p, this.state.pos), fe = ac[ee];
                if (++this.state.pos, fe)
                  return fe;
              }
            }
            return this.state.pos = p, "&";
          }
          jsxReadWord() {
            let p;
            const A = this.state.pos;
            do
              p = this.input.charCodeAt(++this.state.pos);
            while (Ae(p) || p === 45);
            this.finishToken(138, this.input.slice(A, this.state.pos));
          }
          jsxParseIdentifier() {
            const p = this.startNode();
            return this.match(138) ? p.name = this.state.value : ne(this.state.type) ? p.name = ye(this.state.type) : this.unexpected(), this.next(), this.finishNode(p, "JSXIdentifier");
          }
          jsxParseNamespacedName() {
            const p = this.state.startLoc, A = this.jsxParseIdentifier();
            if (!this.eat(14))
              return A;
            const V = this.startNodeAt(p);
            return V.namespace = A, V.name = this.jsxParseIdentifier(), this.finishNode(V, "JSXNamespacedName");
          }
          jsxParseElementName() {
            const p = this.state.startLoc;
            let A = this.jsxParseNamespacedName();
            if (A.type === "JSXNamespacedName")
              return A;
            for (; this.eat(16); ) {
              const V = this.startNodeAt(p);
              V.object = A, V.property = this.jsxParseIdentifier(), A = this.finishNode(V, "JSXMemberExpression");
            }
            return A;
          }
          jsxParseAttributeValue() {
            let p;
            switch (this.state.type) {
              case 5:
                return p = this.startNode(), this.setContext(_.brace), this.next(), p = this.jsxParseExpressionContainer(p, _.j_oTag), p.expression.type === "JSXEmptyExpression" && this.raise(Ki.AttributeIsEmpty, { at: p }), p;
              case 140:
              case 131:
                return this.parseExprAtom();
              default:
                throw this.raise(Ki.UnsupportedJsxValue, { at: this.state.startLoc });
            }
          }
          jsxParseEmptyExpression() {
            const p = this.startNodeAt(this.state.lastTokEndLoc);
            return this.finishNodeAt(p, "JSXEmptyExpression", this.state.startLoc);
          }
          jsxParseSpreadChild(p) {
            return this.next(), p.expression = this.parseExpression(), this.setContext(_.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(p, "JSXSpreadChild");
          }
          jsxParseExpressionContainer(p, A) {
            if (this.match(8))
              p.expression = this.jsxParseEmptyExpression();
            else {
              const V = this.parseExpression();
              p.expression = V;
            }
            return this.setContext(A), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(p, "JSXExpressionContainer");
          }
          jsxParseAttribute() {
            const p = this.startNode();
            return this.match(5) ? (this.setContext(_.brace), this.next(), this.expect(21), p.argument = this.parseMaybeAssignAllowIn(), this.setContext(_.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(p, "JSXSpreadAttribute")) : (p.name = this.jsxParseNamespacedName(), p.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(p, "JSXAttribute"));
          }
          jsxParseOpeningElementAt(p) {
            const A = this.startNodeAt(p);
            return this.eat(141) ? this.finishNode(A, "JSXOpeningFragment") : (A.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(A));
          }
          jsxParseOpeningElementAfterName(p) {
            const A = [];
            for (; !this.match(56) && !this.match(141); )
              A.push(this.jsxParseAttribute());
            return p.attributes = A, p.selfClosing = this.eat(56), this.expect(141), this.finishNode(p, "JSXOpeningElement");
          }
          jsxParseClosingElementAt(p) {
            const A = this.startNodeAt(p);
            return this.eat(141) ? this.finishNode(A, "JSXClosingFragment") : (A.name = this.jsxParseElementName(), this.expect(141), this.finishNode(A, "JSXClosingElement"));
          }
          jsxParseElementAt(p) {
            const A = this.startNodeAt(p), V = [], ee = this.jsxParseOpeningElementAt(p);
            let fe = null;
            if (!ee.selfClosing) {
              e:
                for (; ; )
                  switch (this.state.type) {
                    case 140:
                      if (p = this.state.startLoc, this.next(), this.eat(56)) {
                        fe = this.jsxParseClosingElementAt(p);
                        break e;
                      }
                      V.push(this.jsxParseElementAt(p));
                      break;
                    case 139:
                      V.push(this.parseExprAtom());
                      break;
                    case 5: {
                      const Se = this.startNode();
                      this.setContext(_.brace), this.next(), this.match(21) ? V.push(this.jsxParseSpreadChild(Se)) : V.push(this.jsxParseExpressionContainer(Se, _.j_expr));
                      break;
                    }
                    default:
                      this.unexpected();
                  }
              Yi(ee) && !Yi(fe) && fe !== null ? this.raise(Ki.MissingClosingTagFragment, { at: fe }) : !Yi(ee) && Yi(fe) ? this.raise(Ki.MissingClosingTagElement, { at: fe, openingTagName: Ci(ee.name) }) : Yi(ee) || Yi(fe) || Ci(fe.name) !== Ci(ee.name) && this.raise(Ki.MissingClosingTagElement, { at: fe, openingTagName: Ci(ee.name) });
            }
            if (Yi(ee) ? (A.openingFragment = ee, A.closingFragment = fe) : (A.openingElement = ee, A.closingElement = fe), A.children = V, this.match(47))
              throw this.raise(Ki.UnwrappedAdjacentJSXElements, { at: this.state.startLoc });
            return Yi(ee) ? this.finishNode(A, "JSXFragment") : this.finishNode(A, "JSXElement");
          }
          jsxParseElement() {
            const p = this.state.startLoc;
            return this.next(), this.jsxParseElementAt(p);
          }
          setContext(p) {
            const { context: A } = this.state;
            A[A.length - 1] = p;
          }
          parseExprAtom(p) {
            return this.match(139) ? this.parseLiteral(this.state.value, "JSXText") : this.match(140) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(140), this.jsxParseElement()) : super.parseExprAtom(p);
          }
          skipSpace() {
            this.curContext().preserveSpace || super.skipSpace();
          }
          getTokenFromCode(p) {
            const A = this.curContext();
            if (A !== _.j_expr) {
              if (A === _.j_oTag || A === _.j_cTag) {
                if (Ee(p))
                  return void this.jsxReadWord();
                if (p === 62)
                  return ++this.state.pos, void this.finishToken(141);
                if ((p === 34 || p === 39) && A === _.j_oTag)
                  return void this.jsxReadString(p);
              }
              if (p === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33)
                return ++this.state.pos, void this.finishToken(140);
              super.getTokenFromCode(p);
            } else
              this.jsxReadToken();
          }
          updateContext(p) {
            const { context: A, type: V } = this.state;
            if (V === 56 && p === 140)
              A.splice(-2, 2, _.j_cTag), this.state.canStartJSXElement = !1;
            else if (V === 140)
              A.push(_.j_oTag);
            else if (V === 141) {
              const ee = A[A.length - 1];
              ee === _.j_oTag && p === 56 || ee === _.j_cTag ? (A.pop(), this.state.canStartJSXElement = A[A.length - 1] === _.j_expr) : (this.setContext(_.j_expr), this.state.canStartJSXElement = !0);
            } else
              this.state.canStartJSXElement = B[V];
          }
        }, flow: (Te) => class extends Te {
          constructor(...p) {
            super(...p), this.flowPragma = void 0;
          }
          getScopeHandler() {
            return st;
          }
          shouldParseTypes() {
            return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
          }
          shouldParseEnums() {
            return !!this.getPluginOption("flow", "enums");
          }
          finishToken(p, A) {
            p !== 131 && p !== 13 && p !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(p, A);
          }
          addComment(p) {
            if (this.flowPragma === void 0) {
              const A = sc.exec(p.value);
              if (A)
                if (A[1] === "flow")
                  this.flowPragma = "flow";
                else {
                  if (A[1] !== "noflow")
                    throw new Error("Unexpected flow pragma");
                  this.flowPragma = "noflow";
                }
            }
            super.addComment(p);
          }
          flowParseTypeInitialiser(p) {
            const A = this.state.inType;
            this.state.inType = !0, this.expect(p || 14);
            const V = this.flowParseType();
            return this.state.inType = A, V;
          }
          flowParsePredicate() {
            const p = this.startNode(), A = this.state.startLoc;
            return this.next(), this.expectContextual(108), this.state.lastTokStart > A.index + 1 && this.raise(Rt.UnexpectedSpaceBetweenModuloChecks, { at: A }), this.eat(10) ? (p.value = super.parseExpression(), this.expect(11), this.finishNode(p, "DeclaredPredicate")) : this.finishNode(p, "InferredPredicate");
          }
          flowParseTypeAndPredicateInitialiser() {
            const p = this.state.inType;
            this.state.inType = !0, this.expect(14);
            let A = null, V = null;
            return this.match(54) ? (this.state.inType = p, V = this.flowParsePredicate()) : (A = this.flowParseType(), this.state.inType = p, this.match(54) && (V = this.flowParsePredicate())), [A, V];
          }
          flowParseDeclareClass(p) {
            return this.next(), this.flowParseInterfaceish(p, !0), this.finishNode(p, "DeclareClass");
          }
          flowParseDeclareFunction(p) {
            this.next();
            const A = p.id = this.parseIdentifier(), V = this.startNode(), ee = this.startNode();
            this.match(47) ? V.typeParameters = this.flowParseTypeParameterDeclaration() : V.typeParameters = null, this.expect(10);
            const fe = this.flowParseFunctionTypeParams();
            return V.params = fe.params, V.rest = fe.rest, V.this = fe._this, this.expect(11), [V.returnType, p.predicate] = this.flowParseTypeAndPredicateInitialiser(), ee.typeAnnotation = this.finishNode(V, "FunctionTypeAnnotation"), A.typeAnnotation = this.finishNode(ee, "TypeAnnotation"), this.resetEndLocation(A), this.semicolon(), this.scope.declareName(p.id.name, 2048, p.id.loc.start), this.finishNode(p, "DeclareFunction");
          }
          flowParseDeclare(p, A) {
            return this.match(80) ? this.flowParseDeclareClass(p) : this.match(68) ? this.flowParseDeclareFunction(p) : this.match(74) ? this.flowParseDeclareVariable(p) : this.eatContextual(125) ? this.match(16) ? this.flowParseDeclareModuleExports(p) : (A && this.raise(Rt.NestedDeclareModule, { at: this.state.lastTokStartLoc }), this.flowParseDeclareModule(p)) : this.isContextual(128) ? this.flowParseDeclareTypeAlias(p) : this.isContextual(129) ? this.flowParseDeclareOpaqueType(p) : this.isContextual(127) ? this.flowParseDeclareInterface(p) : this.match(82) ? this.flowParseDeclareExportDeclaration(p, A) : void this.unexpected();
          }
          flowParseDeclareVariable(p) {
            return this.next(), p.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(p.id.name, 5, p.id.loc.start), this.semicolon(), this.finishNode(p, "DeclareVariable");
          }
          flowParseDeclareModule(p) {
            this.scope.enter(0), this.match(131) ? p.id = super.parseExprAtom() : p.id = this.parseIdentifier();
            const A = p.body = this.startNode(), V = A.body = [];
            for (this.expect(5); !this.match(8); ) {
              let Se = this.startNode();
              this.match(83) ? (this.next(), this.isContextual(128) || this.match(87) || this.raise(Rt.InvalidNonTypeImportInDeclareModule, { at: this.state.lastTokStartLoc }), super.parseImport(Se)) : (this.expectContextual(123, Rt.UnsupportedStatementInDeclareModule), Se = this.flowParseDeclare(Se, !0)), V.push(Se);
            }
            this.scope.exit(), this.expect(8), this.finishNode(A, "BlockStatement");
            let ee = null, fe = !1;
            return V.forEach((Se) => {
              (function(Pe) {
                return Pe.type === "DeclareExportAllDeclaration" || Pe.type === "DeclareExportDeclaration" && (!Pe.declaration || Pe.declaration.type !== "TypeAlias" && Pe.declaration.type !== "InterfaceDeclaration");
              })(Se) ? (ee === "CommonJS" && this.raise(Rt.AmbiguousDeclareModuleKind, { at: Se }), ee = "ES") : Se.type === "DeclareModuleExports" && (fe && this.raise(Rt.DuplicateDeclareModuleExports, { at: Se }), ee === "ES" && this.raise(Rt.AmbiguousDeclareModuleKind, { at: Se }), ee = "CommonJS", fe = !0);
            }), p.kind = ee || "CommonJS", this.finishNode(p, "DeclareModule");
          }
          flowParseDeclareExportDeclaration(p, A) {
            if (this.expect(82), this.eat(65))
              return this.match(68) || this.match(80) ? p.declaration = this.flowParseDeclare(this.startNode()) : (p.declaration = this.flowParseType(), this.semicolon()), p.default = !0, this.finishNode(p, "DeclareExportDeclaration");
            if (this.match(75) || this.isLet() || (this.isContextual(128) || this.isContextual(127)) && !A) {
              const V = this.state.value;
              throw this.raise(Rt.UnsupportedDeclareExportKind, { at: this.state.startLoc, unsupportedExportKind: V, suggestion: ni[V] });
            }
            return this.match(74) || this.match(68) || this.match(80) || this.isContextual(129) ? (p.declaration = this.flowParseDeclare(this.startNode()), p.default = !1, this.finishNode(p, "DeclareExportDeclaration")) : this.match(55) || this.match(5) || this.isContextual(127) || this.isContextual(128) || this.isContextual(129) ? ((p = this.parseExport(p, null)).type === "ExportNamedDeclaration" && (p.type = "ExportDeclaration", p.default = !1, delete p.exportKind), p.type = "Declare" + p.type, p) : void this.unexpected();
          }
          flowParseDeclareModuleExports(p) {
            return this.next(), this.expectContextual(109), p.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(p, "DeclareModuleExports");
          }
          flowParseDeclareTypeAlias(p) {
            this.next();
            const A = this.flowParseTypeAlias(p);
            return A.type = "DeclareTypeAlias", A;
          }
          flowParseDeclareOpaqueType(p) {
            this.next();
            const A = this.flowParseOpaqueType(p, !0);
            return A.type = "DeclareOpaqueType", A;
          }
          flowParseDeclareInterface(p) {
            return this.next(), this.flowParseInterfaceish(p, !1), this.finishNode(p, "DeclareInterface");
          }
          flowParseInterfaceish(p, A) {
            if (p.id = this.flowParseRestrictedIdentifier(!A, !0), this.scope.declareName(p.id.name, A ? 17 : 8201, p.id.loc.start), this.match(47) ? p.typeParameters = this.flowParseTypeParameterDeclaration() : p.typeParameters = null, p.extends = [], this.eat(81))
              do
                p.extends.push(this.flowParseInterfaceExtends());
              while (!A && this.eat(12));
            if (A) {
              if (p.implements = [], p.mixins = [], this.eatContextual(115))
                do
                  p.mixins.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
              if (this.eatContextual(111))
                do
                  p.implements.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
            }
            p.body = this.flowParseObjectType({ allowStatic: A, allowExact: !1, allowSpread: !1, allowProto: A, allowInexact: !1 });
          }
          flowParseInterfaceExtends() {
            const p = this.startNode();
            return p.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? p.typeParameters = this.flowParseTypeParameterInstantiation() : p.typeParameters = null, this.finishNode(p, "InterfaceExtends");
          }
          flowParseInterface(p) {
            return this.flowParseInterfaceish(p, !1), this.finishNode(p, "InterfaceDeclaration");
          }
          checkNotUnderscore(p) {
            p === "_" && this.raise(Rt.UnexpectedReservedUnderscore, { at: this.state.startLoc });
          }
          checkReservedType(p, A, V) {
            ga.has(p) && this.raise(V ? Rt.AssignReservedType : Rt.UnexpectedReservedType, { at: A, reservedType: p });
          }
          flowParseRestrictedIdentifier(p, A) {
            return this.checkReservedType(this.state.value, this.state.startLoc, A), this.parseIdentifier(p);
          }
          flowParseTypeAlias(p) {
            return p.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(p.id.name, 8201, p.id.loc.start), this.match(47) ? p.typeParameters = this.flowParseTypeParameterDeclaration() : p.typeParameters = null, p.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(p, "TypeAlias");
          }
          flowParseOpaqueType(p, A) {
            return this.expectContextual(128), p.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(p.id.name, 8201, p.id.loc.start), this.match(47) ? p.typeParameters = this.flowParseTypeParameterDeclaration() : p.typeParameters = null, p.supertype = null, this.match(14) && (p.supertype = this.flowParseTypeInitialiser(14)), p.impltype = null, A || (p.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(p, "OpaqueType");
          }
          flowParseTypeParameter(p = !1) {
            const A = this.state.startLoc, V = this.startNode(), ee = this.flowParseVariance(), fe = this.flowParseTypeAnnotatableIdentifier();
            return V.name = fe.name, V.variance = ee, V.bound = fe.typeAnnotation, this.match(29) ? (this.eat(29), V.default = this.flowParseType()) : p && this.raise(Rt.MissingTypeParamDefault, { at: A }), this.finishNode(V, "TypeParameter");
          }
          flowParseTypeParameterDeclaration() {
            const p = this.state.inType, A = this.startNode();
            A.params = [], this.state.inType = !0, this.match(47) || this.match(140) ? this.next() : this.unexpected();
            let V = !1;
            do {
              const ee = this.flowParseTypeParameter(V);
              A.params.push(ee), ee.default && (V = !0), this.match(48) || this.expect(12);
            } while (!this.match(48));
            return this.expect(48), this.state.inType = p, this.finishNode(A, "TypeParameterDeclaration");
          }
          flowParseTypeParameterInstantiation() {
            const p = this.startNode(), A = this.state.inType;
            p.params = [], this.state.inType = !0, this.expect(47);
            const V = this.state.noAnonFunctionType;
            for (this.state.noAnonFunctionType = !1; !this.match(48); )
              p.params.push(this.flowParseType()), this.match(48) || this.expect(12);
            return this.state.noAnonFunctionType = V, this.expect(48), this.state.inType = A, this.finishNode(p, "TypeParameterInstantiation");
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            const p = this.startNode(), A = this.state.inType;
            for (p.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
              p.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
            return this.expect(48), this.state.inType = A, this.finishNode(p, "TypeParameterInstantiation");
          }
          flowParseInterfaceType() {
            const p = this.startNode();
            if (this.expectContextual(127), p.extends = [], this.eat(81))
              do
                p.extends.push(this.flowParseInterfaceExtends());
              while (this.eat(12));
            return p.body = this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !1, allowProto: !1, allowInexact: !1 }), this.finishNode(p, "InterfaceTypeAnnotation");
          }
          flowParseObjectPropertyKey() {
            return this.match(132) || this.match(131) ? super.parseExprAtom() : this.parseIdentifier(!0);
          }
          flowParseObjectTypeIndexer(p, A, V) {
            return p.static = A, this.lookahead().type === 14 ? (p.id = this.flowParseObjectPropertyKey(), p.key = this.flowParseTypeInitialiser()) : (p.id = null, p.key = this.flowParseType()), this.expect(3), p.value = this.flowParseTypeInitialiser(), p.variance = V, this.finishNode(p, "ObjectTypeIndexer");
          }
          flowParseObjectTypeInternalSlot(p, A) {
            return p.static = A, p.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (p.method = !0, p.optional = !1, p.value = this.flowParseObjectTypeMethodish(this.startNodeAt(p.loc.start))) : (p.method = !1, this.eat(17) && (p.optional = !0), p.value = this.flowParseTypeInitialiser()), this.finishNode(p, "ObjectTypeInternalSlot");
          }
          flowParseObjectTypeMethodish(p) {
            for (p.params = [], p.rest = null, p.typeParameters = null, p.this = null, this.match(47) && (p.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (p.this = this.flowParseFunctionTypeParam(!0), p.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
              p.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
            return this.eat(21) && (p.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), p.returnType = this.flowParseTypeInitialiser(), this.finishNode(p, "FunctionTypeAnnotation");
          }
          flowParseObjectTypeCallProperty(p, A) {
            const V = this.startNode();
            return p.static = A, p.value = this.flowParseObjectTypeMethodish(V), this.finishNode(p, "ObjectTypeCallProperty");
          }
          flowParseObjectType({ allowStatic: p, allowExact: A, allowSpread: V, allowProto: ee, allowInexact: fe }) {
            const Se = this.state.inType;
            this.state.inType = !0;
            const Pe = this.startNode();
            let Re, je;
            Pe.callProperties = [], Pe.properties = [], Pe.indexers = [], Pe.internalSlots = [];
            let ze = !1;
            for (A && this.match(6) ? (this.expect(6), Re = 9, je = !0) : (this.expect(5), Re = 8, je = !1), Pe.exact = je; !this.match(Re); ) {
              let Mt = !1, St = null, Ut = null;
              const Cr = this.startNode();
              if (ee && this.isContextual(116)) {
                const hr = this.lookahead();
                hr.type !== 14 && hr.type !== 17 && (this.next(), St = this.state.startLoc, p = !1);
              }
              if (p && this.isContextual(104)) {
                const hr = this.lookahead();
                hr.type !== 14 && hr.type !== 17 && (this.next(), Mt = !0);
              }
              const nr = this.flowParseVariance();
              if (this.eat(0))
                St != null && this.unexpected(St), this.eat(0) ? (nr && this.unexpected(nr.loc.start), Pe.internalSlots.push(this.flowParseObjectTypeInternalSlot(Cr, Mt))) : Pe.indexers.push(this.flowParseObjectTypeIndexer(Cr, Mt, nr));
              else if (this.match(10) || this.match(47))
                St != null && this.unexpected(St), nr && this.unexpected(nr.loc.start), Pe.callProperties.push(this.flowParseObjectTypeCallProperty(Cr, Mt));
              else {
                let hr = "init";
                (this.isContextual(98) || this.isContextual(103)) && H(this.lookahead().type) && (hr = this.state.value, this.next());
                const nn = this.flowParseObjectTypeProperty(Cr, Mt, St, nr, hr, V, fe ?? !je);
                nn === null ? (ze = !0, Ut = this.state.lastTokStartLoc) : Pe.properties.push(nn);
              }
              this.flowObjectTypeSemicolon(), !Ut || this.match(8) || this.match(9) || this.raise(Rt.UnexpectedExplicitInexactInObject, { at: Ut });
            }
            this.expect(Re), V && (Pe.inexact = ze);
            const mt = this.finishNode(Pe, "ObjectTypeAnnotation");
            return this.state.inType = Se, mt;
          }
          flowParseObjectTypeProperty(p, A, V, ee, fe, Se, Pe) {
            if (this.eat(21))
              return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (Se ? Pe || this.raise(Rt.InexactInsideExact, { at: this.state.lastTokStartLoc }) : this.raise(Rt.InexactInsideNonObject, { at: this.state.lastTokStartLoc }), ee && this.raise(Rt.InexactVariance, { at: ee }), null) : (Se || this.raise(Rt.UnexpectedSpreadType, { at: this.state.lastTokStartLoc }), V != null && this.unexpected(V), ee && this.raise(Rt.SpreadVariance, { at: ee }), p.argument = this.flowParseType(), this.finishNode(p, "ObjectTypeSpreadProperty"));
            {
              p.key = this.flowParseObjectPropertyKey(), p.static = A, p.proto = V != null, p.kind = fe;
              let Re = !1;
              return this.match(47) || this.match(10) ? (p.method = !0, V != null && this.unexpected(V), ee && this.unexpected(ee.loc.start), p.value = this.flowParseObjectTypeMethodish(this.startNodeAt(p.loc.start)), fe !== "get" && fe !== "set" || this.flowCheckGetterSetterParams(p), !Se && p.key.name === "constructor" && p.value.this && this.raise(Rt.ThisParamBannedInConstructor, { at: p.value.this })) : (fe !== "init" && this.unexpected(), p.method = !1, this.eat(17) && (Re = !0), p.value = this.flowParseTypeInitialiser(), p.variance = ee), p.optional = Re, this.finishNode(p, "ObjectTypeProperty");
            }
          }
          flowCheckGetterSetterParams(p) {
            const A = p.kind === "get" ? 0 : 1, V = p.value.params.length + (p.value.rest ? 1 : 0);
            p.value.this && this.raise(p.kind === "get" ? Rt.GetterMayNotHaveThisParam : Rt.SetterMayNotHaveThisParam, { at: p.value.this }), V !== A && this.raise(p.kind === "get" ? C.BadGetterArity : C.BadSetterArity, { at: p }), p.kind === "set" && p.value.rest && this.raise(C.BadSetterRestParameter, { at: p });
          }
          flowObjectTypeSemicolon() {
            this.eat(13) || this.eat(12) || this.match(8) || this.match(9) || this.unexpected();
          }
          flowParseQualifiedTypeIdentifier(p, A) {
            p != null || (p = this.state.startLoc);
            let V = A || this.flowParseRestrictedIdentifier(!0);
            for (; this.eat(16); ) {
              const ee = this.startNodeAt(p);
              ee.qualification = V, ee.id = this.flowParseRestrictedIdentifier(!0), V = this.finishNode(ee, "QualifiedTypeIdentifier");
            }
            return V;
          }
          flowParseGenericType(p, A) {
            const V = this.startNodeAt(p);
            return V.typeParameters = null, V.id = this.flowParseQualifiedTypeIdentifier(p, A), this.match(47) && (V.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(V, "GenericTypeAnnotation");
          }
          flowParseTypeofType() {
            const p = this.startNode();
            return this.expect(87), p.argument = this.flowParsePrimaryType(), this.finishNode(p, "TypeofTypeAnnotation");
          }
          flowParseTupleType() {
            const p = this.startNode();
            for (p.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (p.types.push(this.flowParseType()), !this.match(3)); )
              this.expect(12);
            return this.expect(3), this.finishNode(p, "TupleTypeAnnotation");
          }
          flowParseFunctionTypeParam(p) {
            let A = null, V = !1, ee = null;
            const fe = this.startNode(), Se = this.lookahead(), Pe = this.state.type === 78;
            return Se.type === 14 || Se.type === 17 ? (Pe && !p && this.raise(Rt.ThisParamMustBeFirst, { at: fe }), A = this.parseIdentifier(Pe), this.eat(17) && (V = !0, Pe && this.raise(Rt.ThisParamMayNotBeOptional, { at: fe })), ee = this.flowParseTypeInitialiser()) : ee = this.flowParseType(), fe.name = A, fe.optional = V, fe.typeAnnotation = ee, this.finishNode(fe, "FunctionTypeParam");
          }
          reinterpretTypeAsFunctionTypeParam(p) {
            const A = this.startNodeAt(p.loc.start);
            return A.name = null, A.optional = !1, A.typeAnnotation = p, this.finishNode(A, "FunctionTypeParam");
          }
          flowParseFunctionTypeParams(p = []) {
            let A = null, V = null;
            for (this.match(78) && (V = this.flowParseFunctionTypeParam(!0), V.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
              p.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
            return this.eat(21) && (A = this.flowParseFunctionTypeParam(!1)), { params: p, rest: A, _this: V };
          }
          flowIdentToTypeAnnotation(p, A, V) {
            switch (V.name) {
              case "any":
                return this.finishNode(A, "AnyTypeAnnotation");
              case "bool":
              case "boolean":
                return this.finishNode(A, "BooleanTypeAnnotation");
              case "mixed":
                return this.finishNode(A, "MixedTypeAnnotation");
              case "empty":
                return this.finishNode(A, "EmptyTypeAnnotation");
              case "number":
                return this.finishNode(A, "NumberTypeAnnotation");
              case "string":
                return this.finishNode(A, "StringTypeAnnotation");
              case "symbol":
                return this.finishNode(A, "SymbolTypeAnnotation");
              default:
                return this.checkNotUnderscore(V.name), this.flowParseGenericType(p, V);
            }
          }
          flowParsePrimaryType() {
            const p = this.state.startLoc, A = this.startNode();
            let V, ee, fe = !1;
            const Se = this.state.noAnonFunctionType;
            switch (this.state.type) {
              case 5:
                return this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !0, allowProto: !1, allowInexact: !0 });
              case 6:
                return this.flowParseObjectType({ allowStatic: !1, allowExact: !0, allowSpread: !0, allowProto: !1, allowInexact: !1 });
              case 0:
                return this.state.noAnonFunctionType = !1, ee = this.flowParseTupleType(), this.state.noAnonFunctionType = Se, ee;
              case 47:
                return A.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), V = this.flowParseFunctionTypeParams(), A.params = V.params, A.rest = V.rest, A.this = V._this, this.expect(11), this.expect(19), A.returnType = this.flowParseType(), this.finishNode(A, "FunctionTypeAnnotation");
              case 10:
                if (this.next(), !this.match(11) && !this.match(21))
                  if ($(this.state.type) || this.match(78)) {
                    const Pe = this.lookahead().type;
                    fe = Pe !== 17 && Pe !== 14;
                  } else
                    fe = !0;
                if (fe) {
                  if (this.state.noAnonFunctionType = !1, ee = this.flowParseType(), this.state.noAnonFunctionType = Se, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
                    return this.expect(11), ee;
                  this.eat(12);
                }
                return V = ee ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(ee)]) : this.flowParseFunctionTypeParams(), A.params = V.params, A.rest = V.rest, A.this = V._this, this.expect(11), this.expect(19), A.returnType = this.flowParseType(), A.typeParameters = null, this.finishNode(A, "FunctionTypeAnnotation");
              case 131:
                return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
              case 85:
              case 86:
                return A.value = this.match(85), this.next(), this.finishNode(A, "BooleanLiteralTypeAnnotation");
              case 53:
                if (this.state.value === "-") {
                  if (this.next(), this.match(132))
                    return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", A);
                  if (this.match(133))
                    return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", A);
                  throw this.raise(Rt.UnexpectedSubtractionOperand, { at: this.state.startLoc });
                }
                return void this.unexpected();
              case 132:
                return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
              case 133:
                return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
              case 88:
                return this.next(), this.finishNode(A, "VoidTypeAnnotation");
              case 84:
                return this.next(), this.finishNode(A, "NullLiteralTypeAnnotation");
              case 78:
                return this.next(), this.finishNode(A, "ThisTypeAnnotation");
              case 55:
                return this.next(), this.finishNode(A, "ExistsTypeAnnotation");
              case 87:
                return this.flowParseTypeofType();
              default:
                if (ne(this.state.type)) {
                  const Pe = ye(this.state.type);
                  return this.next(), super.createIdentifier(A, Pe);
                }
                if ($(this.state.type))
                  return this.isContextual(127) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(p, A, this.parseIdentifier());
            }
            this.unexpected();
          }
          flowParsePostfixType() {
            const p = this.state.startLoc;
            let A = this.flowParsePrimaryType(), V = !1;
            for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
              const ee = this.startNodeAt(p), fe = this.eat(18);
              V = V || fe, this.expect(0), !fe && this.match(3) ? (ee.elementType = A, this.next(), A = this.finishNode(ee, "ArrayTypeAnnotation")) : (ee.objectType = A, ee.indexType = this.flowParseType(), this.expect(3), V ? (ee.optional = fe, A = this.finishNode(ee, "OptionalIndexedAccessType")) : A = this.finishNode(ee, "IndexedAccessType"));
            }
            return A;
          }
          flowParsePrefixType() {
            const p = this.startNode();
            return this.eat(17) ? (p.typeAnnotation = this.flowParsePrefixType(), this.finishNode(p, "NullableTypeAnnotation")) : this.flowParsePostfixType();
          }
          flowParseAnonFunctionWithoutParens() {
            const p = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(19)) {
              const A = this.startNodeAt(p.loc.start);
              return A.params = [this.reinterpretTypeAsFunctionTypeParam(p)], A.rest = null, A.this = null, A.returnType = this.flowParseType(), A.typeParameters = null, this.finishNode(A, "FunctionTypeAnnotation");
            }
            return p;
          }
          flowParseIntersectionType() {
            const p = this.startNode();
            this.eat(45);
            const A = this.flowParseAnonFunctionWithoutParens();
            for (p.types = [A]; this.eat(45); )
              p.types.push(this.flowParseAnonFunctionWithoutParens());
            return p.types.length === 1 ? A : this.finishNode(p, "IntersectionTypeAnnotation");
          }
          flowParseUnionType() {
            const p = this.startNode();
            this.eat(43);
            const A = this.flowParseIntersectionType();
            for (p.types = [A]; this.eat(43); )
              p.types.push(this.flowParseIntersectionType());
            return p.types.length === 1 ? A : this.finishNode(p, "UnionTypeAnnotation");
          }
          flowParseType() {
            const p = this.state.inType;
            this.state.inType = !0;
            const A = this.flowParseUnionType();
            return this.state.inType = p, A;
          }
          flowParseTypeOrImplicitInstantiation() {
            if (this.state.type === 130 && this.state.value === "_") {
              const p = this.state.startLoc, A = this.parseIdentifier();
              return this.flowParseGenericType(p, A);
            }
            return this.flowParseType();
          }
          flowParseTypeAnnotation() {
            const p = this.startNode();
            return p.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(p, "TypeAnnotation");
          }
          flowParseTypeAnnotatableIdentifier(p) {
            const A = p ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            return this.match(14) && (A.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(A)), A;
          }
          typeCastToParameter(p) {
            return p.expression.typeAnnotation = p.typeAnnotation, this.resetEndLocation(p.expression, p.typeAnnotation.loc.end), p.expression;
          }
          flowParseVariance() {
            let p = null;
            return this.match(53) ? (p = this.startNode(), this.state.value === "+" ? p.kind = "plus" : p.kind = "minus", this.next(), this.finishNode(p, "Variance")) : p;
          }
          parseFunctionBody(p, A, V = !1) {
            A ? this.forwardNoArrowParamsConversionAt(p, () => super.parseFunctionBody(p, !0, V)) : super.parseFunctionBody(p, !1, V);
          }
          parseFunctionBodyAndFinish(p, A, V = !1) {
            if (this.match(14)) {
              const ee = this.startNode();
              [ee.typeAnnotation, p.predicate] = this.flowParseTypeAndPredicateInitialiser(), p.returnType = ee.typeAnnotation ? this.finishNode(ee, "TypeAnnotation") : null;
            }
            return super.parseFunctionBodyAndFinish(p, A, V);
          }
          parseStatementLike(p) {
            if (this.state.strict && this.isContextual(127)) {
              if (Y(this.lookahead().type)) {
                const V = this.startNode();
                return this.next(), this.flowParseInterface(V);
              }
            } else if (this.shouldParseEnums() && this.isContextual(124)) {
              const V = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(V);
            }
            const A = super.parseStatementLike(p);
            return this.flowPragma !== void 0 || this.isValidDirective(A) || (this.flowPragma = null), A;
          }
          parseExpressionStatement(p, A, V) {
            if (A.type === "Identifier") {
              if (A.name === "declare") {
                if (this.match(80) || $(this.state.type) || this.match(68) || this.match(74) || this.match(82))
                  return this.flowParseDeclare(p);
              } else if ($(this.state.type)) {
                if (A.name === "interface")
                  return this.flowParseInterface(p);
                if (A.name === "type")
                  return this.flowParseTypeAlias(p);
                if (A.name === "opaque")
                  return this.flowParseOpaqueType(p, !1);
              }
            }
            return super.parseExpressionStatement(p, A, V);
          }
          shouldParseExportDeclaration() {
            const { type: p } = this.state;
            return X(p) || this.shouldParseEnums() && p === 124 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
            const { type: p } = this.state;
            return X(p) || this.shouldParseEnums() && p === 124 ? this.state.containsEsc : super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual(124)) {
              const p = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(p);
            }
            return super.parseExportDefaultExpression();
          }
          parseConditional(p, A, V) {
            if (!this.match(17))
              return p;
            if (this.state.maybeInArrowParameters) {
              const mt = this.lookaheadCharCode();
              if (mt === 44 || mt === 61 || mt === 58 || mt === 41)
                return this.setOptionalParametersError(V), p;
            }
            this.expect(17);
            const ee = this.state.clone(), fe = this.state.noArrowAt, Se = this.startNodeAt(A);
            let { consequent: Pe, failed: Re } = this.tryParseConditionalConsequent(), [je, ze] = this.getArrowLikeExpressions(Pe);
            if (Re || ze.length > 0) {
              const mt = [...fe];
              if (ze.length > 0) {
                this.state = ee, this.state.noArrowAt = mt;
                for (let Mt = 0; Mt < ze.length; Mt++)
                  mt.push(ze[Mt].start);
                ({ consequent: Pe, failed: Re } = this.tryParseConditionalConsequent()), [je, ze] = this.getArrowLikeExpressions(Pe);
              }
              Re && je.length > 1 && this.raise(Rt.AmbiguousConditionalArrow, { at: ee.startLoc }), Re && je.length === 1 && (this.state = ee, mt.push(je[0].start), this.state.noArrowAt = mt, { consequent: Pe, failed: Re } = this.tryParseConditionalConsequent());
            }
            return this.getArrowLikeExpressions(Pe, !0), this.state.noArrowAt = fe, this.expect(14), Se.test = p, Se.consequent = Pe, Se.alternate = this.forwardNoArrowParamsConversionAt(Se, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(Se, "ConditionalExpression");
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            const p = this.parseMaybeAssignAllowIn(), A = !this.match(14);
            return this.state.noArrowParamsConversionAt.pop(), { consequent: p, failed: A };
          }
          getArrowLikeExpressions(p, A) {
            const V = [p], ee = [];
            for (; V.length !== 0; ) {
              const fe = V.pop();
              fe.type === "ArrowFunctionExpression" ? (fe.typeParameters || !fe.returnType ? this.finishArrowValidation(fe) : ee.push(fe), V.push(fe.body)) : fe.type === "ConditionalExpression" && (V.push(fe.consequent), V.push(fe.alternate));
            }
            return A ? (ee.forEach((fe) => this.finishArrowValidation(fe)), [ee, []]) : function(fe, Se) {
              const Pe = [], Re = [];
              for (let je = 0; je < fe.length; je++)
                (Se(fe[je], je, fe) ? Pe : Re).push(fe[je]);
              return [Pe, Re];
            }(ee, (fe) => fe.params.every((Se) => this.isAssignable(Se, !0)));
          }
          finishArrowValidation(p) {
            var A;
            this.toAssignableList(p.params, (A = p.extra) == null ? void 0 : A.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(p, !1, !0), this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(p, A) {
            let V;
            return this.state.noArrowParamsConversionAt.indexOf(p.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), V = A(), this.state.noArrowParamsConversionAt.pop()) : V = A(), V;
          }
          parseParenItem(p, A) {
            if (p = super.parseParenItem(p, A), this.eat(17) && (p.optional = !0, this.resetEndLocation(p)), this.match(14)) {
              const V = this.startNodeAt(A);
              return V.expression = p, V.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(V, "TypeCastExpression");
            }
            return p;
          }
          assertModuleNodeAllowed(p) {
            p.type === "ImportDeclaration" && (p.importKind === "type" || p.importKind === "typeof") || p.type === "ExportNamedDeclaration" && p.exportKind === "type" || p.type === "ExportAllDeclaration" && p.exportKind === "type" || super.assertModuleNodeAllowed(p);
          }
          parseExportDeclaration(p) {
            if (this.isContextual(128)) {
              p.exportKind = "type";
              const A = this.startNode();
              return this.next(), this.match(5) ? (p.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(p), null) : this.flowParseTypeAlias(A);
            }
            if (this.isContextual(129)) {
              p.exportKind = "type";
              const A = this.startNode();
              return this.next(), this.flowParseOpaqueType(A, !1);
            }
            if (this.isContextual(127)) {
              p.exportKind = "type";
              const A = this.startNode();
              return this.next(), this.flowParseInterface(A);
            }
            if (this.shouldParseEnums() && this.isContextual(124)) {
              p.exportKind = "value";
              const A = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(A);
            }
            return super.parseExportDeclaration(p);
          }
          eatExportStar(p) {
            return !!super.eatExportStar(p) || !(!this.isContextual(128) || this.lookahead().type !== 55) && (p.exportKind = "type", this.next(), this.next(), !0);
          }
          maybeParseExportNamespaceSpecifier(p) {
            const { startLoc: A } = this.state, V = super.maybeParseExportNamespaceSpecifier(p);
            return V && p.exportKind === "type" && this.unexpected(A), V;
          }
          parseClassId(p, A, V) {
            super.parseClassId(p, A, V), this.match(47) && (p.typeParameters = this.flowParseTypeParameterDeclaration());
          }
          parseClassMember(p, A, V) {
            const { startLoc: ee } = this.state;
            if (this.isContextual(123)) {
              if (super.parseClassMemberFromModifier(p, A))
                return;
              A.declare = !0;
            }
            super.parseClassMember(p, A, V), A.declare && (A.type !== "ClassProperty" && A.type !== "ClassPrivateProperty" && A.type !== "PropertyDefinition" ? this.raise(Rt.DeclareClassElement, { at: ee }) : A.value && this.raise(Rt.DeclareClassFieldInitializer, { at: A.value }));
          }
          isIterator(p) {
            return p === "iterator" || p === "asyncIterator";
          }
          readIterator() {
            const p = super.readWord1(), A = "@@" + p;
            this.isIterator(p) && this.state.inType || this.raise(C.InvalidIdentifier, { at: this.state.curPosition(), identifierName: A }), this.finishToken(130, A);
          }
          getTokenFromCode(p) {
            const A = this.input.charCodeAt(this.state.pos + 1);
            p === 123 && A === 124 ? this.finishOp(6, 2) : !this.state.inType || p !== 62 && p !== 60 ? this.state.inType && p === 63 ? A === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : function(V, ee, fe) {
              return V === 64 && ee === 64 && Ee(fe);
            }(p, A, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(p) : this.finishOp(p === 62 ? 48 : 47, 1);
          }
          isAssignable(p, A) {
            return p.type === "TypeCastExpression" ? this.isAssignable(p.expression, A) : super.isAssignable(p, A);
          }
          toAssignable(p, A = !1) {
            A || p.type !== "AssignmentExpression" || p.left.type !== "TypeCastExpression" || (p.left = this.typeCastToParameter(p.left)), super.toAssignable(p, A);
          }
          toAssignableList(p, A, V) {
            for (let ee = 0; ee < p.length; ee++) {
              const fe = p[ee];
              (fe == null ? void 0 : fe.type) === "TypeCastExpression" && (p[ee] = this.typeCastToParameter(fe));
            }
            super.toAssignableList(p, A, V);
          }
          toReferencedList(p, A) {
            for (let ee = 0; ee < p.length; ee++) {
              var V;
              const fe = p[ee];
              !fe || fe.type !== "TypeCastExpression" || (V = fe.extra) != null && V.parenthesized || !(p.length > 1) && A || this.raise(Rt.TypeCastInPattern, { at: fe.typeAnnotation });
            }
            return p;
          }
          parseArrayLike(p, A, V, ee) {
            const fe = super.parseArrayLike(p, A, V, ee);
            return A && !this.state.maybeInArrowParameters && this.toReferencedList(fe.elements), fe;
          }
          isValidLVal(p, A, V) {
            return p === "TypeCastExpression" || super.isValidLVal(p, A, V);
          }
          parseClassProperty(p) {
            return this.match(14) && (p.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(p);
          }
          parseClassPrivateProperty(p) {
            return this.match(14) && (p.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(p);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(14) || super.isClassProperty();
          }
          isNonstaticConstructor(p) {
            return !this.match(14) && super.isNonstaticConstructor(p);
          }
          pushClassMethod(p, A, V, ee, fe, Se) {
            if (A.variance && this.unexpected(A.variance.loc.start), delete A.variance, this.match(47) && (A.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(p, A, V, ee, fe, Se), A.params && fe) {
              const Pe = A.params;
              Pe.length > 0 && this.isThisParam(Pe[0]) && this.raise(Rt.ThisParamBannedInConstructor, { at: A });
            } else if (A.type === "MethodDefinition" && fe && A.value.params) {
              const Pe = A.value.params;
              Pe.length > 0 && this.isThisParam(Pe[0]) && this.raise(Rt.ThisParamBannedInConstructor, { at: A });
            }
          }
          pushClassPrivateMethod(p, A, V, ee) {
            A.variance && this.unexpected(A.variance.loc.start), delete A.variance, this.match(47) && (A.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(p, A, V, ee);
          }
          parseClassSuper(p) {
            if (super.parseClassSuper(p), p.superClass && this.match(47) && (p.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(111)) {
              this.next();
              const A = p.implements = [];
              do {
                const V = this.startNode();
                V.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? V.typeParameters = this.flowParseTypeParameterInstantiation() : V.typeParameters = null, A.push(this.finishNode(V, "ClassImplements"));
              } while (this.eat(12));
            }
          }
          checkGetterSetterParams(p) {
            super.checkGetterSetterParams(p);
            const A = this.getObjectOrClassMethodParams(p);
            if (A.length > 0) {
              const V = A[0];
              this.isThisParam(V) && p.kind === "get" ? this.raise(Rt.GetterMayNotHaveThisParam, { at: V }) : this.isThisParam(V) && this.raise(Rt.SetterMayNotHaveThisParam, { at: V });
            }
          }
          parsePropertyNamePrefixOperator(p) {
            p.variance = this.flowParseVariance();
          }
          parseObjPropValue(p, A, V, ee, fe, Se, Pe) {
            let Re;
            p.variance && this.unexpected(p.variance.loc.start), delete p.variance, this.match(47) && !Se && (Re = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
            const je = super.parseObjPropValue(p, A, V, ee, fe, Se, Pe);
            return Re && ((je.value || je).typeParameters = Re), je;
          }
          parseAssignableListItemTypes(p) {
            return this.eat(17) && (p.type !== "Identifier" && this.raise(Rt.PatternIsOptional, { at: p }), this.isThisParam(p) && this.raise(Rt.ThisParamMayNotBeOptional, { at: p }), p.optional = !0), this.match(14) ? p.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(p) && this.raise(Rt.ThisParamAnnotationRequired, { at: p }), this.match(29) && this.isThisParam(p) && this.raise(Rt.ThisParamNoDefault, { at: p }), this.resetEndLocation(p), p;
          }
          parseMaybeDefault(p, A) {
            const V = super.parseMaybeDefault(p, A);
            return V.type === "AssignmentPattern" && V.typeAnnotation && V.right.start < V.typeAnnotation.start && this.raise(Rt.TypeBeforeInitializer, { at: V.typeAnnotation }), V;
          }
          checkImportReflection(p) {
            super.checkImportReflection(p), p.module && p.importKind !== "value" && this.raise(Rt.ImportReflectionHasImportType, { at: p.specifiers[0].loc.start });
          }
          parseImportSpecifierLocal(p, A, V) {
            A.local = Pt(p) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), p.specifiers.push(this.finishImportSpecifier(A, V));
          }
          isPotentialImportPhase(p) {
            if (super.isPotentialImportPhase(p))
              return !0;
            if (this.isContextual(128)) {
              if (!p)
                return !0;
              const A = this.lookaheadCharCode();
              return A === 123 || A === 42;
            }
            return !p && this.isContextual(87);
          }
          applyImportPhase(p, A, V, ee) {
            if (super.applyImportPhase(p, A, V, ee), A) {
              if (!V && this.match(65))
                return;
              p.exportKind = V === "type" ? V : "value";
            } else
              V === "type" && this.match(55) && this.unexpected(), p.importKind = V === "type" || V === "typeof" ? V : "value";
          }
          parseImportSpecifier(p, A, V, ee, fe) {
            const Se = p.imported;
            let Pe = null;
            Se.type === "Identifier" && (Se.name === "type" ? Pe = "type" : Se.name === "typeof" && (Pe = "typeof"));
            let Re = !1;
            if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
              const ze = this.parseIdentifier(!0);
              Pe === null || Y(this.state.type) ? (p.imported = Se, p.importKind = null, p.local = this.parseIdentifier()) : (p.imported = ze, p.importKind = Pe, p.local = Vr(ze));
            } else {
              if (Pe !== null && Y(this.state.type))
                p.imported = this.parseIdentifier(!0), p.importKind = Pe;
              else {
                if (A)
                  throw this.raise(C.ImportBindingIsString, { at: p, importName: Se.value });
                p.imported = Se, p.importKind = null;
              }
              this.eatContextual(93) ? p.local = this.parseIdentifier() : (Re = !0, p.local = Vr(p.imported));
            }
            const je = Pt(p);
            return V && je && this.raise(Rt.ImportTypeShorthandOnlyInPureImport, { at: p }), (V || je) && this.checkReservedType(p.local.name, p.local.loc.start, !0), !Re || V || je || this.checkReservedWord(p.local.name, p.loc.start, !0, !0), this.finishImportSpecifier(p, "ImportSpecifier");
          }
          parseBindingAtom() {
            return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
          }
          parseFunctionParams(p, A) {
            const V = p.kind;
            V !== "get" && V !== "set" && this.match(47) && (p.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(p, A);
          }
          parseVarId(p, A) {
            super.parseVarId(p, A), this.match(14) && (p.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(p.id));
          }
          parseAsyncArrowFromCallExpression(p, A) {
            if (this.match(14)) {
              const V = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = !0, p.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = V;
            }
            return super.parseAsyncArrowFromCallExpression(p, A);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(p, A) {
            var V;
            let ee, fe = null;
            if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
              if (fe = this.state.clone(), ee = this.tryParse(() => super.parseMaybeAssign(p, A), fe), !ee.error)
                return ee.node;
              const { context: Re } = this.state, je = Re[Re.length - 1];
              je !== _.j_oTag && je !== _.j_expr || Re.pop();
            }
            if ((V = ee) != null && V.error || this.match(47)) {
              var Se, Pe;
              let Re;
              fe = fe || this.state.clone();
              const je = this.tryParse((mt) => {
                var Mt;
                Re = this.flowParseTypeParameterDeclaration();
                const St = this.forwardNoArrowParamsConversionAt(Re, () => {
                  const Cr = super.parseMaybeAssign(p, A);
                  return this.resetStartLocationFromNode(Cr, Re), Cr;
                });
                (Mt = St.extra) != null && Mt.parenthesized && mt();
                const Ut = this.maybeUnwrapTypeCastExpression(St);
                return Ut.type !== "ArrowFunctionExpression" && mt(), Ut.typeParameters = Re, this.resetStartLocationFromNode(Ut, Re), St;
              }, fe);
              let ze = null;
              if (je.node && this.maybeUnwrapTypeCastExpression(je.node).type === "ArrowFunctionExpression") {
                if (!je.error && !je.aborted)
                  return je.node.async && this.raise(Rt.UnexpectedTypeParameterBeforeAsyncArrowFunction, { at: Re }), je.node;
                ze = je.node;
              }
              if ((Se = ee) != null && Se.node)
                return this.state = ee.failState, ee.node;
              if (ze)
                return this.state = je.failState, ze;
              throw (Pe = ee) != null && Pe.thrown ? ee.error : je.thrown ? je.error : this.raise(Rt.UnexpectedTokenAfterTypeParameter, { at: Re });
            }
            return super.parseMaybeAssign(p, A);
          }
          parseArrow(p) {
            if (this.match(14)) {
              const A = this.tryParse(() => {
                const V = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = !0;
                const ee = this.startNode();
                return [ee.typeAnnotation, p.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = V, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), ee;
              });
              if (A.thrown)
                return null;
              A.error && (this.state = A.failState), p.returnType = A.node.typeAnnotation ? this.finishNode(A.node, "TypeAnnotation") : null;
            }
            return super.parseArrow(p);
          }
          shouldParseArrow(p) {
            return this.match(14) || super.shouldParseArrow(p);
          }
          setArrowFunctionParameters(p, A) {
            this.state.noArrowParamsConversionAt.indexOf(p.start) !== -1 ? p.params = A : super.setArrowFunctionParameters(p, A);
          }
          checkParams(p, A, V, ee = !0) {
            if (!V || this.state.noArrowParamsConversionAt.indexOf(p.start) === -1) {
              for (let fe = 0; fe < p.params.length; fe++)
                this.isThisParam(p.params[fe]) && fe > 0 && this.raise(Rt.ThisParamMustBeFirst, { at: p.params[fe] });
              super.checkParams(p, A, V, ee);
            }
          }
          parseParenAndDistinguishExpression(p) {
            return super.parseParenAndDistinguishExpression(p && this.state.noArrowAt.indexOf(this.state.start) === -1);
          }
          parseSubscripts(p, A, V) {
            if (p.type === "Identifier" && p.name === "async" && this.state.noArrowAt.indexOf(A.index) !== -1) {
              this.next();
              const ee = this.startNodeAt(A);
              ee.callee = p, ee.arguments = super.parseCallExpressionArguments(11, !1), p = this.finishNode(ee, "CallExpression");
            } else if (p.type === "Identifier" && p.name === "async" && this.match(47)) {
              const ee = this.state.clone(), fe = this.tryParse((Pe) => this.parseAsyncArrowWithTypeParameters(A) || Pe(), ee);
              if (!fe.error && !fe.aborted)
                return fe.node;
              const Se = this.tryParse(() => super.parseSubscripts(p, A, V), ee);
              if (Se.node && !Se.error)
                return Se.node;
              if (fe.node)
                return this.state = fe.failState, fe.node;
              if (Se.node)
                return this.state = Se.failState, Se.node;
              throw fe.error || Se.error;
            }
            return super.parseSubscripts(p, A, V);
          }
          parseSubscript(p, A, V, ee) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
              if (ee.optionalChainMember = !0, V)
                return ee.stop = !0, p;
              this.next();
              const fe = this.startNodeAt(A);
              return fe.callee = p, fe.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), fe.arguments = this.parseCallExpressionArguments(11, !1), fe.optional = !0, this.finishCallExpression(fe, !0);
            }
            if (!V && this.shouldParseTypes() && this.match(47)) {
              const fe = this.startNodeAt(A);
              fe.callee = p;
              const Se = this.tryParse(() => (fe.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), fe.arguments = super.parseCallExpressionArguments(11, !1), ee.optionalChainMember && (fe.optional = !1), this.finishCallExpression(fe, ee.optionalChainMember)));
              if (Se.node)
                return Se.error && (this.state = Se.failState), Se.node;
            }
            return super.parseSubscript(p, A, V, ee);
          }
          parseNewCallee(p) {
            super.parseNewCallee(p);
            let A = null;
            this.shouldParseTypes() && this.match(47) && (A = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), p.typeArguments = A;
          }
          parseAsyncArrowWithTypeParameters(p) {
            const A = this.startNodeAt(p);
            if (this.parseFunctionParams(A, !1), this.parseArrow(A))
              return super.parseArrowExpression(A, void 0, !0);
          }
          readToken_mult_modulo(p) {
            const A = this.input.charCodeAt(this.state.pos + 1);
            if (p === 42 && A === 47 && this.state.hasFlowComment)
              return this.state.hasFlowComment = !1, this.state.pos += 2, void this.nextToken();
            super.readToken_mult_modulo(p);
          }
          readToken_pipe_amp(p) {
            const A = this.input.charCodeAt(this.state.pos + 1);
            p !== 124 || A !== 125 ? super.readToken_pipe_amp(p) : this.finishOp(9, 2);
          }
          parseTopLevel(p, A) {
            const V = super.parseTopLevel(p, A);
            return this.state.hasFlowComment && this.raise(Rt.UnterminatedFlowComment, { at: this.state.curPosition() }), V;
          }
          skipBlockComment() {
            if (!this.hasPlugin("flowComments") || !this.skipFlowComment())
              return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
            {
              if (this.state.hasFlowComment)
                throw this.raise(Rt.NestedFlowComment, { at: this.state.startLoc });
              this.hasFlowCommentCompletion();
              const p = this.skipFlowComment();
              p && (this.state.pos += p, this.state.hasFlowComment = !0);
            }
          }
          skipFlowComment() {
            const { pos: p } = this.state;
            let A = 2;
            for (; [32, 9].includes(this.input.charCodeAt(p + A)); )
              A++;
            const V = this.input.charCodeAt(A + p), ee = this.input.charCodeAt(A + p + 1);
            return V === 58 && ee === 58 ? A + 2 : this.input.slice(A + p, A + p + 12) === "flow-include" ? A + 12 : V === 58 && ee !== 58 && A;
          }
          hasFlowCommentCompletion() {
            if (this.input.indexOf("*/", this.state.pos) === -1)
              throw this.raise(C.UnterminatedComment, { at: this.state.curPosition() });
          }
          flowEnumErrorBooleanMemberNotInitialized(p, { enumName: A, memberName: V }) {
            this.raise(Rt.EnumBooleanMemberNotInitialized, { at: p, memberName: V, enumName: A });
          }
          flowEnumErrorInvalidMemberInitializer(p, A) {
            return this.raise(A.explicitType ? A.explicitType === "symbol" ? Rt.EnumInvalidMemberInitializerSymbolType : Rt.EnumInvalidMemberInitializerPrimaryType : Rt.EnumInvalidMemberInitializerUnknownType, Object.assign({ at: p }, A));
          }
          flowEnumErrorNumberMemberNotInitialized(p, { enumName: A, memberName: V }) {
            this.raise(Rt.EnumNumberMemberNotInitialized, { at: p, enumName: A, memberName: V });
          }
          flowEnumErrorStringMemberInconsistentlyInitialized(p, { enumName: A }) {
            this.raise(Rt.EnumStringMemberInconsistentlyInitialized, { at: p, enumName: A });
          }
          flowEnumMemberInit() {
            const p = this.state.startLoc, A = () => this.match(12) || this.match(8);
            switch (this.state.type) {
              case 132: {
                const V = this.parseNumericLiteral(this.state.value);
                return A() ? { type: "number", loc: V.loc.start, value: V } : { type: "invalid", loc: p };
              }
              case 131: {
                const V = this.parseStringLiteral(this.state.value);
                return A() ? { type: "string", loc: V.loc.start, value: V } : { type: "invalid", loc: p };
              }
              case 85:
              case 86: {
                const V = this.parseBooleanLiteral(this.match(85));
                return A() ? { type: "boolean", loc: V.loc.start, value: V } : { type: "invalid", loc: p };
              }
              default:
                return { type: "invalid", loc: p };
            }
          }
          flowEnumMemberRaw() {
            const p = this.state.startLoc;
            return { id: this.parseIdentifier(!0), init: this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: p } };
          }
          flowEnumCheckExplicitTypeMismatch(p, A, V) {
            const { explicitType: ee } = A;
            ee !== null && ee !== V && this.flowEnumErrorInvalidMemberInitializer(p, A);
          }
          flowEnumMembers({ enumName: p, explicitType: A }) {
            const V = /* @__PURE__ */ new Set(), ee = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] };
            let fe = !1;
            for (; !this.match(8); ) {
              if (this.eat(21)) {
                fe = !0;
                break;
              }
              const Se = this.startNode(), { id: Pe, init: Re } = this.flowEnumMemberRaw(), je = Pe.name;
              if (je === "")
                continue;
              /^[a-z]/.test(je) && this.raise(Rt.EnumInvalidMemberName, { at: Pe, memberName: je, suggestion: je[0].toUpperCase() + je.slice(1), enumName: p }), V.has(je) && this.raise(Rt.EnumDuplicateMemberName, { at: Pe, memberName: je, enumName: p }), V.add(je);
              const ze = { enumName: p, explicitType: A, memberName: je };
              switch (Se.id = Pe, Re.type) {
                case "boolean":
                  this.flowEnumCheckExplicitTypeMismatch(Re.loc, ze, "boolean"), Se.init = Re.value, ee.booleanMembers.push(this.finishNode(Se, "EnumBooleanMember"));
                  break;
                case "number":
                  this.flowEnumCheckExplicitTypeMismatch(Re.loc, ze, "number"), Se.init = Re.value, ee.numberMembers.push(this.finishNode(Se, "EnumNumberMember"));
                  break;
                case "string":
                  this.flowEnumCheckExplicitTypeMismatch(Re.loc, ze, "string"), Se.init = Re.value, ee.stringMembers.push(this.finishNode(Se, "EnumStringMember"));
                  break;
                case "invalid":
                  throw this.flowEnumErrorInvalidMemberInitializer(Re.loc, ze);
                case "none":
                  switch (A) {
                    case "boolean":
                      this.flowEnumErrorBooleanMemberNotInitialized(Re.loc, ze);
                      break;
                    case "number":
                      this.flowEnumErrorNumberMemberNotInitialized(Re.loc, ze);
                      break;
                    default:
                      ee.defaultedMembers.push(this.finishNode(Se, "EnumDefaultedMember"));
                  }
              }
              this.match(8) || this.expect(12);
            }
            return { members: ee, hasUnknownMembers: fe };
          }
          flowEnumStringMembers(p, A, { enumName: V }) {
            if (p.length === 0)
              return A;
            if (A.length === 0)
              return p;
            if (A.length > p.length) {
              for (const ee of p)
                this.flowEnumErrorStringMemberInconsistentlyInitialized(ee, { enumName: V });
              return A;
            }
            for (const ee of A)
              this.flowEnumErrorStringMemberInconsistentlyInitialized(ee, { enumName: V });
            return p;
          }
          flowEnumParseExplicitType({ enumName: p }) {
            if (!this.eatContextual(101))
              return null;
            if (!$(this.state.type))
              throw this.raise(Rt.EnumInvalidExplicitTypeUnknownSupplied, { at: this.state.startLoc, enumName: p });
            const { value: A } = this.state;
            return this.next(), A !== "boolean" && A !== "number" && A !== "string" && A !== "symbol" && this.raise(Rt.EnumInvalidExplicitType, { at: this.state.startLoc, enumName: p, invalidEnumType: A }), A;
          }
          flowEnumBody(p, A) {
            const V = A.name, ee = A.loc.start, fe = this.flowEnumParseExplicitType({ enumName: V });
            this.expect(5);
            const { members: Se, hasUnknownMembers: Pe } = this.flowEnumMembers({ enumName: V, explicitType: fe });
            switch (p.hasUnknownMembers = Pe, fe) {
              case "boolean":
                return p.explicitType = !0, p.members = Se.booleanMembers, this.expect(8), this.finishNode(p, "EnumBooleanBody");
              case "number":
                return p.explicitType = !0, p.members = Se.numberMembers, this.expect(8), this.finishNode(p, "EnumNumberBody");
              case "string":
                return p.explicitType = !0, p.members = this.flowEnumStringMembers(Se.stringMembers, Se.defaultedMembers, { enumName: V }), this.expect(8), this.finishNode(p, "EnumStringBody");
              case "symbol":
                return p.members = Se.defaultedMembers, this.expect(8), this.finishNode(p, "EnumSymbolBody");
              default: {
                const Re = () => (p.members = [], this.expect(8), this.finishNode(p, "EnumStringBody"));
                p.explicitType = !1;
                const je = Se.booleanMembers.length, ze = Se.numberMembers.length, mt = Se.stringMembers.length, Mt = Se.defaultedMembers.length;
                if (je || ze || mt || Mt) {
                  if (je || ze) {
                    if (!ze && !mt && je >= Mt) {
                      for (const St of Se.defaultedMembers)
                        this.flowEnumErrorBooleanMemberNotInitialized(St.loc.start, { enumName: V, memberName: St.id.name });
                      return p.members = Se.booleanMembers, this.expect(8), this.finishNode(p, "EnumBooleanBody");
                    }
                    if (!je && !mt && ze >= Mt) {
                      for (const St of Se.defaultedMembers)
                        this.flowEnumErrorNumberMemberNotInitialized(St.loc.start, { enumName: V, memberName: St.id.name });
                      return p.members = Se.numberMembers, this.expect(8), this.finishNode(p, "EnumNumberBody");
                    }
                    return this.raise(Rt.EnumInconsistentMemberValues, { at: ee, enumName: V }), Re();
                  }
                  return p.members = this.flowEnumStringMembers(Se.stringMembers, Se.defaultedMembers, { enumName: V }), this.expect(8), this.finishNode(p, "EnumStringBody");
                }
                return Re();
              }
            }
          }
          flowParseEnumDeclaration(p) {
            const A = this.parseIdentifier();
            return p.id = A, p.body = this.flowEnumBody(this.startNode(), A), this.finishNode(p, "EnumDeclaration");
          }
          isLookaheadToken_lt() {
            const p = this.nextTokenStart();
            if (this.input.charCodeAt(p) === 60) {
              const A = this.input.charCodeAt(p + 1);
              return A !== 60 && A !== 61;
            }
            return !1;
          }
          maybeUnwrapTypeCastExpression(p) {
            return p.type === "TypeCastExpression" ? p.expression : p;
          }
        }, typescript: (Te) => class extends Te {
          constructor(...p) {
            super(...p), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: xt.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: xt.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: xt.InvalidModifierOnTypeParameter });
          }
          getScopeHandler() {
            return lc;
          }
          tsIsIdentifier() {
            return $(this.state.type);
          }
          tsTokenCanFollowModifier() {
            return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(136) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
          }
          tsNextTokenCanFollowModifier() {
            return this.next(), this.tsTokenCanFollowModifier();
          }
          tsParseModifier(p, A) {
            if (!$(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
              return;
            const V = this.state.value;
            if (p.indexOf(V) !== -1) {
              if (A && this.tsIsStartOfStaticBlocks())
                return;
              if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
                return V;
            }
          }
          tsParseModifiers({ allowedModifiers: p, disallowedModifiers: A, stopOnStartOfClassStaticBlock: V, errorTemplate: ee = xt.InvalidModifierOnTypeMember }, fe) {
            const Se = (Re, je, ze, mt) => {
              je === ze && fe[mt] && this.raise(xt.InvalidModifiersOrder, { at: Re, orderedModifiers: [ze, mt] });
            }, Pe = (Re, je, ze, mt) => {
              (fe[ze] && je === mt || fe[mt] && je === ze) && this.raise(xt.IncompatibleModifiers, { at: Re, modifiers: [ze, mt] });
            };
            for (; ; ) {
              const { startLoc: Re } = this.state, je = this.tsParseModifier(p.concat(A ?? []), V);
              if (!je)
                break;
              bl(je) ? fe.accessibility ? this.raise(xt.DuplicateAccessibilityModifier, { at: Re, modifier: je }) : (Se(Re, je, je, "override"), Se(Re, je, je, "static"), Se(Re, je, je, "readonly"), fe.accessibility = je) : uc(je) ? (fe[je] && this.raise(xt.DuplicateModifier, { at: Re, modifier: je }), fe[je] = !0, Se(Re, je, "in", "out")) : (Object.hasOwnProperty.call(fe, je) ? this.raise(xt.DuplicateModifier, { at: Re, modifier: je }) : (Se(Re, je, "static", "readonly"), Se(Re, je, "static", "override"), Se(Re, je, "override", "readonly"), Se(Re, je, "abstract", "override"), Pe(Re, je, "declare", "override"), Pe(Re, je, "static", "abstract")), fe[je] = !0), A != null && A.includes(je) && this.raise(ee, { at: Re, modifier: je });
            }
          }
          tsIsListTerminator(p) {
            switch (p) {
              case "EnumMembers":
              case "TypeMembers":
                return this.match(8);
              case "HeritageClauseElement":
                return this.match(5);
              case "TupleElementTypes":
                return this.match(3);
              case "TypeParametersOrArguments":
                return this.match(48);
            }
          }
          tsParseList(p, A) {
            const V = [];
            for (; !this.tsIsListTerminator(p); )
              V.push(A());
            return V;
          }
          tsParseDelimitedList(p, A, V) {
            return function(ee) {
              if (ee == null)
                throw new Error(`Unexpected ${ee} value.`);
              return ee;
            }(this.tsParseDelimitedListWorker(p, A, !0, V));
          }
          tsParseDelimitedListWorker(p, A, V, ee) {
            const fe = [];
            let Se = -1;
            for (; !this.tsIsListTerminator(p); ) {
              Se = -1;
              const Pe = A();
              if (Pe == null)
                return;
              if (fe.push(Pe), !this.eat(12)) {
                if (this.tsIsListTerminator(p))
                  break;
                return void (V && this.expect(12));
              }
              Se = this.state.lastTokStart;
            }
            return ee && (ee.value = Se), fe;
          }
          tsParseBracketedList(p, A, V, ee, fe) {
            ee || (V ? this.expect(0) : this.expect(47));
            const Se = this.tsParseDelimitedList(p, A, fe);
            return V ? this.expect(3) : this.expect(48), Se;
          }
          tsParseImportType() {
            const p = this.startNode();
            return this.expect(83), this.expect(10), this.match(131) || this.raise(xt.UnsupportedImportTypeArgument, { at: this.state.startLoc }), p.argument = super.parseExprAtom(), this.expect(11), this.eat(16) && (p.qualifier = this.tsParseEntityName()), this.match(47) && (p.typeParameters = this.tsParseTypeArguments()), this.finishNode(p, "TSImportType");
          }
          tsParseEntityName(p = !0) {
            let A = this.parseIdentifier(p);
            for (; this.eat(16); ) {
              const V = this.startNodeAtNode(A);
              V.left = A, V.right = this.parseIdentifier(p), A = this.finishNode(V, "TSQualifiedName");
            }
            return A;
          }
          tsParseTypeReference() {
            const p = this.startNode();
            return p.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (p.typeParameters = this.tsParseTypeArguments()), this.finishNode(p, "TSTypeReference");
          }
          tsParseThisTypePredicate(p) {
            this.next();
            const A = this.startNodeAtNode(p);
            return A.parameterName = p, A.typeAnnotation = this.tsParseTypeAnnotation(!1), A.asserts = !1, this.finishNode(A, "TSTypePredicate");
          }
          tsParseThisTypeNode() {
            const p = this.startNode();
            return this.next(), this.finishNode(p, "TSThisType");
          }
          tsParseTypeQuery() {
            const p = this.startNode();
            return this.expect(87), this.match(83) ? p.exprName = this.tsParseImportType() : p.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (p.typeParameters = this.tsParseTypeArguments()), this.finishNode(p, "TSTypeQuery");
          }
          tsParseTypeParameter(p) {
            const A = this.startNode();
            return p(A), A.name = this.tsParseTypeParameterName(), A.constraint = this.tsEatThenParseType(81), A.default = this.tsEatThenParseType(29), this.finishNode(A, "TSTypeParameter");
          }
          tsTryParseTypeParameters(p) {
            if (this.match(47))
              return this.tsParseTypeParameters(p);
          }
          tsParseTypeParameters(p) {
            const A = this.startNode();
            this.match(47) || this.match(140) ? this.next() : this.unexpected();
            const V = { value: -1 };
            return A.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, p), !1, !0, V), A.params.length === 0 && this.raise(xt.EmptyTypeParameters, { at: A }), V.value !== -1 && this.addExtra(A, "trailingComma", V.value), this.finishNode(A, "TSTypeParameterDeclaration");
          }
          tsFillSignature(p, A) {
            const V = p === 19;
            A.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), A.parameters = this.tsParseBindingListForSignature(), (V || this.match(p)) && (A.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(p));
          }
          tsParseBindingListForSignature() {
            const p = super.parseBindingList(11, 41, 2);
            for (const A of p) {
              const { type: V } = A;
              V !== "AssignmentPattern" && V !== "TSParameterProperty" || this.raise(xt.UnsupportedSignatureParameterKind, { at: A, type: V });
            }
            return p;
          }
          tsParseTypeMemberSemicolon() {
            this.eat(12) || this.isLineTerminator() || this.expect(13);
          }
          tsParseSignatureMember(p, A) {
            return this.tsFillSignature(14, A), this.tsParseTypeMemberSemicolon(), this.finishNode(A, p);
          }
          tsIsUnambiguouslyIndexSignature() {
            return this.next(), !!$(this.state.type) && (this.next(), this.match(14));
          }
          tsTryParseIndexSignature(p) {
            if (!this.match(0) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))
              return;
            this.expect(0);
            const A = this.parseIdentifier();
            A.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(A), this.expect(3), p.parameters = [A];
            const V = this.tsTryParseTypeAnnotation();
            return V && (p.typeAnnotation = V), this.tsParseTypeMemberSemicolon(), this.finishNode(p, "TSIndexSignature");
          }
          tsParsePropertyOrMethodSignature(p, A) {
            this.eat(17) && (p.optional = !0);
            const V = p;
            if (this.match(10) || this.match(47)) {
              A && this.raise(xt.ReadonlyForMethodSignature, { at: p });
              const ee = V;
              ee.kind && this.match(47) && this.raise(xt.AccesorCannotHaveTypeParameters, { at: this.state.curPosition() }), this.tsFillSignature(14, ee), this.tsParseTypeMemberSemicolon();
              const fe = "parameters", Se = "typeAnnotation";
              if (ee.kind === "get")
                ee[fe].length > 0 && (this.raise(C.BadGetterArity, { at: this.state.curPosition() }), this.isThisParam(ee[fe][0]) && this.raise(xt.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }));
              else if (ee.kind === "set") {
                if (ee[fe].length !== 1)
                  this.raise(C.BadSetterArity, { at: this.state.curPosition() });
                else {
                  const Pe = ee[fe][0];
                  this.isThisParam(Pe) && this.raise(xt.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }), Pe.type === "Identifier" && Pe.optional && this.raise(xt.SetAccesorCannotHaveOptionalParameter, { at: this.state.curPosition() }), Pe.type === "RestElement" && this.raise(xt.SetAccesorCannotHaveRestParameter, { at: this.state.curPosition() });
                }
                ee[Se] && this.raise(xt.SetAccesorCannotHaveReturnType, { at: ee[Se] });
              } else
                ee.kind = "method";
              return this.finishNode(ee, "TSMethodSignature");
            }
            {
              const ee = V;
              A && (ee.readonly = !0);
              const fe = this.tsTryParseTypeAnnotation();
              return fe && (ee.typeAnnotation = fe), this.tsParseTypeMemberSemicolon(), this.finishNode(ee, "TSPropertySignature");
            }
          }
          tsParseTypeMember() {
            const p = this.startNode();
            if (this.match(10) || this.match(47))
              return this.tsParseSignatureMember("TSCallSignatureDeclaration", p);
            if (this.match(77)) {
              const V = this.startNode();
              return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", p) : (p.key = this.createIdentifier(V, "new"), this.tsParsePropertyOrMethodSignature(p, !1));
            }
            return this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, p), this.tsTryParseIndexSignature(p) || (super.parsePropertyName(p), p.computed || p.key.type !== "Identifier" || p.key.name !== "get" && p.key.name !== "set" || !this.tsTokenCanFollowModifier() || (p.kind = p.key.name, super.parsePropertyName(p)), this.tsParsePropertyOrMethodSignature(p, !!p.readonly));
          }
          tsParseTypeLiteral() {
            const p = this.startNode();
            return p.members = this.tsParseObjectTypeMembers(), this.finishNode(p, "TSTypeLiteral");
          }
          tsParseObjectTypeMembers() {
            this.expect(5);
            const p = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
            return this.expect(8), p;
          }
          tsIsStartOfMappedType() {
            return this.next(), this.eat(53) ? this.isContextual(120) : (this.isContextual(120) && this.next(), !!this.match(0) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(58))));
          }
          tsParseMappedTypeParameter() {
            const p = this.startNode();
            return p.name = this.tsParseTypeParameterName(), p.constraint = this.tsExpectThenParseType(58), this.finishNode(p, "TSTypeParameter");
          }
          tsParseMappedType() {
            const p = this.startNode();
            return this.expect(5), this.match(53) ? (p.readonly = this.state.value, this.next(), this.expectContextual(120)) : this.eatContextual(120) && (p.readonly = !0), this.expect(0), p.typeParameter = this.tsParseMappedTypeParameter(), p.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (p.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (p.optional = !0), p.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(p, "TSMappedType");
          }
          tsParseTupleType() {
            const p = this.startNode();
            p.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
            let A = !1, V = null;
            return p.elementTypes.forEach((ee) => {
              const { type: fe } = ee;
              !A || fe === "TSRestType" || fe === "TSOptionalType" || fe === "TSNamedTupleMember" && ee.optional || this.raise(xt.OptionalTypeBeforeRequired, { at: ee }), A || (A = fe === "TSNamedTupleMember" && ee.optional || fe === "TSOptionalType");
              let Se = fe;
              fe === "TSRestType" && (Se = (ee = ee.typeAnnotation).type);
              const Pe = Se === "TSNamedTupleMember";
              V != null || (V = Pe), V !== Pe && this.raise(xt.MixedLabeledAndUnlabeledElements, { at: ee });
            }), this.finishNode(p, "TSTupleType");
          }
          tsParseTupleElementType() {
            const { startLoc: p } = this.state, A = this.eat(21);
            let V, ee, fe, Se;
            const Pe = Y(this.state.type) ? this.lookaheadCharCode() : null;
            if (Pe === 58)
              V = !0, fe = !1, ee = this.parseIdentifier(!0), this.expect(14), Se = this.tsParseType();
            else if (Pe === 63) {
              fe = !0;
              const Re = this.state.startLoc, je = this.state.value, ze = this.tsParseNonArrayType();
              this.lookaheadCharCode() === 58 ? (V = !0, ee = this.createIdentifier(this.startNodeAt(Re), je), this.expect(17), this.expect(14), Se = this.tsParseType()) : (V = !1, Se = ze, this.expect(17));
            } else
              Se = this.tsParseType(), fe = this.eat(17), V = this.eat(14);
            if (V) {
              let Re;
              ee ? (Re = this.startNodeAtNode(ee), Re.optional = fe, Re.label = ee, Re.elementType = Se, this.eat(17) && (Re.optional = !0, this.raise(xt.TupleOptionalAfterType, { at: this.state.lastTokStartLoc }))) : (Re = this.startNodeAtNode(Se), Re.optional = fe, this.raise(xt.InvalidTupleMemberLabel, { at: Se }), Re.label = Se, Re.elementType = this.tsParseType()), Se = this.finishNode(Re, "TSNamedTupleMember");
            } else if (fe) {
              const Re = this.startNodeAtNode(Se);
              Re.typeAnnotation = Se, Se = this.finishNode(Re, "TSOptionalType");
            }
            if (A) {
              const Re = this.startNodeAt(p);
              Re.typeAnnotation = Se, Se = this.finishNode(Re, "TSRestType");
            }
            return Se;
          }
          tsParseParenthesizedType() {
            const p = this.startNode();
            return this.expect(10), p.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(p, "TSParenthesizedType");
          }
          tsParseFunctionOrConstructorType(p, A) {
            const V = this.startNode();
            return p === "TSConstructorType" && (V.abstract = !!A, A && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, V)), this.finishNode(V, p);
          }
          tsParseLiteralTypeNode() {
            const p = this.startNode();
            switch (this.state.type) {
              case 132:
              case 133:
              case 131:
              case 85:
              case 86:
                p.literal = super.parseExprAtom();
                break;
              default:
                this.unexpected();
            }
            return this.finishNode(p, "TSLiteralType");
          }
          tsParseTemplateLiteralType() {
            const p = this.startNode();
            return p.literal = super.parseTemplate(!1), this.finishNode(p, "TSLiteralType");
          }
          parseTemplateSubstitution() {
            return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
          }
          tsParseThisTypeOrThisTypePredicate() {
            const p = this.tsParseThisTypeNode();
            return this.isContextual(114) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(p) : p;
          }
          tsParseNonArrayType() {
            switch (this.state.type) {
              case 131:
              case 132:
              case 133:
              case 85:
              case 86:
                return this.tsParseLiteralTypeNode();
              case 53:
                if (this.state.value === "-") {
                  const p = this.startNode(), A = this.lookahead();
                  return A.type !== 132 && A.type !== 133 && this.unexpected(), p.literal = this.parseMaybeUnary(), this.finishNode(p, "TSLiteralType");
                }
                break;
              case 78:
                return this.tsParseThisTypeOrThisTypePredicate();
              case 87:
                return this.tsParseTypeQuery();
              case 83:
                return this.tsParseImportType();
              case 5:
                return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
              case 0:
                return this.tsParseTupleType();
              case 10:
                return this.tsParseParenthesizedType();
              case 25:
              case 24:
                return this.tsParseTemplateLiteralType();
              default: {
                const { type: p } = this.state;
                if ($(p) || p === 88 || p === 84) {
                  const A = p === 88 ? "TSVoidKeyword" : p === 84 ? "TSNullKeyword" : function(V) {
                    switch (V) {
                      case "any":
                        return "TSAnyKeyword";
                      case "boolean":
                        return "TSBooleanKeyword";
                      case "bigint":
                        return "TSBigIntKeyword";
                      case "never":
                        return "TSNeverKeyword";
                      case "number":
                        return "TSNumberKeyword";
                      case "object":
                        return "TSObjectKeyword";
                      case "string":
                        return "TSStringKeyword";
                      case "symbol":
                        return "TSSymbolKeyword";
                      case "undefined":
                        return "TSUndefinedKeyword";
                      case "unknown":
                        return "TSUnknownKeyword";
                      default:
                        return;
                    }
                  }(this.state.value);
                  if (A !== void 0 && this.lookaheadCharCode() !== 46) {
                    const V = this.startNode();
                    return this.next(), this.finishNode(V, A);
                  }
                  return this.tsParseTypeReference();
                }
              }
            }
            this.unexpected();
          }
          tsParseArrayTypeOrHigher() {
            let p = this.tsParseNonArrayType();
            for (; !this.hasPrecedingLineBreak() && this.eat(0); )
              if (this.match(3)) {
                const A = this.startNodeAtNode(p);
                A.elementType = p, this.expect(3), p = this.finishNode(A, "TSArrayType");
              } else {
                const A = this.startNodeAtNode(p);
                A.objectType = p, A.indexType = this.tsParseType(), this.expect(3), p = this.finishNode(A, "TSIndexedAccessType");
              }
            return p;
          }
          tsParseTypeOperator() {
            const p = this.startNode(), A = this.state.value;
            return this.next(), p.operator = A, p.typeAnnotation = this.tsParseTypeOperatorOrHigher(), A === "readonly" && this.tsCheckTypeAnnotationForReadOnly(p), this.finishNode(p, "TSTypeOperator");
          }
          tsCheckTypeAnnotationForReadOnly(p) {
            switch (p.typeAnnotation.type) {
              case "TSTupleType":
              case "TSArrayType":
                return;
              default:
                this.raise(xt.UnexpectedReadonly, { at: p });
            }
          }
          tsParseInferType() {
            const p = this.startNode();
            this.expectContextual(113);
            const A = this.startNode();
            return A.name = this.tsParseTypeParameterName(), A.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), p.typeParameter = this.finishNode(A, "TSTypeParameter"), this.finishNode(p, "TSInferType");
          }
          tsParseConstraintForInferType() {
            if (this.eat(81)) {
              const p = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
              if (this.state.inDisallowConditionalTypesContext || !this.match(17))
                return p;
            }
          }
          tsParseTypeOperatorOrHigher() {
            var p;
            return (p = this.state.type) >= 119 && p <= 121 && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(113) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
          }
          tsParseUnionOrIntersectionType(p, A, V) {
            const ee = this.startNode(), fe = this.eat(V), Se = [];
            do
              Se.push(A());
            while (this.eat(V));
            return Se.length !== 1 || fe ? (ee.types = Se, this.finishNode(ee, p)) : Se[0];
          }
          tsParseIntersectionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
          }
          tsParseUnionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
          }
          tsIsStartOfFunctionType() {
            return !!this.match(47) || this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
          }
          tsSkipParameterStart() {
            if ($(this.state.type) || this.match(78))
              return this.next(), !0;
            if (this.match(5)) {
              const { errors: p } = this.state, A = p.length;
              try {
                return this.parseObjectLike(8, !0), p.length === A;
              } catch {
                return !1;
              }
            }
            if (this.match(0)) {
              this.next();
              const { errors: p } = this.state, A = p.length;
              try {
                return super.parseBindingList(3, 93, 1), p.length === A;
              } catch {
                return !1;
              }
            }
            return !1;
          }
          tsIsUnambiguouslyStartOfFunctionType() {
            return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
          }
          tsParseTypeOrTypePredicateAnnotation(p) {
            return this.tsInType(() => {
              const A = this.startNode();
              this.expect(p);
              const V = this.startNode(), ee = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
              if (ee && this.match(78)) {
                let Pe = this.tsParseThisTypeOrThisTypePredicate();
                return Pe.type === "TSThisType" ? (V.parameterName = Pe, V.asserts = !0, V.typeAnnotation = null, Pe = this.finishNode(V, "TSTypePredicate")) : (this.resetStartLocationFromNode(Pe, V), Pe.asserts = !0), A.typeAnnotation = Pe, this.finishNode(A, "TSTypeAnnotation");
              }
              const fe = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
              if (!fe)
                return ee ? (V.parameterName = this.parseIdentifier(), V.asserts = ee, V.typeAnnotation = null, A.typeAnnotation = this.finishNode(V, "TSTypePredicate"), this.finishNode(A, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, A);
              const Se = this.tsParseTypeAnnotation(!1);
              return V.parameterName = fe, V.typeAnnotation = Se, V.asserts = ee, A.typeAnnotation = this.finishNode(V, "TSTypePredicate"), this.finishNode(A, "TSTypeAnnotation");
            });
          }
          tsTryParseTypeOrTypePredicateAnnotation() {
            if (this.match(14))
              return this.tsParseTypeOrTypePredicateAnnotation(14);
          }
          tsTryParseTypeAnnotation() {
            if (this.match(14))
              return this.tsParseTypeAnnotation();
          }
          tsTryParseType() {
            return this.tsEatThenParseType(14);
          }
          tsParseTypePredicatePrefix() {
            const p = this.parseIdentifier();
            if (this.isContextual(114) && !this.hasPrecedingLineBreak())
              return this.next(), p;
          }
          tsParseTypePredicateAsserts() {
            if (this.state.type !== 107)
              return !1;
            const p = this.state.containsEsc;
            return this.next(), !(!$(this.state.type) && !this.match(78)) && (p && this.raise(C.InvalidEscapedReservedWord, { at: this.state.lastTokStartLoc, reservedWord: "asserts" }), !0);
          }
          tsParseTypeAnnotation(p = !0, A = this.startNode()) {
            return this.tsInType(() => {
              p && this.expect(14), A.typeAnnotation = this.tsParseType();
            }), this.finishNode(A, "TSTypeAnnotation");
          }
          tsParseType() {
            Qt(this.state.inType);
            const p = this.tsParseNonConditionalType();
            if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
              return p;
            const A = this.startNodeAtNode(p);
            return A.checkType = p, A.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), A.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), A.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(A, "TSConditionalType");
          }
          isAbstractConstructorSignature() {
            return this.isContextual(122) && this.lookahead().type === 77;
          }
          tsParseNonConditionalType() {
            return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
          }
          tsParseTypeAssertion() {
            this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(xt.ReservedTypeAssertion, { at: this.state.startLoc });
            const p = this.startNode();
            return p.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), p.expression = this.parseMaybeUnary(), this.finishNode(p, "TSTypeAssertion");
          }
          tsParseHeritageClause(p) {
            const A = this.state.startLoc, V = this.tsParseDelimitedList("HeritageClauseElement", () => {
              const ee = this.startNode();
              return ee.expression = this.tsParseEntityName(), this.match(47) && (ee.typeParameters = this.tsParseTypeArguments()), this.finishNode(ee, "TSExpressionWithTypeArguments");
            });
            return V.length || this.raise(xt.EmptyHeritageClauseType, { at: A, token: p }), V;
          }
          tsParseInterfaceDeclaration(p, A = {}) {
            if (this.hasFollowingLineBreak())
              return null;
            this.expectContextual(127), A.declare && (p.declare = !0), $(this.state.type) ? (p.id = this.parseIdentifier(), this.checkIdentifier(p.id, 130)) : (p.id = null, this.raise(xt.MissingInterfaceName, { at: this.state.startLoc })), p.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (p.extends = this.tsParseHeritageClause("extends"));
            const V = this.startNode();
            return V.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), p.body = this.finishNode(V, "TSInterfaceBody"), this.finishNode(p, "TSInterfaceDeclaration");
          }
          tsParseTypeAliasDeclaration(p) {
            return p.id = this.parseIdentifier(), this.checkIdentifier(p.id, 2), p.typeAnnotation = this.tsInType(() => {
              if (p.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(112) && this.lookahead().type !== 16) {
                const A = this.startNode();
                return this.next(), this.finishNode(A, "TSIntrinsicKeyword");
              }
              return this.tsParseType();
            }), this.semicolon(), this.finishNode(p, "TSTypeAliasDeclaration");
          }
          tsInNoContext(p) {
            const A = this.state.context;
            this.state.context = [A[0]];
            try {
              return p();
            } finally {
              this.state.context = A;
            }
          }
          tsInType(p) {
            const A = this.state.inType;
            this.state.inType = !0;
            try {
              return p();
            } finally {
              this.state.inType = A;
            }
          }
          tsInDisallowConditionalTypesContext(p) {
            const A = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = !0;
            try {
              return p();
            } finally {
              this.state.inDisallowConditionalTypesContext = A;
            }
          }
          tsInAllowConditionalTypesContext(p) {
            const A = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = !1;
            try {
              return p();
            } finally {
              this.state.inDisallowConditionalTypesContext = A;
            }
          }
          tsEatThenParseType(p) {
            if (this.match(p))
              return this.tsNextThenParseType();
          }
          tsExpectThenParseType(p) {
            return this.tsInType(() => (this.expect(p), this.tsParseType()));
          }
          tsNextThenParseType() {
            return this.tsInType(() => (this.next(), this.tsParseType()));
          }
          tsParseEnumMember() {
            const p = this.startNode();
            return p.id = this.match(131) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (p.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(p, "TSEnumMember");
          }
          tsParseEnumDeclaration(p, A = {}) {
            return A.const && (p.const = !0), A.declare && (p.declare = !0), this.expectContextual(124), p.id = this.parseIdentifier(), this.checkIdentifier(p.id, p.const ? 8971 : 8459), this.expect(5), p.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(p, "TSEnumDeclaration");
          }
          tsParseModuleBlock() {
            const p = this.startNode();
            return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(p.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(p, "TSModuleBlock");
          }
          tsParseModuleOrNamespaceDeclaration(p, A = !1) {
            if (p.id = this.parseIdentifier(), A || this.checkIdentifier(p.id, 1024), this.eat(16)) {
              const V = this.startNode();
              this.tsParseModuleOrNamespaceDeclaration(V, !0), p.body = V;
            } else
              this.scope.enter(256), this.prodParam.enter(0), p.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
            return this.finishNode(p, "TSModuleDeclaration");
          }
          tsParseAmbientExternalModuleDeclaration(p) {
            return this.isContextual(110) ? (p.global = !0, p.id = this.parseIdentifier()) : this.match(131) ? p.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), p.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(p, "TSModuleDeclaration");
          }
          tsParseImportEqualsDeclaration(p, A, V) {
            p.isExport = V || !1, p.id = A || this.parseIdentifier(), this.checkIdentifier(p.id, 4096), this.expect(29);
            const ee = this.tsParseModuleReference();
            return p.importKind === "type" && ee.type !== "TSExternalModuleReference" && this.raise(xt.ImportAliasHasImportType, { at: ee }), p.moduleReference = ee, this.semicolon(), this.finishNode(p, "TSImportEqualsDeclaration");
          }
          tsIsExternalModuleReference() {
            return this.isContextual(117) && this.lookaheadCharCode() === 40;
          }
          tsParseModuleReference() {
            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
          }
          tsParseExternalModuleReference() {
            const p = this.startNode();
            return this.expectContextual(117), this.expect(10), this.match(131) || this.unexpected(), p.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(p, "TSExternalModuleReference");
          }
          tsLookAhead(p) {
            const A = this.state.clone(), V = p();
            return this.state = A, V;
          }
          tsTryParseAndCatch(p) {
            const A = this.tryParse((V) => p() || V());
            if (!A.aborted && A.node)
              return A.error && (this.state = A.failState), A.node;
          }
          tsTryParse(p) {
            const A = this.state.clone(), V = p();
            if (V !== void 0 && V !== !1)
              return V;
            this.state = A;
          }
          tsTryParseDeclare(p) {
            if (this.isLineTerminator())
              return;
            let A, V = this.state.type;
            return this.isContextual(99) && (V = 74, A = "let"), this.tsInAmbientContext(() => {
              switch (V) {
                case 68:
                  return p.declare = !0, super.parseFunctionStatement(p, !1, !1);
                case 80:
                  return p.declare = !0, this.parseClass(p, !0, !1);
                case 124:
                  return this.tsParseEnumDeclaration(p, { declare: !0 });
                case 110:
                  return this.tsParseAmbientExternalModuleDeclaration(p);
                case 75:
                case 74:
                  return this.match(75) && this.isLookaheadContextual("enum") ? (this.expect(75), this.tsParseEnumDeclaration(p, { const: !0, declare: !0 })) : (p.declare = !0, this.parseVarStatement(p, A || this.state.value, !0));
                case 127: {
                  const ee = this.tsParseInterfaceDeclaration(p, { declare: !0 });
                  if (ee)
                    return ee;
                }
                default:
                  if ($(V))
                    return this.tsParseDeclaration(p, this.state.value, !0, null);
              }
            });
          }
          tsTryParseExportDeclaration() {
            return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
          }
          tsParseExpressionStatement(p, A, V) {
            switch (A.name) {
              case "declare": {
                const ee = this.tsTryParseDeclare(p);
                return ee && (ee.declare = !0), ee;
              }
              case "global":
                if (this.match(5)) {
                  this.scope.enter(256), this.prodParam.enter(0);
                  const ee = p;
                  return ee.global = !0, ee.id = A, ee.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(ee, "TSModuleDeclaration");
                }
                break;
              default:
                return this.tsParseDeclaration(p, A.name, !1, V);
            }
          }
          tsParseDeclaration(p, A, V, ee) {
            switch (A) {
              case "abstract":
                if (this.tsCheckLineTerminator(V) && (this.match(80) || $(this.state.type)))
                  return this.tsParseAbstractDeclaration(p, ee);
                break;
              case "module":
                if (this.tsCheckLineTerminator(V)) {
                  if (this.match(131))
                    return this.tsParseAmbientExternalModuleDeclaration(p);
                  if ($(this.state.type))
                    return this.tsParseModuleOrNamespaceDeclaration(p);
                }
                break;
              case "namespace":
                if (this.tsCheckLineTerminator(V) && $(this.state.type))
                  return this.tsParseModuleOrNamespaceDeclaration(p);
                break;
              case "type":
                if (this.tsCheckLineTerminator(V) && $(this.state.type))
                  return this.tsParseTypeAliasDeclaration(p);
            }
          }
          tsCheckLineTerminator(p) {
            return p ? !this.hasFollowingLineBreak() && (this.next(), !0) : !this.isLineTerminator();
          }
          tsTryParseGenericAsyncArrowFunction(p) {
            if (!this.match(47))
              return;
            const A = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = !0;
            const V = this.tsTryParseAndCatch(() => {
              const ee = this.startNodeAt(p);
              return ee.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(ee), ee.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), ee;
            });
            return this.state.maybeInArrowParameters = A, V ? super.parseArrowExpression(V, null, !0) : void 0;
          }
          tsParseTypeArgumentsInExpression() {
            if (this.reScan_lt() === 47)
              return this.tsParseTypeArguments();
          }
          tsParseTypeArguments() {
            const p = this.startNode();
            return p.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), p.params.length === 0 ? this.raise(xt.EmptyTypeArguments, { at: p }) : this.state.inType || this.curContext() !== _.brace || this.reScan_lt_gt(), this.expect(48), this.finishNode(p, "TSTypeParameterInstantiation");
          }
          tsIsDeclarationStart() {
            return (p = this.state.type) >= 122 && p <= 128;
            var p;
          }
          isExportDefaultSpecifier() {
            return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
          }
          parseAssignableListItem(p, A) {
            const V = this.state.startLoc, ee = {};
            this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, ee);
            const fe = ee.accessibility, Se = ee.override, Pe = ee.readonly;
            4 & p || !(fe || Pe || Se) || this.raise(xt.UnexpectedParameterModifier, { at: V });
            const Re = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(Re, p);
            const je = this.parseMaybeDefault(Re.loc.start, Re);
            if (fe || Pe || Se) {
              const ze = this.startNodeAt(V);
              return A.length && (ze.decorators = A), fe && (ze.accessibility = fe), Pe && (ze.readonly = Pe), Se && (ze.override = Se), je.type !== "Identifier" && je.type !== "AssignmentPattern" && this.raise(xt.UnsupportedParameterPropertyKind, { at: ze }), ze.parameter = je, this.finishNode(ze, "TSParameterProperty");
            }
            return A.length && (Re.decorators = A), je;
          }
          isSimpleParameter(p) {
            return p.type === "TSParameterProperty" && super.isSimpleParameter(p.parameter) || super.isSimpleParameter(p);
          }
          tsDisallowOptionalPattern(p) {
            for (const A of p.params)
              A.type !== "Identifier" && A.optional && !this.state.isAmbientContext && this.raise(xt.PatternIsOptional, { at: A });
          }
          setArrowFunctionParameters(p, A, V) {
            super.setArrowFunctionParameters(p, A, V), this.tsDisallowOptionalPattern(p);
          }
          parseFunctionBodyAndFinish(p, A, V = !1) {
            this.match(14) && (p.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
            const ee = A === "FunctionDeclaration" ? "TSDeclareFunction" : A === "ClassMethod" || A === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
            return ee && !this.match(5) && this.isLineTerminator() ? this.finishNode(p, ee) : ee === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(xt.DeclareFunctionHasImplementation, { at: p }), p.declare) ? super.parseFunctionBodyAndFinish(p, ee, V) : (this.tsDisallowOptionalPattern(p), super.parseFunctionBodyAndFinish(p, A, V));
          }
          registerFunctionStatementId(p) {
            !p.body && p.id ? this.checkIdentifier(p.id, 1024) : super.registerFunctionStatementId(p);
          }
          tsCheckForInvalidTypeCasts(p) {
            p.forEach((A) => {
              (A == null ? void 0 : A.type) === "TSTypeCastExpression" && this.raise(xt.UnexpectedTypeAnnotation, { at: A.typeAnnotation });
            });
          }
          toReferencedList(p, A) {
            return this.tsCheckForInvalidTypeCasts(p), p;
          }
          parseArrayLike(p, A, V, ee) {
            const fe = super.parseArrayLike(p, A, V, ee);
            return fe.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(fe.elements), fe;
          }
          parseSubscript(p, A, V, ee) {
            if (!this.hasPrecedingLineBreak() && this.match(35)) {
              this.state.canStartJSXElement = !1, this.next();
              const Se = this.startNodeAt(A);
              return Se.expression = p, this.finishNode(Se, "TSNonNullExpression");
            }
            let fe = !1;
            if (this.match(18) && this.lookaheadCharCode() === 60) {
              if (V)
                return ee.stop = !0, p;
              ee.optionalChainMember = fe = !0, this.next();
            }
            if (this.match(47) || this.match(51)) {
              let Se;
              const Pe = this.tsTryParseAndCatch(() => {
                if (!V && this.atPossibleAsyncArrow(p)) {
                  const mt = this.tsTryParseGenericAsyncArrowFunction(A);
                  if (mt)
                    return mt;
                }
                const Re = this.tsParseTypeArgumentsInExpression();
                if (!Re)
                  return;
                if (fe && !this.match(10))
                  return void (Se = this.state.curPosition());
                if (de(this.state.type)) {
                  const mt = super.parseTaggedTemplateExpression(p, A, ee);
                  return mt.typeParameters = Re, mt;
                }
                if (!V && this.eat(10)) {
                  const mt = this.startNodeAt(A);
                  return mt.callee = p, mt.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(mt.arguments), mt.typeParameters = Re, ee.optionalChainMember && (mt.optional = fe), this.finishCallExpression(mt, ee.optionalChainMember);
                }
                const je = this.state.type;
                if (je === 48 || je === 52 || je !== 10 && Q(je) && !this.hasPrecedingLineBreak())
                  return;
                const ze = this.startNodeAt(A);
                return ze.expression = p, ze.typeParameters = Re, this.finishNode(ze, "TSInstantiationExpression");
              });
              if (Se && this.unexpected(Se, 10), Pe)
                return Pe.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(xt.InvalidPropertyAccessAfterInstantiationExpression, { at: this.state.startLoc }), Pe;
            }
            return super.parseSubscript(p, A, V, ee);
          }
          parseNewCallee(p) {
            var A;
            super.parseNewCallee(p);
            const { callee: V } = p;
            V.type !== "TSInstantiationExpression" || (A = V.extra) != null && A.parenthesized || (p.typeParameters = V.typeParameters, p.callee = V.expression);
          }
          parseExprOp(p, A, V) {
            let ee;
            if (ve(58) > V && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (ee = this.isContextual(118)))) {
              const fe = this.startNodeAt(A);
              return fe.expression = p, fe.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (ee && this.raise(C.UnexpectedKeyword, { at: this.state.startLoc, keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(fe, ee ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(fe, A, V);
            }
            return super.parseExprOp(p, A, V);
          }
          checkReservedWord(p, A, V, ee) {
            this.state.isAmbientContext || super.checkReservedWord(p, A, V, ee);
          }
          checkImportReflection(p) {
            super.checkImportReflection(p), p.module && p.importKind !== "value" && this.raise(xt.ImportReflectionHasImportType, { at: p.specifiers[0].loc.start });
          }
          checkDuplicateExports() {
          }
          isPotentialImportPhase(p) {
            if (super.isPotentialImportPhase(p))
              return !0;
            if (this.isContextual(128)) {
              const A = this.lookaheadCharCode();
              return p ? A === 123 || A === 42 : A !== 61;
            }
            return !p && this.isContextual(87);
          }
          applyImportPhase(p, A, V, ee) {
            super.applyImportPhase(p, A, V, ee), A ? p.exportKind = V === "type" ? "type" : "value" : p.importKind = V === "type" || V === "typeof" ? V : "value";
          }
          parseImport(p) {
            if (this.match(131))
              return p.importKind = "value", super.parseImport(p);
            let A;
            if ($(this.state.type) && this.lookaheadCharCode() === 61)
              return p.importKind = "value", this.tsParseImportEqualsDeclaration(p);
            if (this.isContextual(128)) {
              const V = this.parseMaybeImportPhase(p, !1);
              if (this.lookaheadCharCode() === 61)
                return this.tsParseImportEqualsDeclaration(p, V);
              A = super.parseImportSpecifiersAndAfter(p, V);
            } else
              A = super.parseImport(p);
            return A.importKind === "type" && A.specifiers.length > 1 && A.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(xt.TypeImportCannotSpecifyDefaultAndNamed, { at: A }), A;
          }
          parseExport(p, A) {
            if (this.match(83)) {
              this.next();
              let V = null;
              return this.isContextual(128) && this.isPotentialImportPhase(!1) ? V = this.parseMaybeImportPhase(p, !1) : p.importKind = "value", this.tsParseImportEqualsDeclaration(p, V, !0);
            }
            if (this.eat(29)) {
              const V = p;
              return V.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(V, "TSExportAssignment");
            }
            if (this.eatContextual(93)) {
              const V = p;
              return this.expectContextual(126), V.id = this.parseIdentifier(), this.semicolon(), this.finishNode(V, "TSNamespaceExportDeclaration");
            }
            return super.parseExport(p, A);
          }
          isAbstractClass() {
            return this.isContextual(122) && this.lookahead().type === 80;
          }
          parseExportDefaultExpression() {
            if (this.isAbstractClass()) {
              const p = this.startNode();
              return this.next(), p.abstract = !0, this.parseClass(p, !0, !0);
            }
            if (this.match(127)) {
              const p = this.tsParseInterfaceDeclaration(this.startNode());
              if (p)
                return p;
            }
            return super.parseExportDefaultExpression();
          }
          parseVarStatement(p, A, V = !1) {
            const { isAmbientContext: ee } = this.state, fe = super.parseVarStatement(p, A, V || ee);
            if (!ee)
              return fe;
            for (const { id: Se, init: Pe } of fe.declarations)
              Pe && (A !== "const" || Se.typeAnnotation ? this.raise(xt.InitializerNotAllowedInAmbientContext, { at: Pe }) : kt(Pe, this.hasPlugin("estree")) || this.raise(xt.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, { at: Pe }));
            return fe;
          }
          parseStatementContent(p, A) {
            if (this.match(75) && this.isLookaheadContextual("enum")) {
              const V = this.startNode();
              return this.expect(75), this.tsParseEnumDeclaration(V, { const: !0 });
            }
            if (this.isContextual(124))
              return this.tsParseEnumDeclaration(this.startNode());
            if (this.isContextual(127)) {
              const V = this.tsParseInterfaceDeclaration(this.startNode());
              if (V)
                return V;
            }
            return super.parseStatementContent(p, A);
          }
          parseAccessModifier() {
            return this.tsParseModifier(["public", "protected", "private"]);
          }
          tsHasSomeModifiers(p, A) {
            return A.some((V) => bl(V) ? p.accessibility === V : !!p[V]);
          }
          tsIsStartOfStaticBlocks() {
            return this.isContextual(104) && this.lookaheadCharCode() === 123;
          }
          parseClassMember(p, A, V) {
            const ee = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
            this.tsParseModifiers({ allowedModifiers: ee, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: !0, errorTemplate: xt.InvalidModifierOnTypeParameterPositions }, A);
            const fe = () => {
              this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(A, ee) && this.raise(xt.StaticBlockCannotHaveModifier, { at: this.state.curPosition() }), super.parseClassStaticBlock(p, A)) : this.parseClassMemberWithIsStatic(p, A, V, !!A.static);
            };
            A.declare ? this.tsInAmbientContext(fe) : fe();
          }
          parseClassMemberWithIsStatic(p, A, V, ee) {
            const fe = this.tsTryParseIndexSignature(A);
            if (fe)
              return p.body.push(fe), A.abstract && this.raise(xt.IndexSignatureHasAbstract, { at: A }), A.accessibility && this.raise(xt.IndexSignatureHasAccessibility, { at: A, modifier: A.accessibility }), A.declare && this.raise(xt.IndexSignatureHasDeclare, { at: A }), void (A.override && this.raise(xt.IndexSignatureHasOverride, { at: A }));
            !this.state.inAbstractClass && A.abstract && this.raise(xt.NonAbstractClassHasAbstractMethod, { at: A }), A.override && (V.hadSuperClass || this.raise(xt.OverrideNotInSubClass, { at: A })), super.parseClassMemberWithIsStatic(p, A, V, ee);
          }
          parsePostMemberNameModifiers(p) {
            this.eat(17) && (p.optional = !0), p.readonly && this.match(10) && this.raise(xt.ClassMethodHasReadonly, { at: p }), p.declare && this.match(10) && this.raise(xt.ClassMethodHasDeclare, { at: p });
          }
          parseExpressionStatement(p, A, V) {
            return (A.type === "Identifier" ? this.tsParseExpressionStatement(p, A, V) : void 0) || super.parseExpressionStatement(p, A, V);
          }
          shouldParseExportDeclaration() {
            return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
          }
          parseConditional(p, A, V) {
            if (!this.state.maybeInArrowParameters || !this.match(17))
              return super.parseConditional(p, A, V);
            const ee = this.tryParse(() => super.parseConditional(p, A));
            return ee.node ? (ee.error && (this.state = ee.failState), ee.node) : (ee.error && super.setOptionalParametersError(V, ee.error), p);
          }
          parseParenItem(p, A) {
            if (p = super.parseParenItem(p, A), this.eat(17) && (p.optional = !0, this.resetEndLocation(p)), this.match(14)) {
              const V = this.startNodeAt(A);
              return V.expression = p, V.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(V, "TSTypeCastExpression");
            }
            return p;
          }
          parseExportDeclaration(p) {
            if (!this.state.isAmbientContext && this.isContextual(123))
              return this.tsInAmbientContext(() => this.parseExportDeclaration(p));
            const A = this.state.startLoc, V = this.eatContextual(123);
            if (V && (this.isContextual(123) || !this.shouldParseExportDeclaration()))
              throw this.raise(xt.ExpectedAmbientAfterExportDeclare, { at: this.state.startLoc });
            const ee = $(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(p);
            return ee ? ((ee.type === "TSInterfaceDeclaration" || ee.type === "TSTypeAliasDeclaration" || V) && (p.exportKind = "type"), V && (this.resetStartLocation(ee, A), ee.declare = !0), ee) : null;
          }
          parseClassId(p, A, V, ee) {
            if ((!A || V) && this.isContextual(111))
              return;
            super.parseClassId(p, A, V, p.declare ? 1024 : 8331);
            const fe = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
            fe && (p.typeParameters = fe);
          }
          parseClassPropertyAnnotation(p) {
            p.optional || (this.eat(35) ? p.definite = !0 : this.eat(17) && (p.optional = !0));
            const A = this.tsTryParseTypeAnnotation();
            A && (p.typeAnnotation = A);
          }
          parseClassProperty(p) {
            if (this.parseClassPropertyAnnotation(p), this.state.isAmbientContext && (!p.readonly || p.typeAnnotation) && this.match(29) && this.raise(xt.DeclareClassFieldHasInitializer, { at: this.state.startLoc }), p.abstract && this.match(29)) {
              const { key: A } = p;
              this.raise(xt.AbstractPropertyHasInitializer, { at: this.state.startLoc, propertyName: A.type !== "Identifier" || p.computed ? `[${this.input.slice(A.start, A.end)}]` : A.name });
            }
            return super.parseClassProperty(p);
          }
          parseClassPrivateProperty(p) {
            return p.abstract && this.raise(xt.PrivateElementHasAbstract, { at: p }), p.accessibility && this.raise(xt.PrivateElementHasAccessibility, { at: p, modifier: p.accessibility }), this.parseClassPropertyAnnotation(p), super.parseClassPrivateProperty(p);
          }
          parseClassAccessorProperty(p) {
            return this.parseClassPropertyAnnotation(p), p.optional && this.raise(xt.AccessorCannotBeOptional, { at: p }), super.parseClassAccessorProperty(p);
          }
          pushClassMethod(p, A, V, ee, fe, Se) {
            const Pe = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            Pe && fe && this.raise(xt.ConstructorHasTypeParameters, { at: Pe });
            const { declare: Re = !1, kind: je } = A;
            !Re || je !== "get" && je !== "set" || this.raise(xt.DeclareAccessor, { at: A, kind: je }), Pe && (A.typeParameters = Pe), super.pushClassMethod(p, A, V, ee, fe, Se);
          }
          pushClassPrivateMethod(p, A, V, ee) {
            const fe = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            fe && (A.typeParameters = fe), super.pushClassPrivateMethod(p, A, V, ee);
          }
          declareClassPrivateMethodInScope(p, A) {
            p.type !== "TSDeclareMethod" && (p.type !== "MethodDefinition" || p.value.body) && super.declareClassPrivateMethodInScope(p, A);
          }
          parseClassSuper(p) {
            super.parseClassSuper(p), p.superClass && (this.match(47) || this.match(51)) && (p.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(111) && (p.implements = this.tsParseHeritageClause("implements"));
          }
          parseObjPropValue(p, A, V, ee, fe, Se, Pe) {
            const Re = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            return Re && (p.typeParameters = Re), super.parseObjPropValue(p, A, V, ee, fe, Se, Pe);
          }
          parseFunctionParams(p, A) {
            const V = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            V && (p.typeParameters = V), super.parseFunctionParams(p, A);
          }
          parseVarId(p, A) {
            super.parseVarId(p, A), p.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (p.definite = !0);
            const V = this.tsTryParseTypeAnnotation();
            V && (p.id.typeAnnotation = V, this.resetEndLocation(p.id));
          }
          parseAsyncArrowFromCallExpression(p, A) {
            return this.match(14) && (p.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(p, A);
          }
          parseMaybeAssign(p, A) {
            var V, ee, fe, Se, Pe;
            let Re, je, ze, mt;
            if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
              if (Re = this.state.clone(), je = this.tryParse(() => super.parseMaybeAssign(p, A), Re), !je.error)
                return je.node;
              const { context: St } = this.state, Ut = St[St.length - 1];
              Ut !== _.j_oTag && Ut !== _.j_expr || St.pop();
            }
            if (!((V = je) != null && V.error || this.match(47)))
              return super.parseMaybeAssign(p, A);
            Re && Re !== this.state || (Re = this.state.clone());
            const Mt = this.tryParse((St) => {
              var Ut, Cr;
              mt = this.tsParseTypeParameters(this.tsParseConstModifier);
              const nr = super.parseMaybeAssign(p, A);
              return (nr.type !== "ArrowFunctionExpression" || (Ut = nr.extra) != null && Ut.parenthesized) && St(), ((Cr = mt) == null ? void 0 : Cr.params.length) !== 0 && this.resetStartLocationFromNode(nr, mt), nr.typeParameters = mt, nr;
            }, Re);
            if (!Mt.error && !Mt.aborted)
              return mt && this.reportReservedArrowTypeParam(mt), Mt.node;
            if (!je && (Qt(!this.hasPlugin("jsx")), ze = this.tryParse(() => super.parseMaybeAssign(p, A), Re), !ze.error))
              return ze.node;
            if ((ee = je) != null && ee.node)
              return this.state = je.failState, je.node;
            if (Mt.node)
              return this.state = Mt.failState, mt && this.reportReservedArrowTypeParam(mt), Mt.node;
            if ((fe = ze) != null && fe.node)
              return this.state = ze.failState, ze.node;
            throw ((Se = je) == null ? void 0 : Se.error) || Mt.error || ((Pe = ze) == null ? void 0 : Pe.error);
          }
          reportReservedArrowTypeParam(p) {
            var A;
            p.params.length !== 1 || p.params[0].constraint || (A = p.extra) != null && A.trailingComma || !this.getPluginOption("typescript", "disallowAmbiguousJSXLike") || this.raise(xt.ReservedArrowTypeParam, { at: p });
          }
          parseMaybeUnary(p, A) {
            return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(p, A);
          }
          parseArrow(p) {
            if (this.match(14)) {
              const A = this.tryParse((V) => {
                const ee = this.tsParseTypeOrTypePredicateAnnotation(14);
                return !this.canInsertSemicolon() && this.match(19) || V(), ee;
              });
              if (A.aborted)
                return;
              A.thrown || (A.error && (this.state = A.failState), p.returnType = A.node);
            }
            return super.parseArrow(p);
          }
          parseAssignableListItemTypes(p, A) {
            if (!(2 & A))
              return p;
            this.eat(17) && (p.optional = !0);
            const V = this.tsTryParseTypeAnnotation();
            return V && (p.typeAnnotation = V), this.resetEndLocation(p), p;
          }
          isAssignable(p, A) {
            switch (p.type) {
              case "TSTypeCastExpression":
                return this.isAssignable(p.expression, A);
              case "TSParameterProperty":
                return !0;
              default:
                return super.isAssignable(p, A);
            }
          }
          toAssignable(p, A = !1) {
            switch (p.type) {
              case "ParenthesizedExpression":
                this.toAssignableParenthesizedExpression(p, A);
                break;
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
                A ? this.expressionScope.recordArrowParameterBindingError(xt.UnexpectedTypeCastInParameter, { at: p }) : this.raise(xt.UnexpectedTypeCastInParameter, { at: p }), this.toAssignable(p.expression, A);
                break;
              case "AssignmentExpression":
                A || p.left.type !== "TSTypeCastExpression" || (p.left = this.typeCastToParameter(p.left));
              default:
                super.toAssignable(p, A);
            }
          }
          toAssignableParenthesizedExpression(p, A) {
            switch (p.expression.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
              case "ParenthesizedExpression":
                this.toAssignable(p.expression, A);
                break;
              default:
                super.toAssignable(p, A);
            }
          }
          checkToRestConversion(p, A) {
            switch (p.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSTypeAssertion":
              case "TSNonNullExpression":
                this.checkToRestConversion(p.expression, !1);
                break;
              default:
                super.checkToRestConversion(p, A);
            }
          }
          isValidLVal(p, A, V) {
            return ee = { TSTypeCastExpression: !0, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSAsExpression: (V !== 64 || !A) && ["expression", !0], TSSatisfiesExpression: (V !== 64 || !A) && ["expression", !0], TSTypeAssertion: (V !== 64 || !A) && ["expression", !0] }, fe = p, Object.hasOwnProperty.call(ee, fe) && ee[fe] || super.isValidLVal(p, A, V);
            var ee, fe;
          }
          parseBindingAtom() {
            return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
          }
          parseMaybeDecoratorArguments(p) {
            if (this.match(47) || this.match(51)) {
              const A = this.tsParseTypeArgumentsInExpression();
              if (this.match(10)) {
                const V = super.parseMaybeDecoratorArguments(p);
                return V.typeParameters = A, V;
              }
              this.unexpected(null, 10);
            }
            return super.parseMaybeDecoratorArguments(p);
          }
          checkCommaAfterRest(p) {
            return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === p ? (this.next(), !1) : super.checkCommaAfterRest(p);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(35) || this.match(14) || super.isClassProperty();
          }
          parseMaybeDefault(p, A) {
            const V = super.parseMaybeDefault(p, A);
            return V.type === "AssignmentPattern" && V.typeAnnotation && V.right.start < V.typeAnnotation.start && this.raise(xt.TypeAnnotationAfterAssign, { at: V.typeAnnotation }), V;
          }
          getTokenFromCode(p) {
            if (this.state.inType) {
              if (p === 62)
                return void this.finishOp(48, 1);
              if (p === 60)
                return void this.finishOp(47, 1);
            }
            super.getTokenFromCode(p);
          }
          reScan_lt_gt() {
            const { type: p } = this.state;
            p === 47 ? (this.state.pos -= 1, this.readToken_lt()) : p === 48 && (this.state.pos -= 1, this.readToken_gt());
          }
          reScan_lt() {
            const { type: p } = this.state;
            return p === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : p;
          }
          toAssignableList(p, A, V) {
            for (let ee = 0; ee < p.length; ee++) {
              const fe = p[ee];
              (fe == null ? void 0 : fe.type) === "TSTypeCastExpression" && (p[ee] = this.typeCastToParameter(fe));
            }
            super.toAssignableList(p, A, V);
          }
          typeCastToParameter(p) {
            return p.expression.typeAnnotation = p.typeAnnotation, this.resetEndLocation(p.expression, p.typeAnnotation.loc.end), p.expression;
          }
          shouldParseArrow(p) {
            return this.match(14) ? p.every((A) => this.isAssignable(A, !0)) : super.shouldParseArrow(p);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          canHaveLeadingDecorator() {
            return super.canHaveLeadingDecorator() || this.isAbstractClass();
          }
          jsxParseOpeningElementAfterName(p) {
            if (this.match(47) || this.match(51)) {
              const A = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
              A && (p.typeParameters = A);
            }
            return super.jsxParseOpeningElementAfterName(p);
          }
          getGetterSetterExpectedParamCount(p) {
            const A = super.getGetterSetterExpectedParamCount(p), V = this.getObjectOrClassMethodParams(p)[0];
            return V && this.isThisParam(V) ? A + 1 : A;
          }
          parseCatchClauseParam() {
            const p = super.parseCatchClauseParam(), A = this.tsTryParseTypeAnnotation();
            return A && (p.typeAnnotation = A, this.resetEndLocation(p)), p;
          }
          tsInAmbientContext(p) {
            const A = this.state.isAmbientContext;
            this.state.isAmbientContext = !0;
            try {
              return p();
            } finally {
              this.state.isAmbientContext = A;
            }
          }
          parseClass(p, A, V) {
            const ee = this.state.inAbstractClass;
            this.state.inAbstractClass = !!p.abstract;
            try {
              return super.parseClass(p, A, V);
            } finally {
              this.state.inAbstractClass = ee;
            }
          }
          tsParseAbstractDeclaration(p, A) {
            if (this.match(80))
              return p.abstract = !0, this.maybeTakeDecorators(A, this.parseClass(p, !0, !1));
            if (this.isContextual(127)) {
              if (!this.hasFollowingLineBreak())
                return p.abstract = !0, this.raise(xt.NonClassMethodPropertyHasAbstractModifer, { at: p }), this.tsParseInterfaceDeclaration(p);
            } else
              this.unexpected(null, 80);
          }
          parseMethod(p, A, V, ee, fe, Se, Pe) {
            const Re = super.parseMethod(p, A, V, ee, fe, Se, Pe);
            if (Re.abstract && (this.hasPlugin("estree") ? Re.value.body : Re.body)) {
              const { key: je } = Re;
              this.raise(xt.AbstractMethodHasImplementation, { at: Re, methodName: je.type !== "Identifier" || Re.computed ? `[${this.input.slice(je.start, je.end)}]` : je.name });
            }
            return Re;
          }
          tsParseTypeParameterName() {
            return this.parseIdentifier().name;
          }
          shouldParseAsAmbientContext() {
            return !!this.getPluginOption("typescript", "dts");
          }
          parse() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
          }
          getExpression() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
          }
          parseExportSpecifier(p, A, V, ee) {
            return !A && ee ? (this.parseTypeOnlyImportExportSpecifier(p, !1, V), this.finishNode(p, "ExportSpecifier")) : (p.exportKind = "value", super.parseExportSpecifier(p, A, V, ee));
          }
          parseImportSpecifier(p, A, V, ee, fe) {
            return !A && ee ? (this.parseTypeOnlyImportExportSpecifier(p, !0, V), this.finishNode(p, "ImportSpecifier")) : (p.importKind = "value", super.parseImportSpecifier(p, A, V, ee, V ? 4098 : 4096));
          }
          parseTypeOnlyImportExportSpecifier(p, A, V) {
            const ee = A ? "imported" : "local", fe = A ? "local" : "exported";
            let Se, Pe = p[ee], Re = !1, je = !0;
            const ze = Pe.loc.start;
            if (this.isContextual(93)) {
              const mt = this.parseIdentifier();
              if (this.isContextual(93)) {
                const Mt = this.parseIdentifier();
                Y(this.state.type) ? (Re = !0, Pe = mt, Se = A ? this.parseIdentifier() : this.parseModuleExportName(), je = !1) : (Se = Mt, je = !1);
              } else
                Y(this.state.type) ? (je = !1, Se = A ? this.parseIdentifier() : this.parseModuleExportName()) : (Re = !0, Pe = mt);
            } else
              Y(this.state.type) && (Re = !0, A ? (Pe = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(Pe.name, Pe.loc.start, !0, !0)) : Pe = this.parseModuleExportName());
            Re && V && this.raise(A ? xt.TypeModifierIsUsedInTypeImports : xt.TypeModifierIsUsedInTypeExports, { at: ze }), p[ee] = Pe, p[fe] = Se, p[A ? "importKind" : "exportKind"] = Re ? "type" : "value", je && this.eatContextual(93) && (p[fe] = A ? this.parseIdentifier() : this.parseModuleExportName()), p[fe] || (p[fe] = Vr(p[ee])), A && this.checkIdentifier(p[fe], Re ? 4098 : 4096);
          }
        }, v8intrinsic: (Te) => class extends Te {
          parseV8Intrinsic() {
            if (this.match(54)) {
              const p = this.state.startLoc, A = this.startNode();
              if (this.next(), $(this.state.type)) {
                const V = this.parseIdentifierName(), ee = this.createIdentifier(A, V);
                if (ee.type = "V8IntrinsicIdentifier", this.match(10))
                  return ee;
              }
              this.unexpected(p);
            }
          }
          parseExprAtom(p) {
            return this.parseV8Intrinsic() || super.parseExprAtom(p);
          }
        }, placeholders: (Te) => class extends Te {
          parsePlaceholder(p) {
            if (this.match(142)) {
              const A = this.startNode();
              return this.next(), this.assertNoSpace(), A.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(142), this.finishPlaceholder(A, p);
            }
          }
          finishPlaceholder(p, A) {
            const V = !(!p.expectedNode || p.type !== "Placeholder");
            return p.expectedNode = A, V ? p : this.finishNode(p, "Placeholder");
          }
          getTokenFromCode(p) {
            p === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(142, 2) : super.getTokenFromCode(p);
          }
          parseExprAtom(p) {
            return this.parsePlaceholder("Expression") || super.parseExprAtom(p);
          }
          parseIdentifier(p) {
            return this.parsePlaceholder("Identifier") || super.parseIdentifier(p);
          }
          checkReservedWord(p, A, V, ee) {
            p !== void 0 && super.checkReservedWord(p, A, V, ee);
          }
          parseBindingAtom() {
            return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
          }
          isValidLVal(p, A, V) {
            return p === "Placeholder" || super.isValidLVal(p, A, V);
          }
          toAssignable(p, A) {
            p && p.type === "Placeholder" && p.expectedNode === "Expression" ? p.expectedNode = "Pattern" : super.toAssignable(p, A);
          }
          chStartsBindingIdentifier(p, A) {
            return super.chStartsBindingIdentifier(p, A) ? !0 : this.lookahead().type === 142;
          }
          verifyBreakContinue(p, A) {
            p.label && p.label.type === "Placeholder" || super.verifyBreakContinue(p, A);
          }
          parseExpressionStatement(p, A) {
            var V;
            if (A.type !== "Placeholder" || (V = A.extra) != null && V.parenthesized)
              return super.parseExpressionStatement(p, A);
            if (this.match(14)) {
              const ee = p;
              return ee.label = this.finishPlaceholder(A, "Identifier"), this.next(), ee.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(ee, "LabeledStatement");
            }
            return this.semicolon(), p.name = A.name, this.finishPlaceholder(p, "Statement");
          }
          parseBlock(p, A, V) {
            return this.parsePlaceholder("BlockStatement") || super.parseBlock(p, A, V);
          }
          parseFunctionId(p) {
            return this.parsePlaceholder("Identifier") || super.parseFunctionId(p);
          }
          parseClass(p, A, V) {
            const ee = A ? "ClassDeclaration" : "ClassExpression";
            this.next();
            const fe = this.state.strict, Se = this.parsePlaceholder("Identifier");
            if (Se) {
              if (!(this.match(81) || this.match(142) || this.match(5))) {
                if (V || !A)
                  return p.id = null, p.body = this.finishPlaceholder(Se, "ClassBody"), this.finishNode(p, ee);
                throw this.raise(dc.ClassNameIsRequired, { at: this.state.startLoc });
              }
              p.id = Se;
            } else
              this.parseClassId(p, A, V);
            return super.parseClassSuper(p), p.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!p.superClass, fe), this.finishNode(p, ee);
          }
          parseExport(p, A) {
            const V = this.parsePlaceholder("Identifier");
            if (!V)
              return super.parseExport(p, A);
            if (!this.isContextual(97) && !this.match(12))
              return p.specifiers = [], p.source = null, p.declaration = this.finishPlaceholder(V, "Declaration"), this.finishNode(p, "ExportNamedDeclaration");
            this.expectPlugin("exportDefaultFrom");
            const ee = this.startNode();
            return ee.exported = V, p.specifiers = [this.finishNode(ee, "ExportDefaultSpecifier")], super.parseExport(p, A);
          }
          isExportDefaultSpecifier() {
            if (this.match(65)) {
              const p = this.nextTokenStart();
              if (this.isUnparsedContextual(p, "from") && this.input.startsWith(ye(142), this.nextTokenStartSince(p + 4)))
                return !0;
            }
            return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(p, A) {
            var V;
            return !((V = p.specifiers) == null || !V.length) || super.maybeParseExportDefaultSpecifier(p, A);
          }
          checkExport(p) {
            const { specifiers: A } = p;
            A != null && A.length && (p.specifiers = A.filter((V) => V.exported.type === "Placeholder")), super.checkExport(p), p.specifiers = A;
          }
          parseImport(p) {
            const A = this.parsePlaceholder("Identifier");
            if (!A)
              return super.parseImport(p);
            if (p.specifiers = [], !this.isContextual(97) && !this.match(12))
              return p.source = this.finishPlaceholder(A, "StringLiteral"), this.semicolon(), this.finishNode(p, "ImportDeclaration");
            const V = this.startNodeAtNode(A);
            return V.local = A, p.specifiers.push(this.finishNode(V, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(p) || this.parseNamedImportSpecifiers(p)), this.expectContextual(97), p.source = this.parseImportSource(), this.semicolon(), this.finishNode(p, "ImportDeclaration");
          }
          parseImportSource() {
            return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
          }
          assertNoSpace() {
            this.state.start > this.state.lastTokEndLoc.index && this.raise(dc.UnexpectedSpace, { at: this.state.lastTokEndLoc });
          }
        } }, kp = Object.keys(va), qs = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: !1, allowReturnOutsideFunction: !1, allowNewTargetOutsideFunction: !1, allowImportExportEverywhere: !1, allowSuperOutsideMethod: !1, allowUndeclaredExports: !1, plugins: [], strictMode: null, ranges: !1, tokens: !1, createParenthesizedExpressions: !1, errorRecovery: !1, attachComment: !0, annexB: !0 };
        class hc extends yl {
          checkProto(p, A, V, ee) {
            if (p.type === "SpreadElement" || this.isObjectMethod(p) || p.computed || p.shorthand)
              return;
            const fe = p.key;
            if ((fe.type === "Identifier" ? fe.name : fe.value) === "__proto__") {
              if (A)
                return void this.raise(C.RecordNoProto, { at: fe });
              V.used && (ee ? ee.doubleProtoLoc === null && (ee.doubleProtoLoc = fe.loc.start) : this.raise(C.DuplicateProto, { at: fe })), V.used = !0;
            }
          }
          shouldExitDescending(p, A) {
            return p.type === "ArrowFunctionExpression" && p.start === A;
          }
          getExpression() {
            this.enterInitialScopes(), this.nextToken();
            const p = this.parseExpression();
            return this.match(137) || this.unexpected(), this.finalizeRemainingComments(), p.comments = this.state.comments, p.errors = this.state.errors, this.options.tokens && (p.tokens = this.tokens), p;
          }
          parseExpression(p, A) {
            return p ? this.disallowInAnd(() => this.parseExpressionBase(A)) : this.allowInAnd(() => this.parseExpressionBase(A));
          }
          parseExpressionBase(p) {
            const A = this.state.startLoc, V = this.parseMaybeAssign(p);
            if (this.match(12)) {
              const ee = this.startNodeAt(A);
              for (ee.expressions = [V]; this.eat(12); )
                ee.expressions.push(this.parseMaybeAssign(p));
              return this.toReferencedList(ee.expressions), this.finishNode(ee, "SequenceExpression");
            }
            return V;
          }
          parseMaybeAssignDisallowIn(p, A) {
            return this.disallowInAnd(() => this.parseMaybeAssign(p, A));
          }
          parseMaybeAssignAllowIn(p, A) {
            return this.allowInAnd(() => this.parseMaybeAssign(p, A));
          }
          setOptionalParametersError(p, A) {
            var V;
            p.optionalParametersLoc = (V = A == null ? void 0 : A.loc) != null ? V : this.state.startLoc;
          }
          parseMaybeAssign(p, A) {
            const V = this.state.startLoc;
            if (this.isContextual(106) && this.prodParam.hasYield) {
              let Re = this.parseYield();
              return A && (Re = A.call(this, Re, V)), Re;
            }
            let ee;
            p ? ee = !1 : (p = new yn(), ee = !0);
            const { type: fe } = this.state;
            (fe === 10 || $(fe)) && (this.state.potentialArrowAt = this.state.start);
            let Se = this.parseMaybeConditional(p);
            if (A && (Se = A.call(this, Se, V)), (Pe = this.state.type) >= 29 && Pe <= 33) {
              const Re = this.startNodeAt(V), je = this.state.value;
              if (Re.operator = je, this.match(29)) {
                this.toAssignable(Se, !0), Re.left = Se;
                const ze = V.index;
                p.doubleProtoLoc != null && p.doubleProtoLoc.index >= ze && (p.doubleProtoLoc = null), p.shorthandAssignLoc != null && p.shorthandAssignLoc.index >= ze && (p.shorthandAssignLoc = null), p.privateKeyLoc != null && p.privateKeyLoc.index >= ze && (this.checkDestructuringPrivate(p), p.privateKeyLoc = null);
              } else
                Re.left = Se;
              return this.next(), Re.right = this.parseMaybeAssign(), this.checkLVal(Se, { in: this.finishNode(Re, "AssignmentExpression") }), Re;
            }
            var Pe;
            return ee && this.checkExpressionErrors(p, !0), Se;
          }
          parseMaybeConditional(p) {
            const A = this.state.startLoc, V = this.state.potentialArrowAt, ee = this.parseExprOps(p);
            return this.shouldExitDescending(ee, V) ? ee : this.parseConditional(ee, A, p);
          }
          parseConditional(p, A, V) {
            if (this.eat(17)) {
              const ee = this.startNodeAt(A);
              return ee.test = p, ee.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), ee.alternate = this.parseMaybeAssign(), this.finishNode(ee, "ConditionalExpression");
            }
            return p;
          }
          parseMaybeUnaryOrPrivate(p) {
            return this.match(136) ? this.parsePrivateName() : this.parseMaybeUnary(p);
          }
          parseExprOps(p) {
            const A = this.state.startLoc, V = this.state.potentialArrowAt, ee = this.parseMaybeUnaryOrPrivate(p);
            return this.shouldExitDescending(ee, V) ? ee : this.parseExprOp(ee, A, -1);
          }
          parseExprOp(p, A, V) {
            if (this.isPrivateName(p)) {
              const Se = this.getPrivateNameSV(p);
              (V >= ve(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(C.PrivateInExpectedIn, { at: p, identifierName: Se }), this.classScope.usePrivateName(Se, p.loc.start);
            }
            const ee = this.state.type;
            if ((fe = ee) >= 39 && fe <= 59 && (this.prodParam.hasIn || !this.match(58))) {
              let Se = ve(ee);
              if (Se > V) {
                if (ee === 39) {
                  if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
                    return p;
                  this.checkPipelineAtInfixOperator(p, A);
                }
                const Pe = this.startNodeAt(A);
                Pe.left = p, Pe.operator = this.state.value;
                const Re = ee === 41 || ee === 42, je = ee === 40;
                if (je && (Se = ve(42)), this.next(), ee === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 96 && this.prodParam.hasAwait)
                  throw this.raise(C.UnexpectedAwaitAfterPipelineBody, { at: this.state.startLoc });
                Pe.right = this.parseExprOpRightExpr(ee, Se);
                const ze = this.finishNode(Pe, Re || je ? "LogicalExpression" : "BinaryExpression"), mt = this.state.type;
                if (je && (mt === 41 || mt === 42) || Re && mt === 40)
                  throw this.raise(C.MixingCoalesceWithLogical, { at: this.state.startLoc });
                return this.parseExprOp(ze, A, V);
              }
            }
            var fe;
            return p;
          }
          parseExprOpRightExpr(p, A) {
            const V = this.state.startLoc;
            if (p === 39)
              switch (this.getPluginOption("pipelineOperator", "proposal")) {
                case "hack":
                  return this.withTopicBindingContext(() => this.parseHackPipeBody());
                case "smart":
                  return this.withTopicBindingContext(() => {
                    if (this.prodParam.hasYield && this.isContextual(106))
                      throw this.raise(C.PipeBodyIsTighter, { at: this.state.startLoc });
                    return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(p, A), V);
                  });
                case "fsharp":
                  return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(A));
              }
            return this.parseExprOpBaseRightExpr(p, A);
          }
          parseExprOpBaseRightExpr(p, A) {
            const V = this.state.startLoc;
            return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), V, p === 57 ? A - 1 : A);
          }
          parseHackPipeBody() {
            var p;
            const { startLoc: A } = this.state, V = this.parseMaybeAssign();
            return !b.has(V.type) || (p = V.extra) != null && p.parenthesized || this.raise(C.PipeUnparenthesizedBody, { at: A, type: V.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(C.PipeTopicUnused, { at: A }), V;
          }
          checkExponentialAfterUnary(p) {
            this.match(57) && this.raise(C.UnexpectedTokenUnaryExponentiation, { at: p.argument });
          }
          parseMaybeUnary(p, A) {
            const V = this.state.startLoc, ee = this.isContextual(96);
            if (ee && this.isAwaitAllowed()) {
              this.next();
              const je = this.parseAwait(V);
              return A || this.checkExponentialAfterUnary(je), je;
            }
            const fe = this.match(34), Se = this.startNode();
            if (Pe = this.state.type, K[Pe]) {
              Se.operator = this.state.value, Se.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
              const je = this.match(89);
              if (this.next(), Se.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(p, !0), this.state.strict && je) {
                const ze = Se.argument;
                ze.type === "Identifier" ? this.raise(C.StrictDelete, { at: Se }) : this.hasPropertyAsPrivateName(ze) && this.raise(C.DeletePrivateField, { at: Se });
              }
              if (!fe)
                return A || this.checkExponentialAfterUnary(Se), this.finishNode(Se, "UnaryExpression");
            }
            var Pe;
            const Re = this.parseUpdate(Se, fe, p);
            if (ee) {
              const { type: je } = this.state;
              if ((this.hasPlugin("v8intrinsic") ? Q(je) : Q(je) && !this.match(54)) && !this.isAmbiguousAwait())
                return this.raiseOverwrite(C.AwaitNotInAsyncContext, { at: V }), this.parseAwait(V);
            }
            return Re;
          }
          parseUpdate(p, A, V) {
            if (A) {
              const Se = p;
              return this.checkLVal(Se.argument, { in: this.finishNode(Se, "UpdateExpression") }), p;
            }
            const ee = this.state.startLoc;
            let fe = this.parseExprSubscripts(V);
            if (this.checkExpressionErrors(V, !1))
              return fe;
            for (; this.state.type === 34 && !this.canInsertSemicolon(); ) {
              const Se = this.startNodeAt(ee);
              Se.operator = this.state.value, Se.prefix = !1, Se.argument = fe, this.next(), this.checkLVal(fe, { in: fe = this.finishNode(Se, "UpdateExpression") });
            }
            return fe;
          }
          parseExprSubscripts(p) {
            const A = this.state.startLoc, V = this.state.potentialArrowAt, ee = this.parseExprAtom(p);
            return this.shouldExitDescending(ee, V) ? ee : this.parseSubscripts(ee, A);
          }
          parseSubscripts(p, A, V) {
            const ee = { optionalChainMember: !1, maybeAsyncArrow: this.atPossibleAsyncArrow(p), stop: !1 };
            do
              p = this.parseSubscript(p, A, V, ee), ee.maybeAsyncArrow = !1;
            while (!ee.stop);
            return p;
          }
          parseSubscript(p, A, V, ee) {
            const { type: fe } = this.state;
            if (!V && fe === 15)
              return this.parseBind(p, A, V, ee);
            if (de(fe))
              return this.parseTaggedTemplateExpression(p, A, ee);
            let Se = !1;
            if (fe === 18) {
              if (V && (this.raise(C.OptionalChainingNoNew, { at: this.state.startLoc }), this.lookaheadCharCode() === 40))
                return ee.stop = !0, p;
              ee.optionalChainMember = Se = !0, this.next();
            }
            if (!V && this.match(10))
              return this.parseCoverCallAndAsyncArrowHead(p, A, ee, Se);
            {
              const Pe = this.eat(0);
              return Pe || Se || this.eat(16) ? this.parseMember(p, A, ee, Pe, Se) : (ee.stop = !0, p);
            }
          }
          parseMember(p, A, V, ee, fe) {
            const Se = this.startNodeAt(A);
            return Se.object = p, Se.computed = ee, ee ? (Se.property = this.parseExpression(), this.expect(3)) : this.match(136) ? (p.type === "Super" && this.raise(C.SuperPrivateField, { at: A }), this.classScope.usePrivateName(this.state.value, this.state.startLoc), Se.property = this.parsePrivateName()) : Se.property = this.parseIdentifier(!0), V.optionalChainMember ? (Se.optional = fe, this.finishNode(Se, "OptionalMemberExpression")) : this.finishNode(Se, "MemberExpression");
          }
          parseBind(p, A, V, ee) {
            const fe = this.startNodeAt(A);
            return fe.object = p, this.next(), fe.callee = this.parseNoCallExpr(), ee.stop = !0, this.parseSubscripts(this.finishNode(fe, "BindExpression"), A, V);
          }
          parseCoverCallAndAsyncArrowHead(p, A, V, ee) {
            const fe = this.state.maybeInArrowParameters;
            let Se = null;
            this.state.maybeInArrowParameters = !0, this.next();
            const Pe = this.startNodeAt(A);
            Pe.callee = p;
            const { maybeAsyncArrow: Re, optionalChainMember: je } = V;
            Re && (this.expressionScope.enter(new _r(2)), Se = new yn()), je && (Pe.optional = ee), Pe.arguments = ee ? this.parseCallExpressionArguments(11) : this.parseCallExpressionArguments(11, p.type === "Import", p.type !== "Super", Pe, Se);
            let ze = this.finishCallExpression(Pe, je);
            return Re && this.shouldParseAsyncArrow() && !ee ? (V.stop = !0, this.checkDestructuringPrivate(Se), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), ze = this.parseAsyncArrowFromCallExpression(this.startNodeAt(A), ze)) : (Re && (this.checkExpressionErrors(Se, !0), this.expressionScope.exit()), this.toReferencedArguments(ze)), this.state.maybeInArrowParameters = fe, ze;
          }
          toReferencedArguments(p, A) {
            this.toReferencedListDeep(p.arguments, A);
          }
          parseTaggedTemplateExpression(p, A, V) {
            const ee = this.startNodeAt(A);
            return ee.tag = p, ee.quasi = this.parseTemplate(!0), V.optionalChainMember && this.raise(C.OptionalChainingNoTemplate, { at: A }), this.finishNode(ee, "TaggedTemplateExpression");
          }
          atPossibleAsyncArrow(p) {
            return p.type === "Identifier" && p.name === "async" && this.state.lastTokEndLoc.index === p.end && !this.canInsertSemicolon() && p.end - p.start == 5 && p.start === this.state.potentialArrowAt;
          }
          expectImportAttributesPlugin() {
            this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
          }
          finishCallExpression(p, A) {
            if (p.callee.type === "Import")
              if (p.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), p.arguments.length === 0 || p.arguments.length > 2)
                this.raise(C.ImportCallArity, { at: p, maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
              else
                for (const V of p.arguments)
                  V.type === "SpreadElement" && this.raise(C.ImportCallSpreadArgument, { at: V });
            return this.finishNode(p, A ? "OptionalCallExpression" : "CallExpression");
          }
          parseCallExpressionArguments(p, A, V, ee, fe) {
            const Se = [];
            let Pe = !0;
            const Re = this.state.inFSharpPipelineDirectBody;
            for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(p); ) {
              if (Pe)
                Pe = !1;
              else if (this.expect(12), this.match(p)) {
                !A || this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(C.ImportCallArgumentTrailingComma, { at: this.state.lastTokStartLoc }), ee && this.addTrailingCommaExtraToNode(ee), this.next();
                break;
              }
              Se.push(this.parseExprListItem(!1, fe, V));
            }
            return this.state.inFSharpPipelineDirectBody = Re, Se;
          }
          shouldParseAsyncArrow() {
            return this.match(19) && !this.canInsertSemicolon();
          }
          parseAsyncArrowFromCallExpression(p, A) {
            var V;
            return this.resetPreviousNodeTrailingComments(A), this.expect(19), this.parseArrowExpression(p, A.arguments, !0, (V = A.extra) == null ? void 0 : V.trailingCommaLoc), A.innerComments && Ce(p, A.innerComments), A.callee.trailingComments && Ce(p, A.callee.trailingComments), p;
          }
          parseNoCallExpr() {
            const p = this.state.startLoc;
            return this.parseSubscripts(this.parseExprAtom(), p, !0);
          }
          parseExprAtom(p) {
            let A, V = null;
            const { type: ee } = this.state;
            switch (ee) {
              case 79:
                return this.parseSuper();
              case 83:
                return A = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(A) : (this.match(10) || this.raise(C.UnsupportedImport, { at: this.state.lastTokStartLoc }), this.finishNode(A, "Import"));
              case 78:
                return A = this.startNode(), this.next(), this.finishNode(A, "ThisExpression");
              case 90:
                return this.parseDo(this.startNode(), !1);
              case 56:
              case 31:
                return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
              case 132:
                return this.parseNumericLiteral(this.state.value);
              case 133:
                return this.parseBigIntLiteral(this.state.value);
              case 134:
                return this.parseDecimalLiteral(this.state.value);
              case 131:
                return this.parseStringLiteral(this.state.value);
              case 84:
                return this.parseNullLiteral();
              case 85:
                return this.parseBooleanLiteral(!0);
              case 86:
                return this.parseBooleanLiteral(!1);
              case 10: {
                const fe = this.state.potentialArrowAt === this.state.start;
                return this.parseParenAndDistinguishExpression(fe);
              }
              case 2:
              case 1:
                return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
              case 0:
                return this.parseArrayLike(3, !0, !1, p);
              case 6:
              case 7:
                return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
              case 5:
                return this.parseObjectLike(8, !1, !1, p);
              case 68:
                return this.parseFunctionOrFunctionSent();
              case 26:
                V = this.parseDecorators();
              case 80:
                return this.parseClass(this.maybeTakeDecorators(V, this.startNode()), !1);
              case 77:
                return this.parseNewOrNewTarget();
              case 25:
              case 24:
                return this.parseTemplate(!1);
              case 15: {
                A = this.startNode(), this.next(), A.object = null;
                const fe = A.callee = this.parseNoCallExpr();
                if (fe.type === "MemberExpression")
                  return this.finishNode(A, "BindExpression");
                throw this.raise(C.UnsupportedBind, { at: fe });
              }
              case 136:
                return this.raise(C.PrivateInExpectedIn, { at: this.state.startLoc, identifierName: this.state.value }), this.parsePrivateName();
              case 33:
                return this.parseTopicReferenceThenEqualsSign(54, "%");
              case 32:
                return this.parseTopicReferenceThenEqualsSign(44, "^");
              case 37:
              case 38:
                return this.parseTopicReference("hack");
              case 44:
              case 54:
              case 27: {
                const fe = this.getPluginOption("pipelineOperator", "proposal");
                if (fe)
                  return this.parseTopicReference(fe);
                this.unexpected();
                break;
              }
              case 47: {
                const fe = this.input.codePointAt(this.nextTokenStart());
                Ee(fe) || fe === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
                break;
              }
              default:
                if ($(ee)) {
                  if (this.isContextual(125) && this.lookaheadInLineCharCode() === 123)
                    return this.parseModuleExpression();
                  const fe = this.state.potentialArrowAt === this.state.start, Se = this.state.containsEsc, Pe = this.parseIdentifier();
                  if (!Se && Pe.name === "async" && !this.canInsertSemicolon()) {
                    const { type: Re } = this.state;
                    if (Re === 68)
                      return this.resetPreviousNodeTrailingComments(Pe), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(Pe));
                    if ($(Re))
                      return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(Pe)) : Pe;
                    if (Re === 90)
                      return this.resetPreviousNodeTrailingComments(Pe), this.parseDo(this.startNodeAtNode(Pe), !0);
                  }
                  return fe && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(Pe), [Pe], !1)) : Pe;
                }
                this.unexpected();
            }
          }
          parseTopicReferenceThenEqualsSign(p, A) {
            const V = this.getPluginOption("pipelineOperator", "proposal");
            if (V)
              return this.state.type = p, this.state.value = A, this.state.pos--, this.state.end--, this.state.endLoc = d(this.state.endLoc, -1), this.parseTopicReference(V);
            this.unexpected();
          }
          parseTopicReference(p) {
            const A = this.startNode(), V = this.state.startLoc, ee = this.state.type;
            return this.next(), this.finishTopicReference(A, V, p, ee);
          }
          finishTopicReference(p, A, V, ee) {
            if (this.testTopicReferenceConfiguration(V, A, ee)) {
              const fe = V === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
              return this.topicReferenceIsAllowedInCurrentContext() || this.raise(V === "smart" ? C.PrimaryTopicNotAllowed : C.PipeTopicUnbound, { at: A }), this.registerTopicReference(), this.finishNode(p, fe);
            }
            throw this.raise(C.PipeTopicUnconfiguredToken, { at: A, token: ye(ee) });
          }
          testTopicReferenceConfiguration(p, A, V) {
            switch (p) {
              case "hack":
                return this.hasPlugin(["pipelineOperator", { topicToken: ye(V) }]);
              case "smart":
                return V === 27;
              default:
                throw this.raise(C.PipeTopicRequiresHackPipes, { at: A });
            }
          }
          parseAsyncArrowUnaryFunction(p) {
            this.prodParam.enter(mn(!0, this.prodParam.hasYield));
            const A = [this.parseIdentifier()];
            return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(C.LineTerminatorBeforeArrow, { at: this.state.curPosition() }), this.expect(19), this.parseArrowExpression(p, A, !0);
          }
          parseDo(p, A) {
            this.expectPlugin("doExpressions"), A && this.expectPlugin("asyncDoExpressions"), p.async = A, this.next();
            const V = this.state.labels;
            return this.state.labels = [], A ? (this.prodParam.enter(2), p.body = this.parseBlock(), this.prodParam.exit()) : p.body = this.parseBlock(), this.state.labels = V, this.finishNode(p, "DoExpression");
          }
          parseSuper() {
            const p = this.startNode();
            return this.next(), !this.match(10) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(C.UnexpectedSuper, { at: p }) : this.raise(C.SuperNotAllowed, { at: p }), this.match(10) || this.match(0) || this.match(16) || this.raise(C.UnsupportedSuper, { at: p }), this.finishNode(p, "Super");
          }
          parsePrivateName() {
            const p = this.startNode(), A = this.startNodeAt(d(this.state.startLoc, 1)), V = this.state.value;
            return this.next(), p.id = this.createIdentifier(A, V), this.finishNode(p, "PrivateName");
          }
          parseFunctionOrFunctionSent() {
            const p = this.startNode();
            if (this.next(), this.prodParam.hasYield && this.match(16)) {
              const A = this.createIdentifier(this.startNodeAtNode(p), "function");
              return this.next(), this.match(102) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(p, A, "sent");
            }
            return this.parseFunction(p);
          }
          parseMetaProperty(p, A, V) {
            p.meta = A;
            const ee = this.state.containsEsc;
            return p.property = this.parseIdentifier(!0), (p.property.name !== V || ee) && this.raise(C.UnsupportedMetaProperty, { at: p.property, target: A.name, onlyValidPropertyName: V }), this.finishNode(p, "MetaProperty");
          }
          parseImportMetaProperty(p) {
            const A = this.createIdentifier(this.startNodeAtNode(p), "import");
            return this.next(), this.isContextual(100) && (this.inModule || this.raise(C.ImportMetaOutsideModule, { at: A }), this.sawUnambiguousESM = !0), this.parseMetaProperty(p, A, "meta");
          }
          parseLiteralAtNode(p, A, V) {
            return this.addExtra(V, "rawValue", p), this.addExtra(V, "raw", this.input.slice(V.start, this.state.end)), V.value = p, this.next(), this.finishNode(V, A);
          }
          parseLiteral(p, A) {
            const V = this.startNode();
            return this.parseLiteralAtNode(p, A, V);
          }
          parseStringLiteral(p) {
            return this.parseLiteral(p, "StringLiteral");
          }
          parseNumericLiteral(p) {
            return this.parseLiteral(p, "NumericLiteral");
          }
          parseBigIntLiteral(p) {
            return this.parseLiteral(p, "BigIntLiteral");
          }
          parseDecimalLiteral(p) {
            return this.parseLiteral(p, "DecimalLiteral");
          }
          parseRegExpLiteral(p) {
            const A = this.parseLiteral(p.value, "RegExpLiteral");
            return A.pattern = p.pattern, A.flags = p.flags, A;
          }
          parseBooleanLiteral(p) {
            const A = this.startNode();
            return A.value = p, this.next(), this.finishNode(A, "BooleanLiteral");
          }
          parseNullLiteral() {
            const p = this.startNode();
            return this.next(), this.finishNode(p, "NullLiteral");
          }
          parseParenAndDistinguishExpression(p) {
            const A = this.state.startLoc;
            let V;
            this.next(), this.expressionScope.enter(new _r(1));
            const ee = this.state.maybeInArrowParameters, fe = this.state.inFSharpPipelineDirectBody;
            this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
            const Se = this.state.startLoc, Pe = [], Re = new yn();
            let je, ze, mt = !0;
            for (; !this.match(11); ) {
              if (mt)
                mt = !1;
              else if (this.expect(12, Re.optionalParametersLoc === null ? null : Re.optionalParametersLoc), this.match(11)) {
                ze = this.state.startLoc;
                break;
              }
              if (this.match(21)) {
                const Ut = this.state.startLoc;
                if (je = this.state.startLoc, Pe.push(this.parseParenItem(this.parseRestBinding(), Ut)), !this.checkCommaAfterRest(41))
                  break;
              } else
                Pe.push(this.parseMaybeAssignAllowIn(Re, this.parseParenItem));
            }
            const Mt = this.state.lastTokEndLoc;
            this.expect(11), this.state.maybeInArrowParameters = ee, this.state.inFSharpPipelineDirectBody = fe;
            let St = this.startNodeAt(A);
            return p && this.shouldParseArrow(Pe) && (St = this.parseArrow(St)) ? (this.checkDestructuringPrivate(Re), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(St, Pe, !1), St) : (this.expressionScope.exit(), Pe.length || this.unexpected(this.state.lastTokStartLoc), ze && this.unexpected(ze), je && this.unexpected(je), this.checkExpressionErrors(Re, !0), this.toReferencedListDeep(Pe, !0), Pe.length > 1 ? (V = this.startNodeAt(Se), V.expressions = Pe, this.finishNode(V, "SequenceExpression"), this.resetEndLocation(V, Mt)) : V = Pe[0], this.wrapParenthesis(A, V));
          }
          wrapParenthesis(p, A) {
            if (!this.options.createParenthesizedExpressions)
              return this.addExtra(A, "parenthesized", !0), this.addExtra(A, "parenStart", p.index), this.takeSurroundingComments(A, p.index, this.state.lastTokEndLoc.index), A;
            const V = this.startNodeAt(p);
            return V.expression = A, this.finishNode(V, "ParenthesizedExpression");
          }
          shouldParseArrow(p) {
            return !this.canInsertSemicolon();
          }
          parseArrow(p) {
            if (this.eat(19))
              return p;
          }
          parseParenItem(p, A) {
            return p;
          }
          parseNewOrNewTarget() {
            const p = this.startNode();
            if (this.next(), this.match(16)) {
              const A = this.createIdentifier(this.startNodeAtNode(p), "new");
              this.next();
              const V = this.parseMetaProperty(p, A, "target");
              return this.scope.inNonArrowFunction || this.scope.inClass || this.options.allowNewTargetOutsideFunction || this.raise(C.UnexpectedNewTarget, { at: V }), V;
            }
            return this.parseNew(p);
          }
          parseNew(p) {
            if (this.parseNewCallee(p), this.eat(10)) {
              const A = this.parseExprList(11);
              this.toReferencedList(A), p.arguments = A;
            } else
              p.arguments = [];
            return this.finishNode(p, "NewExpression");
          }
          parseNewCallee(p) {
            p.callee = this.parseNoCallExpr(), p.callee.type === "Import" && this.raise(C.ImportCallNotNewExpression, { at: p.callee });
          }
          parseTemplateElement(p) {
            const { start: A, startLoc: V, end: ee, value: fe } = this.state, Se = A + 1, Pe = this.startNodeAt(d(V, 1));
            fe === null && (p || this.raise(C.InvalidEscapeSequenceTemplate, { at: d(this.state.firstInvalidTemplateEscapePos, 1) }));
            const Re = this.match(24), je = Re ? -1 : -2, ze = ee + je;
            Pe.value = { raw: this.input.slice(Se, ze).replace(/\r\n?/g, `
`), cooked: fe === null ? null : fe.slice(1, je) }, Pe.tail = Re, this.next();
            const mt = this.finishNode(Pe, "TemplateElement");
            return this.resetEndLocation(mt, d(this.state.lastTokEndLoc, je)), mt;
          }
          parseTemplate(p) {
            const A = this.startNode();
            A.expressions = [];
            let V = this.parseTemplateElement(p);
            for (A.quasis = [V]; !V.tail; )
              A.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), A.quasis.push(V = this.parseTemplateElement(p));
            return this.finishNode(A, "TemplateLiteral");
          }
          parseTemplateSubstitution() {
            return this.parseExpression();
          }
          parseObjectLike(p, A, V, ee) {
            V && this.expectPlugin("recordAndTuple");
            const fe = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = !1;
            const Se = /* @__PURE__ */ Object.create(null);
            let Pe = !0;
            const Re = this.startNode();
            for (Re.properties = [], this.next(); !this.match(p); ) {
              if (Pe)
                Pe = !1;
              else if (this.expect(12), this.match(p)) {
                this.addTrailingCommaExtraToNode(Re);
                break;
              }
              let ze;
              A ? ze = this.parseBindingProperty() : (ze = this.parsePropertyDefinition(ee), this.checkProto(ze, V, Se, ee)), V && !this.isObjectProperty(ze) && ze.type !== "SpreadElement" && this.raise(C.InvalidRecordProperty, { at: ze }), ze.shorthand && this.addExtra(ze, "shorthand", !0), Re.properties.push(ze);
            }
            this.next(), this.state.inFSharpPipelineDirectBody = fe;
            let je = "ObjectExpression";
            return A ? je = "ObjectPattern" : V && (je = "RecordExpression"), this.finishNode(Re, je);
          }
          addTrailingCommaExtraToNode(p) {
            this.addExtra(p, "trailingComma", this.state.lastTokStart), this.addExtra(p, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
          }
          maybeAsyncOrAccessorProp(p) {
            return !p.computed && p.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
          }
          parsePropertyDefinition(p) {
            let A = [];
            if (this.match(26))
              for (this.hasPlugin("decorators") && this.raise(C.UnsupportedPropertyDecorator, { at: this.state.startLoc }); this.match(26); )
                A.push(this.parseDecorator());
            const V = this.startNode();
            let ee, fe = !1, Se = !1;
            if (this.match(21))
              return A.length && this.unexpected(), this.parseSpread();
            A.length && (V.decorators = A, A = []), V.method = !1, p && (ee = this.state.startLoc);
            let Pe = this.eat(55);
            this.parsePropertyNamePrefixOperator(V);
            const Re = this.state.containsEsc, je = this.parsePropertyName(V, p);
            if (!Pe && !Re && this.maybeAsyncOrAccessorProp(V)) {
              const ze = je.name;
              ze !== "async" || this.hasPrecedingLineBreak() || (fe = !0, this.resetPreviousNodeTrailingComments(je), Pe = this.eat(55), this.parsePropertyName(V)), ze !== "get" && ze !== "set" || (Se = !0, this.resetPreviousNodeTrailingComments(je), V.kind = ze, this.match(55) && (Pe = !0, this.raise(C.AccessorIsGenerator, { at: this.state.curPosition(), kind: ze }), this.next()), this.parsePropertyName(V));
            }
            return this.parseObjPropValue(V, ee, Pe, fe, !1, Se, p);
          }
          getGetterSetterExpectedParamCount(p) {
            return p.kind === "get" ? 0 : 1;
          }
          getObjectOrClassMethodParams(p) {
            return p.params;
          }
          checkGetterSetterParams(p) {
            var A;
            const V = this.getGetterSetterExpectedParamCount(p), ee = this.getObjectOrClassMethodParams(p);
            ee.length !== V && this.raise(p.kind === "get" ? C.BadGetterArity : C.BadSetterArity, { at: p }), p.kind === "set" && ((A = ee[ee.length - 1]) == null ? void 0 : A.type) === "RestElement" && this.raise(C.BadSetterRestParameter, { at: p });
          }
          parseObjectMethod(p, A, V, ee, fe) {
            if (fe) {
              const Se = this.parseMethod(p, A, !1, !1, !1, "ObjectMethod");
              return this.checkGetterSetterParams(Se), Se;
            }
            if (V || A || this.match(10))
              return ee && this.unexpected(), p.kind = "method", p.method = !0, this.parseMethod(p, A, V, !1, !1, "ObjectMethod");
          }
          parseObjectProperty(p, A, V, ee) {
            if (p.shorthand = !1, this.eat(14))
              return p.value = V ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(ee), this.finishNode(p, "ObjectProperty");
            if (!p.computed && p.key.type === "Identifier") {
              if (this.checkReservedWord(p.key.name, p.key.loc.start, !0, !1), V)
                p.value = this.parseMaybeDefault(A, Vr(p.key));
              else if (this.match(29)) {
                const fe = this.state.startLoc;
                ee != null ? ee.shorthandAssignLoc === null && (ee.shorthandAssignLoc = fe) : this.raise(C.InvalidCoverInitializedName, { at: fe }), p.value = this.parseMaybeDefault(A, Vr(p.key));
              } else
                p.value = Vr(p.key);
              return p.shorthand = !0, this.finishNode(p, "ObjectProperty");
            }
          }
          parseObjPropValue(p, A, V, ee, fe, Se, Pe) {
            const Re = this.parseObjectMethod(p, V, ee, fe, Se) || this.parseObjectProperty(p, A, fe, Pe);
            return Re || this.unexpected(), Re;
          }
          parsePropertyName(p, A) {
            if (this.eat(0))
              p.computed = !0, p.key = this.parseMaybeAssignAllowIn(), this.expect(3);
            else {
              const { type: V, value: ee } = this.state;
              let fe;
              if (Y(V))
                fe = this.parseIdentifier(!0);
              else
                switch (V) {
                  case 132:
                    fe = this.parseNumericLiteral(ee);
                    break;
                  case 131:
                    fe = this.parseStringLiteral(ee);
                    break;
                  case 133:
                    fe = this.parseBigIntLiteral(ee);
                    break;
                  case 134:
                    fe = this.parseDecimalLiteral(ee);
                    break;
                  case 136: {
                    const Se = this.state.startLoc;
                    A != null ? A.privateKeyLoc === null && (A.privateKeyLoc = Se) : this.raise(C.UnexpectedPrivateField, { at: Se }), fe = this.parsePrivateName();
                    break;
                  }
                  default:
                    this.unexpected();
                }
              p.key = fe, V !== 136 && (p.computed = !1);
            }
            return p.key;
          }
          initFunction(p, A) {
            p.id = null, p.generator = !1, p.async = A;
          }
          parseMethod(p, A, V, ee, fe, Se, Pe = !1) {
            this.initFunction(p, V), p.generator = A, this.scope.enter(18 | (Pe ? 64 : 0) | (fe ? 32 : 0)), this.prodParam.enter(mn(V, p.generator)), this.parseFunctionParams(p, ee);
            const Re = this.parseFunctionBodyAndFinish(p, Se, !0);
            return this.prodParam.exit(), this.scope.exit(), Re;
          }
          parseArrayLike(p, A, V, ee) {
            V && this.expectPlugin("recordAndTuple");
            const fe = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = !1;
            const Se = this.startNode();
            return this.next(), Se.elements = this.parseExprList(p, !V, ee, Se), this.state.inFSharpPipelineDirectBody = fe, this.finishNode(Se, V ? "TupleExpression" : "ArrayExpression");
          }
          parseArrowExpression(p, A, V, ee) {
            this.scope.enter(6);
            let fe = mn(V, !1);
            !this.match(5) && this.prodParam.hasIn && (fe |= 8), this.prodParam.enter(fe), this.initFunction(p, V);
            const Se = this.state.maybeInArrowParameters;
            return A && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(p, A, ee)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(p, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = Se, this.finishNode(p, "ArrowFunctionExpression");
          }
          setArrowFunctionParameters(p, A, V) {
            this.toAssignableList(A, V, !1), p.params = A;
          }
          parseFunctionBodyAndFinish(p, A, V = !1) {
            return this.parseFunctionBody(p, !1, V), this.finishNode(p, A);
          }
          parseFunctionBody(p, A, V = !1) {
            const ee = A && !this.match(5);
            if (this.expressionScope.enter(Mn()), ee)
              p.body = this.parseMaybeAssign(), this.checkParams(p, !1, A, !1);
            else {
              const fe = this.state.strict, Se = this.state.labels;
              this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), p.body = this.parseBlock(!0, !1, (Pe) => {
                const Re = !this.isSimpleParamList(p.params);
                Pe && Re && this.raise(C.IllegalLanguageModeDirective, { at: p.kind !== "method" && p.kind !== "constructor" || !p.key ? p : p.key.loc.end });
                const je = !fe && this.state.strict;
                this.checkParams(p, !(this.state.strict || A || V || Re), A, je), this.state.strict && p.id && this.checkIdentifier(p.id, 65, je);
              }), this.prodParam.exit(), this.state.labels = Se;
            }
            this.expressionScope.exit();
          }
          isSimpleParameter(p) {
            return p.type === "Identifier";
          }
          isSimpleParamList(p) {
            for (let A = 0, V = p.length; A < V; A++)
              if (!this.isSimpleParameter(p[A]))
                return !1;
            return !0;
          }
          checkParams(p, A, V, ee = !0) {
            const fe = !A && /* @__PURE__ */ new Set(), Se = { type: "FormalParameters" };
            for (const Pe of p.params)
              this.checkLVal(Pe, { in: Se, binding: 5, checkClashes: fe, strictModeChanged: ee });
          }
          parseExprList(p, A, V, ee) {
            const fe = [];
            let Se = !0;
            for (; !this.eat(p); ) {
              if (Se)
                Se = !1;
              else if (this.expect(12), this.match(p)) {
                ee && this.addTrailingCommaExtraToNode(ee), this.next();
                break;
              }
              fe.push(this.parseExprListItem(A, V));
            }
            return fe;
          }
          parseExprListItem(p, A, V) {
            let ee;
            if (this.match(12))
              p || this.raise(C.UnexpectedToken, { at: this.state.curPosition(), unexpected: "," }), ee = null;
            else if (this.match(21)) {
              const fe = this.state.startLoc;
              ee = this.parseParenItem(this.parseSpread(A), fe);
            } else if (this.match(17)) {
              this.expectPlugin("partialApplication"), V || this.raise(C.UnexpectedArgumentPlaceholder, { at: this.state.startLoc });
              const fe = this.startNode();
              this.next(), ee = this.finishNode(fe, "ArgumentPlaceholder");
            } else
              ee = this.parseMaybeAssignAllowIn(A, this.parseParenItem);
            return ee;
          }
          parseIdentifier(p) {
            const A = this.startNode(), V = this.parseIdentifierName(p);
            return this.createIdentifier(A, V);
          }
          createIdentifier(p, A) {
            return p.name = A, p.loc.identifierName = A, this.finishNode(p, "Identifier");
          }
          parseIdentifierName(p) {
            let A;
            const { startLoc: V, type: ee } = this.state;
            Y(ee) ? A = this.state.value : this.unexpected();
            const fe = ee <= 92;
            return p ? fe && this.replaceToken(130) : this.checkReservedWord(A, V, fe, !1), this.next(), A;
          }
          checkReservedWord(p, A, V, ee) {
            if (!(p.length > 10) && function(fe) {
              return tt.has(fe);
            }(p)) {
              if (V && function(fe) {
                return se.has(fe);
              }(p))
                return void this.raise(C.UnexpectedKeyword, { at: A, keyword: p });
              if ((this.state.strict ? ee ? We : _e : be)(p, this.inModule))
                this.raise(C.UnexpectedReservedWord, { at: A, reservedWord: p });
              else if (p === "yield") {
                if (this.prodParam.hasYield)
                  return void this.raise(C.YieldBindingIdentifier, { at: A });
              } else if (p === "await") {
                if (this.prodParam.hasAwait)
                  return void this.raise(C.AwaitBindingIdentifier, { at: A });
                if (this.scope.inStaticBlock)
                  return void this.raise(C.AwaitBindingIdentifierInStaticBlock, { at: A });
                this.expressionScope.recordAsyncArrowParametersError({ at: A });
              } else if (p === "arguments" && this.scope.inClassAndNotInNonArrowFunction)
                return void this.raise(C.ArgumentsInClass, { at: A });
            }
          }
          isAwaitAllowed() {
            return !!this.prodParam.hasAwait || !(!this.options.allowAwaitOutsideFunction || this.scope.inFunction);
          }
          parseAwait(p) {
            const A = this.startNodeAt(p);
            return this.expressionScope.recordParameterInitializerError(C.AwaitExpressionFormalParameter, { at: A }), this.eat(55) && this.raise(C.ObsoleteAwaitStar, { at: A }), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (A.argument = this.parseMaybeUnary(null, !0)), this.finishNode(A, "AwaitExpression");
          }
          isAmbiguousAwait() {
            if (this.hasPrecedingLineBreak())
              return !0;
            const { type: p } = this.state;
            return p === 53 || p === 10 || p === 0 || de(p) || p === 101 && !this.state.containsEsc || p === 135 || p === 56 || this.hasPlugin("v8intrinsic") && p === 54;
          }
          parseYield() {
            const p = this.startNode();
            this.expressionScope.recordParameterInitializerError(C.YieldInParameter, { at: p }), this.next();
            let A = !1, V = null;
            if (!this.hasPrecedingLineBreak())
              switch (A = this.eat(55), this.state.type) {
                case 13:
                case 137:
                case 8:
                case 11:
                case 3:
                case 9:
                case 14:
                case 12:
                  if (!A)
                    break;
                default:
                  V = this.parseMaybeAssign();
              }
            return p.delegate = A, p.argument = V, this.finishNode(p, "YieldExpression");
          }
          checkPipelineAtInfixOperator(p, A) {
            this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && p.type === "SequenceExpression" && this.raise(C.PipelineHeadSequenceExpression, { at: A });
          }
          parseSmartPipelineBodyInStyle(p, A) {
            if (this.isSimpleReference(p)) {
              const V = this.startNodeAt(A);
              return V.callee = p, this.finishNode(V, "PipelineBareFunction");
            }
            {
              const V = this.startNodeAt(A);
              return this.checkSmartPipeTopicBodyEarlyErrors(A), V.expression = p, this.finishNode(V, "PipelineTopicExpression");
            }
          }
          isSimpleReference(p) {
            switch (p.type) {
              case "MemberExpression":
                return !p.computed && this.isSimpleReference(p.object);
              case "Identifier":
                return !0;
              default:
                return !1;
            }
          }
          checkSmartPipeTopicBodyEarlyErrors(p) {
            if (this.match(19))
              throw this.raise(C.PipelineBodyNoArrow, { at: this.state.startLoc });
            this.topicReferenceWasUsedInCurrentContext() || this.raise(C.PipelineTopicUnused, { at: p });
          }
          withTopicBindingContext(p) {
            const A = this.state.topicContext;
            this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
            try {
              return p();
            } finally {
              this.state.topicContext = A;
            }
          }
          withSmartMixTopicForbiddingContext(p) {
            if (!this.hasPlugin(["pipelineOperator", { proposal: "smart" }]))
              return p();
            {
              const A = this.state.topicContext;
              this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
              try {
                return p();
              } finally {
                this.state.topicContext = A;
              }
            }
          }
          withSoloAwaitPermittingContext(p) {
            const A = this.state.soloAwait;
            this.state.soloAwait = !0;
            try {
              return p();
            } finally {
              this.state.soloAwait = A;
            }
          }
          allowInAnd(p) {
            const A = this.prodParam.currentFlags();
            if (8 & ~A) {
              this.prodParam.enter(8 | A);
              try {
                return p();
              } finally {
                this.prodParam.exit();
              }
            }
            return p();
          }
          disallowInAnd(p) {
            const A = this.prodParam.currentFlags();
            if (8 & A) {
              this.prodParam.enter(-9 & A);
              try {
                return p();
              } finally {
                this.prodParam.exit();
              }
            }
            return p();
          }
          registerTopicReference() {
            this.state.topicContext.maxTopicIndex = 0;
          }
          topicReferenceIsAllowedInCurrentContext() {
            return this.state.topicContext.maxNumOfResolvableTopics >= 1;
          }
          topicReferenceWasUsedInCurrentContext() {
            return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
          }
          parseFSharpPipelineBody(p) {
            const A = this.state.startLoc;
            this.state.potentialArrowAt = this.state.start;
            const V = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = !0;
            const ee = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), A, p);
            return this.state.inFSharpPipelineDirectBody = V, ee;
          }
          parseModuleExpression() {
            this.expectPlugin("moduleBlocks");
            const p = this.startNode();
            this.next(), this.match(5) || this.unexpected(null, 5);
            const A = this.startNodeAt(this.state.endLoc);
            this.next();
            const V = this.initializeScopes(!0);
            this.enterInitialScopes();
            try {
              p.body = this.parseProgram(A, 8, "module");
            } finally {
              V();
            }
            return this.finishNode(p, "ModuleExpression");
          }
          parsePropertyNamePrefixOperator(p) {
          }
        }
        const Ea = { kind: "loop" }, Dp = { kind: "switch" }, Np = /[\uD800-\uDFFF]/u, gl = /in(?:stanceof)?/y;
        class Rp extends hc {
          parseTopLevel(p, A) {
            return p.program = this.parseProgram(A), p.comments = this.state.comments, this.options.tokens && (p.tokens = function(V, ee) {
              for (let fe = 0; fe < V.length; fe++) {
                const Se = V[fe], { type: Pe } = Se;
                if (typeof Pe == "number") {
                  if (Pe === 136) {
                    const { loc: Re, start: je, value: ze, end: mt } = Se, Mt = je + 1, St = d(Re.start, 1);
                    V.splice(fe, 1, new Wt({ type: oe(27), value: "#", start: je, end: Mt, startLoc: Re.start, endLoc: St }), new Wt({ type: oe(130), value: ze, start: Mt, end: mt, startLoc: St, endLoc: Re.end })), fe++;
                    continue;
                  }
                  if (de(Pe)) {
                    const { loc: Re, start: je, value: ze, end: mt } = Se, Mt = je + 1, St = d(Re.start, 1);
                    let Ut, Cr, nr, hr, nn;
                    Ut = ee.charCodeAt(je) === 96 ? new Wt({ type: oe(22), value: "`", start: je, end: Mt, startLoc: Re.start, endLoc: St }) : new Wt({ type: oe(8), value: "}", start: je, end: Mt, startLoc: Re.start, endLoc: St }), Pe === 24 ? (nr = mt - 1, hr = d(Re.end, -1), Cr = ze === null ? null : ze.slice(1, -1), nn = new Wt({ type: oe(22), value: "`", start: nr, end: mt, startLoc: hr, endLoc: Re.end })) : (nr = mt - 2, hr = d(Re.end, -2), Cr = ze === null ? null : ze.slice(1, -2), nn = new Wt({ type: oe(23), value: "${", start: nr, end: mt, startLoc: hr, endLoc: Re.end })), V.splice(fe, 1, Ut, new Wt({ type: oe(20), value: Cr, start: Mt, end: nr, startLoc: St, endLoc: hr }), nn), fe += 2;
                    continue;
                  }
                  Se.type = oe(Pe);
                }
              }
              return V;
            }(this.tokens, this.input)), this.finishNode(p, "File");
          }
          parseProgram(p, A = 137, V = this.options.sourceType) {
            if (p.sourceType = V, p.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(p, !0, !0, A), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
              for (const [fe, Se] of Array.from(this.scope.undefinedExports))
                this.raise(C.ModuleExportUndefined, { at: Se, localName: fe });
            let ee;
            return ee = A === 137 ? this.finishNode(p, "Program") : this.finishNodeAt(p, "Program", d(this.state.startLoc, -1)), ee;
          }
          stmtToDirective(p) {
            const A = p;
            A.type = "Directive", A.value = A.expression, delete A.expression;
            const V = A.value, ee = V.value, fe = this.input.slice(V.start, V.end), Se = V.value = fe.slice(1, -1);
            return this.addExtra(V, "raw", fe), this.addExtra(V, "rawValue", Se), this.addExtra(V, "expressionValue", ee), V.type = "DirectiveLiteral", A;
          }
          parseInterpreterDirective() {
            if (!this.match(28))
              return null;
            const p = this.startNode();
            return p.value = this.state.value, this.next(), this.finishNode(p, "InterpreterDirective");
          }
          isLet() {
            return !!this.isContextual(99) && this.hasFollowingBindingAtom();
          }
          chStartsBindingIdentifier(p, A) {
            if (Ee(p)) {
              if (gl.lastIndex = A, gl.test(this.input)) {
                const V = this.codePointAtPos(gl.lastIndex);
                if (!Ae(V) && V !== 92)
                  return !1;
              }
              return !0;
            }
            return p === 92;
          }
          chStartsBindingPattern(p) {
            return p === 91 || p === 123;
          }
          hasFollowingBindingAtom() {
            const p = this.nextTokenStart(), A = this.codePointAtPos(p);
            return this.chStartsBindingPattern(A) || this.chStartsBindingIdentifier(A, p);
          }
          hasInLineFollowingBindingIdentifier() {
            const p = this.nextTokenInLineStart(), A = this.codePointAtPos(p);
            return this.chStartsBindingIdentifier(A, p);
          }
          startsUsingForOf() {
            const { type: p, containsEsc: A } = this.lookahead();
            return !(p === 101 && !A) && ($(p) && !this.hasFollowingLineBreak() ? (this.expectPlugin("explicitResourceManagement"), !0) : void 0);
          }
          startsAwaitUsing() {
            let p = this.nextTokenInLineStart();
            if (this.isUnparsedContextual(p, "using")) {
              p = this.nextTokenInLineStartSince(p + 5);
              const A = this.codePointAtPos(p);
              if (this.chStartsBindingIdentifier(A, p))
                return this.expectPlugin("explicitResourceManagement"), !0;
            }
            return !1;
          }
          parseModuleItem() {
            return this.parseStatementLike(15);
          }
          parseStatementListItem() {
            return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
          }
          parseStatementOrSloppyAnnexBFunctionDeclaration(p = !1) {
            let A = 0;
            return this.options.annexB && !this.state.strict && (A |= 4, p && (A |= 8)), this.parseStatementLike(A);
          }
          parseStatement() {
            return this.parseStatementLike(0);
          }
          parseStatementLike(p) {
            let A = null;
            return this.match(26) && (A = this.parseDecorators(!0)), this.parseStatementContent(p, A);
          }
          parseStatementContent(p, A) {
            const V = this.state.type, ee = this.startNode(), fe = !!(2 & p), Se = !!(4 & p), Pe = 1 & p;
            switch (V) {
              case 60:
                return this.parseBreakContinueStatement(ee, !0);
              case 63:
                return this.parseBreakContinueStatement(ee, !1);
              case 64:
                return this.parseDebuggerStatement(ee);
              case 90:
                return this.parseDoWhileStatement(ee);
              case 91:
                return this.parseForStatement(ee);
              case 68:
                if (this.lookaheadCharCode() === 46)
                  break;
                return Se || this.raise(this.state.strict ? C.StrictFunction : this.options.annexB ? C.SloppyFunctionAnnexB : C.SloppyFunction, { at: this.state.startLoc }), this.parseFunctionStatement(ee, !1, !fe && Se);
              case 80:
                return fe || this.unexpected(), this.parseClass(this.maybeTakeDecorators(A, ee), !0);
              case 69:
                return this.parseIfStatement(ee);
              case 70:
                return this.parseReturnStatement(ee);
              case 71:
                return this.parseSwitchStatement(ee);
              case 72:
                return this.parseThrowStatement(ee);
              case 73:
                return this.parseTryStatement(ee);
              case 96:
                if (!this.state.containsEsc && this.startsAwaitUsing())
                  return this.isAwaitAllowed() ? fe || this.raise(C.UnexpectedLexicalDeclaration, { at: ee }) : this.raise(C.AwaitUsingNotInAsyncContext, { at: ee }), this.next(), this.parseVarStatement(ee, "await using");
                break;
              case 105:
                if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
                  break;
                return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(C.UnexpectedUsingDeclaration, { at: this.state.startLoc }) : fe || this.raise(C.UnexpectedLexicalDeclaration, { at: this.state.startLoc }), this.parseVarStatement(ee, "using");
              case 99: {
                if (this.state.containsEsc)
                  break;
                const ze = this.nextTokenStart(), mt = this.codePointAtPos(ze);
                if (mt !== 91 && (!fe && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(mt, ze) && mt !== 123))
                  break;
              }
              case 75:
                fe || this.raise(C.UnexpectedLexicalDeclaration, { at: this.state.startLoc });
              case 74: {
                const ze = this.state.value;
                return this.parseVarStatement(ee, ze);
              }
              case 92:
                return this.parseWhileStatement(ee);
              case 76:
                return this.parseWithStatement(ee);
              case 5:
                return this.parseBlock();
              case 13:
                return this.parseEmptyStatement(ee);
              case 83: {
                const ze = this.lookaheadCharCode();
                if (ze === 40 || ze === 46)
                  break;
              }
              case 82: {
                let ze;
                return this.options.allowImportExportEverywhere || Pe || this.raise(C.UnexpectedImportExport, { at: this.state.startLoc }), this.next(), V === 83 ? (ze = this.parseImport(ee), ze.type !== "ImportDeclaration" || ze.importKind && ze.importKind !== "value" || (this.sawUnambiguousESM = !0)) : (ze = this.parseExport(ee, A), (ze.type !== "ExportNamedDeclaration" || ze.exportKind && ze.exportKind !== "value") && (ze.type !== "ExportAllDeclaration" || ze.exportKind && ze.exportKind !== "value") && ze.type !== "ExportDefaultDeclaration" || (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(ze), ze;
              }
              default:
                if (this.isAsyncFunction())
                  return fe || this.raise(C.AsyncFunctionInSingleStatementContext, { at: this.state.startLoc }), this.next(), this.parseFunctionStatement(ee, !0, !fe && Se);
            }
            const Re = this.state.value, je = this.parseExpression();
            return $(V) && je.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(ee, Re, je, p) : this.parseExpressionStatement(ee, je, A);
          }
          assertModuleNodeAllowed(p) {
            this.options.allowImportExportEverywhere || this.inModule || this.raise(C.ImportOutsideModule, { at: p });
          }
          decoratorsEnabledBeforeExport() {
            return !!this.hasPlugin("decorators-legacy") || this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
          }
          maybeTakeDecorators(p, A, V) {
            return p && (A.decorators && A.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(C.DecoratorsBeforeAfterExport, { at: A.decorators[0] }), A.decorators.unshift(...p)) : A.decorators = p, this.resetStartLocationFromNode(A, p[0]), V && this.resetStartLocationFromNode(V, A)), A;
          }
          canHaveLeadingDecorator() {
            return this.match(80);
          }
          parseDecorators(p) {
            const A = [];
            do
              A.push(this.parseDecorator());
            while (this.match(26));
            if (this.match(82))
              p || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(C.DecoratorExportClass, { at: this.state.startLoc });
            else if (!this.canHaveLeadingDecorator())
              throw this.raise(C.UnexpectedLeadingDecorator, { at: this.state.startLoc });
            return A;
          }
          parseDecorator() {
            this.expectOnePlugin(["decorators", "decorators-legacy"]);
            const p = this.startNode();
            if (this.next(), this.hasPlugin("decorators")) {
              const A = this.state.startLoc;
              let V;
              if (this.match(10)) {
                const ee = this.state.startLoc;
                this.next(), V = this.parseExpression(), this.expect(11), V = this.wrapParenthesis(ee, V);
                const fe = this.state.startLoc;
                p.expression = this.parseMaybeDecoratorArguments(V), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && p.expression !== V && this.raise(C.DecoratorArgumentsOutsideParentheses, { at: fe });
              } else {
                for (V = this.parseIdentifier(!1); this.eat(16); ) {
                  const ee = this.startNodeAt(A);
                  ee.object = V, this.match(136) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), ee.property = this.parsePrivateName()) : ee.property = this.parseIdentifier(!0), ee.computed = !1, V = this.finishNode(ee, "MemberExpression");
                }
                p.expression = this.parseMaybeDecoratorArguments(V);
              }
            } else
              p.expression = this.parseExprSubscripts();
            return this.finishNode(p, "Decorator");
          }
          parseMaybeDecoratorArguments(p) {
            if (this.eat(10)) {
              const A = this.startNodeAtNode(p);
              return A.callee = p, A.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(A.arguments), this.finishNode(A, "CallExpression");
            }
            return p;
          }
          parseBreakContinueStatement(p, A) {
            return this.next(), this.isLineTerminator() ? p.label = null : (p.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(p, A), this.finishNode(p, A ? "BreakStatement" : "ContinueStatement");
          }
          verifyBreakContinue(p, A) {
            let V;
            for (V = 0; V < this.state.labels.length; ++V) {
              const ee = this.state.labels[V];
              if ((p.label == null || ee.name === p.label.name) && (ee.kind != null && (A || ee.kind === "loop") || p.label && A))
                break;
            }
            if (V === this.state.labels.length) {
              const ee = A ? "BreakStatement" : "ContinueStatement";
              this.raise(C.IllegalBreakContinue, { at: p, type: ee });
            }
          }
          parseDebuggerStatement(p) {
            return this.next(), this.semicolon(), this.finishNode(p, "DebuggerStatement");
          }
          parseHeaderExpression() {
            this.expect(10);
            const p = this.parseExpression();
            return this.expect(11), p;
          }
          parseDoWhileStatement(p) {
            return this.next(), this.state.labels.push(Ea), p.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), p.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(p, "DoWhileStatement");
          }
          parseForStatement(p) {
            this.next(), this.state.labels.push(Ea);
            let A = null;
            if (this.isAwaitAllowed() && this.eatContextual(96) && (A = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13))
              return A !== null && this.unexpected(A), this.parseFor(p, null);
            const V = this.isContextual(99);
            {
              const Re = this.isContextual(96) && this.startsAwaitUsing(), je = Re || this.isContextual(105) && this.startsUsingForOf(), ze = V && this.hasFollowingBindingAtom() || je;
              if (this.match(74) || this.match(75) || ze) {
                const mt = this.startNode();
                let Mt;
                Re ? (Mt = "await using", this.isAwaitAllowed() || this.raise(C.AwaitUsingNotInAsyncContext, { at: this.state.startLoc }), this.next()) : Mt = this.state.value, this.next(), this.parseVar(mt, !0, Mt);
                const St = this.finishNode(mt, "VariableDeclaration"), Ut = this.match(58);
                return Ut && je && this.raise(C.ForInUsing, { at: St }), (Ut || this.isContextual(101)) && St.declarations.length === 1 ? this.parseForIn(p, St, A) : (A !== null && this.unexpected(A), this.parseFor(p, St));
              }
            }
            const ee = this.isContextual(95), fe = new yn(), Se = this.parseExpression(!0, fe), Pe = this.isContextual(101);
            if (Pe && (V && this.raise(C.ForOfLet, { at: Se }), A === null && ee && Se.type === "Identifier" && this.raise(C.ForOfAsync, { at: Se })), Pe || this.match(58)) {
              this.checkDestructuringPrivate(fe), this.toAssignable(Se, !0);
              const Re = Pe ? "ForOfStatement" : "ForInStatement";
              return this.checkLVal(Se, { in: { type: Re } }), this.parseForIn(p, Se, A);
            }
            return this.checkExpressionErrors(fe, !0), A !== null && this.unexpected(A), this.parseFor(p, Se);
          }
          parseFunctionStatement(p, A, V) {
            return this.next(), this.parseFunction(p, 1 | (V ? 2 : 0) | (A ? 8 : 0));
          }
          parseIfStatement(p) {
            return this.next(), p.test = this.parseHeaderExpression(), p.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), p.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(p, "IfStatement");
          }
          parseReturnStatement(p) {
            return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(C.IllegalReturn, { at: this.state.startLoc }), this.next(), this.isLineTerminator() ? p.argument = null : (p.argument = this.parseExpression(), this.semicolon()), this.finishNode(p, "ReturnStatement");
          }
          parseSwitchStatement(p) {
            this.next(), p.discriminant = this.parseHeaderExpression();
            const A = p.cases = [];
            let V;
            this.expect(5), this.state.labels.push(Dp), this.scope.enter(0);
            for (let ee; !this.match(8); )
              if (this.match(61) || this.match(65)) {
                const fe = this.match(61);
                V && this.finishNode(V, "SwitchCase"), A.push(V = this.startNode()), V.consequent = [], this.next(), fe ? V.test = this.parseExpression() : (ee && this.raise(C.MultipleDefaultsInSwitch, { at: this.state.lastTokStartLoc }), ee = !0, V.test = null), this.expect(14);
              } else
                V ? V.consequent.push(this.parseStatementListItem()) : this.unexpected();
            return this.scope.exit(), V && this.finishNode(V, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(p, "SwitchStatement");
          }
          parseThrowStatement(p) {
            return this.next(), this.hasPrecedingLineBreak() && this.raise(C.NewlineAfterThrow, { at: this.state.lastTokEndLoc }), p.argument = this.parseExpression(), this.semicolon(), this.finishNode(p, "ThrowStatement");
          }
          parseCatchClauseParam() {
            const p = this.parseBindingAtom();
            return this.scope.enter(this.options.annexB && p.type === "Identifier" ? 8 : 0), this.checkLVal(p, { in: { type: "CatchClause" }, binding: 9 }), p;
          }
          parseTryStatement(p) {
            if (this.next(), p.block = this.parseBlock(), p.handler = null, this.match(62)) {
              const A = this.startNode();
              this.next(), this.match(10) ? (this.expect(10), A.param = this.parseCatchClauseParam(), this.expect(11)) : (A.param = null, this.scope.enter(0)), A.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), p.handler = this.finishNode(A, "CatchClause");
            }
            return p.finalizer = this.eat(67) ? this.parseBlock() : null, p.handler || p.finalizer || this.raise(C.NoCatchOrFinally, { at: p }), this.finishNode(p, "TryStatement");
          }
          parseVarStatement(p, A, V = !1) {
            return this.next(), this.parseVar(p, !1, A, V), this.semicolon(), this.finishNode(p, "VariableDeclaration");
          }
          parseWhileStatement(p) {
            return this.next(), p.test = this.parseHeaderExpression(), this.state.labels.push(Ea), p.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(p, "WhileStatement");
          }
          parseWithStatement(p) {
            return this.state.strict && this.raise(C.StrictWith, { at: this.state.startLoc }), this.next(), p.object = this.parseHeaderExpression(), p.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(p, "WithStatement");
          }
          parseEmptyStatement(p) {
            return this.next(), this.finishNode(p, "EmptyStatement");
          }
          parseLabeledStatement(p, A, V, ee) {
            for (const Pe of this.state.labels)
              Pe.name === A && this.raise(C.LabelRedeclaration, { at: V, labelName: A });
            const fe = (Se = this.state.type) >= 90 && Se <= 92 ? "loop" : this.match(71) ? "switch" : null;
            var Se;
            for (let Pe = this.state.labels.length - 1; Pe >= 0; Pe--) {
              const Re = this.state.labels[Pe];
              if (Re.statementStart !== p.start)
                break;
              Re.statementStart = this.state.start, Re.kind = fe;
            }
            return this.state.labels.push({ name: A, kind: fe, statementStart: this.state.start }), p.body = 8 & ee ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), p.label = V, this.finishNode(p, "LabeledStatement");
          }
          parseExpressionStatement(p, A, V) {
            return p.expression = A, this.semicolon(), this.finishNode(p, "ExpressionStatement");
          }
          parseBlock(p = !1, A = !0, V) {
            const ee = this.startNode();
            return p && this.state.strictErrors.clear(), this.expect(5), A && this.scope.enter(0), this.parseBlockBody(ee, p, !1, 8, V), A && this.scope.exit(), this.finishNode(ee, "BlockStatement");
          }
          isValidDirective(p) {
            return p.type === "ExpressionStatement" && p.expression.type === "StringLiteral" && !p.expression.extra.parenthesized;
          }
          parseBlockBody(p, A, V, ee, fe) {
            const Se = p.body = [], Pe = p.directives = [];
            this.parseBlockOrModuleBlockBody(Se, A ? Pe : void 0, V, ee, fe);
          }
          parseBlockOrModuleBlockBody(p, A, V, ee, fe) {
            const Se = this.state.strict;
            let Pe = !1, Re = !1;
            for (; !this.match(ee); ) {
              const je = V ? this.parseModuleItem() : this.parseStatementListItem();
              if (A && !Re) {
                if (this.isValidDirective(je)) {
                  const ze = this.stmtToDirective(je);
                  A.push(ze), Pe || ze.value.value !== "use strict" || (Pe = !0, this.setStrict(!0));
                  continue;
                }
                Re = !0, this.state.strictErrors.clear();
              }
              p.push(je);
            }
            fe == null || fe.call(this, Pe), Se || this.setStrict(!1), this.next();
          }
          parseFor(p, A) {
            return p.init = A, this.semicolon(!1), p.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), p.update = this.match(11) ? null : this.parseExpression(), this.expect(11), p.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(p, "ForStatement");
          }
          parseForIn(p, A, V) {
            const ee = this.match(58);
            return this.next(), ee ? V !== null && this.unexpected(V) : p.await = V !== null, A.type !== "VariableDeclaration" || A.declarations[0].init == null || ee && this.options.annexB && !this.state.strict && A.kind === "var" && A.declarations[0].id.type === "Identifier" || this.raise(C.ForInOfLoopInitializer, { at: A, type: ee ? "ForInStatement" : "ForOfStatement" }), A.type === "AssignmentPattern" && this.raise(C.InvalidLhs, { at: A, ancestor: { type: "ForStatement" } }), p.left = A, p.right = ee ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), p.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(p, ee ? "ForInStatement" : "ForOfStatement");
          }
          parseVar(p, A, V, ee = !1) {
            const fe = p.declarations = [];
            for (p.kind = V; ; ) {
              const Se = this.startNode();
              if (this.parseVarId(Se, V), Se.init = this.eat(29) ? A ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, Se.init !== null || ee || (Se.id.type === "Identifier" || A && (this.match(58) || this.isContextual(101)) ? V !== "const" || this.match(58) || this.isContextual(101) || this.raise(C.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "const" }) : this.raise(C.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "destructuring" })), fe.push(this.finishNode(Se, "VariableDeclarator")), !this.eat(12))
                break;
            }
            return p;
          }
          parseVarId(p, A) {
            const V = this.parseBindingAtom();
            this.checkLVal(V, { in: { type: "VariableDeclarator" }, binding: A === "var" ? 5 : 8201 }), p.id = V;
          }
          parseAsyncFunctionExpression(p) {
            return this.parseFunction(p, 8);
          }
          parseFunction(p, A = 0) {
            const V = 2 & A, ee = !!(1 & A), fe = ee && !(4 & A), Se = !!(8 & A);
            this.initFunction(p, Se), this.match(55) && (V && this.raise(C.GeneratorInSingleStatementContext, { at: this.state.startLoc }), this.next(), p.generator = !0), ee && (p.id = this.parseFunctionId(fe));
            const Pe = this.state.maybeInArrowParameters;
            return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(mn(Se, p.generator)), ee || (p.id = this.parseFunctionId()), this.parseFunctionParams(p, !1), this.withSmartMixTopicForbiddingContext(() => {
              this.parseFunctionBodyAndFinish(p, ee ? "FunctionDeclaration" : "FunctionExpression");
            }), this.prodParam.exit(), this.scope.exit(), ee && !V && this.registerFunctionStatementId(p), this.state.maybeInArrowParameters = Pe, p;
          }
          parseFunctionId(p) {
            return p || $(this.state.type) ? this.parseIdentifier() : null;
          }
          parseFunctionParams(p, A) {
            this.expect(10), this.expressionScope.enter(new Ur(3)), p.params = this.parseBindingList(11, 41, 2 | (A ? 4 : 0)), this.expressionScope.exit();
          }
          registerFunctionStatementId(p) {
            p.id && this.scope.declareName(p.id.name, !this.options.annexB || this.state.strict || p.generator || p.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, p.id.loc.start);
          }
          parseClass(p, A, V) {
            this.next();
            const ee = this.state.strict;
            return this.state.strict = !0, this.parseClassId(p, A, V), this.parseClassSuper(p), p.body = this.parseClassBody(!!p.superClass, ee), this.finishNode(p, A ? "ClassDeclaration" : "ClassExpression");
          }
          isClassProperty() {
            return this.match(29) || this.match(13) || this.match(8);
          }
          isClassMethod() {
            return this.match(10);
          }
          isNonstaticConstructor(p) {
            return !(p.computed || p.static || p.key.name !== "constructor" && p.key.value !== "constructor");
          }
          parseClassBody(p, A) {
            this.classScope.enter();
            const V = { hadConstructor: !1, hadSuperClass: p };
            let ee = [];
            const fe = this.startNode();
            if (fe.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
              for (; !this.match(8); ) {
                if (this.eat(13)) {
                  if (ee.length > 0)
                    throw this.raise(C.DecoratorSemicolon, { at: this.state.lastTokEndLoc });
                  continue;
                }
                if (this.match(26)) {
                  ee.push(this.parseDecorator());
                  continue;
                }
                const Se = this.startNode();
                ee.length && (Se.decorators = ee, this.resetStartLocationFromNode(Se, ee[0]), ee = []), this.parseClassMember(fe, Se, V), Se.kind === "constructor" && Se.decorators && Se.decorators.length > 0 && this.raise(C.DecoratorConstructor, { at: Se });
              }
            }), this.state.strict = A, this.next(), ee.length)
              throw this.raise(C.TrailingDecorator, { at: this.state.startLoc });
            return this.classScope.exit(), this.finishNode(fe, "ClassBody");
          }
          parseClassMemberFromModifier(p, A) {
            const V = this.parseIdentifier(!0);
            if (this.isClassMethod()) {
              const ee = A;
              return ee.kind = "method", ee.computed = !1, ee.key = V, ee.static = !1, this.pushClassMethod(p, ee, !1, !1, !1, !1), !0;
            }
            if (this.isClassProperty()) {
              const ee = A;
              return ee.computed = !1, ee.key = V, ee.static = !1, p.body.push(this.parseClassProperty(ee)), !0;
            }
            return this.resetPreviousNodeTrailingComments(V), !1;
          }
          parseClassMember(p, A, V) {
            const ee = this.isContextual(104);
            if (ee) {
              if (this.parseClassMemberFromModifier(p, A))
                return;
              if (this.eat(5))
                return void this.parseClassStaticBlock(p, A);
            }
            this.parseClassMemberWithIsStatic(p, A, V, ee);
          }
          parseClassMemberWithIsStatic(p, A, V, ee) {
            const fe = A, Se = A, Pe = A, Re = A, je = A, ze = fe, mt = fe;
            if (A.static = ee, this.parsePropertyNamePrefixOperator(A), this.eat(55)) {
              ze.kind = "method";
              const nr = this.match(136);
              return this.parseClassElementName(ze), nr ? void this.pushClassPrivateMethod(p, Se, !0, !1) : (this.isNonstaticConstructor(fe) && this.raise(C.ConstructorIsGenerator, { at: fe.key }), void this.pushClassMethod(p, fe, !0, !1, !1, !1));
            }
            const Mt = $(this.state.type) && !this.state.containsEsc, St = this.match(136), Ut = this.parseClassElementName(A), Cr = this.state.startLoc;
            if (this.parsePostMemberNameModifiers(mt), this.isClassMethod()) {
              if (ze.kind = "method", St)
                return void this.pushClassPrivateMethod(p, Se, !1, !1);
              const nr = this.isNonstaticConstructor(fe);
              let hr = !1;
              nr && (fe.kind = "constructor", V.hadConstructor && !this.hasPlugin("typescript") && this.raise(C.DuplicateConstructor, { at: Ut }), nr && this.hasPlugin("typescript") && A.override && this.raise(C.OverrideOnConstructor, { at: Ut }), V.hadConstructor = !0, hr = V.hadSuperClass), this.pushClassMethod(p, fe, !1, !1, nr, hr);
            } else if (this.isClassProperty())
              St ? this.pushClassPrivateProperty(p, Re) : this.pushClassProperty(p, Pe);
            else if (Mt && Ut.name === "async" && !this.isLineTerminator()) {
              this.resetPreviousNodeTrailingComments(Ut);
              const nr = this.eat(55);
              mt.optional && this.unexpected(Cr), ze.kind = "method";
              const hr = this.match(136);
              this.parseClassElementName(ze), this.parsePostMemberNameModifiers(mt), hr ? this.pushClassPrivateMethod(p, Se, nr, !0) : (this.isNonstaticConstructor(fe) && this.raise(C.ConstructorIsAsync, { at: fe.key }), this.pushClassMethod(p, fe, nr, !0, !1, !1));
            } else if (!Mt || Ut.name !== "get" && Ut.name !== "set" || this.match(55) && this.isLineTerminator())
              if (Mt && Ut.name === "accessor" && !this.isLineTerminator()) {
                this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(Ut);
                const nr = this.match(136);
                this.parseClassElementName(Pe), this.pushClassAccessorProperty(p, je, nr);
              } else
                this.isLineTerminator() ? St ? this.pushClassPrivateProperty(p, Re) : this.pushClassProperty(p, Pe) : this.unexpected();
            else {
              this.resetPreviousNodeTrailingComments(Ut), ze.kind = Ut.name;
              const nr = this.match(136);
              this.parseClassElementName(fe), nr ? this.pushClassPrivateMethod(p, Se, !1, !1) : (this.isNonstaticConstructor(fe) && this.raise(C.ConstructorIsAccessor, { at: fe.key }), this.pushClassMethod(p, fe, !1, !1, !1, !1)), this.checkGetterSetterParams(fe);
            }
          }
          parseClassElementName(p) {
            const { type: A, value: V } = this.state;
            if (A !== 130 && A !== 131 || !p.static || V !== "prototype" || this.raise(C.StaticPrototype, { at: this.state.startLoc }), A === 136) {
              V === "constructor" && this.raise(C.ConstructorClassPrivateField, { at: this.state.startLoc });
              const ee = this.parsePrivateName();
              return p.key = ee, ee;
            }
            return this.parsePropertyName(p);
          }
          parseClassStaticBlock(p, A) {
            var V;
            this.scope.enter(208);
            const ee = this.state.labels;
            this.state.labels = [], this.prodParam.enter(0);
            const fe = A.body = [];
            this.parseBlockOrModuleBlockBody(fe, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = ee, p.body.push(this.finishNode(A, "StaticBlock")), (V = A.decorators) != null && V.length && this.raise(C.DecoratorStaticBlock, { at: A });
          }
          pushClassProperty(p, A) {
            A.computed || A.key.name !== "constructor" && A.key.value !== "constructor" || this.raise(C.ConstructorClassField, { at: A.key }), p.body.push(this.parseClassProperty(A));
          }
          pushClassPrivateProperty(p, A) {
            const V = this.parseClassPrivateProperty(A);
            p.body.push(V), this.classScope.declarePrivateName(this.getPrivateNameSV(V.key), 0, V.key.loc.start);
          }
          pushClassAccessorProperty(p, A, V) {
            if (!V && !A.computed) {
              const fe = A.key;
              fe.name !== "constructor" && fe.value !== "constructor" || this.raise(C.ConstructorClassField, { at: fe });
            }
            const ee = this.parseClassAccessorProperty(A);
            p.body.push(ee), V && this.classScope.declarePrivateName(this.getPrivateNameSV(ee.key), 0, ee.key.loc.start);
          }
          pushClassMethod(p, A, V, ee, fe, Se) {
            p.body.push(this.parseMethod(A, V, ee, fe, Se, "ClassMethod", !0));
          }
          pushClassPrivateMethod(p, A, V, ee) {
            const fe = this.parseMethod(A, V, ee, !1, !1, "ClassPrivateMethod", !0);
            p.body.push(fe);
            const Se = fe.kind === "get" ? fe.static ? 6 : 2 : fe.kind === "set" ? fe.static ? 5 : 1 : 0;
            this.declareClassPrivateMethodInScope(fe, Se);
          }
          declareClassPrivateMethodInScope(p, A) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(p.key), A, p.key.loc.start);
          }
          parsePostMemberNameModifiers(p) {
          }
          parseClassPrivateProperty(p) {
            return this.parseInitializer(p), this.semicolon(), this.finishNode(p, "ClassPrivateProperty");
          }
          parseClassProperty(p) {
            return this.parseInitializer(p), this.semicolon(), this.finishNode(p, "ClassProperty");
          }
          parseClassAccessorProperty(p) {
            return this.parseInitializer(p), this.semicolon(), this.finishNode(p, "ClassAccessorProperty");
          }
          parseInitializer(p) {
            this.scope.enter(80), this.expressionScope.enter(Mn()), this.prodParam.enter(0), p.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
          }
          parseClassId(p, A, V, ee = 8331) {
            if ($(this.state.type))
              p.id = this.parseIdentifier(), A && this.declareNameFromIdentifier(p.id, ee);
            else {
              if (!V && A)
                throw this.raise(C.MissingClassName, { at: this.state.startLoc });
              p.id = null;
            }
          }
          parseClassSuper(p) {
            p.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
          }
          parseExport(p, A) {
            const V = this.parseMaybeImportPhase(p, !0), ee = this.maybeParseExportDefaultSpecifier(p, V), fe = !ee || this.eat(12), Se = fe && this.eatExportStar(p), Pe = Se && this.maybeParseExportNamespaceSpecifier(p), Re = fe && (!Pe || this.eat(12)), je = ee || Se;
            if (Se && !Pe) {
              if (ee && this.unexpected(), A)
                throw this.raise(C.UnsupportedDecoratorExport, { at: p });
              return this.parseExportFrom(p, !0), this.finishNode(p, "ExportAllDeclaration");
            }
            const ze = this.maybeParseExportNamedSpecifiers(p);
            let mt;
            if (ee && fe && !Se && !ze && this.unexpected(null, 5), Pe && Re && this.unexpected(null, 97), je || ze) {
              if (mt = !1, A)
                throw this.raise(C.UnsupportedDecoratorExport, { at: p });
              this.parseExportFrom(p, je);
            } else
              mt = this.maybeParseExportDeclaration(p);
            if (je || ze || mt) {
              var Mt;
              const St = p;
              if (this.checkExport(St, !0, !1, !!St.source), ((Mt = St.declaration) == null ? void 0 : Mt.type) === "ClassDeclaration")
                this.maybeTakeDecorators(A, St.declaration, St);
              else if (A)
                throw this.raise(C.UnsupportedDecoratorExport, { at: p });
              return this.finishNode(St, "ExportNamedDeclaration");
            }
            if (this.eat(65)) {
              const St = p, Ut = this.parseExportDefaultExpression();
              if (St.declaration = Ut, Ut.type === "ClassDeclaration")
                this.maybeTakeDecorators(A, Ut, St);
              else if (A)
                throw this.raise(C.UnsupportedDecoratorExport, { at: p });
              return this.checkExport(St, !0, !0), this.finishNode(St, "ExportDefaultDeclaration");
            }
            this.unexpected(null, 5);
          }
          eatExportStar(p) {
            return this.eat(55);
          }
          maybeParseExportDefaultSpecifier(p, A) {
            if (A || this.isExportDefaultSpecifier()) {
              this.expectPlugin("exportDefaultFrom", A == null ? void 0 : A.loc.start);
              const V = A || this.parseIdentifier(!0), ee = this.startNodeAtNode(V);
              return ee.exported = V, p.specifiers = [this.finishNode(ee, "ExportDefaultSpecifier")], !0;
            }
            return !1;
          }
          maybeParseExportNamespaceSpecifier(p) {
            if (this.isContextual(93)) {
              p.specifiers || (p.specifiers = []);
              const A = this.startNodeAt(this.state.lastTokStartLoc);
              return this.next(), A.exported = this.parseModuleExportName(), p.specifiers.push(this.finishNode(A, "ExportNamespaceSpecifier")), !0;
            }
            return !1;
          }
          maybeParseExportNamedSpecifiers(p) {
            if (this.match(5)) {
              p.specifiers || (p.specifiers = []);
              const A = p.exportKind === "type";
              return p.specifiers.push(...this.parseExportSpecifiers(A)), p.source = null, p.declaration = null, this.hasPlugin("importAssertions") && (p.assertions = []), !0;
            }
            return !1;
          }
          maybeParseExportDeclaration(p) {
            return !!this.shouldParseExportDeclaration() && (p.specifiers = [], p.source = null, this.hasPlugin("importAssertions") && (p.assertions = []), p.declaration = this.parseExportDeclaration(p), !0);
          }
          isAsyncFunction() {
            if (!this.isContextual(95))
              return !1;
            const p = this.nextTokenInLineStart();
            return this.isUnparsedContextual(p, "function");
          }
          parseExportDefaultExpression() {
            const p = this.startNode();
            if (this.match(68))
              return this.next(), this.parseFunction(p, 5);
            if (this.isAsyncFunction())
              return this.next(), this.next(), this.parseFunction(p, 13);
            if (this.match(80))
              return this.parseClass(p, !0, !0);
            if (this.match(26))
              return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(C.DecoratorBeforeExport, { at: this.state.startLoc }), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
            if (this.match(75) || this.match(74) || this.isLet())
              throw this.raise(C.UnsupportedDefaultExport, { at: this.state.startLoc });
            const A = this.parseMaybeAssignAllowIn();
            return this.semicolon(), A;
          }
          parseExportDeclaration(p) {
            return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
          }
          isExportDefaultSpecifier() {
            const { type: p } = this.state;
            if ($(p)) {
              if (p === 95 && !this.state.containsEsc || p === 99)
                return !1;
              if ((p === 128 || p === 127) && !this.state.containsEsc) {
                const { type: ee } = this.lookahead();
                if ($(ee) && ee !== 97 || ee === 5)
                  return this.expectOnePlugin(["flow", "typescript"]), !1;
              }
            } else if (!this.match(65))
              return !1;
            const A = this.nextTokenStart(), V = this.isUnparsedContextual(A, "from");
            if (this.input.charCodeAt(A) === 44 || $(this.state.type) && V)
              return !0;
            if (this.match(65) && V) {
              const ee = this.input.charCodeAt(this.nextTokenStartSince(A + 4));
              return ee === 34 || ee === 39;
            }
            return !1;
          }
          parseExportFrom(p, A) {
            this.eatContextual(97) ? (p.source = this.parseImportSource(), this.checkExport(p), this.maybeParseImportAttributes(p), this.checkJSONModuleImport(p)) : A && this.unexpected(), this.semicolon();
          }
          shouldParseExportDeclaration() {
            const { type: p } = this.state;
            return p === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(C.DecoratorBeforeExport, { at: this.state.startLoc }), !0) : p === 74 || p === 75 || p === 68 || p === 80 || this.isLet() || this.isAsyncFunction();
          }
          checkExport(p, A, V, ee) {
            var fe;
            if (A) {
              if (V) {
                if (this.checkDuplicateExports(p, "default"), this.hasPlugin("exportDefaultFrom")) {
                  var Se;
                  const Pe = p.declaration;
                  Pe.type !== "Identifier" || Pe.name !== "from" || Pe.end - Pe.start != 4 || (Se = Pe.extra) != null && Se.parenthesized || this.raise(C.ExportDefaultFromAsIdentifier, { at: Pe });
                }
              } else if ((fe = p.specifiers) != null && fe.length)
                for (const Pe of p.specifiers) {
                  const { exported: Re } = Pe, je = Re.type === "Identifier" ? Re.name : Re.value;
                  if (this.checkDuplicateExports(Pe, je), !ee && Pe.local) {
                    const { local: ze } = Pe;
                    ze.type !== "Identifier" ? this.raise(C.ExportBindingIsString, { at: Pe, localName: ze.value, exportName: je }) : (this.checkReservedWord(ze.name, ze.loc.start, !0, !1), this.scope.checkLocalExport(ze));
                  }
                }
              else if (p.declaration) {
                if (p.declaration.type === "FunctionDeclaration" || p.declaration.type === "ClassDeclaration") {
                  const Pe = p.declaration.id;
                  if (!Pe)
                    throw new Error("Assertion failure");
                  this.checkDuplicateExports(p, Pe.name);
                } else if (p.declaration.type === "VariableDeclaration")
                  for (const Pe of p.declaration.declarations)
                    this.checkDeclaration(Pe.id);
              }
            }
          }
          checkDeclaration(p) {
            if (p.type === "Identifier")
              this.checkDuplicateExports(p, p.name);
            else if (p.type === "ObjectPattern")
              for (const A of p.properties)
                this.checkDeclaration(A);
            else if (p.type === "ArrayPattern")
              for (const A of p.elements)
                A && this.checkDeclaration(A);
            else
              p.type === "ObjectProperty" ? this.checkDeclaration(p.value) : p.type === "RestElement" ? this.checkDeclaration(p.argument) : p.type === "AssignmentPattern" && this.checkDeclaration(p.left);
          }
          checkDuplicateExports(p, A) {
            this.exportedIdentifiers.has(A) && (A === "default" ? this.raise(C.DuplicateDefaultExport, { at: p }) : this.raise(C.DuplicateExport, { at: p, exportName: A })), this.exportedIdentifiers.add(A);
          }
          parseExportSpecifiers(p) {
            const A = [];
            let V = !0;
            for (this.expect(5); !this.eat(8); ) {
              if (V)
                V = !1;
              else if (this.expect(12), this.eat(8))
                break;
              const ee = this.isContextual(128), fe = this.match(131), Se = this.startNode();
              Se.local = this.parseModuleExportName(), A.push(this.parseExportSpecifier(Se, fe, p, ee));
            }
            return A;
          }
          parseExportSpecifier(p, A, V, ee) {
            return this.eatContextual(93) ? p.exported = this.parseModuleExportName() : A ? p.exported = zi(p.local) : p.exported || (p.exported = Vr(p.local)), this.finishNode(p, "ExportSpecifier");
          }
          parseModuleExportName() {
            if (this.match(131)) {
              const p = this.parseStringLiteral(this.state.value), A = p.value.match(Np);
              return A && this.raise(C.ModuleExportNameHasLoneSurrogate, { at: p, surrogateCharCode: A[0].charCodeAt(0) }), p;
            }
            return this.parseIdentifier(!0);
          }
          isJSONModuleImport(p) {
            return p.assertions != null && p.assertions.some(({ key: A, value: V }) => V.value === "json" && (A.type === "Identifier" ? A.name === "type" : A.value === "type"));
          }
          checkImportReflection(p) {
            var A;
            p.module && (p.specifiers.length === 1 && p.specifiers[0].type === "ImportDefaultSpecifier" || this.raise(C.ImportReflectionNotBinding, { at: p.specifiers[0].loc.start }), ((A = p.assertions) == null ? void 0 : A.length) > 0 && this.raise(C.ImportReflectionHasAssertion, { at: p.specifiers[0].loc.start }));
          }
          checkJSONModuleImport(p) {
            if (this.isJSONModuleImport(p) && p.type !== "ExportAllDeclaration") {
              const { specifiers: A } = p;
              if (A != null) {
                const V = A.find((ee) => {
                  let fe;
                  if (ee.type === "ExportSpecifier" ? fe = ee.local : ee.type === "ImportSpecifier" && (fe = ee.imported), fe !== void 0)
                    return fe.type === "Identifier" ? fe.name !== "default" : fe.value !== "default";
                });
                V !== void 0 && this.raise(C.ImportJSONBindingNotDefault, { at: V.loc.start });
              }
            }
          }
          isPotentialImportPhase(p) {
            return !p && this.isContextual(125);
          }
          applyImportPhase(p, A, V, ee) {
            A || (V === "module" ? (this.expectPlugin("importReflection", ee), p.module = !0) : this.hasPlugin("importReflection") && (p.module = !1));
          }
          parseMaybeImportPhase(p, A) {
            if (!this.isPotentialImportPhase(A))
              return this.applyImportPhase(p, A, null), null;
            const V = this.parseIdentifier(!0), { type: ee } = this.state;
            return (Y(ee) ? ee !== 97 || this.lookaheadCharCode() === 102 : ee !== 12) ? (this.resetPreviousIdentifierLeadingComments(V), this.applyImportPhase(p, A, V.name, V.loc.start), null) : (this.applyImportPhase(p, A, null), V);
          }
          isPrecedingIdImportPhase(p) {
            const { type: A } = this.state;
            return $(A) ? A !== 97 || this.lookaheadCharCode() === 102 : A !== 12;
          }
          parseImport(p) {
            return this.match(131) ? this.parseImportSourceAndAttributes(p) : this.parseImportSpecifiersAndAfter(p, this.parseMaybeImportPhase(p, !1));
          }
          parseImportSpecifiersAndAfter(p, A) {
            p.specifiers = [];
            const V = !this.maybeParseDefaultImportSpecifier(p, A) || this.eat(12), ee = V && this.maybeParseStarImportSpecifier(p);
            return V && !ee && this.parseNamedImportSpecifiers(p), this.expectContextual(97), this.parseImportSourceAndAttributes(p);
          }
          parseImportSourceAndAttributes(p) {
            return p.specifiers != null || (p.specifiers = []), p.source = this.parseImportSource(), this.maybeParseImportAttributes(p), this.checkImportReflection(p), this.checkJSONModuleImport(p), this.semicolon(), this.finishNode(p, "ImportDeclaration");
          }
          parseImportSource() {
            return this.match(131) || this.unexpected(), this.parseExprAtom();
          }
          parseImportSpecifierLocal(p, A, V) {
            A.local = this.parseIdentifier(), p.specifiers.push(this.finishImportSpecifier(A, V));
          }
          finishImportSpecifier(p, A, V = 8201) {
            return this.checkLVal(p.local, { in: { type: A }, binding: V }), this.finishNode(p, A);
          }
          parseImportAttributes() {
            this.expect(5);
            const p = [], A = /* @__PURE__ */ new Set();
            do {
              if (this.match(8))
                break;
              const V = this.startNode(), ee = this.state.value;
              if (A.has(ee) && this.raise(C.ModuleAttributesWithDuplicateKeys, { at: this.state.startLoc, key: ee }), A.add(ee), this.match(131) ? V.key = this.parseStringLiteral(ee) : V.key = this.parseIdentifier(!0), this.expect(14), !this.match(131))
                throw this.raise(C.ModuleAttributeInvalidValue, { at: this.state.startLoc });
              V.value = this.parseStringLiteral(this.state.value), p.push(this.finishNode(V, "ImportAttribute"));
            } while (this.eat(12));
            return this.expect(8), p;
          }
          parseModuleAttributes() {
            const p = [], A = /* @__PURE__ */ new Set();
            do {
              const V = this.startNode();
              if (V.key = this.parseIdentifier(!0), V.key.name !== "type" && this.raise(C.ModuleAttributeDifferentFromType, { at: V.key }), A.has(V.key.name) && this.raise(C.ModuleAttributesWithDuplicateKeys, { at: V.key, key: V.key.name }), A.add(V.key.name), this.expect(14), !this.match(131))
                throw this.raise(C.ModuleAttributeInvalidValue, { at: this.state.startLoc });
              V.value = this.parseStringLiteral(this.state.value), p.push(this.finishNode(V, "ImportAttribute"));
            } while (this.eat(12));
            return p;
          }
          maybeParseImportAttributes(p) {
            let A, V = !1;
            if (this.match(76)) {
              if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
                return;
              this.next(), this.hasPlugin("moduleAttributes") ? A = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), A = this.parseImportAttributes()), V = !0;
            } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
              this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(C.ImportAttributesUseAssert, { at: this.state.startLoc }), this.addExtra(p, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), A = this.parseImportAttributes();
            else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
              A = [];
            else {
              if (!this.hasPlugin("moduleAttributes"))
                return;
              A = [];
            }
            !V && this.hasPlugin("importAssertions") ? p.assertions = A : p.attributes = A;
          }
          maybeParseDefaultImportSpecifier(p, A) {
            if (A) {
              const V = this.startNodeAtNode(A);
              return V.local = A, p.specifiers.push(this.finishImportSpecifier(V, "ImportDefaultSpecifier")), !0;
            }
            return !!Y(this.state.type) && (this.parseImportSpecifierLocal(p, this.startNode(), "ImportDefaultSpecifier"), !0);
          }
          maybeParseStarImportSpecifier(p) {
            if (this.match(55)) {
              const A = this.startNode();
              return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(p, A, "ImportNamespaceSpecifier"), !0;
            }
            return !1;
          }
          parseNamedImportSpecifiers(p) {
            let A = !0;
            for (this.expect(5); !this.eat(8); ) {
              if (A)
                A = !1;
              else {
                if (this.eat(14))
                  throw this.raise(C.DestructureNamedImport, { at: this.state.startLoc });
                if (this.expect(12), this.eat(8))
                  break;
              }
              const V = this.startNode(), ee = this.match(131), fe = this.isContextual(128);
              V.imported = this.parseModuleExportName();
              const Se = this.parseImportSpecifier(V, ee, p.importKind === "type" || p.importKind === "typeof", fe, void 0);
              p.specifiers.push(Se);
            }
          }
          parseImportSpecifier(p, A, V, ee, fe) {
            if (this.eatContextual(93))
              p.local = this.parseIdentifier();
            else {
              const { imported: Se } = p;
              if (A)
                throw this.raise(C.ImportBindingIsString, { at: p, importName: Se.value });
              this.checkReservedWord(Se.name, p.loc.start, !0, !0), p.local || (p.local = Vr(Se));
            }
            return this.finishImportSpecifier(p, "ImportSpecifier", fe);
          }
          isThisParam(p) {
            return p.type === "Identifier" && p.name === "this";
          }
        }
        class rn extends Rp {
          constructor(p, A) {
            super(p = function(V) {
              if (V == null)
                return Object.assign({}, qs);
              if (V.annexB != null && V.annexB !== !1)
                throw new Error("The `annexB` option can only be set to `false`.");
              const ee = {};
              for (const Se of Object.keys(qs)) {
                var fe;
                ee[Se] = (fe = V[Se]) != null ? fe : qs[Se];
              }
              return ee;
            }(p), A), this.options = p, this.initializeScopes(), this.plugins = function(V) {
              const ee = /* @__PURE__ */ new Map();
              for (const fe of V) {
                const [Se, Pe] = Array.isArray(fe) ? fe : [fe, {}];
                ee.has(Se) || ee.set(Se, Pe || {});
              }
              return ee;
            }(this.options.plugins), this.filename = p.sourceFilename;
          }
          getScopeHandler() {
            return ht;
          }
          parse() {
            this.enterInitialScopes();
            const p = this.startNode(), A = this.startNode();
            return this.nextToken(), p.errors = null, this.parseTopLevel(p, A), p.errors = this.state.errors, p;
          }
        }
        const no = function(Te) {
          const p = {};
          for (const A of Object.keys(Te))
            p[A] = oe(Te[A]);
          return p;
        }(q);
        function Gs(Te, p) {
          let A = rn;
          return Te != null && Te.plugins && (function(V) {
            if (Wr(V, "decorators")) {
              if (Wr(V, "decorators-legacy"))
                throw new Error("Cannot use the decorators and decorators-legacy plugin together");
              const ee = xs(V, "decorators", "decoratorsBeforeExport");
              if (ee != null && typeof ee != "boolean")
                throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
              const fe = xs(V, "decorators", "allowCallParenthesized");
              if (fe != null && typeof fe != "boolean")
                throw new Error("'allowCallParenthesized' must be a boolean.");
            }
            if (Wr(V, "flow") && Wr(V, "typescript"))
              throw new Error("Cannot combine flow and typescript plugins.");
            if (Wr(V, "placeholders") && Wr(V, "v8intrinsic"))
              throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
            if (Wr(V, "pipelineOperator")) {
              const ee = xs(V, "pipelineOperator", "proposal");
              if (!pc.includes(ee)) {
                const Se = pc.map((Pe) => `"${Pe}"`).join(", ");
                throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${Se}.`);
              }
              const fe = Wr(V, ["recordAndTuple", { syntaxType: "hash" }]);
              if (ee === "hack") {
                if (Wr(V, "placeholders"))
                  throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
                if (Wr(V, "v8intrinsic"))
                  throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
                const Se = xs(V, "pipelineOperator", "topicToken");
                if (!Ii.includes(Se)) {
                  const Pe = Ii.map((Re) => `"${Re}"`).join(", ");
                  throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${Pe}.`);
                }
                if (Se === "#" && fe)
                  throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
              } else if (ee === "smart" && fe)
                throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
            }
            if (Wr(V, "moduleAttributes")) {
              if (Wr(V, "importAssertions") || Wr(V, "importAttributes"))
                throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
              if (xs(V, "moduleAttributes", "version") !== "may-2020")
                throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
            }
            if (Wr(V, "importAssertions") && Wr(V, "importAttributes"))
              throw new Error("Cannot combine importAssertions and importAttributes plugins.");
            if (Wr(V, "recordAndTuple") && xs(V, "recordAndTuple", "syntaxType") != null && !Hs.includes(xs(V, "recordAndTuple", "syntaxType")))
              throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + Hs.map((ee) => `'${ee}'`).join(", "));
            if (Wr(V, "asyncDoExpressions") && !Wr(V, "doExpressions")) {
              const ee = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
              throw ee.missingPlugins = "doExpressions", ee;
            }
          }(Te.plugins), A = function(V) {
            const ee = kp.filter((Pe) => Wr(V, Pe)), fe = ee.join("/");
            let Se = vl[fe];
            if (!Se) {
              Se = rn;
              for (const Pe of ee)
                Se = va[Pe](Se);
              vl[fe] = Se;
            }
            return Se;
          }(Te.plugins)), new A(Te, p);
        }
        const vl = {};
        r.parse = function(Te, p) {
          var A;
          if (((A = p) == null ? void 0 : A.sourceType) !== "unambiguous")
            return Gs(p, Te).parse();
          p = Object.assign({}, p);
          try {
            p.sourceType = "module";
            const V = Gs(p, Te), ee = V.parse();
            if (V.sawUnambiguousESM)
              return ee;
            if (V.ambiguousScriptDifferentAst)
              try {
                return p.sourceType = "script", Gs(p, Te).parse();
              } catch {
              }
            else
              ee.program.sourceType = "script";
            return ee;
          } catch (V) {
            try {
              return p.sourceType = "script", Gs(p, Te).parse();
            } catch {
            }
            throw V;
          }
        }, r.parseExpression = function(Te, p) {
          const A = Gs(p, Te);
          return A.options.strictMode && (A.state.strict = !0), A.getExpression();
        }, r.tokTypes = no;
      }, "./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-proposal-decorators/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js"), f = l("./node_modules/.pnpm/@babel+plugin-syntax-decorators@7.22.10_@babel+core@7.22.15/node_modules/@babel/plugin-syntax-decorators/lib/index.js"), d = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-create-class-features-plugin/lib/index.js"), s = l("./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-proposal-decorators/lib/transformer-legacy.js"), o = l("./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-proposal-decorators/lib/transformer-2023-05.js"), m = (0, i.declare)((h, y) => {
          h.assertVersion(7);
          var { legacy: b } = y;
          const { version: E } = y;
          return b || E === "legacy" ? { name: "proposal-decorators", inherits: f.default, visitor: s.default } : E === "2021-12" || E === "2022-03" || E === "2023-01" || E === "2023-05" ? (0, o.default)(h, y, E) : (h.assertVersion("^7.0.2"), (0, d.createClassFeaturePlugin)({ name: "proposal-decorators", api: h, feature: d.FEATURES.decorators, inherits: f.default }));
        });
        r.default = m;
      }, "./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-proposal-decorators/lib/transformer-2023-05.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function({ assertVersion: W, assumption: U }, { loose: M }, B) {
          var k;
          W(B === "2023-05" || B === "2023-01" ? "^7.21.0" : B === "2021-12" ? "^7.16.0" : "^7.19.0");
          const K = /* @__PURE__ */ new WeakSet(), te = (k = U("constantSuper")) != null ? k : M;
          return { name: "proposal-decorators", inherits: f.default, visitor: { "ExportNamedDeclaration|ExportDefaultDeclaration"(z) {
            var q;
            const { declaration: $ } = z.node;
            ($ == null ? void 0 : $.type) === "ClassDeclaration" && ((q = $.decorators) == null ? void 0 : q.length) > 0 && (0, s.default)(z);
          }, Class(z, q) {
            if (K.has(z))
              return;
            const $ = function(Y, H, Q, X) {
              const ne = Y.get("body.body"), ye = Y.node.decorators;
              let ve = !1;
              const de = function(Ke) {
                let Ce;
                return () => (Ce || (Ce = function(xe) {
                  const He = [], Be = /* @__PURE__ */ new Set();
                  return xe.traverse({ PrivateName(Ze) {
                    Be.add(Ze.node.id.name);
                  } }), () => {
                    let Ze;
                    do
                      o(He), Ze = String.fromCharCode(...He);
                    while (Be.has(Ze));
                    return i.types.privateName(i.types.identifier(Ze));
                  };
                }(Ke)), Ce());
              }(Y);
              for (const Ke of ne)
                if (w(Ke)) {
                  if (Ke.node.decorators && Ke.node.decorators.length > 0)
                    ve = !0;
                  else if (Ke.node.type === "ClassAccessorProperty") {
                    const { key: Ce, value: xe, static: He, computed: Be } = Ke.node, Ze = de(), nt = m(Ze, xe ? i.types.cloneNode(xe) : void 0, He), [$e] = Ke.replaceWith(nt);
                    h(Y.node.id, $e, Ce, Ze, X, Be);
                  }
                }
              if (!ye && !ve)
                return;
              const oe = [];
              let re, ae, le = !1, ue = !1;
              const ie = /* @__PURE__ */ new Set();
              let we, De, Ee, Ae;
              const Me = [], me = Y.scope.parent, se = (Ke, Ce) => {
                const xe = me.generateDeclaredUidIdentifier(Ce);
                return Me.push(i.types.assignmentExpression("=", xe, Ke)), i.types.cloneNode(xe);
              }, Z = /* @__PURE__ */ new Map(), pe = (Ke) => {
                const { expression: Ce } = Ke;
                if (X === "2023-05" && i.types.isMemberExpression(Ce)) {
                  let xe;
                  i.types.isSuper(Ce.object) || i.types.isThisExpression(Ce.object) ? xe = se(i.types.thisExpression(), "obj") : me.isStatic(Ce.object) ? xe = Ce.object : (xe = se(Ce.object, "obj"), Ce.object = xe), Z.set(Ke, i.types.cloneNode(xe));
                }
                me.isStatic(Ce) || (Ke.expression = se(Ce, "dec"));
              };
              if (ye) {
                Ee = me.generateDeclaredUidIdentifier("initClass");
                const [Ke, Ce] = function(xe) {
                  if (xe.type === "ClassDeclaration") {
                    const He = xe.scope.generateUidIdentifierBasedOnNode(xe.node.id), Be = i.types.identifier(xe.node.id.name);
                    return xe.scope.rename(Be.name, He.name), xe.insertBefore(i.types.variableDeclaration("let", [i.types.variableDeclarator(He)])), xe.get("id").replaceWith(Be), [i.types.cloneNode(He), xe];
                  }
                  {
                    let He, Be;
                    xe.node.id ? (He = xe.node.id.name, Be = xe.scope.parent.generateDeclaredUidIdentifier(He), xe.scope.rename(He, Be.name)) : xe.parentPath.node.type === "VariableDeclarator" && xe.parentPath.node.id.type === "Identifier" ? (He = xe.parentPath.node.id.name, Be = xe.scope.parent.generateDeclaredUidIdentifier(He)) : Be = xe.scope.parent.generateDeclaredUidIdentifier("decorated_class");
                    const Ze = i.types.classExpression(He && i.types.identifier(He), xe.node.superClass, xe.node.body), [nt] = xe.replaceWith(i.types.sequenceExpression([Ze, Be]));
                    return [i.types.cloneNode(Be), nt.get("expressions.0")];
                  }
                }(Y);
                Ae = Ke, (Y = Ce).node.decorators = null;
                for (const xe of ye)
                  pe(xe);
              } else
                Y.node.id || (Y.node.id = Y.scope.generateUidIdentifier("Class")), Ae = i.types.cloneNode(Y.node.id);
              let be, _e = !1;
              if (ve)
                for (const Ke of ne) {
                  if (!w(Ke))
                    continue;
                  const { node: Ce } = Ke, xe = Ke.get("decorators"), He = Array.isArray(xe) && xe.length > 0;
                  if (He)
                    for (const yt of xe)
                      pe(yt.node);
                  const Be = "computed" in Ke.node && Ke.node.computed === !0;
                  Be && (me.isStatic(Ce.key) || (Ce.key = se(Ce.key, "computedKey")));
                  const Ze = I(Ke), { key: nt } = Ce, $e = nt.type === "PrivateName", ut = !!Ke.node.static;
                  let vt = "computedKey";
                  if ($e ? vt = nt.id.name : Be || nt.type !== "Identifier" || (vt = nt.name), $e && !ut && (He && (_e = !0), !i.types.isClassPrivateProperty(Ce) && be || (be = nt)), Ke.isClassMethod({ kind: "constructor" }) && (ae = Ke), He) {
                    let yt, et, bt;
                    if (Ze === E) {
                      const { value: lt } = Ke.node, Et = [i.types.thisExpression()];
                      lt && Et.push(i.types.cloneNode(lt));
                      const wt = de(), Ne = Ke.scope.parent.generateDeclaredUidIdentifier(`init_${vt}`), Je = m(wt, i.types.callExpression(i.types.cloneNode(Ne), Et), ut), [ft] = Ke.replaceWith(Je);
                      if ($e) {
                        et = y(wt, X);
                        const rt = ft.scope.parent.generateDeclaredUidIdentifier(`get_${vt}`), At = ft.scope.parent.generateDeclaredUidIdentifier(`set_${vt}`);
                        _(ft, nt, rt, At), yt = [Ne, rt, At];
                      } else
                        h(Y.node.id, ft, nt, wt, X, Be), yt = Ne;
                    } else if (Ze === b) {
                      const lt = Ke.scope.parent.generateDeclaredUidIdentifier(`init_${vt}`), Et = Ke.get("value");
                      Et.replaceWith(i.types.callExpression(i.types.cloneNode(lt), [i.types.thisExpression(), Et.node].filter((wt) => wt))), yt = lt, $e && (et = y(nt, X));
                    } else if ($e) {
                      yt = Ke.scope.parent.generateDeclaredUidIdentifier(`call_${vt}`), new d.default({ constantSuper: Q, methodPath: Ke, objectRef: Ae, superRef: Y.node.superClass, file: H.file, refToPreserve: Ae }).replace();
                      const { params: lt, body: Et, async: wt } = Ke.node;
                      if (et = [i.types.functionExpression(void 0, lt.filter(T), Et, wt)], Ze === g || Ze === P)
                        v(Ke, i.types.cloneNode(nt), i.types.cloneNode(yt), ut);
                      else {
                        const Ne = Ke.node;
                        Y.node.body.body.unshift(i.types.classPrivateProperty(nt, i.types.cloneNode(yt), [], Ne.static)), ie.add(nt.id.name), Ke.remove();
                      }
                    }
                    bt = Be ? i.types.cloneNode(nt) : nt.type === "PrivateName" ? i.types.stringLiteral(nt.id.name) : nt.type === "Identifier" ? i.types.stringLiteral(nt.name) : i.types.cloneNode(nt), oe.push({ kind: Ze, decorators: xe.map((lt) => lt.node.expression), decoratorsThis: xe.map((lt) => Z.get(lt.node)), name: bt, isStatic: ut, privateMethods: et, locals: yt }), Ze !== b && (ut ? ue = !0 : le = !0), Ke.node && (Ke.node.decorators = null), re || ut || Ze !== b && Ze !== E || (re = Ke);
                  }
                }
              const Ie = function(Ke, Ce) {
                return i.types.arrayExpression(j(Ke).map((xe) => {
                  const { decs: He, hasThis: Be } = F(xe.decorators, xe.decoratorsThis, Ce);
                  let Ze = xe.kind;
                  return xe.isStatic && (Ze += Ce === "2023-05" ? N : R), Be && (Ze += C), i.types.arrayExpression([He.length === 1 ? He[0] : i.types.arrayExpression(He), i.types.numericLiteral(Ze), xe.name, ...xe.privateMethods || []]);
                }));
              }(oe, X);
              let We = 0, tt = [];
              if (ye) {
                const { hasThis: Ke, decs: Ce } = F(ye.map((xe) => xe.expression), ye.map((xe) => Z.get(xe)), X);
                We = Ke ? 1 : 0, tt = Ce;
              }
              const Ye = function(Ke) {
                const Ce = [];
                for (const xe of j(Ke)) {
                  const { locals: He } = xe;
                  Array.isArray(He) ? Ce.push(...He) : He !== void 0 && Ce.push(He);
                }
                return Ce;
              }(oe);
              if (le) {
                we = me.generateDeclaredUidIdentifier("initProto"), Ye.push(we);
                const Ke = i.types.callExpression(i.types.cloneNode(we), [i.types.thisExpression()]);
                if (re) {
                  const Ce = re.get("value"), xe = [Ke];
                  Ce.node && xe.push(Ce.node), Ce.replaceWith(i.types.sequenceExpression(xe));
                } else if (ae)
                  Y.node.superClass ? Y.traverse({ CallExpression: { exit(Ce) {
                    Ce.get("callee").isSuper() && (Ce.replaceWith(i.types.callExpression(i.types.cloneNode(we), [Ce.node])), Ce.skip());
                  } } }) : ae.node.body.body.unshift(i.types.expressionStatement(Ke));
                else {
                  const Ce = [i.types.expressionStatement(Ke)];
                  Y.node.superClass && Ce.unshift(i.types.expressionStatement(i.types.callExpression(i.types.super(), [i.types.spreadElement(i.types.identifier("args"))]))), Y.node.body.body.unshift(i.types.classMethod("constructor", i.types.identifier("constructor"), [i.types.restElement(i.types.identifier("args"))], i.types.blockStatement(Ce)));
                }
              }
              ue && (De = me.generateDeclaredUidIdentifier("initStatic"), Ye.push(De)), ie.size > 0 && Y.traverse({ PrivateName(Ke) {
                if (!ie.has(Ke.node.id.name))
                  return;
                const Ce = Ke.parentPath, xe = Ce.parentPath;
                if (xe.node.type === "AssignmentExpression" && xe.node.left === Ce.node || xe.node.type === "UpdateExpression" || xe.node.type === "RestElement" || xe.node.type === "ArrayPattern" || xe.node.type === "ObjectProperty" && xe.node.value === Ce.node && xe.parentPath.type === "ObjectPattern" || xe.node.type === "ForOfStatement" && xe.node.left === Ce.node)
                  throw Ke.buildCodeFrameError(`Decorated private methods are not updatable, but "#${Ke.node.id.name}" is updated via this expression.`);
              } });
              const ht = [];
              let ct = !1;
              const st = Ee && i.types.callExpression(i.types.cloneNode(Ee), []), Xe = Y.node;
              if (ye) {
                ht.push(Ae, Ee);
                const Ke = [];
                let Ce = [];
                if (Y.get("body.body").forEach((xe) => {
                  if (xe.isStaticBlock())
                    return Ce.push(xe.node), void xe.remove();
                  const He = xe.isClassProperty() || xe.isClassPrivateProperty();
                  if ((He || xe.isClassPrivateMethod()) && xe.node.static) {
                    if (He && Ce.length > 0) {
                      const Ze = Ce.map(O);
                      xe.node.value && Ze.push(xe.node.value), xe.node.value = (Be = Ze).length === 0 ? i.types.unaryExpression("void", i.types.numericLiteral(0)) : Be.length === 1 ? Be[0] : i.types.sequenceExpression(Be), Ce = [];
                    }
                    xe.node.static = !1, Ke.push(xe.node), xe.remove();
                  }
                  var Be;
                }), Ke.length > 0 || Ce.length > 0) {
                  const xe = i.template.expression.ast`
        class extends ${H.addHelper("identity")} {}
      `;
                  xe.body.body = [i.types.staticBlock([i.types.toStatement(Xe, !0) || i.types.expressionStatement(Xe)]), ...Ke];
                  const He = [], Be = i.types.newExpression(xe, []);
                  Ce.length > 0 && He.push(...Ce.map(O)), st && (ct = !0, He.push(st)), He.length > 0 ? (He.unshift(i.types.callExpression(i.types.super(), [i.types.cloneNode(Ae)])), xe.body.body.push(i.types.classMethod("constructor", i.types.identifier("constructor"), [], i.types.blockStatement([i.types.expressionStatement(i.types.sequenceExpression(He))])))) : Be.arguments.push(i.types.cloneNode(Ae)), Y.replaceWith(Be);
                }
              }
              return !ct && st && Y.node.body.body.push(i.types.staticBlock([i.types.expressionStatement(st)])), Xe.body.body.unshift(i.types.staticBlock([i.types.expressionStatement(G(Ye, ht, Ie, i.types.arrayExpression(tt), i.types.numericLiteral(We), _e ? be : null, H, X)), ue && i.types.expressionStatement(i.types.callExpression(i.types.cloneNode(De), [i.types.thisExpression()]))].filter(Boolean))), Y.insertBefore(Me.map((Ke) => i.types.expressionStatement(Ke))), Y.scope.crawl(), Y;
            }(z, q, te, B);
            $ && K.add($);
          } } };
        };
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js"), f = l("./node_modules/.pnpm/@babel+plugin-syntax-decorators@7.22.10_@babel+core@7.22.15/node_modules/@babel/plugin-syntax-decorators/lib/index.js"), d = l("./node_modules/.pnpm/@babel+helper-replace-supers@7.22.9_@babel+core@7.22.15/node_modules/@babel/helper-replace-supers/lib/index.js"), s = l("./node_modules/.pnpm/@babel+helper-split-export-declaration@7.22.6/node_modules/@babel/helper-split-export-declaration/lib/index.js");
        function o(W, U = W.length - 1) {
          if (U === -1)
            return void W.unshift(65);
          const M = W[U];
          M === 90 ? W[U] = 97 : M === 122 ? (W[U] = 65, o(W, U - 1)) : W[U] = M + 1;
        }
        function m(W, U, M) {
          return W.type === "PrivateName" ? i.types.classPrivateProperty(W, U, void 0, M) : i.types.classProperty(W, U, void 0, void 0, M);
        }
        function h(W, U, M, B, k, K = !1) {
          const { static: te } = U.node, z = k === "2023-05" && te ? W : i.types.thisExpression(), q = i.types.blockStatement([i.types.returnStatement(i.types.memberExpression(i.types.cloneNode(z), i.types.cloneNode(B)))]), $ = i.types.blockStatement([i.types.expressionStatement(i.types.assignmentExpression("=", i.types.memberExpression(i.types.cloneNode(z), i.types.cloneNode(B)), i.types.identifier("v")))]);
          let Y, H;
          M.type === "PrivateName" ? (Y = i.types.classPrivateMethod("get", i.types.cloneNode(M), [], q, te), H = i.types.classPrivateMethod("set", i.types.cloneNode(M), [i.types.identifier("v")], $, te)) : (Y = i.types.classMethod("get", i.types.cloneNode(M), [], q, K, te), H = i.types.classMethod("set", i.types.cloneNode(M), [i.types.identifier("v")], $, K, te)), U.insertAfter(H), U.insertAfter(Y);
        }
        function y(W, U) {
          return U !== "2023-05" && U !== "2023-01" ? [i.template.expression.ast`
        function () {
          return this.${i.types.cloneNode(W)};
        }
      `, i.template.expression.ast`
        function (value) {
          this.${i.types.cloneNode(W)} = value;
        }
      `] : [i.template.expression.ast`
      o => o.${i.types.cloneNode(W)}
    `, i.template.expression.ast`
      (o, v) => o.${i.types.cloneNode(W)} = v
    `];
        }
        const b = 0, E = 1, S = 2, g = 3, P = 4, R = 5, N = 8, C = 16;
        function I(W) {
          switch (W.node.type) {
            case "ClassProperty":
            case "ClassPrivateProperty":
              return b;
            case "ClassAccessorProperty":
              return E;
            case "ClassMethod":
            case "ClassPrivateMethod":
              return W.node.kind === "get" ? g : W.node.kind === "set" ? P : S;
          }
        }
        function D(W) {
          return "decorators" in W;
        }
        function j(W) {
          const U = W.filter(D);
          return [...U.filter((M) => M.isStatic && M.kind >= E && M.kind <= P), ...U.filter((M) => !M.isStatic && M.kind >= E && M.kind <= P), ...U.filter((M) => M.isStatic && M.kind === b), ...U.filter((M) => !M.isStatic && M.kind === b)];
        }
        function F(W, U, M) {
          const B = W.length, k = U.some(Boolean), K = [];
          for (let te = 0; te < B; te++)
            M === "2023-05" && k && K.push(U[te] || i.types.unaryExpression("void", i.types.numericLiteral(0))), K.push(W[te]);
          return { hasThis: k, decs: K };
        }
        function _(W, U, M, B) {
          W.insertAfter(i.types.classPrivateMethod("get", i.types.cloneNode(U), [], i.types.blockStatement([i.types.returnStatement(i.types.callExpression(i.types.cloneNode(M), [i.types.thisExpression()]))]))), W.insertAfter(i.types.classPrivateMethod("set", i.types.cloneNode(U), [i.types.identifier("v")], i.types.blockStatement([i.types.expressionStatement(i.types.callExpression(i.types.cloneNode(B), [i.types.thisExpression(), i.types.identifier("v")]))])));
        }
        function T(W) {
          return W.type !== "TSParameterProperty";
        }
        function v(W, U, M, B) {
          let k, K;
          W.node.kind === "set" ? (k = [i.types.identifier("v")], K = [i.types.expressionStatement(i.types.callExpression(M, [i.types.thisExpression(), i.types.identifier("v")]))]) : (k = [], K = [i.types.returnStatement(i.types.callExpression(M, [i.types.thisExpression()]))]), W.replaceWith(i.types.classPrivateMethod(W.node.kind, i.types.cloneNode(U), k, i.types.blockStatement(K), B));
        }
        function w(W) {
          const { type: U } = W;
          return U !== "TSDeclareMethod" && U !== "TSIndexSignature" && U !== "StaticBlock";
        }
        function O(W) {
          return i.types.callExpression(i.types.arrowFunctionExpression([], i.types.blockStatement(W.body)), []);
        }
        function G(W, U, M, B, k, K, te, z) {
          let q, $;
          const Y = [i.types.thisExpression(), M, B];
          if (z === "2021-12" || z === "2022-03" && !te.availableHelper("applyDecs2203R")) {
            const H = i.types.arrayPattern([...W, ...U]), Q = i.types.callExpression(te.addHelper(z === "2021-12" ? "applyDecs" : "applyDecs2203"), Y);
            return i.types.assignmentExpression("=", H, Q);
          }
          return z === "2023-05" ? ((K || k.value !== 0) && Y.push(k), K && Y.push(i.template.expression.ast`
            _ => ${i.types.cloneNode(K)} in _
          `), $ = i.types.callExpression(te.addHelper("applyDecs2305"), Y)) : z === "2023-01" ? (K && Y.push(i.template.expression.ast`
            _ => ${i.types.cloneNode(K)} in _
          `), $ = i.types.callExpression(te.addHelper("applyDecs2301"), Y)) : $ = i.types.callExpression(te.addHelper("applyDecs2203R"), Y), W.length > 0 ? U.length > 0 ? q = i.types.objectPattern([i.types.objectProperty(i.types.identifier("e"), i.types.arrayPattern(W)), i.types.objectProperty(i.types.identifier("c"), i.types.arrayPattern(U))]) : (q = i.types.arrayPattern(W), $ = i.types.memberExpression($, i.types.identifier("e"), !1, !1)) : (q = i.types.arrayPattern(U), $ = i.types.memberExpression($, i.types.identifier("c"), !1, !1)), i.types.assignmentExpression("=", q, $);
        }
      }, "./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-proposal-decorators/lib/transformer-legacy.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js");
        const f = i.template.statement(`
  DECORATOR(CLASS_REF = INNER) || CLASS_REF;
`), d = (0, i.template)(`
  CLASS_REF.prototype;
`), s = (0, i.template)(`
    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);
`), o = (0, i.template)(`
    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {
        enumerable: true,
        configurable: true,
        writable: true,
        initializer: function(){
            return TEMP;
        }
    })
`), m = /* @__PURE__ */ new WeakSet();
        function h(P) {
          const R = (P.isClass() ? [P, ...P.get("body.body")] : P.get("properties")).reduce((N, C) => N.concat(C.node.decorators || []), []).filter((N) => !i.types.isIdentifier(N.expression));
          if (R.length !== 0)
            return i.types.sequenceExpression(R.map((N) => {
              const C = N.expression, I = N.expression = P.scope.generateDeclaredUidIdentifier("dec");
              return i.types.assignmentExpression("=", I, C);
            }).concat([P.node]));
        }
        function y(P) {
          var R;
          return !((R = P.decorators) == null || !R.length);
        }
        function b(P) {
          return P.some((R) => {
            var N;
            return (N = R.decorators) == null ? void 0 : N.length;
          });
        }
        function E(P, R, N) {
          const C = P.scope.generateDeclaredUidIdentifier(P.isClass() ? "class" : "obj"), I = N.reduce(function(D, j) {
            let F = [];
            if (j.decorators != null && (F = j.decorators, j.decorators = null), F.length === 0)
              return D;
            if (j.computed)
              throw P.buildCodeFrameError("Computed method/property decorators are not yet supported.");
            const _ = i.types.isLiteral(j.key) ? j.key : i.types.stringLiteral(j.key.name), T = P.isClass() && !j.static ? d({ CLASS_REF: C }).expression : C;
            if (i.types.isClassProperty(j, { static: !1 })) {
              const v = P.scope.generateDeclaredUidIdentifier("descriptor"), w = j.value ? i.types.functionExpression(null, [], i.types.blockStatement([i.types.returnStatement(j.value)])) : i.types.nullLiteral();
              j.value = i.types.callExpression(R.addHelper("initializerWarningHelper"), [v, i.types.thisExpression()]), m.add(j.value), D.push(i.types.assignmentExpression("=", i.types.cloneNode(v), i.types.callExpression(R.addHelper("applyDecoratedDescriptor"), [i.types.cloneNode(T), i.types.cloneNode(_), i.types.arrayExpression(F.map((O) => i.types.cloneNode(O.expression))), i.types.objectExpression([i.types.objectProperty(i.types.identifier("configurable"), i.types.booleanLiteral(!0)), i.types.objectProperty(i.types.identifier("enumerable"), i.types.booleanLiteral(!0)), i.types.objectProperty(i.types.identifier("writable"), i.types.booleanLiteral(!0)), i.types.objectProperty(i.types.identifier("initializer"), w)])])));
            } else
              D.push(i.types.callExpression(R.addHelper("applyDecoratedDescriptor"), [i.types.cloneNode(T), i.types.cloneNode(_), i.types.arrayExpression(F.map((v) => i.types.cloneNode(v.expression))), i.types.isObjectProperty(j) || i.types.isClassProperty(j, { static: !0 }) ? o({ TEMP: P.scope.generateDeclaredUidIdentifier("init"), TARGET: i.types.cloneNode(T), PROPERTY: i.types.cloneNode(_) }).expression : s({ TARGET: i.types.cloneNode(T), PROPERTY: i.types.cloneNode(_) }).expression, i.types.cloneNode(T)]));
            return D;
          }, []);
          return i.types.sequenceExpression([i.types.assignmentExpression("=", i.types.cloneNode(C), P.node), i.types.sequenceExpression(I), i.types.cloneNode(C)]);
        }
        function S({ node: P, scope: R }) {
          if (!y(P) && !b(P.body.body))
            return;
          const N = P.id ? i.types.cloneNode(P.id) : R.generateUidIdentifier("class");
          return i.types.variableDeclaration("let", [i.types.variableDeclarator(N, i.types.toExpression(P))]);
        }
        var g = { ExportDefaultDeclaration(P) {
          const R = P.get("declaration");
          if (!R.isClassDeclaration())
            return;
          const N = S(R);
          if (N) {
            const [C] = P.replaceWithMultiple([N, i.types.exportNamedDeclaration(null, [i.types.exportSpecifier(i.types.cloneNode(N.declarations[0].id), i.types.identifier("default"))])]);
            R.node.id || P.scope.registerDeclaration(C);
          }
        }, ClassDeclaration(P) {
          const R = S(P);
          if (R) {
            const [N] = P.replaceWith(R), C = N.get("declarations.0"), I = C.node.id, D = P.scope.getOwnBinding(I.name);
            D.identifier = I, D.path = C;
          }
        }, ClassExpression(P, R) {
          const N = h(P) || function(C) {
            if (!y(C.node))
              return;
            const I = C.node.decorators || [];
            C.node.decorators = null;
            const D = C.scope.generateDeclaredUidIdentifier("class");
            return I.map((j) => j.expression).reverse().reduce(function(j, F) {
              return f({ CLASS_REF: i.types.cloneNode(D), DECORATOR: i.types.cloneNode(F), INNER: j }).expression;
            }, C.node);
          }(P) || function(C, I) {
            if (b(C.node.body.body))
              return E(C, I, C.node.body.body);
          }(P, R);
          N && P.replaceWith(N);
        }, ObjectExpression(P, R) {
          const N = h(P) || function(C, I) {
            if (b(C.node.properties))
              return E(C, I, C.node.properties.filter((D) => D.type !== "SpreadElement"));
          }(P, R);
          N && P.replaceWith(N);
        }, AssignmentExpression(P, R) {
          m.has(P.node.right) && P.replaceWith(i.types.callExpression(R.addHelper("initializerDefineProperty"), [i.types.cloneNode(P.get("left.object").node), i.types.stringLiteral(P.get("left.property").node.name || P.get("left.property").node.value), i.types.cloneNode(P.get("right.arguments")[0].node), i.types.cloneNode(P.get("right.arguments")[1].node)]));
        }, CallExpression(P, R) {
          P.node.arguments.length === 3 && m.has(P.node.arguments[2]) && P.node.callee.name === R.addHelper("defineProperty").name && P.replaceWith(i.types.callExpression(R.addHelper("initializerDefineProperty"), [i.types.cloneNode(P.get("arguments")[0].node), i.types.cloneNode(P.get("arguments")[1].node), i.types.cloneNode(P.get("arguments.2.arguments")[0].node), i.types.cloneNode(P.get("arguments.2.arguments")[1].node)]));
        } };
        r.default = g;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-decorators@7.22.10_@babel+core@7.22.15/node_modules/@babel/plugin-syntax-decorators/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = (0, l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((f, d) => {
          f.assertVersion(7);
          let { version: s } = d;
          {
            const { legacy: m } = d;
            if (m !== void 0) {
              if (typeof m != "boolean")
                throw new Error(".legacy must be a boolean.");
              if (s !== void 0)
                throw new Error("You can either use the .legacy or the .version option, not both.");
            }
            if (s === void 0)
              s = m ? "legacy" : "2018-09";
            else if (s !== "2023-05" && s !== "2023-01" && s !== "2022-03" && s !== "2021-12" && s !== "2018-09" && s !== "legacy")
              throw new Error("Unsupported decorators version: " + s);
            var { decoratorsBeforeExport: o } = d;
            if (o === void 0) {
              if (s === "2021-12" || s === "2022-03")
                o = !1;
              else if (s === "2018-09")
                throw new Error("The decorators plugin, when .version is '2018-09' or not specified, requires a 'decoratorsBeforeExport' option, whose value must be a boolean.");
            } else {
              if (s === "legacy" || s === "2022-03" || s === "2023-01")
                throw new Error(`'decoratorsBeforeExport' can't be used with ${s} decorators.`);
              if (typeof o != "boolean")
                throw new Error("'decoratorsBeforeExport' must be a boolean.");
            }
          }
          return { name: "syntax-decorators", manipulateOptions({ generatorOpts: m }, h) {
            s === "legacy" ? h.plugins.push("decorators-legacy") : s === "2023-01" || s === "2023-05" ? h.plugins.push(["decorators", { allowCallParenthesized: !1 }], "decoratorAutoAccessors") : s === "2022-03" ? h.plugins.push(["decorators", { decoratorsBeforeExport: !1, allowCallParenthesized: !1 }], "decoratorAutoAccessors") : s === "2021-12" ? (h.plugins.push(["decorators", { decoratorsBeforeExport: o }], "decoratorAutoAccessors"), m.decoratorsBeforeExport = o) : s === "2018-09" && (h.plugins.push(["decorators", { decoratorsBeforeExport: o }]), m.decoratorsBeforeExport = o);
          } };
        });
        r.default = i;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-import-assertions@7.22.5_@babel+core@7.22.15/node_modules/@babel/plugin-syntax-import-assertions/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = (0, l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((f) => (f.assertVersion(7), { name: "syntax-import-assertions", manipulateOptions(d, s) {
          s.plugins.push("importAssertions");
        } }));
        r.default = i;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-jsx@7.22.5_@babel+core@7.22.15/node_modules/@babel/plugin-syntax-jsx/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = (0, l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((f) => (f.assertVersion(7), { name: "syntax-jsx", manipulateOptions(d, s) {
          s.plugins.some((o) => (Array.isArray(o) ? o[0] : o) === "typescript") || s.plugins.push("jsx");
        } }));
        r.default = i;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-typescript@7.22.5_@babel+core@7.22.15/node_modules/@babel/plugin-syntax-typescript/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js"), f = function(s, o) {
          const m = [];
          s.forEach((h, y) => {
            (Array.isArray(h) ? h[0] : h) === o && m.unshift(y);
          });
          for (const h of m)
            s.splice(h, 1);
        }, d = (0, i.declare)((s, o) => {
          s.assertVersion(7);
          const { disallowAmbiguousJSXLike: m, dts: h } = o;
          var { isTSX: y } = o;
          return { name: "syntax-typescript", manipulateOptions(b, E) {
            {
              const { plugins: S } = E;
              f(S, "flow"), f(S, "jsx"), S.push("objectRestSpread", "classProperties"), y && S.push("jsx");
            }
            E.plugins.push(["typescript", { disallowAmbiguousJSXLike: m, dts: h }]);
          } };
        });
        r.default = d;
      }, "./node_modules/.pnpm/@babel+plugin-transform-export-namespace-from@7.22.11_@babel+core@7.22.15/node_modules/@babel/plugin-transform-export-namespace-from/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js"), f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js"), d = (0, i.declare)((s) => (s.assertVersion(7), { name: "transform-export-namespace-from", inherits: l("./node_modules/.pnpm/@babel+plugin-syntax-export-namespace-from@7.8.3_@babel+core@7.22.15/node_modules/@babel/plugin-syntax-export-namespace-from/lib/index.js").Z, visitor: { ExportNamedDeclaration(o) {
          var m;
          const { node: h, scope: y } = o, { specifiers: b } = h, E = f.types.isExportDefaultSpecifier(b[0]) ? 1 : 0;
          if (!f.types.isExportNamespaceSpecifier(b[E]))
            return;
          const S = [];
          E === 1 && S.push(f.types.exportNamedDeclaration(null, [b.shift()], h.source));
          const g = b.shift(), { exported: P } = g, R = y.generateUidIdentifier((m = P.name) != null ? m : P.value);
          S.push(f.types.importDeclaration([f.types.importNamespaceSpecifier(R)], f.types.cloneNode(h.source)), f.types.exportNamedDeclaration(null, [f.types.exportSpecifier(f.types.cloneNode(R), P)])), h.specifiers.length >= 1 && S.push(h);
          const [N] = o.replaceWithMultiple(S);
          o.scope.registerDeclaration(N);
        } } }));
        r.default = d;
      }, "./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.transformDynamicImport = function(o, m, h) {
          const y = m ? d : s;
          o.replaceWith((0, f.buildDynamicImport)(o.node, !0, !1, (b) => y(b, h)));
        };
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js"), f = l("./node_modules/.pnpm/@babel+helper-module-transforms@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-module-transforms/lib/index.js");
        const d = (o) => i.template.expression.ast`require(${o})`, s = (o, m) => i.types.callExpression(m.addHelper("interopRequireWildcard"), [d(o)]);
      }, "./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js"), f = l("./node_modules/.pnpm/@babel+helper-module-transforms@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-module-transforms/lib/index.js"), d = l("./node_modules/.pnpm/@babel+helper-simple-access@7.22.5/node_modules/@babel/helper-simple-access/lib/index.js"), s = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js"), o = l("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js"), m = (0, i.declare)((h, y) => {
          var b, E, S;
          h.assertVersion(7);
          const { strictNamespace: g = !1, mjsStrictNamespace: P = g, allowTopLevelThis: R, strict: N, strictMode: C, noInterop: I, importInterop: D, lazy: j = !1, allowCommonJSExports: F = !0, loose: _ = !1 } = y, T = (b = h.assumption("constantReexports")) != null ? b : _, v = (E = h.assumption("enumerableModuleMeta")) != null ? E : _, w = (S = h.assumption("noIncompleteNsImportDetection")) != null && S;
          if (!(typeof j == "boolean" || typeof j == "function" || Array.isArray(j) && j.every((W) => typeof W == "string")))
            throw new Error(".lazy must be a boolean, array of strings, or a function");
          if (typeof g != "boolean")
            throw new Error(".strictNamespace must be a boolean, or undefined");
          if (typeof P != "boolean")
            throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
          const O = (W) => s.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${W}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `, G = { ReferencedIdentifier(W) {
            const U = W.node.name;
            if (U !== "module" && U !== "exports")
              return;
            const M = W.scope.getBinding(U);
            this.scope.getBinding(U) !== M || W.parentPath.isObjectProperty({ value: W.node }) && W.parentPath.parentPath.isObjectPattern() || W.parentPath.isAssignmentExpression({ left: W.node }) || W.isAssignmentExpression({ left: W.node }) || W.replaceWith(O(U));
          }, UpdateExpression(W) {
            const U = W.get("argument");
            if (!U.isIdentifier())
              return;
            const M = U.node.name;
            if (M !== "module" && M !== "exports")
              return;
            const B = W.scope.getBinding(M);
            this.scope.getBinding(M) === B && W.replaceWith(s.types.assignmentExpression(W.node.operator[0] + "=", U.node, O(M)));
          }, AssignmentExpression(W) {
            const U = W.get("left");
            if (U.isIdentifier()) {
              const M = U.node.name;
              if (M !== "module" && M !== "exports")
                return;
              const B = W.scope.getBinding(M);
              if (this.scope.getBinding(M) !== B)
                return;
              const k = W.get("right");
              k.replaceWith(s.types.sequenceExpression([k.node, O(M)]));
            } else if (U.isPattern()) {
              const M = U.getOuterBindingIdentifiers(), B = Object.keys(M).filter((k) => (k === "module" || k === "exports") && this.scope.getBinding(k) === W.scope.getBinding(k))[0];
              if (B) {
                const k = W.get("right");
                k.replaceWith(s.types.sequenceExpression([k.node, O(B)]));
              }
            }
          } };
          return { name: "transform-modules-commonjs", pre() {
            this.file.set("@babel/plugin-transform-modules-*", "commonjs");
          }, visitor: { CallExpression(W) {
            if (!this.file.has("@babel/plugin-proposal-dynamic-import") || !s.types.isImport(W.node.callee))
              return;
            let { scope: U } = W;
            do
              U.rename("require");
            while (U = U.parent);
            (0, o.transformDynamicImport)(W, I, this.file);
          }, Program: { exit(W, U) {
            if (!(0, f.isModule)(W))
              return;
            W.scope.rename("exports"), W.scope.rename("module"), W.scope.rename("require"), W.scope.rename("__filename"), W.scope.rename("__dirname"), F || ((0, d.default)(W, /* @__PURE__ */ new Set(["module", "exports"]), !1), W.traverse(G, { scope: W.scope }));
            let M = (0, f.getModuleName)(this.file.opts, y);
            M && (M = s.types.stringLiteral(M));
            const { meta: B, headers: k } = (0, f.rewriteModuleStatementsAndPrepareHeader)(W, { exportName: "exports", constantReexports: T, enumerableModuleMeta: v, strict: N, strictMode: C, allowTopLevelThis: R, noInterop: I, importInterop: D, lazy: j, esNamespaceOnly: typeof U.filename == "string" && /\.mjs$/.test(U.filename) ? P : g, noIncompleteNsImportDetection: w, filename: this.file.opts.filename });
            for (const [K, te] of B.source) {
              const z = s.types.callExpression(s.types.identifier("require"), [s.types.stringLiteral(K)]);
              let q;
              if ((0, f.isSideEffectImport)(te)) {
                if (te.lazy)
                  throw new Error("Assertion failure");
                q = s.types.expressionStatement(z);
              } else {
                if (te.lazy && !te.referenced)
                  continue;
                const $ = (0, f.wrapInterop)(W, z, te.interop) || z;
                q = te.lazy ? s.template.statement.ast`
                  function ${te.name}() {
                    const data = ${$};
                    ${te.name} = function(){ return data; };
                    return data;
                  }
                ` : s.template.statement.ast`
                  var ${te.name} = ${$};
                `;
              }
              q.loc = te.loc, k.push(q), k.push(...(0, f.buildNamespaceInitStatements)(B, te, T));
            }
            (0, f.ensureStatementsHoisted)(k), W.unshiftContainer("body", k), W.get("body").forEach((K) => {
              k.indexOf(K.node) !== -1 && K.isVariableDeclaration() && K.scope.registerDeclaration(K);
            });
          } } } };
        });
        r.default = m;
      }, "./node_modules/.pnpm/@babel+plugin-transform-nullish-coalescing-operator@7.22.11_@babel+core@7.22.15/node_modules/@babel/plugin-transform-nullish-coalescing-operator/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js"), f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js"), d = (0, i.declare)((s, { loose: o = !1 }) => {
          var m;
          s.assertVersion(7);
          const h = (m = s.assumption("noDocumentAll")) != null ? m : o;
          return { name: "transform-nullish-coalescing-operator", inherits: l("./node_modules/.pnpm/@babel+plugin-syntax-nullish-coalescing-operator@7.8.3_@babel+core@7.22.15/node_modules/@babel/plugin-syntax-nullish-coalescing-operator/lib/index.js").Z, visitor: { LogicalExpression(y) {
            const { node: b, scope: E } = y;
            if (b.operator !== "??")
              return;
            let S, g;
            if (E.isStatic(b.left))
              S = b.left, g = f.types.cloneNode(b.left);
            else {
              if (E.path.isPattern())
                return void y.replaceWith(f.template.statement.ast`(() => ${y.node})()`);
              S = E.generateUidIdentifierBasedOnNode(b.left), E.push({ id: f.types.cloneNode(S) }), g = f.types.assignmentExpression("=", S, b.left);
            }
            y.replaceWith(f.types.conditionalExpression(h ? f.types.binaryExpression("!=", g, f.types.nullLiteral()) : f.types.logicalExpression("&&", f.types.binaryExpression("!==", g, f.types.nullLiteral()), f.types.binaryExpression("!==", f.types.cloneNode(S), E.buildUndefinedNode())), f.types.cloneNode(S), b.right));
          } } };
        });
        r.default = d;
      }, "./node_modules/.pnpm/@babel+plugin-transform-optional-chaining@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-transform-optional-chaining/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 });
        var i = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js"), f = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js"), d = l("./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.22.5/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js");
        function s(N) {
          const C = o(N), { node: I, parentPath: D } = C;
          if (D.isLogicalExpression()) {
            const { operator: j, right: F } = D.node;
            if (j === "&&" || j === "||" || j === "??" && I === F)
              return s(D);
          }
          if (D.isSequenceExpression()) {
            const { expressions: j } = D.node;
            return j[j.length - 1] !== I || s(D);
          }
          return D.isConditional({ test: I }) || D.isUnaryExpression({ operator: "!" }) || D.isLoop({ test: I });
        }
        function o(N) {
          let C = N;
          return N.findParent((I) => {
            if (!d.isTransparentExprWrapper(I.node))
              return !0;
            C = I;
          }), C;
        }
        const m = (N) => N[N.length - 1];
        function h(N) {
          return N = d.skipTransparentExprWrapperNodes(N), f.types.isIdentifier(N) || f.types.isSuper(N) || f.types.isMemberExpression(N) && !N.computed && h(N.object);
        }
        const y = f.template.expression("%%check%% === null || %%ref%% === void 0"), b = f.template.expression("%%check%% == null"), E = f.template.expression("%%check%% !== null && %%ref%% !== void 0"), S = f.template.expression("%%check%% != null");
        function g(N, { pureGetters: C, noDocumentAll: I }, D, j, F) {
          const { scope: _ } = N;
          if (_.path.isPattern() && function(z) {
            let q = z;
            const { scope: $ } = z;
            for (; q.isOptionalMemberExpression() || q.isOptionalCallExpression(); ) {
              const { node: Y } = q, H = d.skipTransparentExprWrappers(q.isOptionalMemberExpression() ? q.get("object") : q.get("callee"));
              if (Y.optional)
                return !$.isStatic(H.node);
              q = H;
            }
          }(N))
            return void D.replaceWith(f.template.expression.ast`(() => ${D.node})()`);
          const T = [];
          let v = N;
          for (; v.isOptionalMemberExpression() || v.isOptionalCallExpression(); ) {
            const { node: z } = v;
            z.optional && T.push(z), v.isOptionalMemberExpression() ? (v.node.type = "MemberExpression", v = d.skipTransparentExprWrappers(v.get("object"))) : v.isOptionalCallExpression() && (v.node.type = "CallExpression", v = d.skipTransparentExprWrappers(v.get("callee")));
          }
          if (T.length === 0)
            return;
          const w = [];
          let O;
          for (let z = T.length - 1; z >= 0; z--) {
            const q = T[z], $ = f.types.isCallExpression(q), Y = $ ? q.callee : q.object, H = d.skipTransparentExprWrapperNodes(Y);
            let Q, X;
            if ($ && f.types.isIdentifier(H, { name: "eval" }) ? (X = Q = H, q.callee = f.types.sequenceExpression([f.types.numericLiteral(0), Q])) : C && $ && h(H) ? X = Q = q.callee : _.isStatic(H) ? X = Q = Y : (O && !$ || (O = _.generateUidIdentifierBasedOnNode(H), _.push({ id: f.types.cloneNode(O) })), Q = O, X = f.types.assignmentExpression("=", f.types.cloneNode(O), Y), $ ? q.callee = Q : q.object = Q), $ && f.types.isMemberExpression(H))
              if (C && h(H))
                q.callee = Y;
              else {
                const { object: ye } = H;
                let ve;
                if (f.types.isSuper(ye))
                  ve = f.types.thisExpression();
                else {
                  const de = _.maybeGenerateMemoised(ye);
                  de ? (ve = de, H.object = f.types.assignmentExpression("=", de, ye)) : ve = ye;
                }
                q.arguments.unshift(f.types.cloneNode(ve)), q.callee = f.types.memberExpression(q.callee, f.types.identifier("call"));
              }
            const ne = { check: f.types.cloneNode(X), ref: f.types.cloneNode(Q) };
            Object.defineProperty(ne, "ref", { enumerable: !1 }), w.push(ne);
          }
          let G = D.node;
          F && (G = F(G));
          const W = f.types.isBooleanLiteral(j), U = W && j.value === !1, M = !W && f.types.isUnaryExpression(j, { operator: "void" }), B = f.types.isExpressionStatement(D.parent) && !D.isCompletionRecord() || f.types.isSequenceExpression(D.parent) && m(D.parent.expressions) !== D.node, k = U ? I ? S : E : I ? b : y, K = U ? "&&" : "||", te = w.map(k).reduce((z, q) => f.types.logicalExpression(K, z, q));
          D.replaceWith(W || M && B ? f.types.logicalExpression(K, te, G) : f.types.conditionalExpression(te, j, G));
        }
        function P(N, C) {
          const { scope: I } = N, D = o(N), { parentPath: j } = D;
          if (j.isUnaryExpression({ operator: "delete" }))
            g(N, C, j, f.types.booleanLiteral(!0));
          else {
            let F;
            j.isCallExpression({ callee: D.node }) && N.isOptionalMemberExpression() && (F = (_) => {
              var T;
              const v = d.skipTransparentExprWrapperNodes(_.object);
              let w;
              return C.pureGetters && h(v) || (w = I.maybeGenerateMemoised(v), w && (_.object = f.types.assignmentExpression("=", w, v))), f.types.callExpression(f.types.memberExpression(_, f.types.identifier("bind")), [f.types.cloneNode((T = w) != null ? T : v)]);
            }), g(N, C, N, s(D) ? f.types.booleanLiteral(!1) : I.buildUndefinedNode(), F);
          }
        }
        var R = i.declare((N, C) => {
          var I, D;
          N.assertVersion(7);
          const { loose: j = !1 } = C, F = (I = N.assumption("noDocumentAll")) != null ? I : j, _ = (D = N.assumption("pureGetters")) != null ? D : j;
          return { name: "transform-optional-chaining", inherits: l("./node_modules/.pnpm/@babel+plugin-syntax-optional-chaining@7.8.3_@babel+core@7.22.15/node_modules/@babel/plugin-syntax-optional-chaining/lib/index.js").Z, visitor: { "OptionalCallExpression|OptionalMemberExpression"(T) {
            P(T, { noDocumentAll: F, pureGetters: _ });
          } } };
        });
        r.default = R, r.transform = P;
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-transform-typescript/lib/const-enum.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f, d) {
          const { name: s } = f.node.id, o = f.parentPath.isExportNamedDeclaration();
          let m = o;
          !m && d.isProgram(f.parent) && (m = f.parent.body.some((b) => d.isExportNamedDeclaration(b) && b.exportKind !== "type" && !b.source && b.specifiers.some((E) => d.isExportSpecifier(E) && E.exportKind !== "type" && E.local.name === s)));
          const { enumValues: h } = (0, i.translateEnumValues)(f, d);
          if (m) {
            const b = d.objectExpression(h.map(([E, S]) => d.objectProperty(d.isValidIdentifier(E) ? d.identifier(E) : d.stringLiteral(E), S)));
            return void (f.scope.hasOwnBinding(s) ? (o ? f.parentPath : f).replaceWith(d.expressionStatement(d.callExpression(d.memberExpression(d.identifier("Object"), d.identifier("assign")), [f.node.id, b]))) : (f.replaceWith(d.variableDeclaration("var", [d.variableDeclarator(f.node.id, b)])), f.scope.registerDeclaration(f)));
          }
          const y = new Map(h);
          f.scope.path.traverse({ Scope(b) {
            b.scope.hasOwnBinding(s) && b.skip();
          }, MemberExpression(b) {
            if (!d.isIdentifier(b.node.object, { name: s }))
              return;
            let E;
            if (b.node.computed) {
              if (!d.isStringLiteral(b.node.property))
                return;
              E = b.node.property.value;
            } else {
              if (!d.isIdentifier(b.node.property))
                return;
              E = b.node.property.name;
            }
            y.has(E) && b.replaceWith(d.cloneNode(y.get(E)));
          } }), f.remove();
        };
        var i = l("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-transform-typescript/lib/enum.js");
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-transform-typescript/lib/enum.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(P, R) {
          const { node: N, parentPath: C } = P;
          if (N.declare)
            return void P.remove();
          const I = N.id.name, { fill: D, data: j, isPure: F } = function(_, T, v) {
            const { enumValues: w, data: O, isPure: G } = S(_, T), W = w.map(([U, M]) => y(T.isStringLiteral(M), { ENUM: T.cloneNode(v), NAME: U, VALUE: M }));
            return { fill: { ID: T.cloneNode(v), ASSIGNMENTS: W }, data: O, isPure: G };
          }(P, R, N.id);
          switch (C.type) {
            case "BlockStatement":
            case "ExportNamedDeclaration":
            case "Program": {
              const _ = R.isProgram(P.parent), T = function O(G) {
                return G.isExportDeclaration() ? O(G.parentPath) : !!G.getData(I) || (G.setData(I, !0), !1);
              }(C);
              let v = R.objectExpression([]);
              (T || _) && (v = R.logicalExpression("||", R.cloneNode(D.ID), v));
              const w = o(Object.assign({}, D, { INIT: v }));
              F && (0, d.default)(w), T ? (C.isExportDeclaration() ? C : P).replaceWith(R.expressionStatement(R.assignmentExpression("=", R.cloneNode(N.id), w))) : P.scope.registerDeclaration(P.replaceWith(R.variableDeclaration(_ ? "var" : "let", [R.variableDeclarator(N.id, w)]))[0]), s.set(P.scope.getBindingIdentifier(I), j);
              break;
            }
            default:
              throw new Error(`Unexpected enum parent '${P.parent.type}`);
          }
        }, r.translateEnumValues = S;
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js"), f = l("assert"), d = l("./node_modules/.pnpm/@babel+helper-annotate-as-pure@7.22.5/node_modules/@babel/helper-annotate-as-pure/lib/index.js");
        const s = /* @__PURE__ */ new WeakMap(), o = i.template.expression(`
    (function (ID) {
      ASSIGNMENTS;
      return ID;
    })(INIT)
  `), m = (0, i.template)(`
  ENUM["NAME"] = VALUE;
`), h = (0, i.template)(`
  ENUM[ENUM["NAME"] = VALUE] = "NAME";
`), y = (P, R) => (P ? m : h)(R);
        function b(P, R) {
          const { seen: N, path: C, t: I } = R, D = P.node.name;
          N.has(D) && !P.scope.hasOwnBinding(D) && (P.replaceWith(I.memberExpression(I.cloneNode(C.node.id), I.cloneNode(P.node))), P.skip());
        }
        const E = { ReferencedIdentifier: b };
        function S(P, R) {
          const N = /* @__PURE__ */ new Map();
          let C, I = -1, D = !0;
          const j = P.get("members").map((F) => {
            const _ = F.node, T = R.isIdentifier(_.id) ? _.id.name : _.id.value, v = F.get("initializer");
            let w;
            if (_.initializer)
              I = g(v, N), I !== void 0 ? (N.set(T, I), f(typeof I == "number" || typeof I == "string"), w = I === 1 / 0 || Number.isNaN(I) ? R.identifier(String(I)) : I === -1 / 0 ? R.unaryExpression("-", R.identifier("Infinity")) : R.valueToNode(I)) : (D && (D = v.isPure()), v.isReferencedIdentifier() ? b(v, { t: R, seen: N, path: P }) : v.traverse(E, { t: R, seen: N, path: P }), w = v.node, N.set(T, void 0));
            else if (typeof I == "number")
              I += 1, w = R.numericLiteral(I), N.set(T, I);
            else {
              if (typeof I == "string")
                throw P.buildCodeFrameError("Enum member must have initializer.");
              {
                const O = R.memberExpression(R.cloneNode(P.node.id), R.stringLiteral(C), !0);
                w = R.binaryExpression("+", R.numericLiteral(1), O), N.set(T, void 0);
              }
            }
            return C = T, [T, w];
          });
          return { isPure: D, data: N, enumValues: j };
        }
        function g(P, R, N = /* @__PURE__ */ new Set()) {
          return C(P);
          function C(D) {
            const j = D.node;
            switch (j.type) {
              case "MemberExpression":
              case "Identifier":
                return I(D, R, N);
              case "StringLiteral":
              case "NumericLiteral":
                return j.value;
              case "UnaryExpression":
                return function(F) {
                  const _ = C(F.get("argument"));
                  if (_ !== void 0)
                    switch (F.node.operator) {
                      case "+":
                        return _;
                      case "-":
                        return -_;
                      case "~":
                        return ~_;
                      default:
                        return;
                    }
                }(D);
              case "BinaryExpression":
                return function(F) {
                  const _ = C(F.get("left"));
                  if (_ === void 0)
                    return;
                  const T = C(F.get("right"));
                  if (T !== void 0)
                    switch (F.node.operator) {
                      case "|":
                        return _ | T;
                      case "&":
                        return _ & T;
                      case ">>":
                        return _ >> T;
                      case ">>>":
                        return _ >>> T;
                      case "<<":
                        return _ << T;
                      case "^":
                        return _ ^ T;
                      case "*":
                        return _ * T;
                      case "/":
                        return _ / T;
                      case "+":
                        return _ + T;
                      case "-":
                        return _ - T;
                      case "%":
                        return _ % T;
                      case "**":
                        return Math.pow(_, T);
                      default:
                        return;
                    }
                }(D);
              case "ParenthesizedExpression":
                return C(D.get("expression"));
              case "TemplateLiteral": {
                if (j.quasis.length === 1)
                  return j.quasis[0].value.cooked;
                const F = D.get("expressions"), _ = j.quasis;
                let T = "";
                for (let v = 0; v < _.length; v++)
                  if (T += _[v].value.cooked, v + 1 < _.length) {
                    const w = I(F[v], R, N);
                    if (w === void 0)
                      return;
                    T += w;
                  }
                return T;
              }
              default:
                return;
            }
          }
          function I(D, j, F) {
            if (D.isMemberExpression()) {
              const _ = D.node, T = _.object, v = _.property;
              if (!i.types.isIdentifier(T) || (_.computed ? !i.types.isStringLiteral(v) : !i.types.isIdentifier(v)))
                return;
              const w = D.scope.getBindingIdentifier(T.name), O = s.get(w);
              return O ? O.get(v.computed ? v.value : v.name) : void 0;
            }
            if (D.isIdentifier()) {
              const _ = D.node.name;
              if (["Infinity", "NaN"].includes(_))
                return Number(_);
              let T = j == null ? void 0 : j.get(_);
              if (T !== void 0)
                return T;
              if (F.has(D.node))
                return;
              const v = D.resolve();
              if (v)
                return F.add(D.node), T = g(v, void 0, F), j == null || j.set(_, T), T;
            }
          }
        }
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-transform-typescript/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js"), f = l("./node_modules/.pnpm/@babel+plugin-syntax-typescript@7.22.5_@babel+core@7.22.15/node_modules/@babel/plugin-syntax-typescript/lib/index.js"), d = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.15_@babel+core@7.22.15/node_modules/@babel/helper-create-class-features-plugin/lib/index.js"), s = l("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-transform-typescript/lib/const-enum.js"), o = l("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-transform-typescript/lib/enum.js"), m = l("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-transform-typescript/lib/namespace.js");
        function h(C) {
          switch (C.parent.type) {
            case "TSTypeReference":
            case "TSExpressionWithTypeArguments":
            case "TSTypeQuery":
              return !0;
            case "TSQualifiedName":
              return C.parentPath.findParent((I) => I.type !== "TSQualifiedName").type !== "TSImportEqualsDeclaration";
            case "ExportSpecifier":
              return C.parent.exportKind === "type" || C.parentPath.parent.exportKind === "type";
            default:
              return !1;
          }
        }
        const y = /* @__PURE__ */ new WeakMap(), b = /* @__PURE__ */ new WeakMap(), E = /* @__PURE__ */ new WeakSet();
        function S({ scope: C }, I) {
          return !C.hasBinding(I) && (!!y.get(C).has(I) || (console.warn(`The exported identifier "${I}" is not declared in Babel's scope tracker
as a JavaScript value binding, and "@babel/plugin-transform-typescript"
never encountered it as a TypeScript type declaration.
It will be treated as a JavaScript value.

This problem is likely caused by another plugin injecting
"${I}" without registering it in the scope tracker. If you are the author
 of that plugin, please use "scope.registerDeclaration(declarationPath)".`), !1));
        }
        function g(C, I) {
          y.get(C).add(I);
        }
        function P(C) {
          const I = C.getBindingIdentifiers();
          for (const D of Object.keys(I)) {
            const j = C.scope.getBinding(D);
            j && j.identifier === I[D] && j.scope.removeBinding(D);
          }
          C.opts.noScope = !0, C.remove(), C.opts.noScope = !1;
        }
        function R(C, I, D, j, F = "") {
          if (I.file.get("@babel/plugin-transform-modules-*") !== "commonjs")
            throw C.buildCodeFrameError(`\`${D}\` is only supported when compiling modules to CommonJS.
Please consider using \`${j}\`${F}, or add @babel/plugin-transform-modules-commonjs to your Babel config.`);
        }
        var N = (0, i.declare)((C, I) => {
          const { types: D, template: j } = C;
          C.assertVersion(7);
          const F = /\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/, { allowNamespaces: _ = !0, jsxPragma: T = "React.createElement", jsxPragmaFrag: v = "React.Fragment", onlyRemoveTypeImports: w = !1, optimizeConstEnums: O = !1 } = I;
          var { allowDeclareFields: G = !1 } = I;
          const W = { field(k) {
            const { node: K } = k;
            if (!G && K.declare)
              throw k.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");
            if (K.declare) {
              if (K.value)
                throw k.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");
              K.decorators || k.remove();
            } else if (K.definite) {
              if (K.value)
                throw k.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");
              G || K.decorators || D.isClassPrivateProperty(K) || k.remove();
            } else
              K.abstract ? k.remove() : G || K.value || K.decorators || D.isClassPrivateProperty(K) || k.remove();
            K.accessibility && (K.accessibility = null), K.abstract && (K.abstract = null), K.readonly && (K.readonly = null), K.optional && (K.optional = null), K.typeAnnotation && (K.typeAnnotation = null), K.definite && (K.definite = null), K.declare && (K.declare = null), K.override && (K.override = null);
          }, method({ node: k }) {
            k.accessibility && (k.accessibility = null), k.abstract && (k.abstract = null), k.optional && (k.optional = null), k.override && (k.override = null);
          }, constructor(k, K) {
            k.node.accessibility && (k.node.accessibility = null);
            const te = [], { scope: z } = k;
            for (const q of k.get("params")) {
              const $ = q.node;
              if ($.type === "TSParameterProperty") {
                const Y = $.parameter;
                if (E.has(Y))
                  continue;
                let H;
                if (E.add(Y), D.isIdentifier(Y))
                  H = Y;
                else {
                  if (!D.isAssignmentPattern(Y) || !D.isIdentifier(Y.left))
                    throw q.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
                  H = Y.left;
                }
                te.push(j.statement.ast`
          this.${D.cloneNode(H)} = ${D.cloneNode(H)}`), q.replaceWith(q.get("parameter")), z.registerBinding("param", q);
              }
            }
            (0, d.injectInitialization)(K, k, te);
          } };
          return { name: "transform-typescript", inherits: f.default, visitor: { Pattern: M, Identifier: M, RestElement: M, Program: { enter(k, K) {
            const { file: te } = K;
            let z = null, q = null;
            const $ = k.scope;
            if (y.has($) || y.set($, /* @__PURE__ */ new Set()), te.ast.comments)
              for (const Q of te.ast.comments) {
                const X = F.exec(Q.value);
                X && (X[1] ? q = X[2] : z = X[2]);
              }
            let Y = z || T;
            Y && ([Y] = Y.split("."));
            let H = q || v;
            H && ([H] = H.split("."));
            for (let Q of k.get("body"))
              if (Q.isImportDeclaration()) {
                if (b.has(K.file.ast.program) || b.set(K.file.ast.program, !0), Q.node.importKind === "type") {
                  for (const ve of Q.node.specifiers)
                    g($, ve.local.name);
                  Q.remove();
                  continue;
                }
                const X = /* @__PURE__ */ new Set(), ne = Q.node.specifiers.length, ye = () => ne > 0 && ne === X.size;
                for (const ve of Q.node.specifiers)
                  if (ve.type === "ImportSpecifier" && ve.importKind === "type") {
                    g($, ve.local.name);
                    const de = Q.scope.getBinding(ve.local.name);
                    de && X.add(de.path);
                  }
                if (w)
                  b.set(k.node, !1);
                else {
                  if (Q.node.specifiers.length === 0) {
                    b.set(k.node, !1);
                    continue;
                  }
                  for (const ve of Q.node.specifiers) {
                    const de = Q.scope.getBinding(ve.local.name);
                    de && !X.has(de.path) && (B({ binding: de, programPath: k, pragmaImportName: Y, pragmaFragImportName: H }) ? X.add(de.path) : b.set(k.node, !1));
                  }
                }
                if (ye() && !w)
                  Q.remove();
                else
                  for (const ve of X)
                    ve.remove();
              } else if (Q.isExportDeclaration() && (Q = Q.get("declaration")), Q.isVariableDeclaration({ declare: !0 }))
                for (const X of Object.keys(Q.getBindingIdentifiers()))
                  g($, X);
              else
                (Q.isTSTypeAliasDeclaration() || Q.isTSDeclareFunction() && Q.get("id").isIdentifier() || Q.isTSInterfaceDeclaration() || Q.isClassDeclaration({ declare: !0 }) || Q.isTSEnumDeclaration({ declare: !0 }) || Q.isTSModuleDeclaration({ declare: !0 }) && Q.get("id").isIdentifier()) && g($, Q.node.id.name);
          }, exit(k) {
            k.node.sourceType === "module" && b.get(k.node) && k.pushContainer("body", D.exportNamedDeclaration());
          } }, ExportNamedDeclaration(k, K) {
            if (b.has(K.file.ast.program) || b.set(K.file.ast.program, !0), k.node.exportKind !== "type")
              if (k.node.source && k.node.specifiers.length > 0 && k.node.specifiers.every((te) => te.type === "ExportSpecifier" && te.exportKind === "type"))
                k.remove();
              else if (!k.node.source && k.node.specifiers.length > 0 && k.node.specifiers.every((te) => D.isExportSpecifier(te) && S(k, te.local.name)))
                k.remove();
              else {
                if (D.isTSModuleDeclaration(k.node.declaration)) {
                  const te = k.node.declaration, { id: z } = te;
                  if (D.isIdentifier(z))
                    if (k.scope.hasOwnBinding(z.name))
                      k.replaceWith(te);
                    else {
                      const [q] = k.replaceWithMultiple([D.exportNamedDeclaration(D.variableDeclaration("let", [D.variableDeclarator(D.cloneNode(z))])), te]);
                      k.scope.registerDeclaration(q);
                    }
                }
                b.set(K.file.ast.program, !1);
              }
            else
              k.remove();
          }, ExportAllDeclaration(k) {
            k.node.exportKind === "type" && k.remove();
          }, ExportSpecifier(k) {
            (!k.parent.source && S(k, k.node.local.name) || k.node.exportKind === "type") && k.remove();
          }, ExportDefaultDeclaration(k, K) {
            b.has(K.file.ast.program) || b.set(K.file.ast.program, !0), D.isIdentifier(k.node.declaration) && S(k, k.node.declaration.name) ? k.remove() : b.set(K.file.ast.program, !1);
          }, TSDeclareFunction(k) {
            P(k);
          }, TSDeclareMethod(k) {
            P(k);
          }, VariableDeclaration(k) {
            k.node.declare && P(k);
          }, VariableDeclarator({ node: k }) {
            k.definite && (k.definite = null);
          }, TSIndexSignature(k) {
            k.remove();
          }, ClassDeclaration(k) {
            const { node: K } = k;
            K.declare && P(k);
          }, Class(k) {
            const { node: K } = k;
            K.typeParameters && (K.typeParameters = null), K.superTypeParameters && (K.superTypeParameters = null), K.implements && (K.implements = null), K.abstract && (K.abstract = null), k.get("body.body").forEach((te) => {
              te.isClassMethod() || te.isClassPrivateMethod() ? te.node.kind === "constructor" ? W.constructor(te, k) : W.method(te) : (te.isClassProperty() || te.isClassPrivateProperty() || te.isClassAccessorProperty()) && W.field(te);
            });
          }, Function(k) {
            const { node: K } = k;
            K.typeParameters && (K.typeParameters = null), K.returnType && (K.returnType = null);
            const te = K.params;
            te.length > 0 && D.isIdentifier(te[0], { name: "this" }) && te.shift();
          }, TSModuleDeclaration(k) {
            (0, m.default)(k, _);
          }, TSInterfaceDeclaration(k) {
            k.remove();
          }, TSTypeAliasDeclaration(k) {
            k.remove();
          }, TSEnumDeclaration(k) {
            O && k.node.const ? (0, s.default)(k, D) : (0, o.default)(k, D);
          }, TSImportEqualsDeclaration(k, K) {
            const { id: te, moduleReference: z } = k.node;
            let q, $;
            D.isTSExternalModuleReference(z) ? (R(k, K, `import ${te.name} = require(...);`, `import ${te.name} from '...';`, " alongside Typescript's --allowSyntheticDefaultImports option"), q = D.callExpression(D.identifier("require"), [z.expression]), $ = "const") : (q = U(z), $ = "var"), k.replaceWith(D.variableDeclaration($, [D.variableDeclarator(te, q)])), k.scope.registerDeclaration(k);
          }, TSExportAssignment(k, K) {
            R(k, K, "export = <value>;", "export default <value>;"), k.replaceWith(j.statement.ast`module.exports = ${k.node.expression}`);
          }, TSTypeAssertion(k) {
            k.replaceWith(k.node.expression);
          }, ["TSAsExpression" + (D.tsSatisfiesExpression ? "|TSSatisfiesExpression" : "")](k) {
            let { node: K } = k;
            do
              K = K.expression;
            while (D.isTSAsExpression(K) || D.isTSSatisfiesExpression != null && D.isTSSatisfiesExpression(K));
            k.replaceWith(K);
          }, [C.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"](k) {
            k.replaceWith(k.node.expression);
          }, CallExpression(k) {
            k.node.typeParameters = null;
          }, OptionalCallExpression(k) {
            k.node.typeParameters = null;
          }, NewExpression(k) {
            k.node.typeParameters = null;
          }, JSXOpeningElement(k) {
            k.node.typeParameters = null;
          }, TaggedTemplateExpression(k) {
            k.node.typeParameters = null;
          } } };
          function U(k) {
            return D.isTSQualifiedName(k) ? D.memberExpression(U(k.left), k.right) : k;
          }
          function M({ node: k }) {
            k.typeAnnotation && (k.typeAnnotation = null), D.isIdentifier(k) && k.optional && (k.optional = null);
          }
          function B({ binding: k, programPath: K, pragmaImportName: te, pragmaFragImportName: z }) {
            for (const $ of k.referencePaths)
              if (!h($))
                return !1;
            if (k.identifier.name !== te && k.identifier.name !== z)
              return !0;
            let q = !1;
            return K.traverse({ "JSXElement|JSXFragment"($) {
              q = !0, $.stop();
            } }), !q;
          }
        });
        r.default = N;
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-transform-typescript/lib/namespace.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(h, y) {
          if (h.node.declare || h.node.id.type === "StringLiteral")
            return void h.remove();
          if (!y)
            throw h.get("id").buildCodeFrameError("Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
          const b = h.node.id.name, E = m(h, i.types.cloneNode(h.node, !0));
          E === null ? h.remove() : h.scope.hasOwnBinding(b) ? h.replaceWith(E) : h.scope.registerDeclaration(h.replaceWithMultiple([f(b), E])[0]);
        };
        var i = l("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js");
        function f(h) {
          return i.types.variableDeclaration("let", [i.types.variableDeclarator(i.types.identifier(h))]);
        }
        function d(h, y) {
          return i.types.memberExpression(i.types.identifier(h), i.types.identifier(y));
        }
        function s(h, y, b) {
          if (h.kind !== "const")
            throw b.file.buildCodeFrameError(h, "Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
          const { declarations: E } = h;
          if (E.every((P) => i.types.isIdentifier(P.id))) {
            for (const P of E)
              P.init = i.types.assignmentExpression("=", d(y, P.id.name), P.init);
            return [h];
          }
          const S = i.types.getBindingIdentifiers(h), g = [];
          for (const P in S)
            g.push(i.types.assignmentExpression("=", d(y, P), i.types.cloneNode(S[P])));
          return [h, i.types.expressionStatement(i.types.sequenceExpression(g))];
        }
        function o(h, y) {
          return h.hub.buildError(y, "Ambient modules cannot be nested in other modules or namespaces.", Error);
        }
        function m(h, y, b) {
          const E = /* @__PURE__ */ new Set(), S = y.id;
          i.types.assertIdentifier(S);
          const g = h.scope.generateUid(S.name), P = i.types.isTSModuleBlock(y.body) ? y.body.body : [i.types.exportNamedDeclaration(y.body)];
          let R = !0;
          for (let C = 0; C < P.length; C++) {
            const I = P[C];
            switch (I.type) {
              case "TSModuleDeclaration": {
                if (!i.types.isIdentifier(I.id))
                  throw o(h, I);
                const D = m(h, I);
                if (D !== null) {
                  R = !1;
                  const j = I.id.name;
                  E.has(j) ? P[C] = D : (E.add(j), P.splice(C++, 1, f(j), D));
                }
                continue;
              }
              case "TSEnumDeclaration":
              case "FunctionDeclaration":
              case "ClassDeclaration":
                R = !1, E.add(I.id.name);
                continue;
              case "VariableDeclaration":
                R = !1;
                for (const D in i.types.getBindingIdentifiers(I))
                  E.add(D);
                continue;
              default:
                R && (R = i.types.isTypeScript(I));
                continue;
              case "ExportNamedDeclaration":
            }
            if (!("declare" in I.declaration) || !I.declaration.declare)
              switch (I.declaration.type) {
                case "TSEnumDeclaration":
                case "FunctionDeclaration":
                case "ClassDeclaration": {
                  R = !1;
                  const D = I.declaration.id.name;
                  E.add(D), P.splice(C++, 1, I.declaration, i.types.expressionStatement(i.types.assignmentExpression("=", d(g, D), i.types.identifier(D))));
                  break;
                }
                case "VariableDeclaration": {
                  R = !1;
                  const D = s(I.declaration, g, h.hub);
                  P.splice(C, D.length, ...D), C += D.length - 1;
                  break;
                }
                case "TSModuleDeclaration": {
                  if (!i.types.isIdentifier(I.declaration.id))
                    throw o(h, I.declaration);
                  const D = m(h, I.declaration, i.types.identifier(g));
                  if (D !== null) {
                    R = !1;
                    const j = I.declaration.id.name;
                    E.has(j) ? P[C] = D : (E.add(j), P.splice(C++, 1, f(j), D));
                  } else
                    P.splice(C, 1), C--;
                }
              }
          }
          if (R)
            return null;
          let N = i.types.objectExpression([]);
          if (b) {
            const C = i.types.memberExpression(b, S);
            N = i.template.expression.ast`
      ${i.types.cloneNode(C)} ||
        (${i.types.cloneNode(C)} = ${N})
    `;
          }
          return i.template.statement.ast`
    (function (${i.types.identifier(g)}) {
      ${P}
    })(${S} || (${i.types.cloneNode(S)} = ${N}));
  `;
        }
      }, "./node_modules/.pnpm/@babel+preset-typescript@7.22.15_@babel+core@7.22.15/node_modules/@babel/preset-typescript/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 });
        var i = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js"), f = l("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-transform-typescript/lib/index.js");
        l("./node_modules/.pnpm/@babel+plugin-syntax-jsx@7.22.5_@babel+core@7.22.15/node_modules/@babel/plugin-syntax-jsx/lib/index.js");
        var d = l("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js"), s = l("./node_modules/.pnpm/@babel+helper-validator-option@7.22.15/node_modules/@babel/helper-validator-option/lib/index.js");
        function o(E) {
          return E && E.__esModule ? E : { default: E };
        }
        var m = o(f), h = o(d);
        const y = new s.OptionValidator("@babel/preset-typescript");
        var b = i.declarePreset((E, S) => {
          E.assertVersion(7);
          const { allExtensions: g, ignoreExtensions: P, allowNamespaces: R, disallowAmbiguousJSXLike: N, isTSX: C, jsxPragma: I, jsxPragmaFrag: D, onlyRemoveTypeImports: j, optimizeConstEnums: F } = function(v = {}) {
            let { allowNamespaces: w = !0, jsxPragma: O, onlyRemoveTypeImports: G } = v;
            const W = "ignoreExtensions", U = "disallowAmbiguousJSXLike", M = "jsxPragmaFrag", B = "optimizeConstEnums", k = "allExtensions", K = "isTSX", te = y.validateStringOption(M, v.jsxPragmaFrag, "React.Fragment");
            var z = y.validateBooleanOption(k, v.allExtensions, !1), q = y.validateBooleanOption(K, v.isTSX, !1);
            q && y.invariant(z, "isTSX:true requires allExtensions:true");
            const $ = y.validateBooleanOption(W, v.ignoreExtensions, !1), Y = y.validateBooleanOption(U, v.disallowAmbiguousJSXLike, !1);
            Y && y.invariant(z, "disallowAmbiguousJSXLike:true requires allExtensions:true");
            const H = { ignoreExtensions: $, allowNamespaces: w, disallowAmbiguousJSXLike: Y, jsxPragma: O, jsxPragmaFrag: te, onlyRemoveTypeImports: G, optimizeConstEnums: y.validateBooleanOption(B, v.optimizeConstEnums, !1) };
            return H.allExtensions = z, H.isTSX = q, H;
          }(S), _ = (v) => ({ allowDeclareFields: S.allowDeclareFields, allowNamespaces: R, disallowAmbiguousJSXLike: v, jsxPragma: I, jsxPragmaFrag: D, onlyRemoveTypeImports: j, optimizeConstEnums: F }), T = (v, w) => [[m.default, Object.assign({ isTSX: v }, _(w))]];
          return { overrides: g || P ? [{ plugins: T(C, N) }] : [{ test: /\.ts$/, plugins: T(!1, !1) }, { test: /\.mts$/, sourceType: "module", plugins: T(!1, !0) }, { test: /\.cts$/, sourceType: "unambiguous", plugins: [[h.default, { allowTopLevelThis: !0 }], [m.default, _(!0)]] }, { test: /\.tsx$/, plugins: T(!0, !1) }] };
        });
        r.default = b;
      }, "./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/builder.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function m(h, y) {
          const b = /* @__PURE__ */ new WeakMap(), E = /* @__PURE__ */ new WeakMap(), S = y || (0, i.validate)(null);
          return Object.assign((g, ...P) => {
            if (typeof g == "string") {
              if (P.length > 1)
                throw new Error("Unexpected extra params.");
              return o((0, f.default)(h, g, (0, i.merge)(S, (0, i.validate)(P[0]))));
            }
            if (Array.isArray(g)) {
              let R = b.get(g);
              return R || (R = (0, d.default)(h, g, S), b.set(g, R)), o(R(P));
            }
            if (typeof g == "object" && g) {
              if (P.length > 0)
                throw new Error("Unexpected extra params.");
              return m(h, (0, i.merge)(S, (0, i.validate)(g)));
            }
            throw new Error("Unexpected template param " + typeof g);
          }, { ast: (g, ...P) => {
            if (typeof g == "string") {
              if (P.length > 1)
                throw new Error("Unexpected extra params.");
              return (0, f.default)(h, g, (0, i.merge)((0, i.merge)(S, (0, i.validate)(P[0])), s))();
            }
            if (Array.isArray(g)) {
              let R = E.get(g);
              return R || (R = (0, d.default)(h, g, (0, i.merge)(S, s)), E.set(g, R)), R(P)();
            }
            throw new Error("Unexpected template param " + typeof g);
          } });
        };
        var i = l("./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/options.js"), f = l("./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/string.js"), d = l("./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/literal.js");
        const s = (0, i.validate)({ placeholderPattern: !1 });
        function o(m) {
          let h = "";
          try {
            throw new Error();
          } catch (y) {
            y.stack && (h = y.stack.split(`
`).slice(3).join(`
`));
          }
          return (y) => {
            try {
              return m(y);
            } catch (b) {
              throw b.stack += `
    =============
${h}`, b;
            }
          };
        }
      }, "./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/formatters.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.statements = r.statement = r.smart = r.program = r.expression = void 0;
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { assertExpressionStatement: f } = i;
        function d(y) {
          return { code: (b) => `/* @babel/template */;
${b}`, validate: () => {
          }, unwrap: (b) => y(b.program.body.slice(1)) };
        }
        const s = d((y) => y.length > 1 ? y : y[0]);
        r.smart = s;
        const o = d((y) => y);
        r.statements = o;
        const m = d((y) => {
          if (y.length === 0)
            throw new Error("Found nothing to return.");
          if (y.length > 1)
            throw new Error("Found multiple statements but wanted one");
          return y[0];
        });
        r.statement = m;
        const h = { code: (y) => `(
${y}
)`, validate: (y) => {
          if (y.program.body.length > 1)
            throw new Error("Found multiple statements but wanted one");
          if (h.unwrap(y).start === 0)
            throw new Error("Parse result included parens.");
        }, unwrap: ({ program: y }) => {
          const [b] = y.body;
          return f(b), b.expression;
        } };
        r.expression = h, r.program = { code: (y) => y, validate: () => {
        }, unwrap: (y) => y.program };
      }, "./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.statements = r.statement = r.smart = r.program = r.expression = r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/formatters.js"), f = l("./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/builder.js");
        const d = (0, f.default)(i.smart);
        r.smart = d;
        const s = (0, f.default)(i.statement);
        r.statement = s;
        const o = (0, f.default)(i.statements);
        r.statements = o;
        const m = (0, f.default)(i.expression);
        r.expression = m;
        const h = (0, f.default)(i.program);
        r.program = h;
        var y = Object.assign(d.bind(void 0), { smart: d, statement: s, statements: o, expression: m, program: h, ast: d.ast });
        r.default = y;
      }, "./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/literal.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(s, o, m) {
          const { metadata: h, names: y } = function(b, E, S) {
            let g = "BABEL_TPL$";
            const P = E.join("");
            do
              g = "$$" + g;
            while (P.includes(g));
            const { names: R, code: N } = function(I, D) {
              const j = [];
              let F = I[0];
              for (let _ = 1; _ < I.length; _++) {
                const T = `${D}${_ - 1}`;
                j.push(T), F += T + I[_];
              }
              return { names: j, code: F };
            }(E, g);
            return { metadata: (0, f.default)(b, b.code(N), { parser: S.parser, placeholderWhitelist: new Set(R.concat(S.placeholderWhitelist ? Array.from(S.placeholderWhitelist) : [])), placeholderPattern: S.placeholderPattern, preserveComments: S.preserveComments, syntacticPlaceholders: S.syntacticPlaceholders }), names: R };
          }(s, o, m);
          return (b) => {
            const E = {};
            return b.forEach((S, g) => {
              E[y[g]] = S;
            }), (S) => {
              const g = (0, i.normalizeReplacements)(S);
              return g && Object.keys(g).forEach((P) => {
                if (Object.prototype.hasOwnProperty.call(E, P))
                  throw new Error("Unexpected replacement overlap.");
              }), s.unwrap((0, d.default)(h, g ? Object.assign(g, E) : E));
            };
          };
        };
        var i = l("./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/options.js"), f = l("./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/parse.js"), d = l("./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/populate.js");
      }, "./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/options.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.merge = function(i, f) {
          const { placeholderWhitelist: d = i.placeholderWhitelist, placeholderPattern: s = i.placeholderPattern, preserveComments: o = i.preserveComments, syntacticPlaceholders: m = i.syntacticPlaceholders } = f;
          return { parser: Object.assign({}, i.parser, f.parser), placeholderWhitelist: d, placeholderPattern: s, preserveComments: o, syntacticPlaceholders: m };
        }, r.normalizeReplacements = function(i) {
          if (Array.isArray(i))
            return i.reduce((f, d, s) => (f["$" + s] = d, f), {});
          if (typeof i == "object" || i == null)
            return i || void 0;
          throw new Error("Template replacements must be an array, object, null, or undefined");
        }, r.validate = function(i) {
          if (i != null && typeof i != "object")
            throw new Error("Unknown template options.");
          const f = i || {}, { placeholderWhitelist: d, placeholderPattern: s, preserveComments: o, syntacticPlaceholders: m } = f, h = function(y, b) {
            if (y == null)
              return {};
            var E, S, g = {}, P = Object.keys(y);
            for (S = 0; S < P.length; S++)
              E = P[S], b.indexOf(E) >= 0 || (g[E] = y[E]);
            return g;
          }(f, l);
          if (d != null && !(d instanceof Set))
            throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
          if (s != null && !(s instanceof RegExp) && s !== !1)
            throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
          if (o != null && typeof o != "boolean")
            throw new Error("'.preserveComments' must be a boolean, null, or undefined");
          if (m != null && typeof m != "boolean")
            throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
          if (m === !0 && (d != null || s != null))
            throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
          return { parser: h, placeholderWhitelist: d || void 0, placeholderPattern: s ?? void 0, preserveComments: o ?? void 0, syntacticPlaceholders: m ?? void 0 };
        };
        const l = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
      }, "./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/parse.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(I, D, j) {
          const { placeholderWhitelist: F, placeholderPattern: _, preserveComments: T, syntacticPlaceholders: v } = j, w = function(G, W, U) {
            const M = (W.plugins || []).slice();
            U !== !1 && M.push("placeholders"), W = Object.assign({ allowReturnOutsideFunction: !0, allowSuperOutsideMethod: !0, sourceType: "module" }, W, { plugins: M });
            try {
              return (0, f.parse)(G, W);
            } catch (B) {
              const k = B.loc;
              throw k && (B.message += `
` + (0, d.codeFrameColumns)(G, { start: k }), B.code = "BABEL_TEMPLATE_PARSE_ERROR"), B;
            }
          }(D, j.parser, v);
          P(w, { preserveComments: T }), I.validate(w);
          const O = { syntactic: { placeholders: [], placeholderNames: /* @__PURE__ */ new Set() }, legacy: { placeholders: [], placeholderNames: /* @__PURE__ */ new Set() }, placeholderWhitelist: F, placeholderPattern: _, syntacticPlaceholders: v };
          return R(w, C, O), Object.assign({ ast: w }, O.syntactic.placeholders.length ? O.syntactic : O.legacy);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js"), f = l("./node_modules/.pnpm/@babel+parser@7.22.16/node_modules/@babel/parser/lib/index.js"), d = l("./stubs/babel-codeframe.js");
        const { isCallExpression: s, isExpressionStatement: o, isFunction: m, isIdentifier: h, isJSXIdentifier: y, isNewExpression: b, isPlaceholder: E, isStatement: S, isStringLiteral: g, removePropertiesDeep: P, traverse: R } = i, N = /^[_$A-Z0-9]+$/;
        function C(I, D, j) {
          var F;
          let _, T = j.syntactic.placeholders.length > 0;
          if (E(I)) {
            if (j.syntacticPlaceholders === !1)
              throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
            _ = I.name.name, T = !0;
          } else {
            if (T || j.syntacticPlaceholders)
              return;
            if (h(I) || y(I))
              _ = I.name;
            else {
              if (!g(I))
                return;
              _ = I.value;
            }
          }
          if (T && (j.placeholderPattern != null || j.placeholderWhitelist != null))
            throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
          if (!(T || j.placeholderPattern !== !1 && (j.placeholderPattern || N).test(_) || (F = j.placeholderWhitelist) != null && F.has(_)))
            return;
          D = D.slice();
          const { node: v, key: w } = D[D.length - 1];
          let O;
          g(I) || E(I, { expectedNode: "StringLiteral" }) ? O = "string" : b(v) && w === "arguments" || s(v) && w === "arguments" || m(v) && w === "params" ? O = "param" : o(v) && !E(I) ? (O = "statement", D = D.slice(0, -1)) : O = S(I) && E(I) ? "statement" : "other";
          const { placeholders: G, placeholderNames: W } = T ? j.syntactic : j.legacy;
          G.push({ name: _, type: O, resolve: (U) => function(M, B) {
            let k = M;
            for (let z = 0; z < B.length - 1; z++) {
              const { key: q, index: $ } = B[z];
              k = $ === void 0 ? k[q] : k[q][$];
            }
            const { key: K, index: te } = B[B.length - 1];
            return { parent: k, key: K, index: te };
          }(U, D), isDuplicate: W.has(_) }), W.add(_);
        }
      }, "./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/populate.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(S, g) {
          const P = d(S.ast);
          return g && (S.placeholders.forEach((R) => {
            if (!Object.prototype.hasOwnProperty.call(g, R.name)) {
              const N = R.name;
              throw new Error(`Error: No substitution given for "${N}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${N}'])}
            - { placeholderPattern: /^${N}$/ }`);
            }
          }), Object.keys(g).forEach((R) => {
            if (!S.placeholderNames.has(R))
              throw new Error(`Unknown substitution "${R}" given`);
          })), S.placeholders.slice().reverse().forEach((R) => {
            try {
              (function(N, C, I) {
                N.isDuplicate && (Array.isArray(I) ? I = I.map((_) => d(_)) : typeof I == "object" && (I = d(I)));
                const { parent: D, key: j, index: F } = N.resolve(C);
                if (N.type === "string") {
                  if (typeof I == "string" && (I = b(I)), !I || !y(I))
                    throw new Error("Expected string substitution");
                } else if (N.type === "statement")
                  F === void 0 ? I ? Array.isArray(I) ? I = f(I) : typeof I == "string" ? I = o(m(I)) : h(I) || (I = o(I)) : I = s() : I && !Array.isArray(I) && (typeof I == "string" && (I = m(I)), h(I) || (I = o(I)));
                else if (N.type === "param") {
                  if (typeof I == "string" && (I = m(I)), F === void 0)
                    throw new Error("Assertion failure.");
                } else if (typeof I == "string" && (I = m(I)), Array.isArray(I))
                  throw new Error("Cannot replace single expression with an array.");
                if (F === void 0)
                  E(D, j, I), D[j] = I;
                else {
                  const _ = D[j].slice();
                  N.type === "statement" || N.type === "param" ? I == null ? _.splice(F, 1) : Array.isArray(I) ? _.splice(F, 1, ...I) : _[F] = I : _[F] = I, E(D, j, _), D[j] = _;
                }
              })(R, P, g && g[R.name] || null);
            } catch (N) {
              throw N.message = `@babel/template placeholder "${R.name}": ${N.message}`, N;
            }
          }), P;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { blockStatement: f, cloneNode: d, emptyStatement: s, expressionStatement: o, identifier: m, isStatement: h, isStringLiteral: y, stringLiteral: b, validate: E } = i;
      }, "./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/string.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(s, o, m) {
          let h;
          return o = s.code(o), (y) => {
            const b = (0, i.normalizeReplacements)(y);
            return h || (h = (0, f.default)(s, o, m)), s.unwrap((0, d.default)(h, b));
          };
        };
        var i = l("./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/options.js"), f = l("./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/parse.js"), d = l("./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/populate.js");
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/cache.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.clear = function() {
          f(), d();
        }, r.clearPath = f, r.clearScope = d, r.getCachedPaths = function(o, m) {
          var h;
          return (h = l.get(s)) == null ? void 0 : h.get(m);
        }, r.getOrCreateCachedPaths = function(o, m) {
          let h = l.get(s);
          h || l.set(s, h = /* @__PURE__ */ new WeakMap());
          let y = h.get(m);
          return y || h.set(m, y = /* @__PURE__ */ new Map()), y;
        }, r.scope = r.path = void 0;
        let l = /* @__PURE__ */ new WeakMap();
        r.path = l;
        let i = /* @__PURE__ */ new WeakMap();
        function f() {
          r.path = l = /* @__PURE__ */ new WeakMap();
        }
        function d() {
          r.scope = i = /* @__PURE__ */ new WeakMap();
        }
        r.scope = i;
        const s = Object.freeze({});
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/context.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/index.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { VISITOR_KEYS: d } = f;
        r.default = class {
          constructor(s, o, m, h) {
            this.queue = null, this.priorityQueue = null, this.parentPath = h, this.scope = s, this.state = m, this.opts = o;
          }
          shouldVisit(s) {
            const o = this.opts;
            if (o.enter || o.exit || o[s.type])
              return !0;
            const m = d[s.type];
            if (m == null || !m.length)
              return !1;
            for (const h of m)
              if (s[h])
                return !0;
            return !1;
          }
          create(s, o, m, h) {
            return i.default.get({ parentPath: this.parentPath, parent: s, container: o, key: m, listKey: h });
          }
          maybeQueue(s, o) {
            this.queue && (o ? this.queue.push(s) : this.priorityQueue.push(s));
          }
          visitMultiple(s, o, m) {
            if (s.length === 0)
              return !1;
            const h = [];
            for (let y = 0; y < s.length; y++) {
              const b = s[y];
              b && this.shouldVisit(b) && h.push(this.create(o, s, y, m));
            }
            return this.visitQueue(h);
          }
          visitSingle(s, o) {
            return !!this.shouldVisit(s[o]) && this.visitQueue([this.create(s, s, o)]);
          }
          visitQueue(s) {
            this.queue = s, this.priorityQueue = [];
            const o = /* @__PURE__ */ new WeakSet();
            let m = !1;
            for (const h of s) {
              if (h.resync(), h.contexts.length !== 0 && h.contexts[h.contexts.length - 1] === this || h.pushContext(this), h.key === null)
                continue;
              const { node: y } = h;
              if (!o.has(y)) {
                if (y && o.add(y), h.visit()) {
                  m = !0;
                  break;
                }
                if (this.priorityQueue.length && (m = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = s, m))
                  break;
              }
            }
            for (const h of s)
              h.popContext();
            return this.queue = null, m;
          }
          visit(s, o) {
            const m = s[o];
            return !!m && (Array.isArray(m) ? this.visitMultiple(m, s, o) : this.visitSingle(s, o));
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/hub.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0, r.default = class {
          getCode() {
          }
          getScope() {
          }
          addHelper() {
            throw new Error("Helpers are not supported by the default hub.");
          }
          buildError(l, i, f = TypeError) {
            return new f(i);
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), Object.defineProperty(r, "Hub", { enumerable: !0, get: function() {
          return h.default;
        } }), Object.defineProperty(r, "NodePath", { enumerable: !0, get: function() {
          return o.default;
        } }), Object.defineProperty(r, "Scope", { enumerable: !0, get: function() {
          return m.default;
        } }), r.visitors = r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/visitors.js");
        r.visitors = i;
        var f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js"), d = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/cache.js"), s = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/traverse-node.js"), o = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/index.js"), m = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/scope/index.js"), h = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/hub.js");
        const { VISITOR_KEYS: y, removeProperties: b, traverseFast: E } = f;
        function S(R, N = {}, C, I, D, j) {
          if (R) {
            if (!N.noScope && !C && R.type !== "Program" && R.type !== "File")
              throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${R.type} node without passing scope and parentPath.`);
            if (!D && j)
              throw new Error("visitSelf can only be used when providing a NodePath.");
            y[R.type] && (i.explode(N), (0, s.traverseNode)(R, N, C, I, D, null, j));
          }
        }
        var g = S;
        function P(R, N) {
          R.node.type === N.type && (N.has = !0, R.stop());
        }
        r.default = g, S.visitors = i, S.verify = i.verify, S.explode = i.explode, S.cheap = function(R, N) {
          E(R, N);
        }, S.node = function(R, N, C, I, D, j) {
          (0, s.traverseNode)(R, N, C, I, D, j);
        }, S.clearNode = function(R, N) {
          b(R, N);
        }, S.removeProperties = function(R, N) {
          return E(R, S.clearNode, N), R;
        }, S.hasType = function(R, N, C) {
          if (C != null && C.includes(R.type))
            return !1;
          if (R.type === N)
            return !0;
          const I = { has: !1, type: N };
          return S(R, { noScope: !0, denylist: C, enter: P }, null, I), I.has;
        }, S.cache = d;
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/ancestry.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.find = function(d) {
          let s = this;
          do
            if (d(s))
              return s;
          while (s = s.parentPath);
          return null;
        }, r.findParent = function(d) {
          let s = this;
          for (; s = s.parentPath; )
            if (d(s))
              return s;
          return null;
        }, r.getAncestry = function() {
          let d = this;
          const s = [];
          do
            s.push(d);
          while (d = d.parentPath);
          return s;
        }, r.getDeepestCommonAncestorFrom = function(d, s) {
          if (!d.length)
            return this;
          if (d.length === 1)
            return d[0];
          let o, m, h = 1 / 0;
          const y = d.map((E) => {
            const S = [];
            do
              S.unshift(E);
            while ((E = E.parentPath) && E !== this);
            return S.length < h && (h = S.length), S;
          }), b = y[0];
          e:
            for (let E = 0; E < h; E++) {
              const S = b[E];
              for (const g of y)
                if (g[E] !== S)
                  break e;
              o = E, m = S;
            }
          if (m)
            return s ? s(m, o, y) : m;
          throw new Error("Couldn't find intersection");
        }, r.getEarliestCommonAncestorFrom = function(d) {
          return this.getDeepestCommonAncestorFrom(d, function(s, o, m) {
            let h;
            const y = f[s.type];
            for (const b of m) {
              const E = b[o + 1];
              if (!h) {
                h = E;
                continue;
              }
              if (E.listKey && h.listKey === E.listKey && E.key < h.key) {
                h = E;
                continue;
              }
              y.indexOf(h.parentKey) > y.indexOf(E.parentKey) && (h = E);
            }
            return h;
          });
        }, r.getFunctionParent = function() {
          return this.findParent((d) => d.isFunction());
        }, r.getStatementParent = function() {
          let d = this;
          do {
            if (!d.parentPath || Array.isArray(d.container) && d.isStatement())
              break;
            d = d.parentPath;
          } while (d);
          if (d && (d.isProgram() || d.isFile()))
            throw new Error("File/Program node, we can't possibly find a statement parent to this");
          return d;
        }, r.inType = function(...d) {
          let s = this;
          for (; s; ) {
            for (const o of d)
              if (s.node.type === o)
                return !0;
            s = s.parentPath;
          }
          return !1;
        }, r.isAncestor = function(d) {
          return d.isDescendant(this);
        }, r.isDescendant = function(d) {
          return !!this.findParent((s) => s === d);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { VISITOR_KEYS: f } = i;
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/comments.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.addComment = function(o, m, h) {
          f(this.node, o, m, h);
        }, r.addComments = function(o, m) {
          d(this.node, o, m);
        }, r.shareCommentsWithSiblings = function() {
          if (typeof this.key == "string")
            return;
          const o = this.node;
          if (!o)
            return;
          const m = o.trailingComments, h = o.leadingComments;
          if (!m && !h)
            return;
          const y = this.getSibling(this.key - 1), b = this.getSibling(this.key + 1), E = !!y.node, S = !!b.node;
          E && (h && y.addComments("trailing", s(h, y.node.trailingComments)), m && !S && y.addComments("trailing", m)), S && (m && b.addComments("leading", s(m, b.node.leadingComments)), h && !E && b.addComments("leading", h));
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { addComment: f, addComments: d } = i;
        function s(o, m) {
          if (!m)
            return o;
          let h = -1;
          return o.filter((y) => {
            const b = m.indexOf(y, h);
            if (b === -1)
              return !0;
            h = b;
          });
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/context.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r._call = function(s) {
          if (!s)
            return !1;
          for (const o of s) {
            if (!o)
              continue;
            const m = this.node;
            if (!m)
              return !0;
            const h = o.call(this.state, this, this.state);
            if (h && typeof h == "object" && typeof h.then == "function")
              throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
            if (h)
              throw new Error(`Unexpected return value from visitor method ${o}`);
            if (this.node !== m || this._traverseFlags > 0)
              return !0;
          }
          return !1;
        }, r._getQueueContexts = function() {
          let s = this, o = this.contexts;
          for (; !o.length && (s = s.parentPath, s); )
            o = s.contexts;
          return o;
        }, r._resyncKey = function() {
          if (this.container && this.node !== this.container[this.key]) {
            if (Array.isArray(this.container)) {
              for (let s = 0; s < this.container.length; s++)
                if (this.container[s] === this.node)
                  return void this.setKey(s);
            } else
              for (const s of Object.keys(this.container))
                if (this.container[s] === this.node)
                  return void this.setKey(s);
            this.key = null;
          }
        }, r._resyncList = function() {
          if (!this.parent || !this.inList)
            return;
          const s = this.parent[this.listKey];
          this.container !== s && (this.container = s || null);
        }, r._resyncParent = function() {
          this.parentPath && (this.parent = this.parentPath.node);
        }, r._resyncRemoved = function() {
          this.key != null && this.container && this.container[this.key] === this.node || this._markRemoved();
        }, r.call = function(s) {
          const o = this.opts;
          if (this.debug(s), this.node && this._call(o[s]))
            return !0;
          var m;
          return !!this.node && this._call((m = o[this.node.type]) == null ? void 0 : m[s]);
        }, r.isBlacklisted = r.isDenylisted = function() {
          var s;
          const o = (s = this.opts.denylist) != null ? s : this.opts.blacklist;
          return o && o.indexOf(this.node.type) > -1;
        }, r.popContext = function() {
          this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
        }, r.pushContext = function(s) {
          this.contexts.push(s), this.setContext(s);
        }, r.requeue = function(s = this) {
          if (s.removed)
            return;
          const o = this.contexts;
          for (const m of o)
            m.maybeQueue(s);
        }, r.resync = function() {
          this.removed || (this._resyncParent(), this._resyncList(), this._resyncKey());
        }, r.setContext = function(s) {
          return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, s && (this.context = s, this.state = s.state, this.opts = s.opts), this.setScope(), this;
        }, r.setKey = function(s) {
          var o;
          this.key = s, this.node = this.container[this.key], this.type = (o = this.node) == null ? void 0 : o.type;
        }, r.setScope = function() {
          var s, o;
          if ((s = this.opts) != null && s.noScope)
            return;
          let m, h = this.parentPath;
          for (((this.key === "key" || this.listKey === "decorators") && h.isMethod() || this.key === "discriminant" && h.isSwitchStatement()) && (h = h.parentPath); h && !m; ) {
            var y;
            if ((y = h.opts) != null && y.noScope)
              return;
            m = h.scope, h = h.parentPath;
          }
          this.scope = this.getScope(m), (o = this.scope) == null || o.init();
        }, r.setup = function(s, o, m, h) {
          this.listKey = m, this.container = o, this.parentPath = s || this.parentPath, this.setKey(h);
        }, r.skip = function() {
          this.shouldSkip = !0;
        }, r.skipKey = function(s) {
          this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[s] = !0;
        }, r.stop = function() {
          this._traverseFlags |= f.SHOULD_SKIP | f.SHOULD_STOP;
        }, r.visit = function() {
          var s, o;
          if (!this.node || this.isDenylisted() || (s = (o = this.opts).shouldSkip) != null && s.call(o, this))
            return !1;
          const m = this.context;
          return this.shouldSkip || this.call("enter") ? (this.debug("Skip..."), this.shouldStop) : (d(this, m), this.debug("Recursing into..."), this.shouldStop = (0, i.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), d(this, m), this.call("exit"), this.shouldStop);
        };
        var i = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/traverse-node.js"), f = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/index.js");
        function d(s, o) {
          s.context !== o && (s.context = o, s.state = o.state, s.opts = o.opts);
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/conversion.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.arrowFunctionToExpression = function({ allowInsertArrow: $ = !0, allowInsertArrowWithRest: Y = $, noNewArrows: H = !((Q) => (Q = arguments[0]) == null ? void 0 : Q.specCompliant)() } = {}) {
          if (!this.isArrowFunctionExpression())
            throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
          const { thisBinding: Q, fnPath: X } = k(this, H, $, Y);
          if (X.ensureBlock(), function(ne, ye) {
            ne.node.type = ye;
          }(X, "FunctionExpression"), !H) {
            const ne = Q ? null : X.scope.generateUidIdentifier("arrowCheckId");
            return ne && X.parentPath.scope.push({ id: ne, init: F([]) }), X.get("body").unshiftContainer("body", S(b(this.hub.addHelper("newArrowCheck"), [W(), g(ne ? ne.name : Q)]))), X.replaceWith(b(I((0, d.default)(this, !0) || X.node, g("bind")), [ne ? g(ne.name) : W()])), X.get("callee.object");
          }
          return X;
        }, r.ensureBlock = function() {
          const $ = this.get("body"), Y = $.node;
          if (Array.isArray($))
            throw new Error("Can't convert array path to a block statement");
          if (!Y)
            throw new Error("Can't convert node without a body");
          if ($.isBlockStatement())
            return Y;
          const H = [];
          let Q, X, ne = "body";
          $.isStatement() ? (X = "body", Q = 0, H.push($.node)) : (ne += ".body.0", this.isFunction() ? (Q = "argument", H.push(T($.node))) : (Q = "expression", H.push(S($.node)))), this.node.body = y(H);
          const ye = this.get(ne);
          return $.setup(ye, X ? ye.node[X] : ye.node, X, Q), this.node;
        }, r.toComputedKey = function() {
          let $;
          if (this.isMemberExpression())
            $ = this.node.property;
          else {
            if (!this.isProperty() && !this.isMethod())
              throw new ReferenceError("todo");
            $ = this.node.key;
          }
          return this.node.computed || P($) && ($ = O($.name)), $;
        }, r.unwrapFunctionEnvironment = function() {
          if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
            throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
          k(this);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js"), f = l("./node_modules/.pnpm/@babel+helper-environment-visitor@7.22.5/node_modules/@babel/helper-environment-visitor/lib/index.js"), d = l("./node_modules/.pnpm/@babel+helper-function-name@7.22.5/node_modules/@babel/helper-function-name/lib/index.js"), s = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/visitors.js");
        const { arrowFunctionExpression: o, assignmentExpression: m, binaryExpression: h, blockStatement: y, callExpression: b, conditionalExpression: E, expressionStatement: S, identifier: g, isIdentifier: P, jsxIdentifier: R, logicalExpression: N, LOGICAL_OPERATORS: C, memberExpression: I, metaProperty: D, numericLiteral: j, objectExpression: F, restElement: _, returnStatement: T, sequenceExpression: v, spreadElement: w, stringLiteral: O, super: G, thisExpression: W, toExpression: U, unaryExpression: M } = i;
        r.arrowFunctionToShadowed = function() {
          this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
        };
        const B = (0, s.merge)([{ CallExpression($, { allSuperCalls: Y }) {
          $.get("callee").isSuper() && Y.push($);
        } }, f.default]);
        function k($, Y = !0, H = !0, Q = !0) {
          let X, ne = $.findParent((ue) => ue.isArrowFunctionExpression() ? (X != null || (X = ue), !1) : ue.isFunction() || ue.isProgram() || ue.isClassProperty({ static: !1 }) || ue.isClassPrivateProperty({ static: !1 }));
          const ye = ne.isClassMethod({ kind: "constructor" });
          if (ne.isClassProperty() || ne.isClassPrivateProperty())
            if (X)
              ne = X;
            else {
              if (!H)
                throw $.buildCodeFrameError("Unable to transform arrow inside class property");
              $.replaceWith(b(o([], U($.node)), [])), ne = $.get("callee"), $ = ne.get("body");
            }
          const { thisPaths: ve, argumentsPaths: de, newTargetPaths: oe, superProps: re, superCalls: ae } = function(ue) {
            const ie = [], we = [], De = [], Ee = [], Ae = [];
            return ue.traverse(q, { thisPaths: ie, argumentsPaths: we, newTargetPaths: De, superProps: Ee, superCalls: Ae }), { thisPaths: ie, argumentsPaths: we, newTargetPaths: De, superProps: Ee, superCalls: Ae };
          }($);
          if (ye && ae.length > 0) {
            if (!H)
              throw ae[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            if (!Q)
              throw ae[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            const ue = [];
            ne.traverse(B, { allSuperCalls: ue });
            const ie = function(we) {
              return z(we, "supercall", () => {
                const De = we.scope.generateUidIdentifier("args");
                return o([_(De)], b(G(), [w(g(De.name))]));
              });
            }(ne);
            ue.forEach((we) => {
              const De = g(ie);
              De.loc = we.node.callee.loc, we.get("callee").replaceWith(De);
            });
          }
          if (de.length > 0) {
            const ue = z(ne, "arguments", () => {
              const ie = () => g("arguments");
              return ne.scope.path.isProgram() ? E(h("===", M("typeof", ie()), O("undefined")), ne.scope.buildUndefinedNode(), ie()) : ie();
            });
            de.forEach((ie) => {
              const we = g(ue);
              we.loc = ie.node.loc, ie.replaceWith(we);
            });
          }
          if (oe.length > 0) {
            const ue = z(ne, "newtarget", () => D(g("new"), g("target")));
            oe.forEach((ie) => {
              const we = g(ue);
              we.loc = ie.node.loc, ie.replaceWith(we);
            });
          }
          if (re.length > 0) {
            if (!H)
              throw re[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            re.reduce((ue, ie) => ue.concat(function(we) {
              if (we.parentPath.isAssignmentExpression() && we.parentPath.node.operator !== "=") {
                const Ee = we.parentPath, Ae = Ee.node.operator.slice(0, -1), Me = Ee.node.right, me = function(se) {
                  return C.includes(se);
                }(Ae);
                if (we.node.computed) {
                  const se = we.scope.generateDeclaredUidIdentifier("tmp"), Z = we.node.object, pe = we.node.property;
                  Ee.get("left").replaceWith(I(Z, m("=", se, pe), !0)), Ee.get("right").replaceWith(De(me ? "=" : Ae, I(Z, g(se.name), !0), Me));
                } else {
                  const se = we.node.object, Z = we.node.property;
                  Ee.get("left").replaceWith(I(se, Z)), Ee.get("right").replaceWith(De(me ? "=" : Ae, I(se, g(Z.name)), Me));
                }
                return me ? Ee.replaceWith(N(Ae, Ee.node.left, Ee.node.right)) : Ee.node.operator = "=", [Ee.get("left"), Ee.get("right").get("left")];
              }
              if (we.parentPath.isUpdateExpression()) {
                const Ee = we.parentPath, Ae = we.scope.generateDeclaredUidIdentifier("tmp"), Me = we.node.computed ? we.scope.generateDeclaredUidIdentifier("prop") : null, me = [m("=", Ae, I(we.node.object, Me ? m("=", Me, we.node.property) : we.node.property, we.node.computed)), m("=", I(we.node.object, Me ? g(Me.name) : we.node.property, we.node.computed), h(we.parentPath.node.operator[0], g(Ae.name), j(1)))];
                return we.parentPath.node.prefix || me.push(g(Ae.name)), Ee.replaceWith(v(me)), [Ee.get("expressions.0.right"), Ee.get("expressions.1.left")];
              }
              return [we];
              function De(Ee, Ae, Me) {
                return Ee === "=" ? m("=", Ae, Me) : h(Ee, Ae, Me);
              }
            }(ie)), []).forEach((ue) => {
              const ie = ue.node.computed ? "" : ue.get("property").node.name, we = ue.parentPath, De = we.isAssignmentExpression({ left: ue.node }), Ee = we.isCallExpression({ callee: ue.node }), Ae = we.isTaggedTemplateExpression({ tag: ue.node }), Me = function(Z, pe, be) {
                return z(Z, `superprop_${pe ? "set" : "get"}:${be || ""}`, () => {
                  const Ie = [];
                  let We;
                  if (be)
                    We = I(G(), g(be));
                  else {
                    const tt = Z.scope.generateUidIdentifier("prop");
                    Ie.unshift(tt), We = I(G(), g(tt.name), !0);
                  }
                  if (pe) {
                    const tt = Z.scope.generateUidIdentifier("value");
                    Ie.push(tt), We = m("=", We, g(tt.name));
                  }
                  return o(Ie, We);
                });
              }(ne, De, ie), me = [];
              if (ue.node.computed && me.push(ue.get("property").node), De) {
                const Z = we.node.right;
                me.push(Z);
              }
              const se = b(g(Me), me);
              Ee ? (we.unshiftContainer("arguments", W()), ue.replaceWith(I(se, g("call"))), ve.push(we.get("arguments.0"))) : De ? we.replaceWith(se) : Ae ? (ue.replaceWith(b(I(se, g("bind"), !1), [W()])), ve.push(ue.get("arguments.0"))) : ue.replaceWith(se);
            });
          }
          let le;
          return (ve.length > 0 || !Y) && (le = function(ue, ie) {
            return z(ue, "this", (we) => {
              if (!ie || !K(ue))
                return W();
              ue.traverse(te, { supers: /* @__PURE__ */ new WeakSet(), thisBinding: we });
            });
          }(ne, ye), (Y || ye && K(ne)) && (ve.forEach((ue) => {
            const ie = ue.isJSX() ? R(le) : g(le);
            ie.loc = ue.node.loc, ue.replaceWith(ie);
          }), Y || (le = null))), { thisBinding: le, fnPath: $ };
        }
        function K($) {
          return $.isClassMethod() && !!$.parentPath.parentPath.node.superClass;
        }
        const te = (0, s.merge)([{ CallExpression($, { supers: Y, thisBinding: H }) {
          $.get("callee").isSuper() && (Y.has($.node) || (Y.add($.node), $.replaceWithMultiple([$.node, m("=", g(H), g("this"))])));
        } }, f.default]);
        function z($, Y, H) {
          const Q = "binding:" + Y;
          let X = $.getData(Q);
          if (!X) {
            const ne = $.scope.generateUidIdentifier(Y);
            X = ne.name, $.setData(Q, X), $.scope.push({ id: ne, init: H(X) });
          }
          return X;
        }
        const q = (0, s.merge)([{ ThisExpression($, { thisPaths: Y }) {
          Y.push($);
        }, JSXIdentifier($, { thisPaths: Y }) {
          $.node.name === "this" && ($.parentPath.isJSXMemberExpression({ object: $.node }) || $.parentPath.isJSXOpeningElement({ name: $.node })) && Y.push($);
        }, CallExpression($, { superCalls: Y }) {
          $.get("callee").isSuper() && Y.push($);
        }, MemberExpression($, { superProps: Y }) {
          $.get("object").isSuper() && Y.push($);
        }, Identifier($, { argumentsPaths: Y }) {
          if (!$.isReferencedIdentifier({ name: "arguments" }))
            return;
          let H = $.scope;
          do {
            if (H.hasOwnBinding("arguments"))
              return void H.rename("arguments");
            if (H.path.isFunction() && !H.path.isArrowFunctionExpression())
              break;
          } while (H = H.parent);
          Y.push($);
        }, MetaProperty($, { newTargetPaths: Y }) {
          $.get("meta").isIdentifier({ name: "new" }) && $.get("property").isIdentifier({ name: "target" }) && Y.push($);
        } }, f.default]);
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/evaluation.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.evaluate = function() {
          const h = { confident: !0, deoptPath: null, seen: /* @__PURE__ */ new Map() };
          let y = o(this, h);
          return h.confident || (y = void 0), { confident: h.confident, deopt: h.deoptPath, value: y };
        }, r.evaluateTruthy = function() {
          const h = this.evaluate();
          if (h.confident)
            return !!h.value;
        };
        const l = ["String", "Number", "Math"], i = ["random"];
        function f(h) {
          return l.includes(h);
        }
        function d(h, y) {
          y.confident && (y.deoptPath = h, y.confident = !1);
        }
        const s = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
        function o(h, y) {
          const { node: b } = h, { seen: E } = y;
          if (E.has(b)) {
            const S = E.get(b);
            return S.resolved ? S.value : void d(h, y);
          }
          {
            const S = { resolved: !1 };
            E.set(b, S);
            const g = function(P, R) {
              if (R.confident) {
                if (P.isSequenceExpression()) {
                  const N = P.get("expressions");
                  return o(N[N.length - 1], R);
                }
                if (P.isStringLiteral() || P.isNumericLiteral() || P.isBooleanLiteral())
                  return P.node.value;
                if (P.isNullLiteral())
                  return null;
                if (P.isTemplateLiteral())
                  return m(P, P.node.quasis, R);
                if (P.isTaggedTemplateExpression() && P.get("tag").isMemberExpression()) {
                  const N = P.get("tag.object"), { node: { name: C } } = N, I = P.get("tag.property");
                  if (N.isIdentifier() && C === "String" && !P.scope.getBinding(C) && I.isIdentifier() && I.node.name === "raw")
                    return m(P, P.node.quasi.quasis, R, !0);
                }
                if (P.isConditionalExpression()) {
                  const N = o(P.get("test"), R);
                  return R.confident ? o(N ? P.get("consequent") : P.get("alternate"), R) : void 0;
                }
                if (P.isExpressionWrapper())
                  return o(P.get("expression"), R);
                if (P.isMemberExpression() && !P.parentPath.isCallExpression({ callee: P.node })) {
                  const N = P.get("property"), C = P.get("object");
                  if (C.isLiteral()) {
                    const I = C.node.value, D = typeof I;
                    let j = null;
                    if (P.node.computed) {
                      if (j = o(N, R), !R.confident)
                        return;
                    } else
                      N.isIdentifier() && (j = N.node.name);
                    if (!(D !== "number" && D !== "string" || j == null || typeof j != "number" && typeof j != "string"))
                      return I[j];
                  }
                }
                if (P.isReferencedIdentifier()) {
                  const N = P.scope.getBinding(P.node.name);
                  if (N) {
                    if (N.constantViolations.length > 0 || P.node.start < N.path.node.end)
                      return void d(N.path, R);
                    if (N.hasValue)
                      return N.value;
                  }
                  const C = P.node.name;
                  if (s.has(C))
                    return N ? void d(N.path, R) : s.get(C);
                  const I = P.resolve();
                  return I === P ? void d(P, R) : o(I, R);
                }
                if (P.isUnaryExpression({ prefix: !0 })) {
                  if (P.node.operator === "void")
                    return;
                  const N = P.get("argument");
                  if (P.node.operator === "typeof" && (N.isFunction() || N.isClass()))
                    return "function";
                  const C = o(N, R);
                  if (!R.confident)
                    return;
                  switch (P.node.operator) {
                    case "!":
                      return !C;
                    case "+":
                      return +C;
                    case "-":
                      return -C;
                    case "~":
                      return ~C;
                    case "typeof":
                      return typeof C;
                  }
                }
                if (P.isArrayExpression()) {
                  const N = [], C = P.get("elements");
                  for (const I of C) {
                    const D = I.evaluate();
                    if (!D.confident)
                      return void d(D.deopt, R);
                    N.push(D.value);
                  }
                  return N;
                }
                if (P.isObjectExpression()) {
                  const N = {}, C = P.get("properties");
                  for (const I of C) {
                    if (I.isObjectMethod() || I.isSpreadElement())
                      return void d(I, R);
                    const D = I.get("key");
                    let j;
                    if (I.node.computed) {
                      if (j = D.evaluate(), !j.confident)
                        return void d(j.deopt, R);
                      j = j.value;
                    } else
                      j = D.isIdentifier() ? D.node.name : D.node.value;
                    let F = I.get("value").evaluate();
                    if (!F.confident)
                      return void d(F.deopt, R);
                    F = F.value, N[j] = F;
                  }
                  return N;
                }
                if (P.isLogicalExpression()) {
                  const N = R.confident, C = o(P.get("left"), R), I = R.confident;
                  R.confident = N;
                  const D = o(P.get("right"), R), j = R.confident;
                  switch (P.node.operator) {
                    case "||":
                      return R.confident = I && (!!C || j), R.confident ? C || D : void 0;
                    case "&&":
                      return R.confident = I && (!C || j), R.confident ? C && D : void 0;
                    case "??":
                      return R.confident = I && (C != null || j), R.confident ? C ?? D : void 0;
                  }
                }
                if (P.isBinaryExpression()) {
                  const N = o(P.get("left"), R);
                  if (!R.confident)
                    return;
                  const C = o(P.get("right"), R);
                  if (!R.confident)
                    return;
                  switch (P.node.operator) {
                    case "-":
                      return N - C;
                    case "+":
                      return N + C;
                    case "/":
                      return N / C;
                    case "*":
                      return N * C;
                    case "%":
                      return N % C;
                    case "**":
                      return Math.pow(N, C);
                    case "<":
                      return N < C;
                    case ">":
                      return N > C;
                    case "<=":
                      return N <= C;
                    case ">=":
                      return N >= C;
                    case "==":
                      return N == C;
                    case "!=":
                      return N != C;
                    case "===":
                      return N === C;
                    case "!==":
                      return N !== C;
                    case "|":
                      return N | C;
                    case "&":
                      return N & C;
                    case "^":
                      return N ^ C;
                    case "<<":
                      return N << C;
                    case ">>":
                      return N >> C;
                    case ">>>":
                      return N >>> C;
                  }
                }
                if (P.isCallExpression()) {
                  const N = P.get("callee");
                  let C, I;
                  if (N.isIdentifier() && !P.scope.getBinding(N.node.name) && f(N.node.name) && (I = Bt[N.node.name]), N.isMemberExpression()) {
                    const D = N.get("object"), j = N.get("property");
                    if (D.isIdentifier() && j.isIdentifier() && f(D.node.name) && !function(F) {
                      return i.includes(F);
                    }(j.node.name) && (C = Bt[D.node.name], I = C[j.node.name]), D.isLiteral() && j.isIdentifier()) {
                      const F = typeof D.node.value;
                      F !== "string" && F !== "number" || (C = D.node.value, I = C[j.node.name]);
                    }
                  }
                  if (I) {
                    const D = P.get("arguments").map((j) => o(j, R));
                    return R.confident ? I.apply(C, D) : void 0;
                  }
                }
                d(P, R);
              }
            }(h, y);
            return y.confident && (S.resolved = !0, S.value = g), g;
          }
        }
        function m(h, y, b, E = !1) {
          let S = "", g = 0;
          const P = h.isTemplateLiteral() ? h.get("expressions") : h.get("quasi.expressions");
          for (const R of y) {
            if (!b.confident)
              break;
            S += E ? R.value.raw : R.value.cooked;
            const N = P[g++];
            N && (S += String(o(N, b)));
          }
          if (b.confident)
            return S;
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/family.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r._getKey = function(N, C) {
          const I = this.node, D = I[N];
          return Array.isArray(D) ? D.map((j, F) => i.default.get({ listKey: N, parentPath: this, parent: I, container: D, key: F }).setContext(C)) : i.default.get({ parentPath: this, parent: I, container: I, key: N }).setContext(C);
        }, r._getPattern = function(N, C) {
          let I = this;
          for (const D of N)
            I = D === "." ? I.parentPath : Array.isArray(I) ? I[D] : I.get(D, C);
          return I;
        }, r.get = function(N, C = !0) {
          C === !0 && (C = this.context);
          const I = N.split(".");
          return I.length === 1 ? this._getKey(N, C) : this._getPattern(I, C);
        }, r.getAllNextSiblings = function() {
          let N = this.key, C = this.getSibling(++N);
          const I = [];
          for (; C.node; )
            I.push(C), C = this.getSibling(++N);
          return I;
        }, r.getAllPrevSiblings = function() {
          let N = this.key, C = this.getSibling(--N);
          const I = [];
          for (; C.node; )
            I.push(C), C = this.getSibling(--N);
          return I;
        }, r.getBindingIdentifierPaths = function(N = !1, C = !1) {
          const I = [this], D = /* @__PURE__ */ Object.create(null);
          for (; I.length; ) {
            const j = I.shift();
            if (!j || !j.node)
              continue;
            const F = d.keys[j.node.type];
            if (j.isIdentifier())
              N ? (D[j.node.name] = D[j.node.name] || []).push(j) : D[j.node.name] = j;
            else if (j.isExportDeclaration()) {
              const _ = j.get("declaration");
              o(_) && I.push(_);
            } else {
              if (C) {
                if (j.isFunctionDeclaration()) {
                  I.push(j.get("id"));
                  continue;
                }
                if (j.isFunctionExpression())
                  continue;
              }
              if (F)
                for (let _ = 0; _ < F.length; _++) {
                  const T = F[_], v = j.get(T);
                  Array.isArray(v) ? I.push(...v) : v.node && I.push(v);
                }
            }
          }
          return D;
        }, r.getBindingIdentifiers = function(N) {
          return d(this.node, N);
        }, r.getCompletionRecords = function() {
          return R(this, { canHaveBreak: !1, shouldPopulateBreak: !1, inCaseClause: !1 }).map((N) => N.path);
        }, r.getNextSibling = function() {
          return this.getSibling(this.key + 1);
        }, r.getOpposite = function() {
          return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
        }, r.getOuterBindingIdentifierPaths = function(N = !1) {
          return this.getBindingIdentifierPaths(N, !0);
        }, r.getOuterBindingIdentifiers = function(N) {
          return s(this.node, N);
        }, r.getPrevSibling = function() {
          return this.getSibling(this.key - 1);
        }, r.getSibling = function(N) {
          return i.default.get({ parentPath: this.parentPath, parent: this.parent, container: this.container, listKey: this.listKey, key: N }).setContext(this.context);
        };
        var i = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/index.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { getBindingIdentifiers: d, getOuterBindingIdentifiers: s, isDeclaration: o, numericLiteral: m, unaryExpression: h } = f, y = 0, b = 1;
        function E(N, C, I) {
          return N && C.push(...R(N, I)), C;
        }
        function S(N) {
          N.forEach((C) => {
            C.type = b;
          });
        }
        function g(N, C) {
          N.forEach((I) => {
            I.path.isBreakStatement({ label: null }) && (C ? I.path.replaceWith(h("void", m(0))) : I.path.remove());
          });
        }
        function P(N, C) {
          const I = [];
          if (C.canHaveBreak) {
            let D = [];
            for (let j = 0; j < N.length; j++) {
              const F = N[j], _ = Object.assign({}, C, { inCaseClause: !1 });
              F.isBlockStatement() && (C.inCaseClause || C.shouldPopulateBreak) ? _.shouldPopulateBreak = !0 : _.shouldPopulateBreak = !1;
              const T = R(F, _);
              if (T.length > 0 && T.every((v) => v.type === b)) {
                D.length > 0 && T.every((v) => v.path.isBreakStatement({ label: null })) ? (S(D), I.push(...D), D.some((v) => v.path.isDeclaration()) && (I.push(...T), g(T, !0)), g(T, !1)) : (I.push(...T), C.shouldPopulateBreak || g(T, !0));
                break;
              }
              if (j === N.length - 1)
                I.push(...T);
              else {
                D = [];
                for (let v = 0; v < T.length; v++) {
                  const w = T[v];
                  w.type === b && I.push(w), w.type === y && D.push(w);
                }
              }
            }
          } else if (N.length)
            for (let D = N.length - 1; D >= 0; D--) {
              const j = R(N[D], C);
              if (j.length > 1 || j.length === 1 && !j[0].path.isVariableDeclaration()) {
                I.push(...j);
                break;
              }
            }
          return I;
        }
        function R(N, C) {
          let I = [];
          if (N.isIfStatement())
            I = E(N.get("consequent"), I, C), I = E(N.get("alternate"), I, C);
          else {
            if (N.isDoExpression() || N.isFor() || N.isWhile() || N.isLabeledStatement())
              return E(N.get("body"), I, C);
            if (N.isProgram() || N.isBlockStatement())
              return P(N.get("body"), C);
            if (N.isFunction())
              return R(N.get("body"), C);
            if (N.isTryStatement())
              I = E(N.get("block"), I, C), I = E(N.get("handler"), I, C);
            else {
              if (N.isCatchClause())
                return E(N.get("body"), I, C);
              if (N.isSwitchStatement())
                return function(D, j, F) {
                  let _ = [];
                  for (let T = 0; T < D.length; T++) {
                    const v = R(D[T], F), w = [], O = [];
                    for (const G of v)
                      G.type === y && w.push(G), G.type === b && O.push(G);
                    w.length && (_ = w), j.push(...O);
                  }
                  return j.push(..._), j;
                }(N.get("cases"), I, C);
              if (N.isSwitchCase())
                return P(N.get("consequent"), { canHaveBreak: !0, shouldPopulateBreak: !1, inCaseClause: !0 });
              N.isBreakStatement() ? I.push(function(D) {
                return { type: b, path: D };
              }(N)) : I.push(function(D) {
                return { type: y, path: D };
              }(N));
            }
          }
          return I;
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = r.SHOULD_STOP = r.SHOULD_SKIP = r.REMOVED = void 0;
        var i = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"), f = l("./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js"), d = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/index.js"), s = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/scope/index.js"), o = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js"), m = o, h = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/cache.js"), y = l("./node_modules/.pnpm/@babel+generator@7.22.15/node_modules/@babel/generator/lib/index.js"), b = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/ancestry.js"), E = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/inference/index.js"), S = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/replacement.js"), g = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/evaluation.js"), P = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/conversion.js"), R = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/introspection.js"), N = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/context.js"), C = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/removal.js"), I = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/modification.js"), D = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/family.js"), j = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/comments.js"), F = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js");
        const { validate: _ } = o, T = f("babel");
        r.REMOVED = 1, r.SHOULD_STOP = 2, r.SHOULD_SKIP = 4;
        class v {
          constructor(G, W) {
            this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = W, this.hub = G, this.data = null, this.context = null, this.scope = null;
          }
          static get({ hub: G, parentPath: W, parent: U, container: M, listKey: B, key: k }) {
            if (!G && W && (G = W.hub), !U)
              throw new Error("To get a node path the parent needs to exist");
            const K = M[k], te = h.getOrCreateCachedPaths(G, U);
            let z = te.get(K);
            return z || (z = new v(G, U), K && te.set(K, z)), z.setup(W, M, B, k), z;
          }
          getScope(G) {
            return this.isScope() ? new s.default(this) : G;
          }
          setData(G, W) {
            return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[G] = W;
          }
          getData(G, W) {
            this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
            let U = this.data[G];
            return U === void 0 && W !== void 0 && (U = this.data[G] = W), U;
          }
          hasNode() {
            return this.node != null;
          }
          buildCodeFrameError(G, W = SyntaxError) {
            return this.hub.buildError(this.node, G, W);
          }
          traverse(G, W) {
            (0, d.default)(this.node, G, this.scope, W, this);
          }
          set(G, W) {
            _(this.node, G, W), this.node[G] = W;
          }
          getPathLocation() {
            const G = [];
            let W = this;
            do {
              let U = W.key;
              W.inList && (U = `${W.listKey}[${U}]`), G.unshift(U);
            } while (W = W.parentPath);
            return G.join(".");
          }
          debug(G) {
            T.enabled && T(`${this.getPathLocation()} ${this.type}: ${G}`);
          }
          toString() {
            return (0, y.default)(this.node).code;
          }
          get inList() {
            return !!this.listKey;
          }
          set inList(G) {
            G || (this.listKey = null);
          }
          get parentKey() {
            return this.listKey || this.key;
          }
          get shouldSkip() {
            return !!(4 & this._traverseFlags);
          }
          set shouldSkip(G) {
            G ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
          }
          get shouldStop() {
            return !!(2 & this._traverseFlags);
          }
          set shouldStop(G) {
            G ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
          }
          get removed() {
            return !!(1 & this._traverseFlags);
          }
          set removed(G) {
            G ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
          }
        }
        Object.assign(v.prototype, b, E, S, g, P, R, N, C, I, D, j), v.prototype._guessExecutionStatusRelativeToDifferentFunctions = R._guessExecutionStatusRelativeTo;
        for (const O of m.TYPES) {
          const G = `is${O}`, W = m[G];
          v.prototype[G] = function(U) {
            return W(this.node, U);
          }, v.prototype[`assert${O}`] = function(U) {
            if (!W(this.node, U))
              throw new TypeError(`Expected node path of type ${O}`);
          };
        }
        Object.assign(v.prototype, F);
        for (const O of Object.keys(i))
          O[0] !== "_" && (m.TYPES.includes(O) || m.TYPES.push(O));
        var w = v;
        r.default = w;
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/inference/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r._getTypeAnnotation = function() {
          const O = this.node;
          if (!O) {
            if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
              const W = this.parentPath.parentPath, U = W.parentPath;
              return W.key === "left" && U.isForInStatement() ? _() : W.key === "left" && U.isForOfStatement() ? d() : T();
            }
            return;
          }
          if (O.typeAnnotation)
            return O.typeAnnotation;
          if (!v.has(O)) {
            v.add(O);
            try {
              var G;
              let W = i[O.type];
              if (W)
                return W.call(this, O);
              if (W = i[this.parentPath.type], (G = W) != null && G.validParent)
                return this.parentPath.getTypeAnnotation();
            } finally {
              v.delete(O);
            }
          }
        }, r.baseTypeStrictlyMatches = function(O) {
          const G = this.getTypeAnnotation(), W = O.getTypeAnnotation();
          return !s(G) && y(G) ? W.type === G.type : !1;
        }, r.couldBeBaseType = function(O) {
          const G = this.getTypeAnnotation();
          if (s(G))
            return !0;
          if (j(G)) {
            for (const W of G.types)
              if (s(W) || w(O, W, !0))
                return !0;
            return !1;
          }
          return w(O, G, !0);
        }, r.getTypeAnnotation = function() {
          let O = this.getData("typeAnnotation");
          return O ?? (O = this._getTypeAnnotation() || d(), (D(O) || N(O)) && (O = O.typeAnnotation), this.setData("typeAnnotation", O), O);
        }, r.isBaseType = function(O, G) {
          return w(O, this.getTypeAnnotation(), G);
        }, r.isGenericType = function(O) {
          const G = this.getTypeAnnotation();
          return O === "Array" && (R(G) || o(G) || I(G)) ? !0 : b(G) && E(G.id, { name: O }) || C(G) && E(G.typeName, { name: O });
        };
        var i = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/inference/inferers.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { anyTypeAnnotation: d, isAnyTypeAnnotation: s, isArrayTypeAnnotation: o, isBooleanTypeAnnotation: m, isEmptyTypeAnnotation: h, isFlowBaseAnnotation: y, isGenericTypeAnnotation: b, isIdentifier: E, isMixedTypeAnnotation: S, isNumberTypeAnnotation: g, isStringTypeAnnotation: P, isTSArrayType: R, isTSTypeAnnotation: N, isTSTypeReference: C, isTupleTypeAnnotation: I, isTypeAnnotation: D, isUnionTypeAnnotation: j, isVoidTypeAnnotation: F, stringTypeAnnotation: _, voidTypeAnnotation: T } = f, v = /* @__PURE__ */ new WeakSet();
        function w(O, G, W) {
          if (O === "string")
            return P(G);
          if (O === "number")
            return g(G);
          if (O === "boolean")
            return m(G);
          if (O === "any")
            return s(G);
          if (O === "mixed")
            return S(G);
          if (O === "empty")
            return h(G);
          if (O === "void")
            return F(G);
          if (W)
            return !1;
          throw new Error(`Unknown base type ${O}`);
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(E) {
          if (!this.isReferenced())
            return;
          const S = this.scope.getBinding(E.name);
          if (S)
            return S.identifier.typeAnnotation ? S.identifier.typeAnnotation : function(g, P, R) {
              const N = [], C = [];
              let I = h(g, P, C);
              const D = b(g, P, R);
              if (D) {
                const j = h(g, D.ifStatement);
                I = I.filter((F) => j.indexOf(F) < 0), N.push(D.typeAnnotation);
              }
              if (I.length) {
                I.push(...C);
                for (const j of I)
                  N.push(j.getTypeAnnotation());
              }
              if (N.length)
                return (0, f.createUnionType)(N);
            }(S, this, E.name);
          if (E.name === "undefined")
            return m();
          if (E.name === "NaN" || E.name === "Infinity")
            return o();
          E.name;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js"), f = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/inference/util.js");
        const { BOOLEAN_NUMBER_BINARY_OPERATORS: d, createTypeAnnotationBasedOnTypeof: s, numberTypeAnnotation: o, voidTypeAnnotation: m } = i;
        function h(E, S, g) {
          const P = E.constantViolations.slice();
          return P.unshift(E.path), P.filter((R) => {
            const N = (R = R.resolve())._guessExecutionStatusRelativeTo(S);
            return g && N === "unknown" && g.push(R), N === "before";
          });
        }
        function y(E, S) {
          const g = S.node.operator, P = S.get("right").resolve(), R = S.get("left").resolve();
          let N, C, I;
          if (R.isIdentifier({ name: E }) ? N = P : P.isIdentifier({ name: E }) && (N = R), N)
            return g === "===" ? N.getTypeAnnotation() : d.indexOf(g) >= 0 ? o() : void 0;
          if (g !== "===" && g !== "==" || (R.isUnaryExpression({ operator: "typeof" }) ? (C = R, I = P) : P.isUnaryExpression({ operator: "typeof" }) && (C = P, I = R), !C) || !C.get("argument").isIdentifier({ name: E }) || (I = I.resolve(), !I.isLiteral()))
            return;
          const D = I.node.value;
          return typeof D == "string" ? s(D) : void 0;
        }
        function b(E, S, g) {
          const P = function(C, I, D) {
            let j;
            for (; j = I.parentPath; ) {
              if (j.isIfStatement() || j.isConditionalExpression())
                return I.key === "test" ? void 0 : j;
              if (j.isFunction() && j.parentPath.scope.getBinding(D) !== C)
                return;
              I = j;
            }
          }(E, S, g);
          if (!P)
            return;
          const R = [P.get("test")], N = [];
          for (let C = 0; C < R.length; C++) {
            const I = R[C];
            if (I.isLogicalExpression())
              I.node.operator === "&&" && (R.push(I.get("left")), R.push(I.get("right")));
            else if (I.isBinaryExpression()) {
              const D = y(g, I);
              D && N.push(D);
            }
          }
          return N.length ? { typeAnnotation: (0, f.createUnionType)(N), ifStatement: P } : b(E, P, g);
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/inference/inferers.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.ArrayExpression = w, r.AssignmentExpression = function() {
          return this.get("right").getTypeAnnotation();
        }, r.BinaryExpression = function(k) {
          const K = k.operator;
          if (m.indexOf(K) >= 0)
            return C();
          if (s.indexOf(K) >= 0)
            return S();
          if (K === "+") {
            const te = this.get("right"), z = this.get("left");
            return z.isBaseType("number") && te.isBaseType("number") ? C() : z.isBaseType("string") || te.isBaseType("string") ? I() : j([I(), C()]);
          }
        }, r.BooleanLiteral = function() {
          return S();
        }, r.CallExpression = function() {
          const { callee: k } = this.node;
          return W(k) ? E(I()) : G(k) || U(k) || _(k, { name: "Array" }) ? E(b()) : M(k) ? E(D([I(), b()])) : B(this.get("callee"));
        }, r.ConditionalExpression = function() {
          const k = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
          return (0, d.createUnionType)(k);
        }, r.ClassDeclaration = r.ClassExpression = r.FunctionDeclaration = r.ArrowFunctionExpression = r.FunctionExpression = function() {
          return P(R("Function"));
        }, Object.defineProperty(r, "Identifier", { enumerable: !0, get: function() {
          return f.default;
        } }), r.LogicalExpression = function() {
          const k = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
          return (0, d.createUnionType)(k);
        }, r.NewExpression = function(k) {
          if (k.callee.type === "Identifier")
            return P(k.callee);
        }, r.NullLiteral = function() {
          return N();
        }, r.NumericLiteral = function() {
          return C();
        }, r.ObjectExpression = function() {
          return P(R("Object"));
        }, r.ParenthesizedExpression = function() {
          return this.get("expression").getTypeAnnotation();
        }, r.RegExpLiteral = function() {
          return P(R("RegExp"));
        }, r.RestElement = O, r.SequenceExpression = function() {
          return this.get("expressions").pop().getTypeAnnotation();
        }, r.StringLiteral = function() {
          return I();
        }, r.TSAsExpression = v, r.TSNonNullExpression = function() {
          return this.get("expression").getTypeAnnotation();
        }, r.TaggedTemplateExpression = function() {
          return B(this.get("tag"));
        }, r.TemplateLiteral = function() {
          return I();
        }, r.TypeCastExpression = T, r.UnaryExpression = function(k) {
          const K = k.operator;
          if (K === "void")
            return F();
          if (h.indexOf(K) >= 0)
            return C();
          if (y.indexOf(K) >= 0)
            return I();
          if (o.indexOf(K) >= 0)
            return S();
        }, r.UpdateExpression = function(k) {
          const K = k.operator;
          if (K === "++" || K === "--")
            return C();
        }, r.VariableDeclarator = function() {
          if (this.get("id").isIdentifier())
            return this.get("init").getTypeAnnotation();
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js"), f = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"), d = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/inference/util.js");
        const { BOOLEAN_BINARY_OPERATORS: s, BOOLEAN_UNARY_OPERATORS: o, NUMBER_BINARY_OPERATORS: m, NUMBER_UNARY_OPERATORS: h, STRING_UNARY_OPERATORS: y, anyTypeAnnotation: b, arrayTypeAnnotation: E, booleanTypeAnnotation: S, buildMatchMemberExpression: g, genericTypeAnnotation: P, identifier: R, nullLiteralTypeAnnotation: N, numberTypeAnnotation: C, stringTypeAnnotation: I, tupleTypeAnnotation: D, unionTypeAnnotation: j, voidTypeAnnotation: F, isIdentifier: _ } = i;
        function T(k) {
          return k.typeAnnotation;
        }
        function v(k) {
          return k.typeAnnotation;
        }
        function w() {
          return P(R("Array"));
        }
        function O() {
          return w();
        }
        T.validParent = !0, v.validParent = !0, O.validParent = !0;
        const G = g("Array.from"), W = g("Object.keys"), U = g("Object.values"), M = g("Object.entries");
        function B(k) {
          if ((k = k.resolve()).isFunction()) {
            const { node: K } = k;
            if (K.async)
              return K.generator ? P(R("AsyncIterator")) : P(R("Promise"));
            if (K.generator)
              return P(R("Iterator"));
            if (k.node.returnType)
              return k.node.returnType;
          }
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/inference/util.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.createUnionType = function(h) {
          if (o(h[0]))
            return f ? f(h) : s(h);
          if (d)
            return d(h);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { createFlowUnionType: f, createTSUnionType: d, createUnionTypeAnnotation: s, isFlowType: o, isTSType: m } = i;
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/introspection.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r._guessExecutionStatusRelativeTo = function(D) {
          return I(this, D, /* @__PURE__ */ new Map());
        }, r._resolve = function(D, j) {
          if (!(j && j.indexOf(this) >= 0))
            if ((j = j || []).push(this), this.isVariableDeclarator()) {
              if (this.get("id").isIdentifier())
                return this.get("init").resolve(D, j);
            } else if (this.isReferencedIdentifier()) {
              const F = this.scope.getBinding(this.node.name);
              if (!F || !F.constant || F.kind === "module")
                return;
              if (F.path !== this) {
                const _ = F.path.resolve(D, j);
                return this.find((T) => T.node === _.node) ? void 0 : _;
              }
            } else {
              if (this.isTypeCastExpression())
                return this.get("expression").resolve(D, j);
              if (D && this.isMemberExpression()) {
                const F = this.toComputedKey();
                if (!h(F))
                  return;
                const _ = F.value, T = this.get("object").resolve(D, j);
                if (T.isObjectExpression()) {
                  const v = T.get("properties");
                  for (const w of v) {
                    if (!w.isProperty())
                      continue;
                    const O = w.get("key");
                    let G = w.isnt("computed") && O.isIdentifier({ name: _ });
                    if (G = G || O.isLiteral({ value: _ }), G)
                      return w.get("value").resolve(D, j);
                  }
                } else if (T.isArrayExpression() && !isNaN(+_)) {
                  const v = T.get("elements")[_];
                  if (v)
                    return v.resolve(D, j);
                }
              }
            }
        }, r.canHaveVariableDeclarationOrExpression = function() {
          return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
        }, r.canSwapBetweenExpressionAndStatement = function(D) {
          return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? !1 : this.isExpression() ? s(D) : this.isBlockStatement() ? o(D) : !1;
        }, r.equals = function(D, j) {
          return this.node[D] === j;
        }, r.getSource = function() {
          const D = this.node;
          if (D.end) {
            const j = this.hub.getCode();
            if (j)
              return j.slice(D.start, D.end);
          }
          return "";
        }, r.has = S, r.is = void 0, r.isCompletionRecord = function(D) {
          let j = this, F = !0;
          do {
            const { type: _, container: T } = j;
            if (!F && (j.isFunction() || _ === "StaticBlock"))
              return !!D;
            if (F = !1, Array.isArray(T) && j.key !== T.length - 1)
              return !1;
          } while ((j = j.parentPath) && !j.isProgram() && !j.isDoExpression());
          return !0;
        }, r.isConstantExpression = function() {
          if (this.isIdentifier()) {
            const D = this.scope.getBinding(this.node.name);
            return !!D && D.constant;
          }
          if (this.isLiteral())
            return !this.isRegExpLiteral() && (!this.isTemplateLiteral() || this.get("expressions").every((D) => D.isConstantExpression()));
          if (this.isUnaryExpression())
            return this.node.operator === "void" && this.get("argument").isConstantExpression();
          if (this.isBinaryExpression()) {
            const { operator: D } = this.node;
            return D !== "in" && D !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
          }
          return !1;
        }, r.isInStrictMode = function() {
          return !!(this.isProgram() ? this : this.parentPath).find((j) => {
            if (j.isProgram({ sourceType: "module" }) || j.isClass())
              return !0;
            if (j.isArrowFunctionExpression() && !j.get("body").isBlockStatement())
              return !1;
            let F;
            if (j.isFunction())
              F = j.node.body;
            else {
              if (!j.isProgram())
                return !1;
              F = j.node;
            }
            for (const _ of F.directives)
              if (_.value.value === "use strict")
                return !0;
          });
        }, r.isNodeType = function(D) {
          return b(this.type, D);
        }, r.isStatementOrBlock = function() {
          return !this.parentPath.isLabeledStatement() && !s(this.container) && f.includes(this.key);
        }, r.isStatic = function() {
          return this.scope.isStatic(this.node);
        }, r.isnt = function(D) {
          return !this.has(D);
        }, r.matchesPattern = function(D, j) {
          return E(this.node, D, j);
        }, r.referencesImport = function(D, j) {
          if (!this.isReferencedIdentifier()) {
            if (this.isJSXMemberExpression() && this.node.property.name === j || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? y(this.node.property, { value: j }) : this.node.property.name === j)) {
              const v = this.get("object");
              return v.isReferencedIdentifier() && v.referencesImport(D, "*");
            }
            return !1;
          }
          const F = this.scope.getBinding(this.node.name);
          if (!F || F.kind !== "module")
            return !1;
          const _ = F.path, T = _.parentPath;
          return !T.isImportDeclaration() || T.node.source.value !== D ? !1 : !!(!j || _.isImportDefaultSpecifier() && j === "default" || _.isImportNamespaceSpecifier() && j === "*" || _.isImportSpecifier() && m(_.node.imported, { name: j }));
        }, r.resolve = function(D, j) {
          return this._resolve(D, j) || this;
        }, r.willIMaybeExecuteBefore = function(D) {
          return this._guessExecutionStatusRelativeTo(D) !== "after";
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { STATEMENT_OR_BLOCK_KEYS: f, VISITOR_KEYS: d, isBlockStatement: s, isExpression: o, isIdentifier: m, isLiteral: h, isStringLiteral: y, isType: b, matchesPattern: E } = i;
        function S(D) {
          const j = this.node && this.node[D];
          return j && Array.isArray(j) ? !!j.length : !!j;
        }
        const g = S;
        function P(D) {
          return D.isProgram() ? D : (D.parentPath.scope.getFunctionParent() || D.parentPath.scope.getProgramParent()).path;
        }
        function R(D, j) {
          switch (D) {
            case "LogicalExpression":
            case "AssignmentPattern":
              return j === "right";
            case "ConditionalExpression":
            case "IfStatement":
              return j === "consequent" || j === "alternate";
            case "WhileStatement":
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForOfStatement":
              return j === "body";
            case "ForStatement":
              return j === "body" || j === "update";
            case "SwitchStatement":
              return j === "cases";
            case "TryStatement":
              return j === "handler";
            case "OptionalMemberExpression":
              return j === "property";
            case "OptionalCallExpression":
              return j === "arguments";
            default:
              return !1;
          }
        }
        function N(D, j) {
          for (let F = 0; F < j; F++) {
            const _ = D[F];
            if (R(_.parent.type, _.parentKey))
              return !0;
          }
          return !1;
        }
        r.is = g;
        const C = Symbol();
        function I(D, j, F) {
          const _ = { this: P(D), target: P(j) };
          if (_.target.node !== _.this.node)
            return function(U, M, B) {
              let k, K = B.get(U.node);
              if (K) {
                if (k = K.get(M.node))
                  return k === C ? "unknown" : k;
              } else
                B.set(U.node, K = /* @__PURE__ */ new Map());
              K.set(M.node, C);
              const te = function(z, q, $) {
                if (!q.isFunctionDeclaration())
                  return I(z, q, $) === "before" ? "before" : "unknown";
                if (q.parentPath.isExportDeclaration())
                  return "unknown";
                const Y = q.scope.getBinding(q.node.id.name);
                if (!Y.references)
                  return "before";
                const H = Y.referencePaths;
                let Q;
                for (const X of H) {
                  if (X.find((ye) => ye.node === q.node))
                    continue;
                  if (X.key !== "callee" || !X.parentPath.isCallExpression())
                    return "unknown";
                  const ne = I(z, X, $);
                  if (Q && Q !== ne)
                    return "unknown";
                  Q = ne;
                }
                return Q;
              }(U, M, B);
              return K.set(M.node, te), te;
            }(D, _.target, F);
          const T = { target: j.getAncestry(), this: D.getAncestry() };
          if (T.target.indexOf(D) >= 0)
            return "after";
          if (T.this.indexOf(j) >= 0)
            return "before";
          let v;
          const w = { target: 0, this: 0 };
          for (; !v && w.this < T.this.length; ) {
            const U = T.this[w.this];
            w.target = T.target.indexOf(U), w.target >= 0 ? v = U : w.this++;
          }
          if (!v)
            throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
          if (N(T.this, w.this - 1) || N(T.target, w.target - 1))
            return "unknown";
          const O = { this: T.this[w.this - 1], target: T.target[w.target - 1] };
          if (O.target.listKey && O.this.listKey && O.target.container === O.this.container)
            return O.target.key > O.this.key ? "before" : "after";
          const G = d[v.type], W = G.indexOf(O.this.parentKey);
          return G.indexOf(O.target.parentKey) > W ? "before" : "after";
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/lib/hoister.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js"), f = i;
        const { react: d } = i, { cloneNode: s, jsxExpressionContainer: o, variableDeclaration: m, variableDeclarator: h } = f, y = { ReferencedIdentifier(b, E) {
          if (b.isJSXIdentifier() && d.isCompatTag(b.node.name) && !b.parentPath.isJSXMemberExpression())
            return;
          if (b.node.name === "this") {
            let g = b.scope;
            do
              if (g.path.isFunction() && !g.path.isArrowFunctionExpression())
                break;
            while (g = g.parent);
            g && E.breakOnScopePaths.push(g.path);
          }
          const S = b.scope.getBinding(b.node.name);
          if (S) {
            for (const g of S.constantViolations)
              if (g.scope !== S.path.scope)
                return E.mutableBinding = !0, void b.stop();
            S === E.scope.getBinding(b.node.name) && (E.bindings[b.node.name] = S);
          }
        } };
        r.default = class {
          constructor(b, E) {
            this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [], this.scope = E, this.path = b, this.attachAfter = !1;
          }
          isCompatibleScope(b) {
            for (const E of Object.keys(this.bindings)) {
              const S = this.bindings[E];
              if (!b.bindingIdentifierEquals(E, S.identifier))
                return !1;
            }
            return !0;
          }
          getCompatibleScopes() {
            let b = this.path.scope;
            do
              if (!this.isCompatibleScope(b) || (this.scopes.push(b), this.breakOnScopePaths.indexOf(b.path) >= 0))
                break;
            while (b = b.parent);
          }
          getAttachmentPath() {
            let b = this._getAttachmentPath();
            if (!b)
              return;
            let E = b.scope;
            if (E.path === b && (E = b.scope.parent), E.path.isProgram() || E.path.isFunction())
              for (const S of Object.keys(this.bindings)) {
                if (!E.hasOwnBinding(S))
                  continue;
                const g = this.bindings[S];
                if (!(g.kind === "param" || g.path.parentKey === "params") && this.getAttachmentParentForPath(g.path).key >= b.key) {
                  this.attachAfter = !0, b = g.path;
                  for (const P of g.constantViolations)
                    this.getAttachmentParentForPath(P).key > b.key && (b = P);
                }
              }
            return b;
          }
          _getAttachmentPath() {
            const b = this.scopes.pop();
            if (b) {
              if (b.path.isFunction()) {
                if (!this.hasOwnParamBindings(b))
                  return this.getNextScopeAttachmentParent();
                {
                  if (this.scope === b)
                    return;
                  const E = b.path.get("body").get("body");
                  for (let S = 0; S < E.length; S++)
                    if (!E[S].node._blockHoist)
                      return E[S];
                }
              } else if (b.path.isProgram())
                return this.getNextScopeAttachmentParent();
            }
          }
          getNextScopeAttachmentParent() {
            const b = this.scopes.pop();
            if (b)
              return this.getAttachmentParentForPath(b.path);
          }
          getAttachmentParentForPath(b) {
            do
              if (!b.parentPath || Array.isArray(b.container) && b.isStatement())
                return b;
            while (b = b.parentPath);
          }
          hasOwnParamBindings(b) {
            for (const E of Object.keys(this.bindings)) {
              if (!b.hasOwnBinding(E))
                continue;
              const S = this.bindings[E];
              if (S.kind === "param" && S.constant)
                return !0;
            }
            return !1;
          }
          run() {
            if (this.path.traverse(y, this), this.mutableBinding)
              return;
            this.getCompatibleScopes();
            const b = this.getAttachmentPath();
            if (!b || b.getFunctionParent() === this.path.getFunctionParent())
              return;
            let E = b.scope.generateUidIdentifier("ref");
            const S = h(E, this.path.node), g = this.attachAfter ? "insertAfter" : "insertBefore", [P] = b[g]([b.isVariableDeclarator() ? S : m("var", [S])]), R = this.path.parentPath;
            return R.isJSXElement() && this.path.container === R.node.children && (E = o(E)), this.path.replaceWith(s(E)), b.isVariableDeclarator() ? P.get("init") : P.get("declarations.0.init");
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.hooks = void 0, r.hooks = [function(l, i) {
          if (l.key === "test" && (i.isWhile() || i.isSwitchCase()) || l.key === "declaration" && i.isExportDeclaration() || l.key === "body" && i.isLabeledStatement() || l.listKey === "declarations" && i.isVariableDeclaration() && i.node.declarations.length === 1 || l.key === "expression" && i.isExpressionStatement())
            return i.remove(), !0;
        }, function(l, i) {
          if (i.isSequenceExpression() && i.node.expressions.length === 1)
            return i.replaceWith(i.node.expressions[0]), !0;
        }, function(l, i) {
          if (i.isBinary())
            return l.key === "left" ? i.replaceWith(i.node.right) : i.replaceWith(i.node.left), !0;
        }, function(l, i) {
          if (i.isIfStatement() && l.key === "consequent" || l.key === "body" && (i.isLoop() || i.isArrowFunctionExpression()))
            return l.replaceWith({ type: "BlockStatement", body: [] }), !0;
        }];
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.isBindingIdentifier = function() {
          const { node: w, parent: O } = this, G = this.parentPath.parent;
          return b(w) && f(w, O, G);
        }, r.isBlockScoped = function() {
          return d(this.node);
        }, r.isExpression = function() {
          return this.isIdentifier() ? this.isReferencedIdentifier() : o(this.node);
        }, r.isFlow = function() {
          const { node: w } = this;
          return !!m(w) || (E(w) ? w.importKind === "type" || w.importKind === "typeof" : s(w) ? w.exportKind === "type" : !!S(w) && (w.importKind === "type" || w.importKind === "typeof"));
        }, r.isForAwaitStatement = function() {
          return T(this.node, { await: !0 });
        }, r.isGenerated = function() {
          return !this.isUser();
        }, r.isPure = function(w) {
          return this.scope.isPure(this.node, w);
        }, r.isReferenced = function() {
          return C(this.node, this.parent);
        }, r.isReferencedIdentifier = function(w) {
          const { node: O, parent: G } = this;
          return !b(O, w) && !P(G, w) && (!g(O, w) || v(O.name)) ? !1 : C(O, G, this.parentPath.parent);
        }, r.isReferencedMemberExpression = function() {
          const { node: w, parent: O } = this;
          return R(w) && C(w, O);
        }, r.isRestProperty = function() {
          return N(this.node) && this.parentPath && this.parentPath.isObjectPattern();
        }, r.isScope = function() {
          return I(this.node, this.parent);
        }, r.isSpreadProperty = function() {
          return N(this.node) && this.parentPath && this.parentPath.isObjectExpression();
        }, r.isStatement = function() {
          const { node: w, parent: O } = this;
          return D(w) ? !(F(w) && (y(O, { left: w }) || h(O, { init: w }))) : !1;
        }, r.isUser = function() {
          return this.node && !!this.node.loc;
        }, r.isVar = function() {
          return j(this.node);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { isBinding: f, isBlockScoped: d, isExportDeclaration: s, isExpression: o, isFlow: m, isForStatement: h, isForXStatement: y, isIdentifier: b, isImportDeclaration: E, isImportSpecifier: S, isJSXIdentifier: g, isJSXMemberExpression: P, isMemberExpression: R, isRestElement: N, isReferenced: C, isScope: I, isStatement: D, isVar: j, isVariableDeclaration: F, react: _, isForOfStatement: T } = i, { isCompatTag: v } = _;
        r.isExistentialTypeParam = function() {
          throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
        }, r.isNumericLiteralTypeAnnotation = function() {
          throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/lib/virtual-types.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.Var = r.User = r.Statement = r.SpreadProperty = r.Scope = r.RestProperty = r.ReferencedMemberExpression = r.ReferencedIdentifier = r.Referenced = r.Pure = r.NumericLiteralTypeAnnotation = r.Generated = r.ForAwaitStatement = r.Flow = r.Expression = r.ExistentialTypeParam = r.BlockScoped = r.BindingIdentifier = void 0, r.ReferencedIdentifier = ["Identifier", "JSXIdentifier"], r.ReferencedMemberExpression = ["MemberExpression"], r.BindingIdentifier = ["Identifier"], r.Statement = ["Statement"], r.Expression = ["Expression"], r.Scope = ["Scopable", "Pattern"], r.Referenced = null, r.BlockScoped = null, r.Var = ["VariableDeclaration"], r.User = null, r.Generated = null, r.Pure = null, r.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"], r.RestProperty = ["RestElement"], r.SpreadProperty = ["RestElement"], r.ExistentialTypeParam = ["ExistsTypeAnnotation"], r.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"], r.ForAwaitStatement = ["ForOfStatement"];
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/modification.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r._containerInsert = function(T, v) {
          this.updateSiblingKeys(T, v.length);
          const w = [];
          this.container.splice(T, 0, ...v);
          for (let W = 0; W < v.length; W++) {
            var O;
            const U = T + W, M = this.getSibling(U);
            w.push(M), (O = this.context) != null && O.queue && M.pushContext(this.context);
          }
          const G = this._getQueueContexts();
          for (const W of w) {
            W.setScope(), W.debug("Inserted.");
            for (const U of G)
              U.maybeQueue(W, !0);
          }
          return w;
        }, r._containerInsertAfter = function(T) {
          return this._containerInsert(this.key + 1, T);
        }, r._containerInsertBefore = function(T) {
          return this._containerInsert(this.key, T);
        }, r._verifyNodeList = function(T) {
          if (!T)
            return [];
          Array.isArray(T) || (T = [T]);
          for (let v = 0; v < T.length; v++) {
            const w = T[v];
            let O;
            if (w ? typeof w != "object" ? O = "contains a non-object node" : w.type ? w instanceof d.default && (O = "has a NodePath when it expected a raw object") : O = "without a type" : O = "has falsy node", O) {
              const G = Array.isArray(w) ? "array" : typeof w;
              throw new Error(`Node list ${O} with the index of ${v} and type of ${G}`);
            }
          }
          return T;
        }, r.hoist = function(T = this.scope) {
          return new f.default(this, T).run();
        }, r.insertAfter = function(T) {
          if (this._assertUnremoved(), this.isSequenceExpression())
            return F(this.get("expressions")).insertAfter(T);
          const v = this._verifyNodeList(T), { parentPath: w, parent: O } = this;
          if (w.isExpressionStatement() || w.isLabeledStatement() || R(O) || w.isExportDefaultDeclaration() && this.isDeclaration())
            return w.insertAfter(v.map((G) => N(G) ? S(G) : G));
          if (this.isNodeType("Expression") && !this.isJSXElement() && !w.isJSXElement() || w.isForStatement() && this.key === "init") {
            if (this.node) {
              const G = this.node;
              let { scope: W } = this;
              if (W.path.isPattern())
                return m(G), this.replaceWith(b(o([], G), [])), this.get("callee.body").insertAfter(v), [this];
              if (_(this))
                v.unshift(G);
              else if (P(G) && D(G.callee))
                v.unshift(G), v.push(j());
              else if (function(U, M) {
                if (!g(U) || !C(U.left))
                  return !1;
                const B = M.getBlockParent();
                return B.hasOwnBinding(U.left.name) && B.getOwnBinding(U.left.name).constantViolations.length <= 1;
              }(G, W))
                v.unshift(G), v.push(E(G.left));
              else if (W.isPure(G, !0))
                v.push(G);
              else {
                w.isMethod({ computed: !0, key: G }) && (W = W.parent);
                const U = W.generateDeclaredUidIdentifier();
                v.unshift(S(h("=", E(U), G))), v.push(S(E(U)));
              }
            }
            return this.replaceExpressionWithStatements(v);
          }
          if (Array.isArray(this.container))
            return this._containerInsertAfter(v);
          if (this.isStatementOrBlock()) {
            const G = this.node, W = G && (!this.isExpressionStatement() || G.expression != null);
            return this.replaceWith(y(W ? [G] : [])), this.pushContainer("body", v);
          }
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }, r.insertBefore = function(T) {
          this._assertUnremoved();
          const v = this._verifyNodeList(T), { parentPath: w, parent: O } = this;
          if (w.isExpressionStatement() || w.isLabeledStatement() || R(O) || w.isExportDefaultDeclaration() && this.isDeclaration())
            return w.insertBefore(v);
          if (this.isNodeType("Expression") && !this.isJSXElement() || w.isForStatement() && this.key === "init")
            return this.node && v.push(this.node), this.replaceExpressionWithStatements(v);
          if (Array.isArray(this.container))
            return this._containerInsertBefore(v);
          if (this.isStatementOrBlock()) {
            const G = this.node, W = G && (!this.isExpressionStatement() || G.expression != null);
            return this.replaceWith(y(W ? [G] : [])), this.unshiftContainer("body", v);
          }
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }, r.pushContainer = function(T, v) {
          this._assertUnremoved();
          const w = this._verifyNodeList(v), O = this.node[T];
          return d.default.get({ parentPath: this, parent: this.node, container: O, listKey: T, key: O.length }).setContext(this.context).replaceWithMultiple(w);
        }, r.unshiftContainer = function(T, v) {
          return this._assertUnremoved(), v = this._verifyNodeList(v), d.default.get({ parentPath: this, parent: this.node, container: this.node[T], listKey: T, key: 0 }).setContext(this.context)._containerInsertBefore(v);
        }, r.updateSiblingKeys = function(T, v) {
          if (!this.parent)
            return;
          const w = (0, i.getCachedPaths)(this.hub, this.parent) || [];
          for (const [, O] of w)
            typeof O.key == "number" && O.key >= T && (O.key += v);
        };
        var i = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/cache.js"), f = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/lib/hoister.js"), d = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/index.js"), s = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { arrowFunctionExpression: o, assertExpression: m, assignmentExpression: h, blockStatement: y, callExpression: b, cloneNode: E, expressionStatement: S, isAssignmentExpression: g, isCallExpression: P, isExportNamedDeclaration: R, isExpression: N, isIdentifier: C, isSequenceExpression: I, isSuper: D, thisExpression: j } = s, F = (T) => T[T.length - 1];
        function _(T) {
          return I(T.parent) && (F(T.parent.expressions) !== T.node || _(T.parentPath));
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/removal.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r._assertUnremoved = function() {
          if (this.removed)
            throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
        }, r._callRemovalHooks = function() {
          for (const s of i.hooks)
            if (s(this, this.parentPath))
              return !0;
        }, r._markRemoved = function() {
          this._traverseFlags |= d.SHOULD_SKIP | d.REMOVED, this.parent && (0, f.getCachedPaths)(this.hub, this.parent).delete(this.node), this.node = null;
        }, r._remove = function() {
          Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : this._replaceWith(null);
        }, r._removeFromScope = function() {
          const s = this.getBindingIdentifiers();
          Object.keys(s).forEach((o) => this.scope.removeBinding(o));
        }, r.remove = function() {
          var s;
          if (this._assertUnremoved(), this.resync(), (s = this.opts) != null && s.noScope || this._removeFromScope(), this._callRemovalHooks())
            return void this._markRemoved();
          this.shareCommentsWithSiblings(), this._remove(), this._markRemoved();
        };
        var i = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js"), f = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/cache.js"), d = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/index.js");
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/replacement.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r._replaceWith = function(U) {
          var M;
          if (!this.container)
            throw new ReferenceError("Container is falsy");
          this.inList ? G(this.parent, this.key, [U]) : G(this.parent, this.key, U), this.debug(`Replace with ${U == null ? void 0 : U.type}`), (M = (0, s.getCachedPaths)(this.hub, this.parent)) == null || M.set(U, this).delete(this.node), this.node = this.container[this.key] = U;
        }, r.replaceExpressionWithStatements = function(U) {
          this.resync();
          const M = O(U, this.scope);
          if (M)
            return this.replaceWith(M)[0].get("expressions");
          const B = this.getFunctionParent(), k = B == null ? void 0 : B.is("async"), K = B == null ? void 0 : B.is("generator"), te = b([], g(U));
          this.replaceWith(P(te, []));
          const z = this.get("callee");
          (0, h.default)(z.get("body"), (Q) => {
            this.scope.push({ id: Q });
          }, "var");
          const q = this.get("callee").getCompletionRecords();
          for (const Q of q) {
            if (!Q.isExpressionStatement())
              continue;
            const X = Q.findParent((ne) => ne.isLoop());
            if (X) {
              let ne = X.getData("expressionReplacementReturnUid");
              ne ? ne = C(ne.name) : (ne = z.scope.generateDeclaredUidIdentifier("ret"), z.get("body").pushContainer("body", w(R(ne))), X.setData("expressionReplacementReturnUid", ne)), Q.get("expression").replaceWith(E("=", R(ne), Q.node.expression));
            } else
              Q.replaceWith(w(Q.node.expression));
          }
          z.arrowFunctionToExpression();
          const $ = z, Y = k && f.default.hasType(this.get("callee.body").node, "AwaitExpression", y), H = K && f.default.hasType(this.get("callee.body").node, "YieldExpression", y);
          return Y && ($.set("async", !0), H || this.replaceWith(S(this.node))), H && ($.set("generator", !0), this.replaceWith(W(this.node, !0))), $.get("body.body");
        }, r.replaceInline = function(U) {
          if (this.resync(), Array.isArray(U)) {
            if (Array.isArray(this.container)) {
              U = this._verifyNodeList(U);
              const M = this._containerInsertAfter(U);
              return this.remove(), M;
            }
            return this.replaceWithMultiple(U);
          }
          return this.replaceWith(U);
        }, r.replaceWith = function(U) {
          if (this.resync(), this.removed)
            throw new Error("You can't replace this node, we've already removed it");
          let M = U instanceof d.default ? U.node : U;
          if (!M)
            throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
          if (this.node === M)
            return [this];
          if (this.isProgram() && !_(M))
            throw new Error("You can only replace a Program root node with another Program node");
          if (Array.isArray(M))
            throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
          if (typeof M == "string")
            throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
          let B = "";
          if (this.isNodeType("Statement") && F(M) && (this.canHaveVariableDeclarationOrExpression() || this.canSwapBetweenExpressionAndStatement(M) || this.parentPath.isExportDefaultDeclaration() || (M = N(M), B = "expression")), this.isNodeType("Expression") && T(M) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(M))
            return this.replaceExpressionWithStatements([M]);
          const k = this.node;
          return k && (j(M, k), v(k)), this._replaceWith(M), this.type = M.type, this.setScope(), this.requeue(), [B ? this.get(B) : this];
        }, r.replaceWithMultiple = function(U) {
          var M;
          this.resync(), U = this._verifyNodeList(U), I(U[0], this.node), D(U[U.length - 1], this.node), (M = (0, s.getCachedPaths)(this.hub, this.parent)) == null || M.delete(this.node), this.node = this.container[this.key] = null;
          const B = this.insertAfter(U);
          return this.node ? this.requeue() : this.remove(), B;
        }, r.replaceWithSourceString = function(U) {
          let M;
          this.resync();
          try {
            U = `(${U})`, M = (0, o.parse)(U);
          } catch (k) {
            const K = k.loc;
            throw K && (k.message += ` - make sure this is an expression.
` + (0, i.codeFrameColumns)(U, { start: { line: K.line, column: K.column + 1 } }), k.code = "BABEL_REPLACE_SOURCE_ERROR"), k;
          }
          const B = M.program.body[0].expression;
          return f.default.removeProperties(B), this.replaceWith(B);
        };
        var i = l("./stubs/babel-codeframe.js"), f = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/index.js"), d = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/index.js"), s = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/cache.js"), o = l("./node_modules/.pnpm/@babel+parser@7.22.16/node_modules/@babel/parser/lib/index.js"), m = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js"), h = l("./node_modules/.pnpm/@babel+helper-hoist-variables@7.22.5/node_modules/@babel/helper-hoist-variables/lib/index.js");
        const { FUNCTION_TYPES: y, arrowFunctionExpression: b, assignmentExpression: E, awaitExpression: S, blockStatement: g, callExpression: P, cloneNode: R, expressionStatement: N, identifier: C, inheritLeadingComments: I, inheritTrailingComments: D, inheritsComments: j, isExpression: F, isProgram: _, isStatement: T, removeComments: v, returnStatement: w, toSequenceExpression: O, validate: G, yieldExpression: W } = m;
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/scope/binding.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0, r.default = class {
          constructor({ identifier: l, scope: i, path: f, kind: d }) {
            this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0, this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = l, this.scope = i, this.path = f, this.kind = d, d !== "var" && d !== "hoisted" || !function(s) {
              for (let { parentPath: o, key: m } = s; o; { parentPath: o, key: m } = o) {
                if (o.isFunctionParent())
                  return !1;
                if (o.isWhile() || o.isForXStatement() || o.isForStatement() && m === "body")
                  return !0;
              }
              return !1;
            }(f) || this.reassign(f), this.clearValue();
          }
          deoptValue() {
            this.clearValue(), this.hasDeoptedValue = !0;
          }
          setValue(l) {
            this.hasDeoptedValue || (this.hasValue = !0, this.value = l);
          }
          clearValue() {
            this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
          }
          reassign(l) {
            this.constant = !1, this.constantViolations.indexOf(l) === -1 && this.constantViolations.push(l);
          }
          reference(l) {
            this.referencePaths.indexOf(l) === -1 && (this.referenced = !0, this.references++, this.referencePaths.push(l));
          }
          dereference() {
            this.references--, this.referenced = !!this.references;
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/scope/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/scope/lib/renamer.js"), f = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/index.js"), d = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/scope/binding.js"), s = l("./node_modules/.pnpm/globals@11.12.0/node_modules/globals/index.js"), o = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js"), m = o, h = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/cache.js"), y = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/visitors.js");
        const { NOT_LOCAL_BINDING: b, callExpression: E, cloneNode: S, getBindingIdentifiers: g, identifier: P, isArrayExpression: R, isBinary: N, isClass: C, isClassBody: I, isClassDeclaration: D, isExportAllDeclaration: j, isExportDefaultDeclaration: F, isExportNamedDeclaration: _, isFunctionDeclaration: T, isIdentifier: v, isImportDeclaration: w, isLiteral: O, isMethod: G, isModuleSpecifier: W, isNullLiteral: U, isObjectExpression: M, isProperty: B, isPureish: k, isRegExpLiteral: K, isSuper: te, isTaggedTemplateExpression: z, isTemplateLiteral: q, isThisExpression: $, isUnaryExpression: Y, isVariableDeclaration: H, matchesPattern: Q, memberExpression: X, numericLiteral: ne, toIdentifier: ye, unaryExpression: ve, variableDeclaration: de, variableDeclarator: oe, isRecordExpression: re, isTupleExpression: ae, isObjectProperty: le, isTopicReference: ue, isMetaProperty: ie, isPrivateName: we, isExportDeclaration: De } = o;
        function Ee(se, Z) {
          switch (se == null ? void 0 : se.type) {
            default:
              var pe;
              if (w(se) || De(se))
                if ((j(se) || _(se) || w(se)) && se.source)
                  Ee(se.source, Z);
                else if ((_(se) || w(se)) && (pe = se.specifiers) != null && pe.length)
                  for (const be of se.specifiers)
                    Ee(be, Z);
                else
                  (F(se) || _(se)) && se.declaration && Ee(se.declaration, Z);
              else
                W(se) ? Ee(se.local, Z) : !O(se) || U(se) || K(se) || q(se) || Z.push(se.value);
              break;
            case "MemberExpression":
            case "OptionalMemberExpression":
            case "JSXMemberExpression":
              Ee(se.object, Z), Ee(se.property, Z);
              break;
            case "Identifier":
            case "JSXIdentifier":
              Z.push(se.name);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
            case "NewExpression":
              Ee(se.callee, Z);
              break;
            case "ObjectExpression":
            case "ObjectPattern":
              for (const be of se.properties)
                Ee(be, Z);
              break;
            case "SpreadElement":
            case "RestElement":
            case "UnaryExpression":
            case "UpdateExpression":
              Ee(se.argument, Z);
              break;
            case "ObjectProperty":
            case "ObjectMethod":
            case "ClassProperty":
            case "ClassMethod":
            case "ClassPrivateProperty":
            case "ClassPrivateMethod":
              Ee(se.key, Z);
              break;
            case "ThisExpression":
              Z.push("this");
              break;
            case "Super":
              Z.push("super");
              break;
            case "Import":
              Z.push("import");
              break;
            case "DoExpression":
              Z.push("do");
              break;
            case "YieldExpression":
              Z.push("yield"), Ee(se.argument, Z);
              break;
            case "AwaitExpression":
              Z.push("await"), Ee(se.argument, Z);
              break;
            case "AssignmentExpression":
              Ee(se.left, Z);
              break;
            case "VariableDeclarator":
            case "FunctionExpression":
            case "FunctionDeclaration":
            case "ClassExpression":
            case "ClassDeclaration":
            case "PrivateName":
              Ee(se.id, Z);
              break;
            case "ParenthesizedExpression":
              Ee(se.expression, Z);
              break;
            case "MetaProperty":
              Ee(se.meta, Z), Ee(se.property, Z);
              break;
            case "JSXElement":
              Ee(se.openingElement, Z);
              break;
            case "JSXOpeningElement":
              Ee(se.name, Z);
              break;
            case "JSXFragment":
              Ee(se.openingFragment, Z);
              break;
            case "JSXOpeningFragment":
              Z.push("Fragment");
              break;
            case "JSXNamespacedName":
              Ee(se.namespace, Z), Ee(se.name, Z);
          }
        }
        const Ae = { ForStatement(se) {
          const Z = se.get("init");
          if (Z.isVar()) {
            const { scope: pe } = se;
            (pe.getFunctionParent() || pe.getProgramParent()).registerBinding("var", Z);
          }
        }, Declaration(se) {
          se.isBlockScoped() || se.isImportDeclaration() || se.isExportDeclaration() || (se.scope.getFunctionParent() || se.scope.getProgramParent()).registerDeclaration(se);
        }, ImportDeclaration(se) {
          se.scope.getBlockParent().registerDeclaration(se);
        }, ReferencedIdentifier(se, Z) {
          Z.references.push(se);
        }, ForXStatement(se, Z) {
          const pe = se.get("left");
          if (pe.isPattern() || pe.isIdentifier())
            Z.constantViolations.push(se);
          else if (pe.isVar()) {
            const { scope: be } = se;
            (be.getFunctionParent() || be.getProgramParent()).registerBinding("var", pe);
          }
        }, ExportDeclaration: { exit(se) {
          const { node: Z, scope: pe } = se;
          if (j(Z))
            return;
          const be = Z.declaration;
          if (D(be) || T(be)) {
            const _e = be.id;
            if (!_e)
              return;
            const Ie = pe.getBinding(_e.name);
            Ie == null || Ie.reference(se);
          } else if (H(be))
            for (const _e of be.declarations)
              for (const Ie of Object.keys(g(_e))) {
                const We = pe.getBinding(Ie);
                We == null || We.reference(se);
              }
        } }, LabeledStatement(se) {
          se.scope.getBlockParent().registerDeclaration(se);
        }, AssignmentExpression(se, Z) {
          Z.assignments.push(se);
        }, UpdateExpression(se, Z) {
          Z.constantViolations.push(se);
        }, UnaryExpression(se, Z) {
          se.node.operator === "delete" && Z.constantViolations.push(se);
        }, BlockScoped(se) {
          let Z = se.scope;
          if (Z.path === se && (Z = Z.parent), Z.getBlockParent().registerDeclaration(se), se.isClassDeclaration() && se.node.id) {
            const pe = se.node.id.name;
            se.scope.bindings[pe] = se.scope.parent.getBinding(pe);
          }
        }, CatchClause(se) {
          se.scope.registerBinding("let", se);
        }, Function(se) {
          const Z = se.get("params");
          for (const pe of Z)
            se.scope.registerBinding("param", pe);
          se.isFunctionExpression() && se.has("id") && !se.get("id").node[b] && se.scope.registerBinding("local", se.get("id"), se);
        }, ClassExpression(se) {
          se.has("id") && !se.get("id").node[b] && se.scope.registerBinding("local", se);
        } };
        let Me = 0;
        class me {
          constructor(Z) {
            this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, this.inited = void 0, this.bindings = void 0, this.references = void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
            const { node: pe } = Z, be = h.scope.get(pe);
            if ((be == null ? void 0 : be.path) === Z)
              return be;
            h.scope.set(pe, this), this.uid = Me++, this.block = pe, this.path = Z, this.labels = /* @__PURE__ */ new Map(), this.inited = !1;
          }
          get parent() {
            var Z;
            let pe, be = this.path;
            do {
              const _e = be.key === "key" || be.listKey === "decorators";
              be = be.parentPath, _e && be.isMethod() && (be = be.parentPath), be && be.isScope() && (pe = be);
            } while (be && !pe);
            return (Z = pe) == null ? void 0 : Z.scope;
          }
          get parentBlock() {
            return this.path.parent;
          }
          get hub() {
            return this.path.hub;
          }
          traverse(Z, pe, be) {
            (0, f.default)(Z, pe, this, be, this.path);
          }
          generateDeclaredUidIdentifier(Z) {
            const pe = this.generateUidIdentifier(Z);
            return this.push({ id: pe }), S(pe);
          }
          generateUidIdentifier(Z) {
            return P(this.generateUid(Z));
          }
          generateUid(Z = "temp") {
            let pe;
            Z = ye(Z).replace(/^_+/, "").replace(/[0-9]+$/g, "");
            let be = 1;
            do
              pe = this._generateUid(Z, be), be++;
            while (this.hasLabel(pe) || this.hasBinding(pe) || this.hasGlobal(pe) || this.hasReference(pe));
            const _e = this.getProgramParent();
            return _e.references[pe] = !0, _e.uids[pe] = !0, pe;
          }
          _generateUid(Z, pe) {
            let be = Z;
            return pe > 1 && (be += pe), `_${be}`;
          }
          generateUidBasedOnNode(Z, pe) {
            const be = [];
            Ee(Z, be);
            let _e = be.join("$");
            return _e = _e.replace(/^_/, "") || pe || "ref", this.generateUid(_e.slice(0, 20));
          }
          generateUidIdentifierBasedOnNode(Z, pe) {
            return P(this.generateUidBasedOnNode(Z, pe));
          }
          isStatic(Z) {
            if ($(Z) || te(Z) || ue(Z))
              return !0;
            if (v(Z)) {
              const pe = this.getBinding(Z.name);
              return pe ? pe.constant : this.hasBinding(Z.name);
            }
            return !1;
          }
          maybeGenerateMemoised(Z, pe) {
            if (this.isStatic(Z))
              return null;
            {
              const be = this.generateUidIdentifierBasedOnNode(Z);
              return pe ? be : (this.push({ id: be }), S(be));
            }
          }
          checkBlockScopedCollisions(Z, pe, be, _e) {
            if (pe !== "param" && Z.kind !== "local" && (pe === "let" || Z.kind === "let" || Z.kind === "const" || Z.kind === "module" || Z.kind === "param" && pe === "const"))
              throw this.hub.buildError(_e, `Duplicate declaration "${be}"`, TypeError);
          }
          rename(Z, pe) {
            const be = this.getBinding(Z);
            be && (pe || (pe = this.generateUidIdentifier(Z).name), new i.default(be, Z, pe).rename(arguments[2]));
          }
          _renameFromMap(Z, pe, be, _e) {
            Z[pe] && (Z[be] = _e, Z[pe] = null);
          }
          dump() {
            const Z = "-".repeat(60);
            console.log(Z);
            let pe = this;
            do {
              console.log("#", pe.block.type);
              for (const be of Object.keys(pe.bindings)) {
                const _e = pe.bindings[be];
                console.log(" -", be, { constant: _e.constant, references: _e.references, violations: _e.constantViolations.length, kind: _e.kind });
              }
            } while (pe = pe.parent);
            console.log(Z);
          }
          toArray(Z, pe, be) {
            if (v(Z)) {
              const We = this.getBinding(Z.name);
              if (We != null && We.constant && We.path.isGenericType("Array"))
                return Z;
            }
            if (R(Z))
              return Z;
            if (v(Z, { name: "arguments" }))
              return E(X(X(X(P("Array"), P("prototype")), P("slice")), P("call")), [Z]);
            let _e;
            const Ie = [Z];
            return pe === !0 ? _e = "toConsumableArray" : typeof pe == "number" ? (Ie.push(ne(pe)), _e = "slicedToArray") : _e = "toArray", be && (Ie.unshift(this.hub.addHelper(_e)), _e = "maybeArrayLike"), E(this.hub.addHelper(_e), Ie);
          }
          hasLabel(Z) {
            return !!this.getLabel(Z);
          }
          getLabel(Z) {
            return this.labels.get(Z);
          }
          registerLabel(Z) {
            this.labels.set(Z.node.label.name, Z);
          }
          registerDeclaration(Z) {
            if (Z.isLabeledStatement())
              this.registerLabel(Z);
            else if (Z.isFunctionDeclaration())
              this.registerBinding("hoisted", Z.get("id"), Z);
            else if (Z.isVariableDeclaration()) {
              const pe = Z.get("declarations"), { kind: be } = Z.node;
              for (const _e of pe)
                this.registerBinding(be === "using" || be === "await using" ? "const" : be, _e);
            } else if (Z.isClassDeclaration()) {
              if (Z.node.declare)
                return;
              this.registerBinding("let", Z);
            } else if (Z.isImportDeclaration()) {
              const pe = Z.node.importKind === "type" || Z.node.importKind === "typeof", be = Z.get("specifiers");
              for (const _e of be) {
                const Ie = pe || _e.isImportSpecifier() && (_e.node.importKind === "type" || _e.node.importKind === "typeof");
                this.registerBinding(Ie ? "unknown" : "module", _e);
              }
            } else if (Z.isExportDeclaration()) {
              const pe = Z.get("declaration");
              (pe.isClassDeclaration() || pe.isFunctionDeclaration() || pe.isVariableDeclaration()) && this.registerDeclaration(pe);
            } else
              this.registerBinding("unknown", Z);
          }
          buildUndefinedNode() {
            return ve("void", ne(0), !0);
          }
          registerConstantViolation(Z) {
            const pe = Z.getBindingIdentifiers();
            for (const _e of Object.keys(pe)) {
              var be;
              (be = this.getBinding(_e)) == null || be.reassign(Z);
            }
          }
          registerBinding(Z, pe, be = pe) {
            if (!Z)
              throw new ReferenceError("no `kind`");
            if (pe.isVariableDeclaration()) {
              const We = pe.get("declarations");
              for (const tt of We)
                this.registerBinding(Z, tt);
              return;
            }
            const _e = this.getProgramParent(), Ie = pe.getOuterBindingIdentifiers(!0);
            for (const We of Object.keys(Ie)) {
              _e.references[We] = !0;
              for (const tt of Ie[We]) {
                const Ye = this.getOwnBinding(We);
                if (Ye) {
                  if (Ye.identifier === tt)
                    continue;
                  this.checkBlockScopedCollisions(Ye, Z, We, tt);
                }
                Ye ? this.registerConstantViolation(be) : this.bindings[We] = new d.default({ identifier: tt, scope: this, path: be, kind: Z });
              }
            }
          }
          addGlobal(Z) {
            this.globals[Z.name] = Z;
          }
          hasUid(Z) {
            let pe = this;
            do
              if (pe.uids[Z])
                return !0;
            while (pe = pe.parent);
            return !1;
          }
          hasGlobal(Z) {
            let pe = this;
            do
              if (pe.globals[Z])
                return !0;
            while (pe = pe.parent);
            return !1;
          }
          hasReference(Z) {
            return !!this.getProgramParent().references[Z];
          }
          isPure(Z, pe) {
            if (v(Z)) {
              const We = this.getBinding(Z.name);
              return !!We && (!pe || We.constant);
            }
            if ($(Z) || ie(Z) || ue(Z) || we(Z))
              return !0;
            var be, _e, Ie;
            if (C(Z))
              return !(Z.superClass && !this.isPure(Z.superClass, pe)) && !(((be = Z.decorators) == null ? void 0 : be.length) > 0) && this.isPure(Z.body, pe);
            if (I(Z)) {
              for (const We of Z.body)
                if (!this.isPure(We, pe))
                  return !1;
              return !0;
            }
            if (N(Z))
              return this.isPure(Z.left, pe) && this.isPure(Z.right, pe);
            if (R(Z) || ae(Z)) {
              for (const We of Z.elements)
                if (We !== null && !this.isPure(We, pe))
                  return !1;
              return !0;
            }
            if (M(Z) || re(Z)) {
              for (const We of Z.properties)
                if (!this.isPure(We, pe))
                  return !1;
              return !0;
            }
            if (G(Z))
              return !(Z.computed && !this.isPure(Z.key, pe)) && !(((_e = Z.decorators) == null ? void 0 : _e.length) > 0);
            if (B(Z))
              return !(Z.computed && !this.isPure(Z.key, pe)) && !(((Ie = Z.decorators) == null ? void 0 : Ie.length) > 0) && !((le(Z) || Z.static) && Z.value !== null && !this.isPure(Z.value, pe));
            if (Y(Z))
              return this.isPure(Z.argument, pe);
            if (z(Z))
              return Q(Z.tag, "String.raw") && !this.hasBinding("String", !0) && this.isPure(Z.quasi, pe);
            if (q(Z)) {
              for (const We of Z.expressions)
                if (!this.isPure(We, pe))
                  return !1;
              return !0;
            }
            return k(Z);
          }
          setData(Z, pe) {
            return this.data[Z] = pe;
          }
          getData(Z) {
            let pe = this;
            do {
              const be = pe.data[Z];
              if (be != null)
                return be;
            } while (pe = pe.parent);
          }
          removeData(Z) {
            let pe = this;
            do
              pe.data[Z] != null && (pe.data[Z] = null);
            while (pe = pe.parent);
          }
          init() {
            this.inited || (this.inited = !0, this.crawl());
          }
          crawl() {
            const Z = this.path;
            this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
            const pe = this.getProgramParent();
            if (pe.crawling)
              return;
            const be = { references: [], constantViolations: [], assignments: [] };
            if (this.crawling = !0, Z.type !== "Program" && (0, y.isExplodedVisitor)(Ae)) {
              for (const Ie of Ae.enter)
                Ie.call(be, Z, be);
              const _e = Ae[Z.type];
              if (_e)
                for (const Ie of _e.enter)
                  Ie.call(be, Z, be);
            }
            Z.traverse(Ae, be), this.crawling = !1;
            for (const _e of be.assignments) {
              const Ie = _e.getBindingIdentifiers();
              for (const We of Object.keys(Ie))
                _e.scope.getBinding(We) || pe.addGlobal(Ie[We]);
              _e.scope.registerConstantViolation(_e);
            }
            for (const _e of be.references) {
              const Ie = _e.scope.getBinding(_e.node.name);
              Ie ? Ie.reference(_e) : pe.addGlobal(_e.node);
            }
            for (const _e of be.constantViolations)
              _e.scope.registerConstantViolation(_e);
          }
          push(Z) {
            let pe = this.path;
            pe.isPattern() ? pe = this.getPatternParent().path : pe.isBlockStatement() || pe.isProgram() || (pe = this.getBlockParent().path), pe.isSwitchStatement() && (pe = (this.getFunctionParent() || this.getProgramParent()).path);
            const { init: be, unique: _e, kind: Ie = "var", id: We } = Z;
            if (!be && !_e && (Ie === "var" || Ie === "let") && pe.isFunction() && !pe.node.name && m.isCallExpression(pe.parent, { callee: pe.node }) && pe.parent.arguments.length <= pe.node.params.length && m.isIdentifier(We))
              return pe.pushContainer("params", We), void pe.scope.registerBinding("param", pe.get("params")[pe.node.params.length - 1]);
            (pe.isLoop() || pe.isCatchClause() || pe.isFunction()) && (pe.ensureBlock(), pe = pe.get("body"));
            const tt = Z._blockHoist == null ? 2 : Z._blockHoist, Ye = `declaration:${Ie}:${tt}`;
            let ht = !_e && pe.getData(Ye);
            if (!ht) {
              const Xe = de(Ie, []);
              Xe._blockHoist = tt, [ht] = pe.unshiftContainer("body", [Xe]), _e || pe.setData(Ye, ht);
            }
            const ct = oe(We, be), st = ht.node.declarations.push(ct);
            pe.scope.registerBinding(Ie, ht.get("declarations")[st - 1]);
          }
          getProgramParent() {
            let Z = this;
            do
              if (Z.path.isProgram())
                return Z;
            while (Z = Z.parent);
            throw new Error("Couldn't find a Program");
          }
          getFunctionParent() {
            let Z = this;
            do
              if (Z.path.isFunctionParent())
                return Z;
            while (Z = Z.parent);
            return null;
          }
          getBlockParent() {
            let Z = this;
            do
              if (Z.path.isBlockParent())
                return Z;
            while (Z = Z.parent);
            throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
          }
          getPatternParent() {
            let Z = this;
            do
              if (!Z.path.isPattern())
                return Z.getBlockParent();
            while (Z = Z.parent.parent);
            throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
          }
          getAllBindings() {
            const Z = /* @__PURE__ */ Object.create(null);
            let pe = this;
            do {
              for (const be of Object.keys(pe.bindings))
                !(be in Z) && (Z[be] = pe.bindings[be]);
              pe = pe.parent;
            } while (pe);
            return Z;
          }
          getAllBindingsOfKind(...Z) {
            const pe = /* @__PURE__ */ Object.create(null);
            for (const be of Z) {
              let _e = this;
              do {
                for (const Ie of Object.keys(_e.bindings)) {
                  const We = _e.bindings[Ie];
                  We.kind === be && (pe[Ie] = We);
                }
                _e = _e.parent;
              } while (_e);
            }
            return pe;
          }
          bindingIdentifierEquals(Z, pe) {
            return this.getBindingIdentifier(Z) === pe;
          }
          getBinding(Z) {
            let pe, be = this;
            do {
              const Ie = be.getOwnBinding(Z);
              var _e;
              if (Ie) {
                if ((_e = pe) == null || !_e.isPattern() || Ie.kind === "param" || Ie.kind === "local")
                  return Ie;
              } else if (!Ie && Z === "arguments" && be.path.isFunction() && !be.path.isArrowFunctionExpression())
                break;
              pe = be.path;
            } while (be = be.parent);
          }
          getOwnBinding(Z) {
            return this.bindings[Z];
          }
          getBindingIdentifier(Z) {
            var pe;
            return (pe = this.getBinding(Z)) == null ? void 0 : pe.identifier;
          }
          getOwnBindingIdentifier(Z) {
            const pe = this.bindings[Z];
            return pe == null ? void 0 : pe.identifier;
          }
          hasOwnBinding(Z) {
            return !!this.getOwnBinding(Z);
          }
          hasBinding(Z, pe) {
            var be, _e, Ie;
            return !!Z && (!!this.hasOwnBinding(Z) || (typeof pe == "boolean" && (pe = { noGlobals: pe }), !!this.parentHasBinding(Z, pe) || !((be = pe) != null && be.noUids || !this.hasUid(Z)) || !((_e = pe) != null && _e.noGlobals || !me.globals.includes(Z)) || !((Ie = pe) != null && Ie.noGlobals || !me.contextVariables.includes(Z))));
          }
          parentHasBinding(Z, pe) {
            var be;
            return (be = this.parent) == null ? void 0 : be.hasBinding(Z, pe);
          }
          moveBindingTo(Z, pe) {
            const be = this.getBinding(Z);
            be && (be.scope.removeOwnBinding(Z), be.scope = pe, pe.bindings[Z] = be);
          }
          removeOwnBinding(Z) {
            delete this.bindings[Z];
          }
          removeBinding(Z) {
            var pe;
            (pe = this.getBinding(Z)) == null || pe.scope.removeOwnBinding(Z);
            let be = this;
            do
              be.uids[Z] && (be.uids[Z] = !1);
            while (be = be.parent);
          }
        }
        r.default = me, me.globals = Object.keys(s.builtin), me.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/scope/lib/renamer.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+helper-split-export-declaration@7.22.6/node_modules/@babel/helper-split-export-declaration/lib/index.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js"), d = l("./node_modules/.pnpm/@babel+helper-environment-visitor@7.22.5/node_modules/@babel/helper-environment-visitor/lib/index.js"), s = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/traverse-node.js"), o = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/visitors.js");
        const m = { ReferencedIdentifier({ node: h }, y) {
          h.name === y.oldName && (h.name = y.newName);
        }, Scope(h, y) {
          h.scope.bindingIdentifierEquals(y.oldName, y.binding.identifier) || (h.skip(), h.isMethod() && (0, d.requeueComputedKeyAndDecorators)(h));
        }, ObjectProperty({ node: h, scope: y }, b) {
          const { name: E } = h.key;
          var S;
          !h.shorthand || E !== b.oldName && E !== b.newName || y.getBindingIdentifier(E) !== b.binding.identifier || (h.shorthand = !1, (S = h.extra) != null && S.shorthand && (h.extra.shorthand = !1));
        }, "AssignmentExpression|Declaration|VariableDeclarator"(h, y) {
          if (h.isVariableDeclaration())
            return;
          const b = h.getOuterBindingIdentifiers();
          for (const E in b)
            E === y.oldName && (b[E].name = y.newName);
        } };
        r.default = class {
          constructor(h, y, b) {
            this.newName = b, this.oldName = y, this.binding = h;
          }
          maybeConvertFromExportDeclaration(h) {
            const y = h.parentPath;
            if (y.isExportDeclaration()) {
              if (y.isExportDefaultDeclaration()) {
                const { declaration: b } = y.node;
                if (f.isDeclaration(b) && !b.id)
                  return;
              }
              y.isExportAllDeclaration() || (0, i.default)(y);
            }
          }
          maybeConvertFromClassFunctionDeclaration(h) {
            return h;
          }
          maybeConvertFromClassFunctionExpression(h) {
            return h;
          }
          rename() {
            const { binding: h, oldName: y, newName: b } = this, { scope: E, path: S } = h, g = S.find((R) => R.isDeclaration() || R.isFunctionExpression() || R.isClassExpression());
            g && g.getOuterBindingIdentifiers()[y] === h.identifier && this.maybeConvertFromExportDeclaration(g);
            const P = arguments[0] || E.block;
            (0, s.traverseNode)(P, (0, o.explode)(m), E, this, E.path, { discriminant: !0 }), arguments[0] || (E.removeOwnBinding(y), E.bindings[b] = h, this.binding.identifier.name = b), g && (this.maybeConvertFromClassFunctionDeclaration(S), this.maybeConvertFromClassFunctionExpression(S));
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/traverse-node.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.traverseNode = function(s, o, m, h, y, b, E) {
          const S = d[s.type];
          if (!S)
            return !1;
          const g = new i.default(m, o, h, y);
          if (E)
            return (b == null || !b[y.parentKey]) && g.visitQueue([y]);
          for (const P of S)
            if ((b == null || !b[P]) && g.visit(s, P))
              return !0;
          return !1;
        };
        var i = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/context.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { VISITOR_KEYS: d } = f;
      }, "./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/visitors.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.explode = b, r.isExplodedVisitor = y, r.merge = function(I, D = [], j) {
          const F = {};
          for (let _ = 0; _ < I.length; _++) {
            const T = b(I[_]), v = D[_];
            let w = T;
            (v || j) && (w = g(w, v, j)), C(F, w);
            for (const O of Object.keys(T)) {
              if (N(O))
                continue;
              let G = T[O];
              (v || j) && (G = g(G, v, j)), C(F[O] || (F[O] = {}), G);
            }
          }
          return F;
        }, r.verify = E;
        var i = l("./node_modules/.pnpm/@babel+traverse@7.22.15/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
        const { DEPRECATED_KEYS: d, DEPRECATED_ALIASES: s, FLIPPED_ALIAS_KEYS: o, TYPES: m, __internal__deprecationWarning: h } = f;
        function y(I) {
          return I == null ? void 0 : I._exploded;
        }
        function b(I) {
          if (y(I))
            return I;
          I._exploded = !0;
          for (const D of Object.keys(I)) {
            if (N(D))
              continue;
            const j = D.split("|");
            if (j.length === 1)
              continue;
            const F = I[D];
            delete I[D];
            for (const _ of j)
              I[_] = F;
          }
          E(I), delete I.__esModule, function(D) {
            for (const j of Object.keys(D)) {
              if (N(j))
                continue;
              const F = D[j];
              typeof F == "function" && (D[j] = { enter: F });
            }
          }(I), P(I);
          for (const D of Object.keys(I)) {
            if (N(D) || !(D in i))
              continue;
            const j = I[D];
            for (const _ of Object.keys(j))
              j[_] = R(D, j[_]);
            delete I[D];
            const F = i[D];
            if (F !== null)
              for (const _ of F)
                I[_] ? C(I[_], j) : I[_] = j;
            else
              C(I, j);
          }
          for (const D of Object.keys(I)) {
            if (N(D))
              continue;
            let j = o[D];
            if (D in d) {
              const _ = d[D];
              h(D, _, "Visitor "), j = [_];
            } else if (D in s) {
              const _ = s[D];
              h(D, _, "Visitor "), j = o[_];
            }
            if (!j)
              continue;
            const F = I[D];
            delete I[D];
            for (const _ of j) {
              const T = I[_];
              T ? C(T, F) : I[_] = Object.assign({}, F);
            }
          }
          for (const D of Object.keys(I))
            N(D) || P(I[D]);
          return I;
        }
        function E(I) {
          if (!I._verified) {
            if (typeof I == "function")
              throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
            for (const D of Object.keys(I)) {
              if (D !== "enter" && D !== "exit" || S(D, I[D]), N(D))
                continue;
              if (m.indexOf(D) < 0)
                throw new Error(`You gave us a visitor for the node type ${D} but it's not a valid type`);
              const j = I[D];
              if (typeof j == "object")
                for (const F of Object.keys(j)) {
                  if (F !== "enter" && F !== "exit")
                    throw new Error(`You passed \`traverse()\` a visitor object with the property ${D} that has the invalid property ${F}`);
                  S(`${D}.${F}`, j[F]);
                }
            }
            I._verified = !0;
          }
        }
        function S(I, D) {
          const j = [].concat(D);
          for (const F of j)
            if (typeof F != "function")
              throw new TypeError(`Non-function found defined in ${I} with type ${typeof F}`);
        }
        function g(I, D, j) {
          const F = {};
          for (const _ of ["enter", "exit"]) {
            let T = I[_];
            Array.isArray(T) && (T = T.map(function(v) {
              let w = v;
              return D && (w = function(O) {
                v.call(D, O, D);
              }), j && (w = j(D == null ? void 0 : D.key, _, w)), w !== v && (w.toString = () => v.toString()), w;
            }), F[_] = T);
          }
          return F;
        }
        function P(I) {
          I.enter && !Array.isArray(I.enter) && (I.enter = [I.enter]), I.exit && !Array.isArray(I.exit) && (I.exit = [I.exit]);
        }
        function R(I, D) {
          const j = function(F) {
            if (F[`is${I}`]())
              return D.apply(this, arguments);
          };
          return j.toString = () => D.toString(), j;
        }
        function N(I) {
          return I[0] === "_" || I === "enter" || I === "exit" || I === "shouldSkip" || I === "denylist" || I === "noScope" || I === "skipKeys" || I === "blacklist";
        }
        function C(I, D) {
          for (const j of ["enter", "exit"])
            D[j] && (I[j] = [].concat(I[j] || [], D[j]));
        }
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/asserts/assertNode.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f) {
          if (!(0, i.default)(f)) {
            var d;
            const s = (d = f == null ? void 0 : f.type) != null ? d : JSON.stringify(f);
            throw new TypeError(`Not a valid node of type "${s}"`);
          }
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/asserts/generated/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.assertAccessor = function(s, o) {
          d("Accessor", s, o);
        }, r.assertAnyTypeAnnotation = function(s, o) {
          d("AnyTypeAnnotation", s, o);
        }, r.assertArgumentPlaceholder = function(s, o) {
          d("ArgumentPlaceholder", s, o);
        }, r.assertArrayExpression = function(s, o) {
          d("ArrayExpression", s, o);
        }, r.assertArrayPattern = function(s, o) {
          d("ArrayPattern", s, o);
        }, r.assertArrayTypeAnnotation = function(s, o) {
          d("ArrayTypeAnnotation", s, o);
        }, r.assertArrowFunctionExpression = function(s, o) {
          d("ArrowFunctionExpression", s, o);
        }, r.assertAssignmentExpression = function(s, o) {
          d("AssignmentExpression", s, o);
        }, r.assertAssignmentPattern = function(s, o) {
          d("AssignmentPattern", s, o);
        }, r.assertAwaitExpression = function(s, o) {
          d("AwaitExpression", s, o);
        }, r.assertBigIntLiteral = function(s, o) {
          d("BigIntLiteral", s, o);
        }, r.assertBinary = function(s, o) {
          d("Binary", s, o);
        }, r.assertBinaryExpression = function(s, o) {
          d("BinaryExpression", s, o);
        }, r.assertBindExpression = function(s, o) {
          d("BindExpression", s, o);
        }, r.assertBlock = function(s, o) {
          d("Block", s, o);
        }, r.assertBlockParent = function(s, o) {
          d("BlockParent", s, o);
        }, r.assertBlockStatement = function(s, o) {
          d("BlockStatement", s, o);
        }, r.assertBooleanLiteral = function(s, o) {
          d("BooleanLiteral", s, o);
        }, r.assertBooleanLiteralTypeAnnotation = function(s, o) {
          d("BooleanLiteralTypeAnnotation", s, o);
        }, r.assertBooleanTypeAnnotation = function(s, o) {
          d("BooleanTypeAnnotation", s, o);
        }, r.assertBreakStatement = function(s, o) {
          d("BreakStatement", s, o);
        }, r.assertCallExpression = function(s, o) {
          d("CallExpression", s, o);
        }, r.assertCatchClause = function(s, o) {
          d("CatchClause", s, o);
        }, r.assertClass = function(s, o) {
          d("Class", s, o);
        }, r.assertClassAccessorProperty = function(s, o) {
          d("ClassAccessorProperty", s, o);
        }, r.assertClassBody = function(s, o) {
          d("ClassBody", s, o);
        }, r.assertClassDeclaration = function(s, o) {
          d("ClassDeclaration", s, o);
        }, r.assertClassExpression = function(s, o) {
          d("ClassExpression", s, o);
        }, r.assertClassImplements = function(s, o) {
          d("ClassImplements", s, o);
        }, r.assertClassMethod = function(s, o) {
          d("ClassMethod", s, o);
        }, r.assertClassPrivateMethod = function(s, o) {
          d("ClassPrivateMethod", s, o);
        }, r.assertClassPrivateProperty = function(s, o) {
          d("ClassPrivateProperty", s, o);
        }, r.assertClassProperty = function(s, o) {
          d("ClassProperty", s, o);
        }, r.assertCompletionStatement = function(s, o) {
          d("CompletionStatement", s, o);
        }, r.assertConditional = function(s, o) {
          d("Conditional", s, o);
        }, r.assertConditionalExpression = function(s, o) {
          d("ConditionalExpression", s, o);
        }, r.assertContinueStatement = function(s, o) {
          d("ContinueStatement", s, o);
        }, r.assertDebuggerStatement = function(s, o) {
          d("DebuggerStatement", s, o);
        }, r.assertDecimalLiteral = function(s, o) {
          d("DecimalLiteral", s, o);
        }, r.assertDeclaration = function(s, o) {
          d("Declaration", s, o);
        }, r.assertDeclareClass = function(s, o) {
          d("DeclareClass", s, o);
        }, r.assertDeclareExportAllDeclaration = function(s, o) {
          d("DeclareExportAllDeclaration", s, o);
        }, r.assertDeclareExportDeclaration = function(s, o) {
          d("DeclareExportDeclaration", s, o);
        }, r.assertDeclareFunction = function(s, o) {
          d("DeclareFunction", s, o);
        }, r.assertDeclareInterface = function(s, o) {
          d("DeclareInterface", s, o);
        }, r.assertDeclareModule = function(s, o) {
          d("DeclareModule", s, o);
        }, r.assertDeclareModuleExports = function(s, o) {
          d("DeclareModuleExports", s, o);
        }, r.assertDeclareOpaqueType = function(s, o) {
          d("DeclareOpaqueType", s, o);
        }, r.assertDeclareTypeAlias = function(s, o) {
          d("DeclareTypeAlias", s, o);
        }, r.assertDeclareVariable = function(s, o) {
          d("DeclareVariable", s, o);
        }, r.assertDeclaredPredicate = function(s, o) {
          d("DeclaredPredicate", s, o);
        }, r.assertDecorator = function(s, o) {
          d("Decorator", s, o);
        }, r.assertDirective = function(s, o) {
          d("Directive", s, o);
        }, r.assertDirectiveLiteral = function(s, o) {
          d("DirectiveLiteral", s, o);
        }, r.assertDoExpression = function(s, o) {
          d("DoExpression", s, o);
        }, r.assertDoWhileStatement = function(s, o) {
          d("DoWhileStatement", s, o);
        }, r.assertEmptyStatement = function(s, o) {
          d("EmptyStatement", s, o);
        }, r.assertEmptyTypeAnnotation = function(s, o) {
          d("EmptyTypeAnnotation", s, o);
        }, r.assertEnumBody = function(s, o) {
          d("EnumBody", s, o);
        }, r.assertEnumBooleanBody = function(s, o) {
          d("EnumBooleanBody", s, o);
        }, r.assertEnumBooleanMember = function(s, o) {
          d("EnumBooleanMember", s, o);
        }, r.assertEnumDeclaration = function(s, o) {
          d("EnumDeclaration", s, o);
        }, r.assertEnumDefaultedMember = function(s, o) {
          d("EnumDefaultedMember", s, o);
        }, r.assertEnumMember = function(s, o) {
          d("EnumMember", s, o);
        }, r.assertEnumNumberBody = function(s, o) {
          d("EnumNumberBody", s, o);
        }, r.assertEnumNumberMember = function(s, o) {
          d("EnumNumberMember", s, o);
        }, r.assertEnumStringBody = function(s, o) {
          d("EnumStringBody", s, o);
        }, r.assertEnumStringMember = function(s, o) {
          d("EnumStringMember", s, o);
        }, r.assertEnumSymbolBody = function(s, o) {
          d("EnumSymbolBody", s, o);
        }, r.assertExistsTypeAnnotation = function(s, o) {
          d("ExistsTypeAnnotation", s, o);
        }, r.assertExportAllDeclaration = function(s, o) {
          d("ExportAllDeclaration", s, o);
        }, r.assertExportDeclaration = function(s, o) {
          d("ExportDeclaration", s, o);
        }, r.assertExportDefaultDeclaration = function(s, o) {
          d("ExportDefaultDeclaration", s, o);
        }, r.assertExportDefaultSpecifier = function(s, o) {
          d("ExportDefaultSpecifier", s, o);
        }, r.assertExportNamedDeclaration = function(s, o) {
          d("ExportNamedDeclaration", s, o);
        }, r.assertExportNamespaceSpecifier = function(s, o) {
          d("ExportNamespaceSpecifier", s, o);
        }, r.assertExportSpecifier = function(s, o) {
          d("ExportSpecifier", s, o);
        }, r.assertExpression = function(s, o) {
          d("Expression", s, o);
        }, r.assertExpressionStatement = function(s, o) {
          d("ExpressionStatement", s, o);
        }, r.assertExpressionWrapper = function(s, o) {
          d("ExpressionWrapper", s, o);
        }, r.assertFile = function(s, o) {
          d("File", s, o);
        }, r.assertFlow = function(s, o) {
          d("Flow", s, o);
        }, r.assertFlowBaseAnnotation = function(s, o) {
          d("FlowBaseAnnotation", s, o);
        }, r.assertFlowDeclaration = function(s, o) {
          d("FlowDeclaration", s, o);
        }, r.assertFlowPredicate = function(s, o) {
          d("FlowPredicate", s, o);
        }, r.assertFlowType = function(s, o) {
          d("FlowType", s, o);
        }, r.assertFor = function(s, o) {
          d("For", s, o);
        }, r.assertForInStatement = function(s, o) {
          d("ForInStatement", s, o);
        }, r.assertForOfStatement = function(s, o) {
          d("ForOfStatement", s, o);
        }, r.assertForStatement = function(s, o) {
          d("ForStatement", s, o);
        }, r.assertForXStatement = function(s, o) {
          d("ForXStatement", s, o);
        }, r.assertFunction = function(s, o) {
          d("Function", s, o);
        }, r.assertFunctionDeclaration = function(s, o) {
          d("FunctionDeclaration", s, o);
        }, r.assertFunctionExpression = function(s, o) {
          d("FunctionExpression", s, o);
        }, r.assertFunctionParent = function(s, o) {
          d("FunctionParent", s, o);
        }, r.assertFunctionTypeAnnotation = function(s, o) {
          d("FunctionTypeAnnotation", s, o);
        }, r.assertFunctionTypeParam = function(s, o) {
          d("FunctionTypeParam", s, o);
        }, r.assertGenericTypeAnnotation = function(s, o) {
          d("GenericTypeAnnotation", s, o);
        }, r.assertIdentifier = function(s, o) {
          d("Identifier", s, o);
        }, r.assertIfStatement = function(s, o) {
          d("IfStatement", s, o);
        }, r.assertImmutable = function(s, o) {
          d("Immutable", s, o);
        }, r.assertImport = function(s, o) {
          d("Import", s, o);
        }, r.assertImportAttribute = function(s, o) {
          d("ImportAttribute", s, o);
        }, r.assertImportDeclaration = function(s, o) {
          d("ImportDeclaration", s, o);
        }, r.assertImportDefaultSpecifier = function(s, o) {
          d("ImportDefaultSpecifier", s, o);
        }, r.assertImportNamespaceSpecifier = function(s, o) {
          d("ImportNamespaceSpecifier", s, o);
        }, r.assertImportOrExportDeclaration = function(s, o) {
          d("ImportOrExportDeclaration", s, o);
        }, r.assertImportSpecifier = function(s, o) {
          d("ImportSpecifier", s, o);
        }, r.assertIndexedAccessType = function(s, o) {
          d("IndexedAccessType", s, o);
        }, r.assertInferredPredicate = function(s, o) {
          d("InferredPredicate", s, o);
        }, r.assertInterfaceDeclaration = function(s, o) {
          d("InterfaceDeclaration", s, o);
        }, r.assertInterfaceExtends = function(s, o) {
          d("InterfaceExtends", s, o);
        }, r.assertInterfaceTypeAnnotation = function(s, o) {
          d("InterfaceTypeAnnotation", s, o);
        }, r.assertInterpreterDirective = function(s, o) {
          d("InterpreterDirective", s, o);
        }, r.assertIntersectionTypeAnnotation = function(s, o) {
          d("IntersectionTypeAnnotation", s, o);
        }, r.assertJSX = function(s, o) {
          d("JSX", s, o);
        }, r.assertJSXAttribute = function(s, o) {
          d("JSXAttribute", s, o);
        }, r.assertJSXClosingElement = function(s, o) {
          d("JSXClosingElement", s, o);
        }, r.assertJSXClosingFragment = function(s, o) {
          d("JSXClosingFragment", s, o);
        }, r.assertJSXElement = function(s, o) {
          d("JSXElement", s, o);
        }, r.assertJSXEmptyExpression = function(s, o) {
          d("JSXEmptyExpression", s, o);
        }, r.assertJSXExpressionContainer = function(s, o) {
          d("JSXExpressionContainer", s, o);
        }, r.assertJSXFragment = function(s, o) {
          d("JSXFragment", s, o);
        }, r.assertJSXIdentifier = function(s, o) {
          d("JSXIdentifier", s, o);
        }, r.assertJSXMemberExpression = function(s, o) {
          d("JSXMemberExpression", s, o);
        }, r.assertJSXNamespacedName = function(s, o) {
          d("JSXNamespacedName", s, o);
        }, r.assertJSXOpeningElement = function(s, o) {
          d("JSXOpeningElement", s, o);
        }, r.assertJSXOpeningFragment = function(s, o) {
          d("JSXOpeningFragment", s, o);
        }, r.assertJSXSpreadAttribute = function(s, o) {
          d("JSXSpreadAttribute", s, o);
        }, r.assertJSXSpreadChild = function(s, o) {
          d("JSXSpreadChild", s, o);
        }, r.assertJSXText = function(s, o) {
          d("JSXText", s, o);
        }, r.assertLVal = function(s, o) {
          d("LVal", s, o);
        }, r.assertLabeledStatement = function(s, o) {
          d("LabeledStatement", s, o);
        }, r.assertLiteral = function(s, o) {
          d("Literal", s, o);
        }, r.assertLogicalExpression = function(s, o) {
          d("LogicalExpression", s, o);
        }, r.assertLoop = function(s, o) {
          d("Loop", s, o);
        }, r.assertMemberExpression = function(s, o) {
          d("MemberExpression", s, o);
        }, r.assertMetaProperty = function(s, o) {
          d("MetaProperty", s, o);
        }, r.assertMethod = function(s, o) {
          d("Method", s, o);
        }, r.assertMiscellaneous = function(s, o) {
          d("Miscellaneous", s, o);
        }, r.assertMixedTypeAnnotation = function(s, o) {
          d("MixedTypeAnnotation", s, o);
        }, r.assertModuleDeclaration = function(s, o) {
          (0, f.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), d("ModuleDeclaration", s, o);
        }, r.assertModuleExpression = function(s, o) {
          d("ModuleExpression", s, o);
        }, r.assertModuleSpecifier = function(s, o) {
          d("ModuleSpecifier", s, o);
        }, r.assertNewExpression = function(s, o) {
          d("NewExpression", s, o);
        }, r.assertNoop = function(s, o) {
          d("Noop", s, o);
        }, r.assertNullLiteral = function(s, o) {
          d("NullLiteral", s, o);
        }, r.assertNullLiteralTypeAnnotation = function(s, o) {
          d("NullLiteralTypeAnnotation", s, o);
        }, r.assertNullableTypeAnnotation = function(s, o) {
          d("NullableTypeAnnotation", s, o);
        }, r.assertNumberLiteral = function(s, o) {
          (0, f.default)("assertNumberLiteral", "assertNumericLiteral"), d("NumberLiteral", s, o);
        }, r.assertNumberLiteralTypeAnnotation = function(s, o) {
          d("NumberLiteralTypeAnnotation", s, o);
        }, r.assertNumberTypeAnnotation = function(s, o) {
          d("NumberTypeAnnotation", s, o);
        }, r.assertNumericLiteral = function(s, o) {
          d("NumericLiteral", s, o);
        }, r.assertObjectExpression = function(s, o) {
          d("ObjectExpression", s, o);
        }, r.assertObjectMember = function(s, o) {
          d("ObjectMember", s, o);
        }, r.assertObjectMethod = function(s, o) {
          d("ObjectMethod", s, o);
        }, r.assertObjectPattern = function(s, o) {
          d("ObjectPattern", s, o);
        }, r.assertObjectProperty = function(s, o) {
          d("ObjectProperty", s, o);
        }, r.assertObjectTypeAnnotation = function(s, o) {
          d("ObjectTypeAnnotation", s, o);
        }, r.assertObjectTypeCallProperty = function(s, o) {
          d("ObjectTypeCallProperty", s, o);
        }, r.assertObjectTypeIndexer = function(s, o) {
          d("ObjectTypeIndexer", s, o);
        }, r.assertObjectTypeInternalSlot = function(s, o) {
          d("ObjectTypeInternalSlot", s, o);
        }, r.assertObjectTypeProperty = function(s, o) {
          d("ObjectTypeProperty", s, o);
        }, r.assertObjectTypeSpreadProperty = function(s, o) {
          d("ObjectTypeSpreadProperty", s, o);
        }, r.assertOpaqueType = function(s, o) {
          d("OpaqueType", s, o);
        }, r.assertOptionalCallExpression = function(s, o) {
          d("OptionalCallExpression", s, o);
        }, r.assertOptionalIndexedAccessType = function(s, o) {
          d("OptionalIndexedAccessType", s, o);
        }, r.assertOptionalMemberExpression = function(s, o) {
          d("OptionalMemberExpression", s, o);
        }, r.assertParenthesizedExpression = function(s, o) {
          d("ParenthesizedExpression", s, o);
        }, r.assertPattern = function(s, o) {
          d("Pattern", s, o);
        }, r.assertPatternLike = function(s, o) {
          d("PatternLike", s, o);
        }, r.assertPipelineBareFunction = function(s, o) {
          d("PipelineBareFunction", s, o);
        }, r.assertPipelinePrimaryTopicReference = function(s, o) {
          d("PipelinePrimaryTopicReference", s, o);
        }, r.assertPipelineTopicExpression = function(s, o) {
          d("PipelineTopicExpression", s, o);
        }, r.assertPlaceholder = function(s, o) {
          d("Placeholder", s, o);
        }, r.assertPrivate = function(s, o) {
          d("Private", s, o);
        }, r.assertPrivateName = function(s, o) {
          d("PrivateName", s, o);
        }, r.assertProgram = function(s, o) {
          d("Program", s, o);
        }, r.assertProperty = function(s, o) {
          d("Property", s, o);
        }, r.assertPureish = function(s, o) {
          d("Pureish", s, o);
        }, r.assertQualifiedTypeIdentifier = function(s, o) {
          d("QualifiedTypeIdentifier", s, o);
        }, r.assertRecordExpression = function(s, o) {
          d("RecordExpression", s, o);
        }, r.assertRegExpLiteral = function(s, o) {
          d("RegExpLiteral", s, o);
        }, r.assertRegexLiteral = function(s, o) {
          (0, f.default)("assertRegexLiteral", "assertRegExpLiteral"), d("RegexLiteral", s, o);
        }, r.assertRestElement = function(s, o) {
          d("RestElement", s, o);
        }, r.assertRestProperty = function(s, o) {
          (0, f.default)("assertRestProperty", "assertRestElement"), d("RestProperty", s, o);
        }, r.assertReturnStatement = function(s, o) {
          d("ReturnStatement", s, o);
        }, r.assertScopable = function(s, o) {
          d("Scopable", s, o);
        }, r.assertSequenceExpression = function(s, o) {
          d("SequenceExpression", s, o);
        }, r.assertSpreadElement = function(s, o) {
          d("SpreadElement", s, o);
        }, r.assertSpreadProperty = function(s, o) {
          (0, f.default)("assertSpreadProperty", "assertSpreadElement"), d("SpreadProperty", s, o);
        }, r.assertStandardized = function(s, o) {
          d("Standardized", s, o);
        }, r.assertStatement = function(s, o) {
          d("Statement", s, o);
        }, r.assertStaticBlock = function(s, o) {
          d("StaticBlock", s, o);
        }, r.assertStringLiteral = function(s, o) {
          d("StringLiteral", s, o);
        }, r.assertStringLiteralTypeAnnotation = function(s, o) {
          d("StringLiteralTypeAnnotation", s, o);
        }, r.assertStringTypeAnnotation = function(s, o) {
          d("StringTypeAnnotation", s, o);
        }, r.assertSuper = function(s, o) {
          d("Super", s, o);
        }, r.assertSwitchCase = function(s, o) {
          d("SwitchCase", s, o);
        }, r.assertSwitchStatement = function(s, o) {
          d("SwitchStatement", s, o);
        }, r.assertSymbolTypeAnnotation = function(s, o) {
          d("SymbolTypeAnnotation", s, o);
        }, r.assertTSAnyKeyword = function(s, o) {
          d("TSAnyKeyword", s, o);
        }, r.assertTSArrayType = function(s, o) {
          d("TSArrayType", s, o);
        }, r.assertTSAsExpression = function(s, o) {
          d("TSAsExpression", s, o);
        }, r.assertTSBaseType = function(s, o) {
          d("TSBaseType", s, o);
        }, r.assertTSBigIntKeyword = function(s, o) {
          d("TSBigIntKeyword", s, o);
        }, r.assertTSBooleanKeyword = function(s, o) {
          d("TSBooleanKeyword", s, o);
        }, r.assertTSCallSignatureDeclaration = function(s, o) {
          d("TSCallSignatureDeclaration", s, o);
        }, r.assertTSConditionalType = function(s, o) {
          d("TSConditionalType", s, o);
        }, r.assertTSConstructSignatureDeclaration = function(s, o) {
          d("TSConstructSignatureDeclaration", s, o);
        }, r.assertTSConstructorType = function(s, o) {
          d("TSConstructorType", s, o);
        }, r.assertTSDeclareFunction = function(s, o) {
          d("TSDeclareFunction", s, o);
        }, r.assertTSDeclareMethod = function(s, o) {
          d("TSDeclareMethod", s, o);
        }, r.assertTSEntityName = function(s, o) {
          d("TSEntityName", s, o);
        }, r.assertTSEnumDeclaration = function(s, o) {
          d("TSEnumDeclaration", s, o);
        }, r.assertTSEnumMember = function(s, o) {
          d("TSEnumMember", s, o);
        }, r.assertTSExportAssignment = function(s, o) {
          d("TSExportAssignment", s, o);
        }, r.assertTSExpressionWithTypeArguments = function(s, o) {
          d("TSExpressionWithTypeArguments", s, o);
        }, r.assertTSExternalModuleReference = function(s, o) {
          d("TSExternalModuleReference", s, o);
        }, r.assertTSFunctionType = function(s, o) {
          d("TSFunctionType", s, o);
        }, r.assertTSImportEqualsDeclaration = function(s, o) {
          d("TSImportEqualsDeclaration", s, o);
        }, r.assertTSImportType = function(s, o) {
          d("TSImportType", s, o);
        }, r.assertTSIndexSignature = function(s, o) {
          d("TSIndexSignature", s, o);
        }, r.assertTSIndexedAccessType = function(s, o) {
          d("TSIndexedAccessType", s, o);
        }, r.assertTSInferType = function(s, o) {
          d("TSInferType", s, o);
        }, r.assertTSInstantiationExpression = function(s, o) {
          d("TSInstantiationExpression", s, o);
        }, r.assertTSInterfaceBody = function(s, o) {
          d("TSInterfaceBody", s, o);
        }, r.assertTSInterfaceDeclaration = function(s, o) {
          d("TSInterfaceDeclaration", s, o);
        }, r.assertTSIntersectionType = function(s, o) {
          d("TSIntersectionType", s, o);
        }, r.assertTSIntrinsicKeyword = function(s, o) {
          d("TSIntrinsicKeyword", s, o);
        }, r.assertTSLiteralType = function(s, o) {
          d("TSLiteralType", s, o);
        }, r.assertTSMappedType = function(s, o) {
          d("TSMappedType", s, o);
        }, r.assertTSMethodSignature = function(s, o) {
          d("TSMethodSignature", s, o);
        }, r.assertTSModuleBlock = function(s, o) {
          d("TSModuleBlock", s, o);
        }, r.assertTSModuleDeclaration = function(s, o) {
          d("TSModuleDeclaration", s, o);
        }, r.assertTSNamedTupleMember = function(s, o) {
          d("TSNamedTupleMember", s, o);
        }, r.assertTSNamespaceExportDeclaration = function(s, o) {
          d("TSNamespaceExportDeclaration", s, o);
        }, r.assertTSNeverKeyword = function(s, o) {
          d("TSNeverKeyword", s, o);
        }, r.assertTSNonNullExpression = function(s, o) {
          d("TSNonNullExpression", s, o);
        }, r.assertTSNullKeyword = function(s, o) {
          d("TSNullKeyword", s, o);
        }, r.assertTSNumberKeyword = function(s, o) {
          d("TSNumberKeyword", s, o);
        }, r.assertTSObjectKeyword = function(s, o) {
          d("TSObjectKeyword", s, o);
        }, r.assertTSOptionalType = function(s, o) {
          d("TSOptionalType", s, o);
        }, r.assertTSParameterProperty = function(s, o) {
          d("TSParameterProperty", s, o);
        }, r.assertTSParenthesizedType = function(s, o) {
          d("TSParenthesizedType", s, o);
        }, r.assertTSPropertySignature = function(s, o) {
          d("TSPropertySignature", s, o);
        }, r.assertTSQualifiedName = function(s, o) {
          d("TSQualifiedName", s, o);
        }, r.assertTSRestType = function(s, o) {
          d("TSRestType", s, o);
        }, r.assertTSSatisfiesExpression = function(s, o) {
          d("TSSatisfiesExpression", s, o);
        }, r.assertTSStringKeyword = function(s, o) {
          d("TSStringKeyword", s, o);
        }, r.assertTSSymbolKeyword = function(s, o) {
          d("TSSymbolKeyword", s, o);
        }, r.assertTSThisType = function(s, o) {
          d("TSThisType", s, o);
        }, r.assertTSTupleType = function(s, o) {
          d("TSTupleType", s, o);
        }, r.assertTSType = function(s, o) {
          d("TSType", s, o);
        }, r.assertTSTypeAliasDeclaration = function(s, o) {
          d("TSTypeAliasDeclaration", s, o);
        }, r.assertTSTypeAnnotation = function(s, o) {
          d("TSTypeAnnotation", s, o);
        }, r.assertTSTypeAssertion = function(s, o) {
          d("TSTypeAssertion", s, o);
        }, r.assertTSTypeElement = function(s, o) {
          d("TSTypeElement", s, o);
        }, r.assertTSTypeLiteral = function(s, o) {
          d("TSTypeLiteral", s, o);
        }, r.assertTSTypeOperator = function(s, o) {
          d("TSTypeOperator", s, o);
        }, r.assertTSTypeParameter = function(s, o) {
          d("TSTypeParameter", s, o);
        }, r.assertTSTypeParameterDeclaration = function(s, o) {
          d("TSTypeParameterDeclaration", s, o);
        }, r.assertTSTypeParameterInstantiation = function(s, o) {
          d("TSTypeParameterInstantiation", s, o);
        }, r.assertTSTypePredicate = function(s, o) {
          d("TSTypePredicate", s, o);
        }, r.assertTSTypeQuery = function(s, o) {
          d("TSTypeQuery", s, o);
        }, r.assertTSTypeReference = function(s, o) {
          d("TSTypeReference", s, o);
        }, r.assertTSUndefinedKeyword = function(s, o) {
          d("TSUndefinedKeyword", s, o);
        }, r.assertTSUnionType = function(s, o) {
          d("TSUnionType", s, o);
        }, r.assertTSUnknownKeyword = function(s, o) {
          d("TSUnknownKeyword", s, o);
        }, r.assertTSVoidKeyword = function(s, o) {
          d("TSVoidKeyword", s, o);
        }, r.assertTaggedTemplateExpression = function(s, o) {
          d("TaggedTemplateExpression", s, o);
        }, r.assertTemplateElement = function(s, o) {
          d("TemplateElement", s, o);
        }, r.assertTemplateLiteral = function(s, o) {
          d("TemplateLiteral", s, o);
        }, r.assertTerminatorless = function(s, o) {
          d("Terminatorless", s, o);
        }, r.assertThisExpression = function(s, o) {
          d("ThisExpression", s, o);
        }, r.assertThisTypeAnnotation = function(s, o) {
          d("ThisTypeAnnotation", s, o);
        }, r.assertThrowStatement = function(s, o) {
          d("ThrowStatement", s, o);
        }, r.assertTopicReference = function(s, o) {
          d("TopicReference", s, o);
        }, r.assertTryStatement = function(s, o) {
          d("TryStatement", s, o);
        }, r.assertTupleExpression = function(s, o) {
          d("TupleExpression", s, o);
        }, r.assertTupleTypeAnnotation = function(s, o) {
          d("TupleTypeAnnotation", s, o);
        }, r.assertTypeAlias = function(s, o) {
          d("TypeAlias", s, o);
        }, r.assertTypeAnnotation = function(s, o) {
          d("TypeAnnotation", s, o);
        }, r.assertTypeCastExpression = function(s, o) {
          d("TypeCastExpression", s, o);
        }, r.assertTypeParameter = function(s, o) {
          d("TypeParameter", s, o);
        }, r.assertTypeParameterDeclaration = function(s, o) {
          d("TypeParameterDeclaration", s, o);
        }, r.assertTypeParameterInstantiation = function(s, o) {
          d("TypeParameterInstantiation", s, o);
        }, r.assertTypeScript = function(s, o) {
          d("TypeScript", s, o);
        }, r.assertTypeofTypeAnnotation = function(s, o) {
          d("TypeofTypeAnnotation", s, o);
        }, r.assertUnaryExpression = function(s, o) {
          d("UnaryExpression", s, o);
        }, r.assertUnaryLike = function(s, o) {
          d("UnaryLike", s, o);
        }, r.assertUnionTypeAnnotation = function(s, o) {
          d("UnionTypeAnnotation", s, o);
        }, r.assertUpdateExpression = function(s, o) {
          d("UpdateExpression", s, o);
        }, r.assertUserWhitespacable = function(s, o) {
          d("UserWhitespacable", s, o);
        }, r.assertV8IntrinsicIdentifier = function(s, o) {
          d("V8IntrinsicIdentifier", s, o);
        }, r.assertVariableDeclaration = function(s, o) {
          d("VariableDeclaration", s, o);
        }, r.assertVariableDeclarator = function(s, o) {
          d("VariableDeclarator", s, o);
        }, r.assertVariance = function(s, o) {
          d("Variance", s, o);
        }, r.assertVoidTypeAnnotation = function(s, o) {
          d("VoidTypeAnnotation", s, o);
        }, r.assertWhile = function(s, o) {
          d("While", s, o);
        }, r.assertWhileStatement = function(s, o) {
          d("WhileStatement", s, o);
        }, r.assertWithStatement = function(s, o) {
          d("WithStatement", s, o);
        }, r.assertYieldExpression = function(s, o) {
          d("YieldExpression", s, o);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/is.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/utils/deprecationWarning.js");
        function d(s, o, m) {
          if (!(0, i.default)(s, o, m))
            throw new Error(`Expected type "${s}" with option ${JSON.stringify(m)}, but instead got "${o.type}".`);
        }
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(d) {
          const s = (0, f.default)(d);
          return s.length === 1 ? s[0] : (0, i.unionTypeAnnotation)(s);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/generated/index.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/generated/index.js"), f = function(d) {
          switch (d) {
            case "string":
              return (0, i.stringTypeAnnotation)();
            case "number":
              return (0, i.numberTypeAnnotation)();
            case "undefined":
              return (0, i.voidTypeAnnotation)();
            case "boolean":
              return (0, i.booleanTypeAnnotation)();
            case "function":
              return (0, i.genericTypeAnnotation)((0, i.identifier)("Function"));
            case "object":
              return (0, i.genericTypeAnnotation)((0, i.identifier)("Object"));
            case "symbol":
              return (0, i.genericTypeAnnotation)((0, i.identifier)("Symbol"));
            case "bigint":
              return (0, i.anyTypeAnnotation)();
          }
          throw new Error("Invalid typeof value: " + d);
        };
        r.default = f;
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/generated/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.anyTypeAnnotation = function() {
          return { type: "AnyTypeAnnotation" };
        }, r.argumentPlaceholder = function() {
          return { type: "ArgumentPlaceholder" };
        }, r.arrayExpression = function(h = []) {
          return (0, i.default)({ type: "ArrayExpression", elements: h });
        }, r.arrayPattern = function(h) {
          return (0, i.default)({ type: "ArrayPattern", elements: h });
        }, r.arrayTypeAnnotation = function(h) {
          return (0, i.default)({ type: "ArrayTypeAnnotation", elementType: h });
        }, r.arrowFunctionExpression = function(h, y, b = !1) {
          return (0, i.default)({ type: "ArrowFunctionExpression", params: h, body: y, async: b, expression: null });
        }, r.assignmentExpression = function(h, y, b) {
          return (0, i.default)({ type: "AssignmentExpression", operator: h, left: y, right: b });
        }, r.assignmentPattern = function(h, y) {
          return (0, i.default)({ type: "AssignmentPattern", left: h, right: y });
        }, r.awaitExpression = function(h) {
          return (0, i.default)({ type: "AwaitExpression", argument: h });
        }, r.bigIntLiteral = function(h) {
          return (0, i.default)({ type: "BigIntLiteral", value: h });
        }, r.binaryExpression = function(h, y, b) {
          return (0, i.default)({ type: "BinaryExpression", operator: h, left: y, right: b });
        }, r.bindExpression = function(h, y) {
          return (0, i.default)({ type: "BindExpression", object: h, callee: y });
        }, r.blockStatement = function(h, y = []) {
          return (0, i.default)({ type: "BlockStatement", body: h, directives: y });
        }, r.booleanLiteral = function(h) {
          return (0, i.default)({ type: "BooleanLiteral", value: h });
        }, r.booleanLiteralTypeAnnotation = function(h) {
          return (0, i.default)({ type: "BooleanLiteralTypeAnnotation", value: h });
        }, r.booleanTypeAnnotation = function() {
          return { type: "BooleanTypeAnnotation" };
        }, r.breakStatement = function(h = null) {
          return (0, i.default)({ type: "BreakStatement", label: h });
        }, r.callExpression = function(h, y) {
          return (0, i.default)({ type: "CallExpression", callee: h, arguments: y });
        }, r.catchClause = function(h = null, y) {
          return (0, i.default)({ type: "CatchClause", param: h, body: y });
        }, r.classAccessorProperty = function(h, y = null, b = null, E = null, S = !1, g = !1) {
          return (0, i.default)({ type: "ClassAccessorProperty", key: h, value: y, typeAnnotation: b, decorators: E, computed: S, static: g });
        }, r.classBody = function(h) {
          return (0, i.default)({ type: "ClassBody", body: h });
        }, r.classDeclaration = function(h, y = null, b, E = null) {
          return (0, i.default)({ type: "ClassDeclaration", id: h, superClass: y, body: b, decorators: E });
        }, r.classExpression = function(h = null, y = null, b, E = null) {
          return (0, i.default)({ type: "ClassExpression", id: h, superClass: y, body: b, decorators: E });
        }, r.classImplements = function(h, y = null) {
          return (0, i.default)({ type: "ClassImplements", id: h, typeParameters: y });
        }, r.classMethod = function(h = "method", y, b, E, S = !1, g = !1, P = !1, R = !1) {
          return (0, i.default)({ type: "ClassMethod", kind: h, key: y, params: b, body: E, computed: S, static: g, generator: P, async: R });
        }, r.classPrivateMethod = function(h = "method", y, b, E, S = !1) {
          return (0, i.default)({ type: "ClassPrivateMethod", kind: h, key: y, params: b, body: E, static: S });
        }, r.classPrivateProperty = function(h, y = null, b = null, E = !1) {
          return (0, i.default)({ type: "ClassPrivateProperty", key: h, value: y, decorators: b, static: E });
        }, r.classProperty = function(h, y = null, b = null, E = null, S = !1, g = !1) {
          return (0, i.default)({ type: "ClassProperty", key: h, value: y, typeAnnotation: b, decorators: E, computed: S, static: g });
        }, r.conditionalExpression = function(h, y, b) {
          return (0, i.default)({ type: "ConditionalExpression", test: h, consequent: y, alternate: b });
        }, r.continueStatement = function(h = null) {
          return (0, i.default)({ type: "ContinueStatement", label: h });
        }, r.debuggerStatement = function() {
          return { type: "DebuggerStatement" };
        }, r.decimalLiteral = function(h) {
          return (0, i.default)({ type: "DecimalLiteral", value: h });
        }, r.declareClass = function(h, y = null, b = null, E) {
          return (0, i.default)({ type: "DeclareClass", id: h, typeParameters: y, extends: b, body: E });
        }, r.declareExportAllDeclaration = function(h) {
          return (0, i.default)({ type: "DeclareExportAllDeclaration", source: h });
        }, r.declareExportDeclaration = function(h = null, y = null, b = null) {
          return (0, i.default)({ type: "DeclareExportDeclaration", declaration: h, specifiers: y, source: b });
        }, r.declareFunction = function(h) {
          return (0, i.default)({ type: "DeclareFunction", id: h });
        }, r.declareInterface = function(h, y = null, b = null, E) {
          return (0, i.default)({ type: "DeclareInterface", id: h, typeParameters: y, extends: b, body: E });
        }, r.declareModule = function(h, y, b = null) {
          return (0, i.default)({ type: "DeclareModule", id: h, body: y, kind: b });
        }, r.declareModuleExports = function(h) {
          return (0, i.default)({ type: "DeclareModuleExports", typeAnnotation: h });
        }, r.declareOpaqueType = function(h, y = null, b = null) {
          return (0, i.default)({ type: "DeclareOpaqueType", id: h, typeParameters: y, supertype: b });
        }, r.declareTypeAlias = function(h, y = null, b) {
          return (0, i.default)({ type: "DeclareTypeAlias", id: h, typeParameters: y, right: b });
        }, r.declareVariable = function(h) {
          return (0, i.default)({ type: "DeclareVariable", id: h });
        }, r.declaredPredicate = function(h) {
          return (0, i.default)({ type: "DeclaredPredicate", value: h });
        }, r.decorator = function(h) {
          return (0, i.default)({ type: "Decorator", expression: h });
        }, r.directive = function(h) {
          return (0, i.default)({ type: "Directive", value: h });
        }, r.directiveLiteral = function(h) {
          return (0, i.default)({ type: "DirectiveLiteral", value: h });
        }, r.doExpression = function(h, y = !1) {
          return (0, i.default)({ type: "DoExpression", body: h, async: y });
        }, r.doWhileStatement = function(h, y) {
          return (0, i.default)({ type: "DoWhileStatement", test: h, body: y });
        }, r.emptyStatement = function() {
          return { type: "EmptyStatement" };
        }, r.emptyTypeAnnotation = function() {
          return { type: "EmptyTypeAnnotation" };
        }, r.enumBooleanBody = function(h) {
          return (0, i.default)({ type: "EnumBooleanBody", members: h, explicitType: null, hasUnknownMembers: null });
        }, r.enumBooleanMember = function(h) {
          return (0, i.default)({ type: "EnumBooleanMember", id: h, init: null });
        }, r.enumDeclaration = function(h, y) {
          return (0, i.default)({ type: "EnumDeclaration", id: h, body: y });
        }, r.enumDefaultedMember = function(h) {
          return (0, i.default)({ type: "EnumDefaultedMember", id: h });
        }, r.enumNumberBody = function(h) {
          return (0, i.default)({ type: "EnumNumberBody", members: h, explicitType: null, hasUnknownMembers: null });
        }, r.enumNumberMember = function(h, y) {
          return (0, i.default)({ type: "EnumNumberMember", id: h, init: y });
        }, r.enumStringBody = function(h) {
          return (0, i.default)({ type: "EnumStringBody", members: h, explicitType: null, hasUnknownMembers: null });
        }, r.enumStringMember = function(h, y) {
          return (0, i.default)({ type: "EnumStringMember", id: h, init: y });
        }, r.enumSymbolBody = function(h) {
          return (0, i.default)({ type: "EnumSymbolBody", members: h, hasUnknownMembers: null });
        }, r.existsTypeAnnotation = function() {
          return { type: "ExistsTypeAnnotation" };
        }, r.exportAllDeclaration = function(h) {
          return (0, i.default)({ type: "ExportAllDeclaration", source: h });
        }, r.exportDefaultDeclaration = function(h) {
          return (0, i.default)({ type: "ExportDefaultDeclaration", declaration: h });
        }, r.exportDefaultSpecifier = function(h) {
          return (0, i.default)({ type: "ExportDefaultSpecifier", exported: h });
        }, r.exportNamedDeclaration = function(h = null, y = [], b = null) {
          return (0, i.default)({ type: "ExportNamedDeclaration", declaration: h, specifiers: y, source: b });
        }, r.exportNamespaceSpecifier = function(h) {
          return (0, i.default)({ type: "ExportNamespaceSpecifier", exported: h });
        }, r.exportSpecifier = function(h, y) {
          return (0, i.default)({ type: "ExportSpecifier", local: h, exported: y });
        }, r.expressionStatement = function(h) {
          return (0, i.default)({ type: "ExpressionStatement", expression: h });
        }, r.file = function(h, y = null, b = null) {
          return (0, i.default)({ type: "File", program: h, comments: y, tokens: b });
        }, r.forInStatement = function(h, y, b) {
          return (0, i.default)({ type: "ForInStatement", left: h, right: y, body: b });
        }, r.forOfStatement = function(h, y, b, E = !1) {
          return (0, i.default)({ type: "ForOfStatement", left: h, right: y, body: b, await: E });
        }, r.forStatement = function(h = null, y = null, b = null, E) {
          return (0, i.default)({ type: "ForStatement", init: h, test: y, update: b, body: E });
        }, r.functionDeclaration = function(h = null, y, b, E = !1, S = !1) {
          return (0, i.default)({ type: "FunctionDeclaration", id: h, params: y, body: b, generator: E, async: S });
        }, r.functionExpression = function(h = null, y, b, E = !1, S = !1) {
          return (0, i.default)({ type: "FunctionExpression", id: h, params: y, body: b, generator: E, async: S });
        }, r.functionTypeAnnotation = function(h = null, y, b = null, E) {
          return (0, i.default)({ type: "FunctionTypeAnnotation", typeParameters: h, params: y, rest: b, returnType: E });
        }, r.functionTypeParam = function(h = null, y) {
          return (0, i.default)({ type: "FunctionTypeParam", name: h, typeAnnotation: y });
        }, r.genericTypeAnnotation = function(h, y = null) {
          return (0, i.default)({ type: "GenericTypeAnnotation", id: h, typeParameters: y });
        }, r.identifier = function(h) {
          return (0, i.default)({ type: "Identifier", name: h });
        }, r.ifStatement = function(h, y, b = null) {
          return (0, i.default)({ type: "IfStatement", test: h, consequent: y, alternate: b });
        }, r.import = function() {
          return { type: "Import" };
        }, r.importAttribute = function(h, y) {
          return (0, i.default)({ type: "ImportAttribute", key: h, value: y });
        }, r.importDeclaration = function(h, y) {
          return (0, i.default)({ type: "ImportDeclaration", specifiers: h, source: y });
        }, r.importDefaultSpecifier = function(h) {
          return (0, i.default)({ type: "ImportDefaultSpecifier", local: h });
        }, r.importNamespaceSpecifier = function(h) {
          return (0, i.default)({ type: "ImportNamespaceSpecifier", local: h });
        }, r.importSpecifier = function(h, y) {
          return (0, i.default)({ type: "ImportSpecifier", local: h, imported: y });
        }, r.indexedAccessType = function(h, y) {
          return (0, i.default)({ type: "IndexedAccessType", objectType: h, indexType: y });
        }, r.inferredPredicate = function() {
          return { type: "InferredPredicate" };
        }, r.interfaceDeclaration = function(h, y = null, b = null, E) {
          return (0, i.default)({ type: "InterfaceDeclaration", id: h, typeParameters: y, extends: b, body: E });
        }, r.interfaceExtends = function(h, y = null) {
          return (0, i.default)({ type: "InterfaceExtends", id: h, typeParameters: y });
        }, r.interfaceTypeAnnotation = function(h = null, y) {
          return (0, i.default)({ type: "InterfaceTypeAnnotation", extends: h, body: y });
        }, r.interpreterDirective = function(h) {
          return (0, i.default)({ type: "InterpreterDirective", value: h });
        }, r.intersectionTypeAnnotation = function(h) {
          return (0, i.default)({ type: "IntersectionTypeAnnotation", types: h });
        }, r.jSXAttribute = r.jsxAttribute = function(h, y = null) {
          return (0, i.default)({ type: "JSXAttribute", name: h, value: y });
        }, r.jSXClosingElement = r.jsxClosingElement = function(h) {
          return (0, i.default)({ type: "JSXClosingElement", name: h });
        }, r.jSXClosingFragment = r.jsxClosingFragment = function() {
          return { type: "JSXClosingFragment" };
        }, r.jSXElement = r.jsxElement = function(h, y = null, b, E = null) {
          return (0, i.default)({ type: "JSXElement", openingElement: h, closingElement: y, children: b, selfClosing: E });
        }, r.jSXEmptyExpression = r.jsxEmptyExpression = function() {
          return { type: "JSXEmptyExpression" };
        }, r.jSXExpressionContainer = r.jsxExpressionContainer = function(h) {
          return (0, i.default)({ type: "JSXExpressionContainer", expression: h });
        }, r.jSXFragment = r.jsxFragment = function(h, y, b) {
          return (0, i.default)({ type: "JSXFragment", openingFragment: h, closingFragment: y, children: b });
        }, r.jSXIdentifier = r.jsxIdentifier = function(h) {
          return (0, i.default)({ type: "JSXIdentifier", name: h });
        }, r.jSXMemberExpression = r.jsxMemberExpression = function(h, y) {
          return (0, i.default)({ type: "JSXMemberExpression", object: h, property: y });
        }, r.jSXNamespacedName = r.jsxNamespacedName = function(h, y) {
          return (0, i.default)({ type: "JSXNamespacedName", namespace: h, name: y });
        }, r.jSXOpeningElement = r.jsxOpeningElement = function(h, y, b = !1) {
          return (0, i.default)({ type: "JSXOpeningElement", name: h, attributes: y, selfClosing: b });
        }, r.jSXOpeningFragment = r.jsxOpeningFragment = function() {
          return { type: "JSXOpeningFragment" };
        }, r.jSXSpreadAttribute = r.jsxSpreadAttribute = function(h) {
          return (0, i.default)({ type: "JSXSpreadAttribute", argument: h });
        }, r.jSXSpreadChild = r.jsxSpreadChild = function(h) {
          return (0, i.default)({ type: "JSXSpreadChild", expression: h });
        }, r.jSXText = r.jsxText = function(h) {
          return (0, i.default)({ type: "JSXText", value: h });
        }, r.labeledStatement = function(h, y) {
          return (0, i.default)({ type: "LabeledStatement", label: h, body: y });
        }, r.logicalExpression = function(h, y, b) {
          return (0, i.default)({ type: "LogicalExpression", operator: h, left: y, right: b });
        }, r.memberExpression = function(h, y, b = !1, E = null) {
          return (0, i.default)({ type: "MemberExpression", object: h, property: y, computed: b, optional: E });
        }, r.metaProperty = function(h, y) {
          return (0, i.default)({ type: "MetaProperty", meta: h, property: y });
        }, r.mixedTypeAnnotation = function() {
          return { type: "MixedTypeAnnotation" };
        }, r.moduleExpression = function(h) {
          return (0, i.default)({ type: "ModuleExpression", body: h });
        }, r.newExpression = function(h, y) {
          return (0, i.default)({ type: "NewExpression", callee: h, arguments: y });
        }, r.noop = function() {
          return { type: "Noop" };
        }, r.nullLiteral = function() {
          return { type: "NullLiteral" };
        }, r.nullLiteralTypeAnnotation = function() {
          return { type: "NullLiteralTypeAnnotation" };
        }, r.nullableTypeAnnotation = function(h) {
          return (0, i.default)({ type: "NullableTypeAnnotation", typeAnnotation: h });
        }, r.numberLiteral = function(h) {
          return (0, f.default)("NumberLiteral", "NumericLiteral", "The node type "), d(h);
        }, r.numberLiteralTypeAnnotation = function(h) {
          return (0, i.default)({ type: "NumberLiteralTypeAnnotation", value: h });
        }, r.numberTypeAnnotation = function() {
          return { type: "NumberTypeAnnotation" };
        }, r.numericLiteral = d, r.objectExpression = function(h) {
          return (0, i.default)({ type: "ObjectExpression", properties: h });
        }, r.objectMethod = function(h = "method", y, b, E, S = !1, g = !1, P = !1) {
          return (0, i.default)({ type: "ObjectMethod", kind: h, key: y, params: b, body: E, computed: S, generator: g, async: P });
        }, r.objectPattern = function(h) {
          return (0, i.default)({ type: "ObjectPattern", properties: h });
        }, r.objectProperty = function(h, y, b = !1, E = !1, S = null) {
          return (0, i.default)({ type: "ObjectProperty", key: h, value: y, computed: b, shorthand: E, decorators: S });
        }, r.objectTypeAnnotation = function(h, y = [], b = [], E = [], S = !1) {
          return (0, i.default)({ type: "ObjectTypeAnnotation", properties: h, indexers: y, callProperties: b, internalSlots: E, exact: S });
        }, r.objectTypeCallProperty = function(h) {
          return (0, i.default)({ type: "ObjectTypeCallProperty", value: h, static: null });
        }, r.objectTypeIndexer = function(h = null, y, b, E = null) {
          return (0, i.default)({ type: "ObjectTypeIndexer", id: h, key: y, value: b, variance: E, static: null });
        }, r.objectTypeInternalSlot = function(h, y, b, E, S) {
          return (0, i.default)({ type: "ObjectTypeInternalSlot", id: h, value: y, optional: b, static: E, method: S });
        }, r.objectTypeProperty = function(h, y, b = null) {
          return (0, i.default)({ type: "ObjectTypeProperty", key: h, value: y, variance: b, kind: null, method: null, optional: null, proto: null, static: null });
        }, r.objectTypeSpreadProperty = function(h) {
          return (0, i.default)({ type: "ObjectTypeSpreadProperty", argument: h });
        }, r.opaqueType = function(h, y = null, b = null, E) {
          return (0, i.default)({ type: "OpaqueType", id: h, typeParameters: y, supertype: b, impltype: E });
        }, r.optionalCallExpression = function(h, y, b) {
          return (0, i.default)({ type: "OptionalCallExpression", callee: h, arguments: y, optional: b });
        }, r.optionalIndexedAccessType = function(h, y) {
          return (0, i.default)({ type: "OptionalIndexedAccessType", objectType: h, indexType: y, optional: null });
        }, r.optionalMemberExpression = function(h, y, b = !1, E) {
          return (0, i.default)({ type: "OptionalMemberExpression", object: h, property: y, computed: b, optional: E });
        }, r.parenthesizedExpression = function(h) {
          return (0, i.default)({ type: "ParenthesizedExpression", expression: h });
        }, r.pipelineBareFunction = function(h) {
          return (0, i.default)({ type: "PipelineBareFunction", callee: h });
        }, r.pipelinePrimaryTopicReference = function() {
          return { type: "PipelinePrimaryTopicReference" };
        }, r.pipelineTopicExpression = function(h) {
          return (0, i.default)({ type: "PipelineTopicExpression", expression: h });
        }, r.placeholder = function(h, y) {
          return (0, i.default)({ type: "Placeholder", expectedNode: h, name: y });
        }, r.privateName = function(h) {
          return (0, i.default)({ type: "PrivateName", id: h });
        }, r.program = function(h, y = [], b = "script", E = null) {
          return (0, i.default)({ type: "Program", body: h, directives: y, sourceType: b, interpreter: E, sourceFile: null });
        }, r.qualifiedTypeIdentifier = function(h, y) {
          return (0, i.default)({ type: "QualifiedTypeIdentifier", id: h, qualification: y });
        }, r.recordExpression = function(h) {
          return (0, i.default)({ type: "RecordExpression", properties: h });
        }, r.regExpLiteral = s, r.regexLiteral = function(h, y = "") {
          return (0, f.default)("RegexLiteral", "RegExpLiteral", "The node type "), s(h, y);
        }, r.restElement = o, r.restProperty = function(h) {
          return (0, f.default)("RestProperty", "RestElement", "The node type "), o(h);
        }, r.returnStatement = function(h = null) {
          return (0, i.default)({ type: "ReturnStatement", argument: h });
        }, r.sequenceExpression = function(h) {
          return (0, i.default)({ type: "SequenceExpression", expressions: h });
        }, r.spreadElement = m, r.spreadProperty = function(h) {
          return (0, f.default)("SpreadProperty", "SpreadElement", "The node type "), m(h);
        }, r.staticBlock = function(h) {
          return (0, i.default)({ type: "StaticBlock", body: h });
        }, r.stringLiteral = function(h) {
          return (0, i.default)({ type: "StringLiteral", value: h });
        }, r.stringLiteralTypeAnnotation = function(h) {
          return (0, i.default)({ type: "StringLiteralTypeAnnotation", value: h });
        }, r.stringTypeAnnotation = function() {
          return { type: "StringTypeAnnotation" };
        }, r.super = function() {
          return { type: "Super" };
        }, r.switchCase = function(h = null, y) {
          return (0, i.default)({ type: "SwitchCase", test: h, consequent: y });
        }, r.switchStatement = function(h, y) {
          return (0, i.default)({ type: "SwitchStatement", discriminant: h, cases: y });
        }, r.symbolTypeAnnotation = function() {
          return { type: "SymbolTypeAnnotation" };
        }, r.taggedTemplateExpression = function(h, y) {
          return (0, i.default)({ type: "TaggedTemplateExpression", tag: h, quasi: y });
        }, r.templateElement = function(h, y = !1) {
          return (0, i.default)({ type: "TemplateElement", value: h, tail: y });
        }, r.templateLiteral = function(h, y) {
          return (0, i.default)({ type: "TemplateLiteral", quasis: h, expressions: y });
        }, r.thisExpression = function() {
          return { type: "ThisExpression" };
        }, r.thisTypeAnnotation = function() {
          return { type: "ThisTypeAnnotation" };
        }, r.throwStatement = function(h) {
          return (0, i.default)({ type: "ThrowStatement", argument: h });
        }, r.topicReference = function() {
          return { type: "TopicReference" };
        }, r.tryStatement = function(h, y = null, b = null) {
          return (0, i.default)({ type: "TryStatement", block: h, handler: y, finalizer: b });
        }, r.tSAnyKeyword = r.tsAnyKeyword = function() {
          return { type: "TSAnyKeyword" };
        }, r.tSArrayType = r.tsArrayType = function(h) {
          return (0, i.default)({ type: "TSArrayType", elementType: h });
        }, r.tSAsExpression = r.tsAsExpression = function(h, y) {
          return (0, i.default)({ type: "TSAsExpression", expression: h, typeAnnotation: y });
        }, r.tSBigIntKeyword = r.tsBigIntKeyword = function() {
          return { type: "TSBigIntKeyword" };
        }, r.tSBooleanKeyword = r.tsBooleanKeyword = function() {
          return { type: "TSBooleanKeyword" };
        }, r.tSCallSignatureDeclaration = r.tsCallSignatureDeclaration = function(h = null, y, b = null) {
          return (0, i.default)({ type: "TSCallSignatureDeclaration", typeParameters: h, parameters: y, typeAnnotation: b });
        }, r.tSConditionalType = r.tsConditionalType = function(h, y, b, E) {
          return (0, i.default)({ type: "TSConditionalType", checkType: h, extendsType: y, trueType: b, falseType: E });
        }, r.tSConstructSignatureDeclaration = r.tsConstructSignatureDeclaration = function(h = null, y, b = null) {
          return (0, i.default)({ type: "TSConstructSignatureDeclaration", typeParameters: h, parameters: y, typeAnnotation: b });
        }, r.tSConstructorType = r.tsConstructorType = function(h = null, y, b = null) {
          return (0, i.default)({ type: "TSConstructorType", typeParameters: h, parameters: y, typeAnnotation: b });
        }, r.tSDeclareFunction = r.tsDeclareFunction = function(h = null, y = null, b, E = null) {
          return (0, i.default)({ type: "TSDeclareFunction", id: h, typeParameters: y, params: b, returnType: E });
        }, r.tSDeclareMethod = r.tsDeclareMethod = function(h = null, y, b = null, E, S = null) {
          return (0, i.default)({ type: "TSDeclareMethod", decorators: h, key: y, typeParameters: b, params: E, returnType: S });
        }, r.tSEnumDeclaration = r.tsEnumDeclaration = function(h, y) {
          return (0, i.default)({ type: "TSEnumDeclaration", id: h, members: y });
        }, r.tSEnumMember = r.tsEnumMember = function(h, y = null) {
          return (0, i.default)({ type: "TSEnumMember", id: h, initializer: y });
        }, r.tSExportAssignment = r.tsExportAssignment = function(h) {
          return (0, i.default)({ type: "TSExportAssignment", expression: h });
        }, r.tSExpressionWithTypeArguments = r.tsExpressionWithTypeArguments = function(h, y = null) {
          return (0, i.default)({ type: "TSExpressionWithTypeArguments", expression: h, typeParameters: y });
        }, r.tSExternalModuleReference = r.tsExternalModuleReference = function(h) {
          return (0, i.default)({ type: "TSExternalModuleReference", expression: h });
        }, r.tSFunctionType = r.tsFunctionType = function(h = null, y, b = null) {
          return (0, i.default)({ type: "TSFunctionType", typeParameters: h, parameters: y, typeAnnotation: b });
        }, r.tSImportEqualsDeclaration = r.tsImportEqualsDeclaration = function(h, y) {
          return (0, i.default)({ type: "TSImportEqualsDeclaration", id: h, moduleReference: y, isExport: null });
        }, r.tSImportType = r.tsImportType = function(h, y = null, b = null) {
          return (0, i.default)({ type: "TSImportType", argument: h, qualifier: y, typeParameters: b });
        }, r.tSIndexSignature = r.tsIndexSignature = function(h, y = null) {
          return (0, i.default)({ type: "TSIndexSignature", parameters: h, typeAnnotation: y });
        }, r.tSIndexedAccessType = r.tsIndexedAccessType = function(h, y) {
          return (0, i.default)({ type: "TSIndexedAccessType", objectType: h, indexType: y });
        }, r.tSInferType = r.tsInferType = function(h) {
          return (0, i.default)({ type: "TSInferType", typeParameter: h });
        }, r.tSInstantiationExpression = r.tsInstantiationExpression = function(h, y = null) {
          return (0, i.default)({ type: "TSInstantiationExpression", expression: h, typeParameters: y });
        }, r.tSInterfaceBody = r.tsInterfaceBody = function(h) {
          return (0, i.default)({ type: "TSInterfaceBody", body: h });
        }, r.tSInterfaceDeclaration = r.tsInterfaceDeclaration = function(h, y = null, b = null, E) {
          return (0, i.default)({ type: "TSInterfaceDeclaration", id: h, typeParameters: y, extends: b, body: E });
        }, r.tSIntersectionType = r.tsIntersectionType = function(h) {
          return (0, i.default)({ type: "TSIntersectionType", types: h });
        }, r.tSIntrinsicKeyword = r.tsIntrinsicKeyword = function() {
          return { type: "TSIntrinsicKeyword" };
        }, r.tSLiteralType = r.tsLiteralType = function(h) {
          return (0, i.default)({ type: "TSLiteralType", literal: h });
        }, r.tSMappedType = r.tsMappedType = function(h, y = null, b = null) {
          return (0, i.default)({ type: "TSMappedType", typeParameter: h, typeAnnotation: y, nameType: b });
        }, r.tSMethodSignature = r.tsMethodSignature = function(h, y = null, b, E = null) {
          return (0, i.default)({ type: "TSMethodSignature", key: h, typeParameters: y, parameters: b, typeAnnotation: E, kind: null });
        }, r.tSModuleBlock = r.tsModuleBlock = function(h) {
          return (0, i.default)({ type: "TSModuleBlock", body: h });
        }, r.tSModuleDeclaration = r.tsModuleDeclaration = function(h, y) {
          return (0, i.default)({ type: "TSModuleDeclaration", id: h, body: y });
        }, r.tSNamedTupleMember = r.tsNamedTupleMember = function(h, y, b = !1) {
          return (0, i.default)({ type: "TSNamedTupleMember", label: h, elementType: y, optional: b });
        }, r.tSNamespaceExportDeclaration = r.tsNamespaceExportDeclaration = function(h) {
          return (0, i.default)({ type: "TSNamespaceExportDeclaration", id: h });
        }, r.tSNeverKeyword = r.tsNeverKeyword = function() {
          return { type: "TSNeverKeyword" };
        }, r.tSNonNullExpression = r.tsNonNullExpression = function(h) {
          return (0, i.default)({ type: "TSNonNullExpression", expression: h });
        }, r.tSNullKeyword = r.tsNullKeyword = function() {
          return { type: "TSNullKeyword" };
        }, r.tSNumberKeyword = r.tsNumberKeyword = function() {
          return { type: "TSNumberKeyword" };
        }, r.tSObjectKeyword = r.tsObjectKeyword = function() {
          return { type: "TSObjectKeyword" };
        }, r.tSOptionalType = r.tsOptionalType = function(h) {
          return (0, i.default)({ type: "TSOptionalType", typeAnnotation: h });
        }, r.tSParameterProperty = r.tsParameterProperty = function(h) {
          return (0, i.default)({ type: "TSParameterProperty", parameter: h });
        }, r.tSParenthesizedType = r.tsParenthesizedType = function(h) {
          return (0, i.default)({ type: "TSParenthesizedType", typeAnnotation: h });
        }, r.tSPropertySignature = r.tsPropertySignature = function(h, y = null, b = null) {
          return (0, i.default)({ type: "TSPropertySignature", key: h, typeAnnotation: y, initializer: b, kind: null });
        }, r.tSQualifiedName = r.tsQualifiedName = function(h, y) {
          return (0, i.default)({ type: "TSQualifiedName", left: h, right: y });
        }, r.tSRestType = r.tsRestType = function(h) {
          return (0, i.default)({ type: "TSRestType", typeAnnotation: h });
        }, r.tSSatisfiesExpression = r.tsSatisfiesExpression = function(h, y) {
          return (0, i.default)({ type: "TSSatisfiesExpression", expression: h, typeAnnotation: y });
        }, r.tSStringKeyword = r.tsStringKeyword = function() {
          return { type: "TSStringKeyword" };
        }, r.tSSymbolKeyword = r.tsSymbolKeyword = function() {
          return { type: "TSSymbolKeyword" };
        }, r.tSThisType = r.tsThisType = function() {
          return { type: "TSThisType" };
        }, r.tSTupleType = r.tsTupleType = function(h) {
          return (0, i.default)({ type: "TSTupleType", elementTypes: h });
        }, r.tSTypeAliasDeclaration = r.tsTypeAliasDeclaration = function(h, y = null, b) {
          return (0, i.default)({ type: "TSTypeAliasDeclaration", id: h, typeParameters: y, typeAnnotation: b });
        }, r.tSTypeAnnotation = r.tsTypeAnnotation = function(h) {
          return (0, i.default)({ type: "TSTypeAnnotation", typeAnnotation: h });
        }, r.tSTypeAssertion = r.tsTypeAssertion = function(h, y) {
          return (0, i.default)({ type: "TSTypeAssertion", typeAnnotation: h, expression: y });
        }, r.tSTypeLiteral = r.tsTypeLiteral = function(h) {
          return (0, i.default)({ type: "TSTypeLiteral", members: h });
        }, r.tSTypeOperator = r.tsTypeOperator = function(h) {
          return (0, i.default)({ type: "TSTypeOperator", typeAnnotation: h, operator: null });
        }, r.tSTypeParameter = r.tsTypeParameter = function(h = null, y = null, b) {
          return (0, i.default)({ type: "TSTypeParameter", constraint: h, default: y, name: b });
        }, r.tSTypeParameterDeclaration = r.tsTypeParameterDeclaration = function(h) {
          return (0, i.default)({ type: "TSTypeParameterDeclaration", params: h });
        }, r.tSTypeParameterInstantiation = r.tsTypeParameterInstantiation = function(h) {
          return (0, i.default)({ type: "TSTypeParameterInstantiation", params: h });
        }, r.tSTypePredicate = r.tsTypePredicate = function(h, y = null, b = null) {
          return (0, i.default)({ type: "TSTypePredicate", parameterName: h, typeAnnotation: y, asserts: b });
        }, r.tSTypeQuery = r.tsTypeQuery = function(h, y = null) {
          return (0, i.default)({ type: "TSTypeQuery", exprName: h, typeParameters: y });
        }, r.tSTypeReference = r.tsTypeReference = function(h, y = null) {
          return (0, i.default)({ type: "TSTypeReference", typeName: h, typeParameters: y });
        }, r.tSUndefinedKeyword = r.tsUndefinedKeyword = function() {
          return { type: "TSUndefinedKeyword" };
        }, r.tSUnionType = r.tsUnionType = function(h) {
          return (0, i.default)({ type: "TSUnionType", types: h });
        }, r.tSUnknownKeyword = r.tsUnknownKeyword = function() {
          return { type: "TSUnknownKeyword" };
        }, r.tSVoidKeyword = r.tsVoidKeyword = function() {
          return { type: "TSVoidKeyword" };
        }, r.tupleExpression = function(h = []) {
          return (0, i.default)({ type: "TupleExpression", elements: h });
        }, r.tupleTypeAnnotation = function(h) {
          return (0, i.default)({ type: "TupleTypeAnnotation", types: h });
        }, r.typeAlias = function(h, y = null, b) {
          return (0, i.default)({ type: "TypeAlias", id: h, typeParameters: y, right: b });
        }, r.typeAnnotation = function(h) {
          return (0, i.default)({ type: "TypeAnnotation", typeAnnotation: h });
        }, r.typeCastExpression = function(h, y) {
          return (0, i.default)({ type: "TypeCastExpression", expression: h, typeAnnotation: y });
        }, r.typeParameter = function(h = null, y = null, b = null) {
          return (0, i.default)({ type: "TypeParameter", bound: h, default: y, variance: b, name: null });
        }, r.typeParameterDeclaration = function(h) {
          return (0, i.default)({ type: "TypeParameterDeclaration", params: h });
        }, r.typeParameterInstantiation = function(h) {
          return (0, i.default)({ type: "TypeParameterInstantiation", params: h });
        }, r.typeofTypeAnnotation = function(h) {
          return (0, i.default)({ type: "TypeofTypeAnnotation", argument: h });
        }, r.unaryExpression = function(h, y, b = !0) {
          return (0, i.default)({ type: "UnaryExpression", operator: h, argument: y, prefix: b });
        }, r.unionTypeAnnotation = function(h) {
          return (0, i.default)({ type: "UnionTypeAnnotation", types: h });
        }, r.updateExpression = function(h, y, b = !1) {
          return (0, i.default)({ type: "UpdateExpression", operator: h, argument: y, prefix: b });
        }, r.v8IntrinsicIdentifier = function(h) {
          return (0, i.default)({ type: "V8IntrinsicIdentifier", name: h });
        }, r.variableDeclaration = function(h, y) {
          return (0, i.default)({ type: "VariableDeclaration", kind: h, declarations: y });
        }, r.variableDeclarator = function(h, y = null) {
          return (0, i.default)({ type: "VariableDeclarator", id: h, init: y });
        }, r.variance = function(h) {
          return (0, i.default)({ type: "Variance", kind: h });
        }, r.voidTypeAnnotation = function() {
          return { type: "VoidTypeAnnotation" };
        }, r.whileStatement = function(h, y) {
          return (0, i.default)({ type: "WhileStatement", test: h, body: y });
        }, r.withStatement = function(h, y) {
          return (0, i.default)({ type: "WithStatement", object: h, body: y });
        }, r.yieldExpression = function(h = null, y = !1) {
          return (0, i.default)({ type: "YieldExpression", argument: h, delegate: y });
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/validateNode.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/utils/deprecationWarning.js");
        function d(h) {
          return (0, i.default)({ type: "NumericLiteral", value: h });
        }
        function s(h, y = "") {
          return (0, i.default)({ type: "RegExpLiteral", pattern: h, flags: y });
        }
        function o(h) {
          return (0, i.default)({ type: "RestElement", argument: h });
        }
        function m(h) {
          return (0, i.default)({ type: "SpreadElement", argument: h });
        }
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/generated/uppercase.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), Object.defineProperty(r, "AnyTypeAnnotation", { enumerable: !0, get: function() {
          return i.anyTypeAnnotation;
        } }), Object.defineProperty(r, "ArgumentPlaceholder", { enumerable: !0, get: function() {
          return i.argumentPlaceholder;
        } }), Object.defineProperty(r, "ArrayExpression", { enumerable: !0, get: function() {
          return i.arrayExpression;
        } }), Object.defineProperty(r, "ArrayPattern", { enumerable: !0, get: function() {
          return i.arrayPattern;
        } }), Object.defineProperty(r, "ArrayTypeAnnotation", { enumerable: !0, get: function() {
          return i.arrayTypeAnnotation;
        } }), Object.defineProperty(r, "ArrowFunctionExpression", { enumerable: !0, get: function() {
          return i.arrowFunctionExpression;
        } }), Object.defineProperty(r, "AssignmentExpression", { enumerable: !0, get: function() {
          return i.assignmentExpression;
        } }), Object.defineProperty(r, "AssignmentPattern", { enumerable: !0, get: function() {
          return i.assignmentPattern;
        } }), Object.defineProperty(r, "AwaitExpression", { enumerable: !0, get: function() {
          return i.awaitExpression;
        } }), Object.defineProperty(r, "BigIntLiteral", { enumerable: !0, get: function() {
          return i.bigIntLiteral;
        } }), Object.defineProperty(r, "BinaryExpression", { enumerable: !0, get: function() {
          return i.binaryExpression;
        } }), Object.defineProperty(r, "BindExpression", { enumerable: !0, get: function() {
          return i.bindExpression;
        } }), Object.defineProperty(r, "BlockStatement", { enumerable: !0, get: function() {
          return i.blockStatement;
        } }), Object.defineProperty(r, "BooleanLiteral", { enumerable: !0, get: function() {
          return i.booleanLiteral;
        } }), Object.defineProperty(r, "BooleanLiteralTypeAnnotation", { enumerable: !0, get: function() {
          return i.booleanLiteralTypeAnnotation;
        } }), Object.defineProperty(r, "BooleanTypeAnnotation", { enumerable: !0, get: function() {
          return i.booleanTypeAnnotation;
        } }), Object.defineProperty(r, "BreakStatement", { enumerable: !0, get: function() {
          return i.breakStatement;
        } }), Object.defineProperty(r, "CallExpression", { enumerable: !0, get: function() {
          return i.callExpression;
        } }), Object.defineProperty(r, "CatchClause", { enumerable: !0, get: function() {
          return i.catchClause;
        } }), Object.defineProperty(r, "ClassAccessorProperty", { enumerable: !0, get: function() {
          return i.classAccessorProperty;
        } }), Object.defineProperty(r, "ClassBody", { enumerable: !0, get: function() {
          return i.classBody;
        } }), Object.defineProperty(r, "ClassDeclaration", { enumerable: !0, get: function() {
          return i.classDeclaration;
        } }), Object.defineProperty(r, "ClassExpression", { enumerable: !0, get: function() {
          return i.classExpression;
        } }), Object.defineProperty(r, "ClassImplements", { enumerable: !0, get: function() {
          return i.classImplements;
        } }), Object.defineProperty(r, "ClassMethod", { enumerable: !0, get: function() {
          return i.classMethod;
        } }), Object.defineProperty(r, "ClassPrivateMethod", { enumerable: !0, get: function() {
          return i.classPrivateMethod;
        } }), Object.defineProperty(r, "ClassPrivateProperty", { enumerable: !0, get: function() {
          return i.classPrivateProperty;
        } }), Object.defineProperty(r, "ClassProperty", { enumerable: !0, get: function() {
          return i.classProperty;
        } }), Object.defineProperty(r, "ConditionalExpression", { enumerable: !0, get: function() {
          return i.conditionalExpression;
        } }), Object.defineProperty(r, "ContinueStatement", { enumerable: !0, get: function() {
          return i.continueStatement;
        } }), Object.defineProperty(r, "DebuggerStatement", { enumerable: !0, get: function() {
          return i.debuggerStatement;
        } }), Object.defineProperty(r, "DecimalLiteral", { enumerable: !0, get: function() {
          return i.decimalLiteral;
        } }), Object.defineProperty(r, "DeclareClass", { enumerable: !0, get: function() {
          return i.declareClass;
        } }), Object.defineProperty(r, "DeclareExportAllDeclaration", { enumerable: !0, get: function() {
          return i.declareExportAllDeclaration;
        } }), Object.defineProperty(r, "DeclareExportDeclaration", { enumerable: !0, get: function() {
          return i.declareExportDeclaration;
        } }), Object.defineProperty(r, "DeclareFunction", { enumerable: !0, get: function() {
          return i.declareFunction;
        } }), Object.defineProperty(r, "DeclareInterface", { enumerable: !0, get: function() {
          return i.declareInterface;
        } }), Object.defineProperty(r, "DeclareModule", { enumerable: !0, get: function() {
          return i.declareModule;
        } }), Object.defineProperty(r, "DeclareModuleExports", { enumerable: !0, get: function() {
          return i.declareModuleExports;
        } }), Object.defineProperty(r, "DeclareOpaqueType", { enumerable: !0, get: function() {
          return i.declareOpaqueType;
        } }), Object.defineProperty(r, "DeclareTypeAlias", { enumerable: !0, get: function() {
          return i.declareTypeAlias;
        } }), Object.defineProperty(r, "DeclareVariable", { enumerable: !0, get: function() {
          return i.declareVariable;
        } }), Object.defineProperty(r, "DeclaredPredicate", { enumerable: !0, get: function() {
          return i.declaredPredicate;
        } }), Object.defineProperty(r, "Decorator", { enumerable: !0, get: function() {
          return i.decorator;
        } }), Object.defineProperty(r, "Directive", { enumerable: !0, get: function() {
          return i.directive;
        } }), Object.defineProperty(r, "DirectiveLiteral", { enumerable: !0, get: function() {
          return i.directiveLiteral;
        } }), Object.defineProperty(r, "DoExpression", { enumerable: !0, get: function() {
          return i.doExpression;
        } }), Object.defineProperty(r, "DoWhileStatement", { enumerable: !0, get: function() {
          return i.doWhileStatement;
        } }), Object.defineProperty(r, "EmptyStatement", { enumerable: !0, get: function() {
          return i.emptyStatement;
        } }), Object.defineProperty(r, "EmptyTypeAnnotation", { enumerable: !0, get: function() {
          return i.emptyTypeAnnotation;
        } }), Object.defineProperty(r, "EnumBooleanBody", { enumerable: !0, get: function() {
          return i.enumBooleanBody;
        } }), Object.defineProperty(r, "EnumBooleanMember", { enumerable: !0, get: function() {
          return i.enumBooleanMember;
        } }), Object.defineProperty(r, "EnumDeclaration", { enumerable: !0, get: function() {
          return i.enumDeclaration;
        } }), Object.defineProperty(r, "EnumDefaultedMember", { enumerable: !0, get: function() {
          return i.enumDefaultedMember;
        } }), Object.defineProperty(r, "EnumNumberBody", { enumerable: !0, get: function() {
          return i.enumNumberBody;
        } }), Object.defineProperty(r, "EnumNumberMember", { enumerable: !0, get: function() {
          return i.enumNumberMember;
        } }), Object.defineProperty(r, "EnumStringBody", { enumerable: !0, get: function() {
          return i.enumStringBody;
        } }), Object.defineProperty(r, "EnumStringMember", { enumerable: !0, get: function() {
          return i.enumStringMember;
        } }), Object.defineProperty(r, "EnumSymbolBody", { enumerable: !0, get: function() {
          return i.enumSymbolBody;
        } }), Object.defineProperty(r, "ExistsTypeAnnotation", { enumerable: !0, get: function() {
          return i.existsTypeAnnotation;
        } }), Object.defineProperty(r, "ExportAllDeclaration", { enumerable: !0, get: function() {
          return i.exportAllDeclaration;
        } }), Object.defineProperty(r, "ExportDefaultDeclaration", { enumerable: !0, get: function() {
          return i.exportDefaultDeclaration;
        } }), Object.defineProperty(r, "ExportDefaultSpecifier", { enumerable: !0, get: function() {
          return i.exportDefaultSpecifier;
        } }), Object.defineProperty(r, "ExportNamedDeclaration", { enumerable: !0, get: function() {
          return i.exportNamedDeclaration;
        } }), Object.defineProperty(r, "ExportNamespaceSpecifier", { enumerable: !0, get: function() {
          return i.exportNamespaceSpecifier;
        } }), Object.defineProperty(r, "ExportSpecifier", { enumerable: !0, get: function() {
          return i.exportSpecifier;
        } }), Object.defineProperty(r, "ExpressionStatement", { enumerable: !0, get: function() {
          return i.expressionStatement;
        } }), Object.defineProperty(r, "File", { enumerable: !0, get: function() {
          return i.file;
        } }), Object.defineProperty(r, "ForInStatement", { enumerable: !0, get: function() {
          return i.forInStatement;
        } }), Object.defineProperty(r, "ForOfStatement", { enumerable: !0, get: function() {
          return i.forOfStatement;
        } }), Object.defineProperty(r, "ForStatement", { enumerable: !0, get: function() {
          return i.forStatement;
        } }), Object.defineProperty(r, "FunctionDeclaration", { enumerable: !0, get: function() {
          return i.functionDeclaration;
        } }), Object.defineProperty(r, "FunctionExpression", { enumerable: !0, get: function() {
          return i.functionExpression;
        } }), Object.defineProperty(r, "FunctionTypeAnnotation", { enumerable: !0, get: function() {
          return i.functionTypeAnnotation;
        } }), Object.defineProperty(r, "FunctionTypeParam", { enumerable: !0, get: function() {
          return i.functionTypeParam;
        } }), Object.defineProperty(r, "GenericTypeAnnotation", { enumerable: !0, get: function() {
          return i.genericTypeAnnotation;
        } }), Object.defineProperty(r, "Identifier", { enumerable: !0, get: function() {
          return i.identifier;
        } }), Object.defineProperty(r, "IfStatement", { enumerable: !0, get: function() {
          return i.ifStatement;
        } }), Object.defineProperty(r, "Import", { enumerable: !0, get: function() {
          return i.import;
        } }), Object.defineProperty(r, "ImportAttribute", { enumerable: !0, get: function() {
          return i.importAttribute;
        } }), Object.defineProperty(r, "ImportDeclaration", { enumerable: !0, get: function() {
          return i.importDeclaration;
        } }), Object.defineProperty(r, "ImportDefaultSpecifier", { enumerable: !0, get: function() {
          return i.importDefaultSpecifier;
        } }), Object.defineProperty(r, "ImportNamespaceSpecifier", { enumerable: !0, get: function() {
          return i.importNamespaceSpecifier;
        } }), Object.defineProperty(r, "ImportSpecifier", { enumerable: !0, get: function() {
          return i.importSpecifier;
        } }), Object.defineProperty(r, "IndexedAccessType", { enumerable: !0, get: function() {
          return i.indexedAccessType;
        } }), Object.defineProperty(r, "InferredPredicate", { enumerable: !0, get: function() {
          return i.inferredPredicate;
        } }), Object.defineProperty(r, "InterfaceDeclaration", { enumerable: !0, get: function() {
          return i.interfaceDeclaration;
        } }), Object.defineProperty(r, "InterfaceExtends", { enumerable: !0, get: function() {
          return i.interfaceExtends;
        } }), Object.defineProperty(r, "InterfaceTypeAnnotation", { enumerable: !0, get: function() {
          return i.interfaceTypeAnnotation;
        } }), Object.defineProperty(r, "InterpreterDirective", { enumerable: !0, get: function() {
          return i.interpreterDirective;
        } }), Object.defineProperty(r, "IntersectionTypeAnnotation", { enumerable: !0, get: function() {
          return i.intersectionTypeAnnotation;
        } }), Object.defineProperty(r, "JSXAttribute", { enumerable: !0, get: function() {
          return i.jsxAttribute;
        } }), Object.defineProperty(r, "JSXClosingElement", { enumerable: !0, get: function() {
          return i.jsxClosingElement;
        } }), Object.defineProperty(r, "JSXClosingFragment", { enumerable: !0, get: function() {
          return i.jsxClosingFragment;
        } }), Object.defineProperty(r, "JSXElement", { enumerable: !0, get: function() {
          return i.jsxElement;
        } }), Object.defineProperty(r, "JSXEmptyExpression", { enumerable: !0, get: function() {
          return i.jsxEmptyExpression;
        } }), Object.defineProperty(r, "JSXExpressionContainer", { enumerable: !0, get: function() {
          return i.jsxExpressionContainer;
        } }), Object.defineProperty(r, "JSXFragment", { enumerable: !0, get: function() {
          return i.jsxFragment;
        } }), Object.defineProperty(r, "JSXIdentifier", { enumerable: !0, get: function() {
          return i.jsxIdentifier;
        } }), Object.defineProperty(r, "JSXMemberExpression", { enumerable: !0, get: function() {
          return i.jsxMemberExpression;
        } }), Object.defineProperty(r, "JSXNamespacedName", { enumerable: !0, get: function() {
          return i.jsxNamespacedName;
        } }), Object.defineProperty(r, "JSXOpeningElement", { enumerable: !0, get: function() {
          return i.jsxOpeningElement;
        } }), Object.defineProperty(r, "JSXOpeningFragment", { enumerable: !0, get: function() {
          return i.jsxOpeningFragment;
        } }), Object.defineProperty(r, "JSXSpreadAttribute", { enumerable: !0, get: function() {
          return i.jsxSpreadAttribute;
        } }), Object.defineProperty(r, "JSXSpreadChild", { enumerable: !0, get: function() {
          return i.jsxSpreadChild;
        } }), Object.defineProperty(r, "JSXText", { enumerable: !0, get: function() {
          return i.jsxText;
        } }), Object.defineProperty(r, "LabeledStatement", { enumerable: !0, get: function() {
          return i.labeledStatement;
        } }), Object.defineProperty(r, "LogicalExpression", { enumerable: !0, get: function() {
          return i.logicalExpression;
        } }), Object.defineProperty(r, "MemberExpression", { enumerable: !0, get: function() {
          return i.memberExpression;
        } }), Object.defineProperty(r, "MetaProperty", { enumerable: !0, get: function() {
          return i.metaProperty;
        } }), Object.defineProperty(r, "MixedTypeAnnotation", { enumerable: !0, get: function() {
          return i.mixedTypeAnnotation;
        } }), Object.defineProperty(r, "ModuleExpression", { enumerable: !0, get: function() {
          return i.moduleExpression;
        } }), Object.defineProperty(r, "NewExpression", { enumerable: !0, get: function() {
          return i.newExpression;
        } }), Object.defineProperty(r, "Noop", { enumerable: !0, get: function() {
          return i.noop;
        } }), Object.defineProperty(r, "NullLiteral", { enumerable: !0, get: function() {
          return i.nullLiteral;
        } }), Object.defineProperty(r, "NullLiteralTypeAnnotation", { enumerable: !0, get: function() {
          return i.nullLiteralTypeAnnotation;
        } }), Object.defineProperty(r, "NullableTypeAnnotation", { enumerable: !0, get: function() {
          return i.nullableTypeAnnotation;
        } }), Object.defineProperty(r, "NumberLiteral", { enumerable: !0, get: function() {
          return i.numberLiteral;
        } }), Object.defineProperty(r, "NumberLiteralTypeAnnotation", { enumerable: !0, get: function() {
          return i.numberLiteralTypeAnnotation;
        } }), Object.defineProperty(r, "NumberTypeAnnotation", { enumerable: !0, get: function() {
          return i.numberTypeAnnotation;
        } }), Object.defineProperty(r, "NumericLiteral", { enumerable: !0, get: function() {
          return i.numericLiteral;
        } }), Object.defineProperty(r, "ObjectExpression", { enumerable: !0, get: function() {
          return i.objectExpression;
        } }), Object.defineProperty(r, "ObjectMethod", { enumerable: !0, get: function() {
          return i.objectMethod;
        } }), Object.defineProperty(r, "ObjectPattern", { enumerable: !0, get: function() {
          return i.objectPattern;
        } }), Object.defineProperty(r, "ObjectProperty", { enumerable: !0, get: function() {
          return i.objectProperty;
        } }), Object.defineProperty(r, "ObjectTypeAnnotation", { enumerable: !0, get: function() {
          return i.objectTypeAnnotation;
        } }), Object.defineProperty(r, "ObjectTypeCallProperty", { enumerable: !0, get: function() {
          return i.objectTypeCallProperty;
        } }), Object.defineProperty(r, "ObjectTypeIndexer", { enumerable: !0, get: function() {
          return i.objectTypeIndexer;
        } }), Object.defineProperty(r, "ObjectTypeInternalSlot", { enumerable: !0, get: function() {
          return i.objectTypeInternalSlot;
        } }), Object.defineProperty(r, "ObjectTypeProperty", { enumerable: !0, get: function() {
          return i.objectTypeProperty;
        } }), Object.defineProperty(r, "ObjectTypeSpreadProperty", { enumerable: !0, get: function() {
          return i.objectTypeSpreadProperty;
        } }), Object.defineProperty(r, "OpaqueType", { enumerable: !0, get: function() {
          return i.opaqueType;
        } }), Object.defineProperty(r, "OptionalCallExpression", { enumerable: !0, get: function() {
          return i.optionalCallExpression;
        } }), Object.defineProperty(r, "OptionalIndexedAccessType", { enumerable: !0, get: function() {
          return i.optionalIndexedAccessType;
        } }), Object.defineProperty(r, "OptionalMemberExpression", { enumerable: !0, get: function() {
          return i.optionalMemberExpression;
        } }), Object.defineProperty(r, "ParenthesizedExpression", { enumerable: !0, get: function() {
          return i.parenthesizedExpression;
        } }), Object.defineProperty(r, "PipelineBareFunction", { enumerable: !0, get: function() {
          return i.pipelineBareFunction;
        } }), Object.defineProperty(r, "PipelinePrimaryTopicReference", { enumerable: !0, get: function() {
          return i.pipelinePrimaryTopicReference;
        } }), Object.defineProperty(r, "PipelineTopicExpression", { enumerable: !0, get: function() {
          return i.pipelineTopicExpression;
        } }), Object.defineProperty(r, "Placeholder", { enumerable: !0, get: function() {
          return i.placeholder;
        } }), Object.defineProperty(r, "PrivateName", { enumerable: !0, get: function() {
          return i.privateName;
        } }), Object.defineProperty(r, "Program", { enumerable: !0, get: function() {
          return i.program;
        } }), Object.defineProperty(r, "QualifiedTypeIdentifier", { enumerable: !0, get: function() {
          return i.qualifiedTypeIdentifier;
        } }), Object.defineProperty(r, "RecordExpression", { enumerable: !0, get: function() {
          return i.recordExpression;
        } }), Object.defineProperty(r, "RegExpLiteral", { enumerable: !0, get: function() {
          return i.regExpLiteral;
        } }), Object.defineProperty(r, "RegexLiteral", { enumerable: !0, get: function() {
          return i.regexLiteral;
        } }), Object.defineProperty(r, "RestElement", { enumerable: !0, get: function() {
          return i.restElement;
        } }), Object.defineProperty(r, "RestProperty", { enumerable: !0, get: function() {
          return i.restProperty;
        } }), Object.defineProperty(r, "ReturnStatement", { enumerable: !0, get: function() {
          return i.returnStatement;
        } }), Object.defineProperty(r, "SequenceExpression", { enumerable: !0, get: function() {
          return i.sequenceExpression;
        } }), Object.defineProperty(r, "SpreadElement", { enumerable: !0, get: function() {
          return i.spreadElement;
        } }), Object.defineProperty(r, "SpreadProperty", { enumerable: !0, get: function() {
          return i.spreadProperty;
        } }), Object.defineProperty(r, "StaticBlock", { enumerable: !0, get: function() {
          return i.staticBlock;
        } }), Object.defineProperty(r, "StringLiteral", { enumerable: !0, get: function() {
          return i.stringLiteral;
        } }), Object.defineProperty(r, "StringLiteralTypeAnnotation", { enumerable: !0, get: function() {
          return i.stringLiteralTypeAnnotation;
        } }), Object.defineProperty(r, "StringTypeAnnotation", { enumerable: !0, get: function() {
          return i.stringTypeAnnotation;
        } }), Object.defineProperty(r, "Super", { enumerable: !0, get: function() {
          return i.super;
        } }), Object.defineProperty(r, "SwitchCase", { enumerable: !0, get: function() {
          return i.switchCase;
        } }), Object.defineProperty(r, "SwitchStatement", { enumerable: !0, get: function() {
          return i.switchStatement;
        } }), Object.defineProperty(r, "SymbolTypeAnnotation", { enumerable: !0, get: function() {
          return i.symbolTypeAnnotation;
        } }), Object.defineProperty(r, "TSAnyKeyword", { enumerable: !0, get: function() {
          return i.tsAnyKeyword;
        } }), Object.defineProperty(r, "TSArrayType", { enumerable: !0, get: function() {
          return i.tsArrayType;
        } }), Object.defineProperty(r, "TSAsExpression", { enumerable: !0, get: function() {
          return i.tsAsExpression;
        } }), Object.defineProperty(r, "TSBigIntKeyword", { enumerable: !0, get: function() {
          return i.tsBigIntKeyword;
        } }), Object.defineProperty(r, "TSBooleanKeyword", { enumerable: !0, get: function() {
          return i.tsBooleanKeyword;
        } }), Object.defineProperty(r, "TSCallSignatureDeclaration", { enumerable: !0, get: function() {
          return i.tsCallSignatureDeclaration;
        } }), Object.defineProperty(r, "TSConditionalType", { enumerable: !0, get: function() {
          return i.tsConditionalType;
        } }), Object.defineProperty(r, "TSConstructSignatureDeclaration", { enumerable: !0, get: function() {
          return i.tsConstructSignatureDeclaration;
        } }), Object.defineProperty(r, "TSConstructorType", { enumerable: !0, get: function() {
          return i.tsConstructorType;
        } }), Object.defineProperty(r, "TSDeclareFunction", { enumerable: !0, get: function() {
          return i.tsDeclareFunction;
        } }), Object.defineProperty(r, "TSDeclareMethod", { enumerable: !0, get: function() {
          return i.tsDeclareMethod;
        } }), Object.defineProperty(r, "TSEnumDeclaration", { enumerable: !0, get: function() {
          return i.tsEnumDeclaration;
        } }), Object.defineProperty(r, "TSEnumMember", { enumerable: !0, get: function() {
          return i.tsEnumMember;
        } }), Object.defineProperty(r, "TSExportAssignment", { enumerable: !0, get: function() {
          return i.tsExportAssignment;
        } }), Object.defineProperty(r, "TSExpressionWithTypeArguments", { enumerable: !0, get: function() {
          return i.tsExpressionWithTypeArguments;
        } }), Object.defineProperty(r, "TSExternalModuleReference", { enumerable: !0, get: function() {
          return i.tsExternalModuleReference;
        } }), Object.defineProperty(r, "TSFunctionType", { enumerable: !0, get: function() {
          return i.tsFunctionType;
        } }), Object.defineProperty(r, "TSImportEqualsDeclaration", { enumerable: !0, get: function() {
          return i.tsImportEqualsDeclaration;
        } }), Object.defineProperty(r, "TSImportType", { enumerable: !0, get: function() {
          return i.tsImportType;
        } }), Object.defineProperty(r, "TSIndexSignature", { enumerable: !0, get: function() {
          return i.tsIndexSignature;
        } }), Object.defineProperty(r, "TSIndexedAccessType", { enumerable: !0, get: function() {
          return i.tsIndexedAccessType;
        } }), Object.defineProperty(r, "TSInferType", { enumerable: !0, get: function() {
          return i.tsInferType;
        } }), Object.defineProperty(r, "TSInstantiationExpression", { enumerable: !0, get: function() {
          return i.tsInstantiationExpression;
        } }), Object.defineProperty(r, "TSInterfaceBody", { enumerable: !0, get: function() {
          return i.tsInterfaceBody;
        } }), Object.defineProperty(r, "TSInterfaceDeclaration", { enumerable: !0, get: function() {
          return i.tsInterfaceDeclaration;
        } }), Object.defineProperty(r, "TSIntersectionType", { enumerable: !0, get: function() {
          return i.tsIntersectionType;
        } }), Object.defineProperty(r, "TSIntrinsicKeyword", { enumerable: !0, get: function() {
          return i.tsIntrinsicKeyword;
        } }), Object.defineProperty(r, "TSLiteralType", { enumerable: !0, get: function() {
          return i.tsLiteralType;
        } }), Object.defineProperty(r, "TSMappedType", { enumerable: !0, get: function() {
          return i.tsMappedType;
        } }), Object.defineProperty(r, "TSMethodSignature", { enumerable: !0, get: function() {
          return i.tsMethodSignature;
        } }), Object.defineProperty(r, "TSModuleBlock", { enumerable: !0, get: function() {
          return i.tsModuleBlock;
        } }), Object.defineProperty(r, "TSModuleDeclaration", { enumerable: !0, get: function() {
          return i.tsModuleDeclaration;
        } }), Object.defineProperty(r, "TSNamedTupleMember", { enumerable: !0, get: function() {
          return i.tsNamedTupleMember;
        } }), Object.defineProperty(r, "TSNamespaceExportDeclaration", { enumerable: !0, get: function() {
          return i.tsNamespaceExportDeclaration;
        } }), Object.defineProperty(r, "TSNeverKeyword", { enumerable: !0, get: function() {
          return i.tsNeverKeyword;
        } }), Object.defineProperty(r, "TSNonNullExpression", { enumerable: !0, get: function() {
          return i.tsNonNullExpression;
        } }), Object.defineProperty(r, "TSNullKeyword", { enumerable: !0, get: function() {
          return i.tsNullKeyword;
        } }), Object.defineProperty(r, "TSNumberKeyword", { enumerable: !0, get: function() {
          return i.tsNumberKeyword;
        } }), Object.defineProperty(r, "TSObjectKeyword", { enumerable: !0, get: function() {
          return i.tsObjectKeyword;
        } }), Object.defineProperty(r, "TSOptionalType", { enumerable: !0, get: function() {
          return i.tsOptionalType;
        } }), Object.defineProperty(r, "TSParameterProperty", { enumerable: !0, get: function() {
          return i.tsParameterProperty;
        } }), Object.defineProperty(r, "TSParenthesizedType", { enumerable: !0, get: function() {
          return i.tsParenthesizedType;
        } }), Object.defineProperty(r, "TSPropertySignature", { enumerable: !0, get: function() {
          return i.tsPropertySignature;
        } }), Object.defineProperty(r, "TSQualifiedName", { enumerable: !0, get: function() {
          return i.tsQualifiedName;
        } }), Object.defineProperty(r, "TSRestType", { enumerable: !0, get: function() {
          return i.tsRestType;
        } }), Object.defineProperty(r, "TSSatisfiesExpression", { enumerable: !0, get: function() {
          return i.tsSatisfiesExpression;
        } }), Object.defineProperty(r, "TSStringKeyword", { enumerable: !0, get: function() {
          return i.tsStringKeyword;
        } }), Object.defineProperty(r, "TSSymbolKeyword", { enumerable: !0, get: function() {
          return i.tsSymbolKeyword;
        } }), Object.defineProperty(r, "TSThisType", { enumerable: !0, get: function() {
          return i.tsThisType;
        } }), Object.defineProperty(r, "TSTupleType", { enumerable: !0, get: function() {
          return i.tsTupleType;
        } }), Object.defineProperty(r, "TSTypeAliasDeclaration", { enumerable: !0, get: function() {
          return i.tsTypeAliasDeclaration;
        } }), Object.defineProperty(r, "TSTypeAnnotation", { enumerable: !0, get: function() {
          return i.tsTypeAnnotation;
        } }), Object.defineProperty(r, "TSTypeAssertion", { enumerable: !0, get: function() {
          return i.tsTypeAssertion;
        } }), Object.defineProperty(r, "TSTypeLiteral", { enumerable: !0, get: function() {
          return i.tsTypeLiteral;
        } }), Object.defineProperty(r, "TSTypeOperator", { enumerable: !0, get: function() {
          return i.tsTypeOperator;
        } }), Object.defineProperty(r, "TSTypeParameter", { enumerable: !0, get: function() {
          return i.tsTypeParameter;
        } }), Object.defineProperty(r, "TSTypeParameterDeclaration", { enumerable: !0, get: function() {
          return i.tsTypeParameterDeclaration;
        } }), Object.defineProperty(r, "TSTypeParameterInstantiation", { enumerable: !0, get: function() {
          return i.tsTypeParameterInstantiation;
        } }), Object.defineProperty(r, "TSTypePredicate", { enumerable: !0, get: function() {
          return i.tsTypePredicate;
        } }), Object.defineProperty(r, "TSTypeQuery", { enumerable: !0, get: function() {
          return i.tsTypeQuery;
        } }), Object.defineProperty(r, "TSTypeReference", { enumerable: !0, get: function() {
          return i.tsTypeReference;
        } }), Object.defineProperty(r, "TSUndefinedKeyword", { enumerable: !0, get: function() {
          return i.tsUndefinedKeyword;
        } }), Object.defineProperty(r, "TSUnionType", { enumerable: !0, get: function() {
          return i.tsUnionType;
        } }), Object.defineProperty(r, "TSUnknownKeyword", { enumerable: !0, get: function() {
          return i.tsUnknownKeyword;
        } }), Object.defineProperty(r, "TSVoidKeyword", { enumerable: !0, get: function() {
          return i.tsVoidKeyword;
        } }), Object.defineProperty(r, "TaggedTemplateExpression", { enumerable: !0, get: function() {
          return i.taggedTemplateExpression;
        } }), Object.defineProperty(r, "TemplateElement", { enumerable: !0, get: function() {
          return i.templateElement;
        } }), Object.defineProperty(r, "TemplateLiteral", { enumerable: !0, get: function() {
          return i.templateLiteral;
        } }), Object.defineProperty(r, "ThisExpression", { enumerable: !0, get: function() {
          return i.thisExpression;
        } }), Object.defineProperty(r, "ThisTypeAnnotation", { enumerable: !0, get: function() {
          return i.thisTypeAnnotation;
        } }), Object.defineProperty(r, "ThrowStatement", { enumerable: !0, get: function() {
          return i.throwStatement;
        } }), Object.defineProperty(r, "TopicReference", { enumerable: !0, get: function() {
          return i.topicReference;
        } }), Object.defineProperty(r, "TryStatement", { enumerable: !0, get: function() {
          return i.tryStatement;
        } }), Object.defineProperty(r, "TupleExpression", { enumerable: !0, get: function() {
          return i.tupleExpression;
        } }), Object.defineProperty(r, "TupleTypeAnnotation", { enumerable: !0, get: function() {
          return i.tupleTypeAnnotation;
        } }), Object.defineProperty(r, "TypeAlias", { enumerable: !0, get: function() {
          return i.typeAlias;
        } }), Object.defineProperty(r, "TypeAnnotation", { enumerable: !0, get: function() {
          return i.typeAnnotation;
        } }), Object.defineProperty(r, "TypeCastExpression", { enumerable: !0, get: function() {
          return i.typeCastExpression;
        } }), Object.defineProperty(r, "TypeParameter", { enumerable: !0, get: function() {
          return i.typeParameter;
        } }), Object.defineProperty(r, "TypeParameterDeclaration", { enumerable: !0, get: function() {
          return i.typeParameterDeclaration;
        } }), Object.defineProperty(r, "TypeParameterInstantiation", { enumerable: !0, get: function() {
          return i.typeParameterInstantiation;
        } }), Object.defineProperty(r, "TypeofTypeAnnotation", { enumerable: !0, get: function() {
          return i.typeofTypeAnnotation;
        } }), Object.defineProperty(r, "UnaryExpression", { enumerable: !0, get: function() {
          return i.unaryExpression;
        } }), Object.defineProperty(r, "UnionTypeAnnotation", { enumerable: !0, get: function() {
          return i.unionTypeAnnotation;
        } }), Object.defineProperty(r, "UpdateExpression", { enumerable: !0, get: function() {
          return i.updateExpression;
        } }), Object.defineProperty(r, "V8IntrinsicIdentifier", { enumerable: !0, get: function() {
          return i.v8IntrinsicIdentifier;
        } }), Object.defineProperty(r, "VariableDeclaration", { enumerable: !0, get: function() {
          return i.variableDeclaration;
        } }), Object.defineProperty(r, "VariableDeclarator", { enumerable: !0, get: function() {
          return i.variableDeclarator;
        } }), Object.defineProperty(r, "Variance", { enumerable: !0, get: function() {
          return i.variance;
        } }), Object.defineProperty(r, "VoidTypeAnnotation", { enumerable: !0, get: function() {
          return i.voidTypeAnnotation;
        } }), Object.defineProperty(r, "WhileStatement", { enumerable: !0, get: function() {
          return i.whileStatement;
        } }), Object.defineProperty(r, "WithStatement", { enumerable: !0, get: function() {
          return i.withStatement;
        } }), Object.defineProperty(r, "YieldExpression", { enumerable: !0, get: function() {
          return i.yieldExpression;
        } });
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/react/buildChildren.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(d) {
          const s = [];
          for (let o = 0; o < d.children.length; o++) {
            let m = d.children[o];
            (0, i.isJSXText)(m) ? (0, f.default)(m, s) : ((0, i.isJSXExpressionContainer)(m) && (m = m.expression), (0, i.isJSXEmptyExpression)(m) || s.push(m));
          }
          return s;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(s) {
          const o = s.map((h) => (0, d.isTSTypeAnnotation)(h) ? h.typeAnnotation : h), m = (0, f.default)(o);
          return m.length === 1 ? m[0] : (0, i.tsUnionType)(m);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/generated/index.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js"), d = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/validateNode.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(d) {
          const s = f.BUILDER_KEYS[d.type];
          for (const o of s)
            (0, i.default)(d, o, d[o]);
          return d;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/validate.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/clone/clone.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f) {
          return (0, i.default)(f, !1);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/clone/cloneDeep.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f) {
          return (0, i.default)(f);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f) {
          return (0, i.default)(f, !0, !0);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/clone/cloneNode.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(y, b = !0, E = !1) {
          return m(y, b, E, /* @__PURE__ */ new Map());
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/index.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js");
        const d = Function.call.bind(Object.prototype.hasOwnProperty);
        function s(y, b, E, S) {
          return y && typeof y.type == "string" ? m(y, b, E, S) : y;
        }
        function o(y, b, E, S) {
          return Array.isArray(y) ? y.map((g) => s(g, b, E, S)) : s(y, b, E, S);
        }
        function m(y, b = !0, E = !1, S) {
          if (!y)
            return y;
          const { type: g } = y, P = { type: y.type };
          if ((0, f.isIdentifier)(y))
            P.name = y.name, d(y, "optional") && typeof y.optional == "boolean" && (P.optional = y.optional), d(y, "typeAnnotation") && (P.typeAnnotation = b ? o(y.typeAnnotation, !0, E, S) : y.typeAnnotation);
          else {
            if (!d(i.NODE_FIELDS, g))
              throw new Error(`Unknown node type: "${g}"`);
            for (const R of Object.keys(i.NODE_FIELDS[g]))
              d(y, R) && (P[R] = b ? (0, f.isFile)(y) && R === "comments" ? h(y.comments, b, E, S) : o(y[R], !0, E, S) : y[R]);
          }
          return d(y, "loc") && (P.loc = E ? null : y.loc), d(y, "leadingComments") && (P.leadingComments = h(y.leadingComments, b, E, S)), d(y, "innerComments") && (P.innerComments = h(y.innerComments, b, E, S)), d(y, "trailingComments") && (P.trailingComments = h(y.trailingComments, b, E, S)), d(y, "extra") && (P.extra = Object.assign({}, y.extra)), P;
        }
        function h(y, b, E, S) {
          return y && b ? y.map((g) => {
            const P = S.get(g);
            if (P)
              return P;
            const { type: R, value: N, loc: C } = g, I = { type: R, value: N, loc: C };
            return E && (I.loc = null), S.set(g, I), I;
          }) : y;
        }
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f) {
          return (0, i.default)(f, !1, !0);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/comments/addComment.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f, d, s, o) {
          return (0, i.default)(f, d, [{ type: o ? "CommentLine" : "CommentBlock", value: s }]);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/comments/addComments.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/comments/addComments.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(l, i, f) {
          if (!f || !l)
            return l;
          const d = `${i}Comments`;
          return l[d] ? i === "leading" ? l[d] = f.concat(l[d]) : l[d].push(...f) : l[d] = f, l;
        };
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/comments/inheritInnerComments.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f, d) {
          (0, i.default)("innerComments", f, d);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/utils/inherit.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/comments/inheritLeadingComments.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f, d) {
          (0, i.default)("leadingComments", f, d);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/utils/inherit.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/comments/inheritTrailingComments.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f, d) {
          (0, i.default)("trailingComments", f, d);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/utils/inherit.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/comments/inheritsComments.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(s, o) {
          return (0, i.default)(s, o), (0, f.default)(s, o), (0, d.default)(s, o), s;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/comments/inheritTrailingComments.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/comments/inheritLeadingComments.js"), d = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/comments/inheritInnerComments.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/comments/removeComments.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f) {
          return i.COMMENT_KEYS.forEach((d) => {
            f[d] = null;
          }), f;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/constants/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/constants/generated/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.WHILE_TYPES = r.USERWHITESPACABLE_TYPES = r.UNARYLIKE_TYPES = r.TYPESCRIPT_TYPES = r.TSTYPE_TYPES = r.TSTYPEELEMENT_TYPES = r.TSENTITYNAME_TYPES = r.TSBASETYPE_TYPES = r.TERMINATORLESS_TYPES = r.STATEMENT_TYPES = r.STANDARDIZED_TYPES = r.SCOPABLE_TYPES = r.PUREISH_TYPES = r.PROPERTY_TYPES = r.PRIVATE_TYPES = r.PATTERN_TYPES = r.PATTERNLIKE_TYPES = r.OBJECTMEMBER_TYPES = r.MODULESPECIFIER_TYPES = r.MODULEDECLARATION_TYPES = r.MISCELLANEOUS_TYPES = r.METHOD_TYPES = r.LVAL_TYPES = r.LOOP_TYPES = r.LITERAL_TYPES = r.JSX_TYPES = r.IMPORTOREXPORTDECLARATION_TYPES = r.IMMUTABLE_TYPES = r.FUNCTION_TYPES = r.FUNCTIONPARENT_TYPES = r.FOR_TYPES = r.FORXSTATEMENT_TYPES = r.FLOW_TYPES = r.FLOWTYPE_TYPES = r.FLOWPREDICATE_TYPES = r.FLOWDECLARATION_TYPES = r.FLOWBASEANNOTATION_TYPES = r.EXPRESSION_TYPES = r.EXPRESSIONWRAPPER_TYPES = r.EXPORTDECLARATION_TYPES = r.ENUMMEMBER_TYPES = r.ENUMBODY_TYPES = r.DECLARATION_TYPES = r.CONDITIONAL_TYPES = r.COMPLETIONSTATEMENT_TYPES = r.CLASS_TYPES = r.BLOCK_TYPES = r.BLOCKPARENT_TYPES = r.BINARY_TYPES = r.ACCESSOR_TYPES = void 0;
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/index.js");
        const f = i.FLIPPED_ALIAS_KEYS.Standardized;
        r.STANDARDIZED_TYPES = f;
        const d = i.FLIPPED_ALIAS_KEYS.Expression;
        r.EXPRESSION_TYPES = d;
        const s = i.FLIPPED_ALIAS_KEYS.Binary;
        r.BINARY_TYPES = s;
        const o = i.FLIPPED_ALIAS_KEYS.Scopable;
        r.SCOPABLE_TYPES = o;
        const m = i.FLIPPED_ALIAS_KEYS.BlockParent;
        r.BLOCKPARENT_TYPES = m;
        const h = i.FLIPPED_ALIAS_KEYS.Block;
        r.BLOCK_TYPES = h;
        const y = i.FLIPPED_ALIAS_KEYS.Statement;
        r.STATEMENT_TYPES = y;
        const b = i.FLIPPED_ALIAS_KEYS.Terminatorless;
        r.TERMINATORLESS_TYPES = b;
        const E = i.FLIPPED_ALIAS_KEYS.CompletionStatement;
        r.COMPLETIONSTATEMENT_TYPES = E;
        const S = i.FLIPPED_ALIAS_KEYS.Conditional;
        r.CONDITIONAL_TYPES = S;
        const g = i.FLIPPED_ALIAS_KEYS.Loop;
        r.LOOP_TYPES = g;
        const P = i.FLIPPED_ALIAS_KEYS.While;
        r.WHILE_TYPES = P;
        const R = i.FLIPPED_ALIAS_KEYS.ExpressionWrapper;
        r.EXPRESSIONWRAPPER_TYPES = R;
        const N = i.FLIPPED_ALIAS_KEYS.For;
        r.FOR_TYPES = N;
        const C = i.FLIPPED_ALIAS_KEYS.ForXStatement;
        r.FORXSTATEMENT_TYPES = C;
        const I = i.FLIPPED_ALIAS_KEYS.Function;
        r.FUNCTION_TYPES = I;
        const D = i.FLIPPED_ALIAS_KEYS.FunctionParent;
        r.FUNCTIONPARENT_TYPES = D;
        const j = i.FLIPPED_ALIAS_KEYS.Pureish;
        r.PUREISH_TYPES = j;
        const F = i.FLIPPED_ALIAS_KEYS.Declaration;
        r.DECLARATION_TYPES = F;
        const _ = i.FLIPPED_ALIAS_KEYS.PatternLike;
        r.PATTERNLIKE_TYPES = _;
        const T = i.FLIPPED_ALIAS_KEYS.LVal;
        r.LVAL_TYPES = T;
        const v = i.FLIPPED_ALIAS_KEYS.TSEntityName;
        r.TSENTITYNAME_TYPES = v;
        const w = i.FLIPPED_ALIAS_KEYS.Literal;
        r.LITERAL_TYPES = w;
        const O = i.FLIPPED_ALIAS_KEYS.Immutable;
        r.IMMUTABLE_TYPES = O;
        const G = i.FLIPPED_ALIAS_KEYS.UserWhitespacable;
        r.USERWHITESPACABLE_TYPES = G;
        const W = i.FLIPPED_ALIAS_KEYS.Method;
        r.METHOD_TYPES = W;
        const U = i.FLIPPED_ALIAS_KEYS.ObjectMember;
        r.OBJECTMEMBER_TYPES = U;
        const M = i.FLIPPED_ALIAS_KEYS.Property;
        r.PROPERTY_TYPES = M;
        const B = i.FLIPPED_ALIAS_KEYS.UnaryLike;
        r.UNARYLIKE_TYPES = B;
        const k = i.FLIPPED_ALIAS_KEYS.Pattern;
        r.PATTERN_TYPES = k;
        const K = i.FLIPPED_ALIAS_KEYS.Class;
        r.CLASS_TYPES = K;
        const te = i.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration;
        r.IMPORTOREXPORTDECLARATION_TYPES = te;
        const z = i.FLIPPED_ALIAS_KEYS.ExportDeclaration;
        r.EXPORTDECLARATION_TYPES = z;
        const q = i.FLIPPED_ALIAS_KEYS.ModuleSpecifier;
        r.MODULESPECIFIER_TYPES = q;
        const $ = i.FLIPPED_ALIAS_KEYS.Accessor;
        r.ACCESSOR_TYPES = $;
        const Y = i.FLIPPED_ALIAS_KEYS.Private;
        r.PRIVATE_TYPES = Y;
        const H = i.FLIPPED_ALIAS_KEYS.Flow;
        r.FLOW_TYPES = H;
        const Q = i.FLIPPED_ALIAS_KEYS.FlowType;
        r.FLOWTYPE_TYPES = Q;
        const X = i.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;
        r.FLOWBASEANNOTATION_TYPES = X;
        const ne = i.FLIPPED_ALIAS_KEYS.FlowDeclaration;
        r.FLOWDECLARATION_TYPES = ne;
        const ye = i.FLIPPED_ALIAS_KEYS.FlowPredicate;
        r.FLOWPREDICATE_TYPES = ye;
        const ve = i.FLIPPED_ALIAS_KEYS.EnumBody;
        r.ENUMBODY_TYPES = ve;
        const de = i.FLIPPED_ALIAS_KEYS.EnumMember;
        r.ENUMMEMBER_TYPES = de;
        const oe = i.FLIPPED_ALIAS_KEYS.JSX;
        r.JSX_TYPES = oe;
        const re = i.FLIPPED_ALIAS_KEYS.Miscellaneous;
        r.MISCELLANEOUS_TYPES = re;
        const ae = i.FLIPPED_ALIAS_KEYS.TypeScript;
        r.TYPESCRIPT_TYPES = ae;
        const le = i.FLIPPED_ALIAS_KEYS.TSTypeElement;
        r.TSTYPEELEMENT_TYPES = le;
        const ue = i.FLIPPED_ALIAS_KEYS.TSType;
        r.TSTYPE_TYPES = ue;
        const ie = i.FLIPPED_ALIAS_KEYS.TSBaseType;
        r.TSBASETYPE_TYPES = ie;
        const we = te;
        r.MODULEDECLARATION_TYPES = we;
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/constants/index.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.UPDATE_OPERATORS = r.UNARY_OPERATORS = r.STRING_UNARY_OPERATORS = r.STATEMENT_OR_BLOCK_KEYS = r.NUMBER_UNARY_OPERATORS = r.NUMBER_BINARY_OPERATORS = r.NOT_LOCAL_BINDING = r.LOGICAL_OPERATORS = r.INHERIT_KEYS = r.FOR_INIT_KEYS = r.FLATTENABLE_KEYS = r.EQUALITY_BINARY_OPERATORS = r.COMPARISON_BINARY_OPERATORS = r.COMMENT_KEYS = r.BOOLEAN_UNARY_OPERATORS = r.BOOLEAN_NUMBER_BINARY_OPERATORS = r.BOOLEAN_BINARY_OPERATORS = r.BLOCK_SCOPED_SYMBOL = r.BINARY_OPERATORS = r.ASSIGNMENT_OPERATORS = void 0, r.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], r.FLATTENABLE_KEYS = ["body", "expressions"], r.FOR_INIT_KEYS = ["left", "init"], r.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
        const l = ["||", "&&", "??"];
        r.LOGICAL_OPERATORS = l, r.UPDATE_OPERATORS = ["++", "--"];
        const i = [">", "<", ">=", "<="];
        r.BOOLEAN_NUMBER_BINARY_OPERATORS = i;
        const f = ["==", "===", "!=", "!=="];
        r.EQUALITY_BINARY_OPERATORS = f;
        const d = [...f, "in", "instanceof"];
        r.COMPARISON_BINARY_OPERATORS = d;
        const s = [...d, ...i];
        r.BOOLEAN_BINARY_OPERATORS = s;
        const o = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
        r.NUMBER_BINARY_OPERATORS = o;
        const m = ["+", ...o, ...s, "|>"];
        r.BINARY_OPERATORS = m;
        const h = ["=", "+=", ...o.map((R) => R + "="), ...l.map((R) => R + "=")];
        r.ASSIGNMENT_OPERATORS = h;
        const y = ["delete", "!"];
        r.BOOLEAN_UNARY_OPERATORS = y;
        const b = ["+", "-", "~"];
        r.NUMBER_UNARY_OPERATORS = b;
        const E = ["typeof"];
        r.STRING_UNARY_OPERATORS = E;
        const S = ["void", "throw", ...y, ...b, ...E];
        r.UNARY_OPERATORS = S, r.INHERIT_KEYS = { optional: ["typeAnnotation", "typeParameters", "returnType"], force: ["start", "loc", "end"] };
        const g = Symbol.for("var used to be block scoped");
        r.BLOCK_SCOPED_SYMBOL = g;
        const P = Symbol.for("should not be considered a local binding");
        r.NOT_LOCAL_BINDING = P;
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/ensureBlock.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f, d = "body") {
          const s = (0, i.default)(f[d], f);
          return f[d] = s, s;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/toBlock.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function o(m, h, y) {
          const b = [];
          let E = !0;
          for (const S of m)
            if ((0, f.isEmptyStatement)(S) || (E = !1), (0, f.isExpression)(S))
              b.push(S);
            else if ((0, f.isExpressionStatement)(S))
              b.push(S.expression);
            else if ((0, f.isVariableDeclaration)(S)) {
              if (S.kind !== "var")
                return;
              for (const g of S.declarations) {
                const P = (0, i.default)(g);
                for (const R of Object.keys(P))
                  y.push({ kind: S.kind, id: (0, s.default)(P[R]) });
                g.init && b.push((0, d.assignmentExpression)("=", g.id, g.init));
              }
              E = !0;
            } else if ((0, f.isIfStatement)(S)) {
              const g = S.consequent ? o([S.consequent], h, y) : h.buildUndefinedNode(), P = S.alternate ? o([S.alternate], h, y) : h.buildUndefinedNode();
              if (!g || !P)
                return;
              b.push((0, d.conditionalExpression)(S.test, g, P));
            } else if ((0, f.isBlockStatement)(S)) {
              const g = o(S.body, h, y);
              if (!g)
                return;
              b.push(g);
            } else {
              if (!(0, f.isEmptyStatement)(S))
                return;
              m.indexOf(S) === 0 && (E = !0);
            }
          return E && b.push(h.buildUndefinedNode()), b.length === 1 ? b[0] : (0, d.sequenceExpression)(b);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js"), d = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/generated/index.js"), s = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f) {
          return (f = (0, i.default)(f)) !== "eval" && f !== "arguments" || (f = "_" + f), f;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/toIdentifier.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/toBlock.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(d, s) {
          if ((0, i.isBlockStatement)(d))
            return d;
          let o = [];
          return (0, i.isEmptyStatement)(d) ? o = [] : ((0, i.isStatement)(d) || (d = (0, i.isFunction)(s) ? (0, f.returnStatement)(d) : (0, f.expressionStatement)(d)), o = [d]), (0, f.blockStatement)(o);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/toComputedKey.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(d, s = d.key || d.property) {
          return !d.computed && (0, i.isIdentifier)(s) && (s = (0, f.stringLiteral)(s.name)), s;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/toExpression.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js"), f = function(d) {
          if ((0, i.isExpressionStatement)(d) && (d = d.expression), (0, i.isExpression)(d))
            return d;
          if ((0, i.isClass)(d) ? d.type = "ClassExpression" : (0, i.isFunction)(d) && (d.type = "FunctionExpression"), !(0, i.isExpression)(d))
            throw new Error(`cannot turn ${d.type} to an expression`);
          return d;
        };
        r.default = f;
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/toIdentifier.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(d) {
          d += "";
          let s = "";
          for (const o of d)
            s += (0, f.isIdentifierChar)(o.codePointAt(0)) ? o : "-";
          return s = s.replace(/^[-0-9]+/, ""), s = s.replace(/[-\s]+(.)?/g, function(o, m) {
            return m ? m.toUpperCase() : "";
          }), (0, i.default)(s) || (s = `_${s}`), s || "_";
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isValidIdentifier.js"), f = l("./node_modules/.pnpm/@babel+helper-validator-identifier@7.22.15/node_modules/@babel/helper-validator-identifier/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/toKeyAlias.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = s;
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/clone/cloneNode.js"), d = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js");
        function s(o, m = o.key) {
          let h;
          return o.kind === "method" ? s.increment() + "" : (h = (0, i.isIdentifier)(m) ? m.name : (0, i.isStringLiteral)(m) ? JSON.stringify(m.value) : JSON.stringify((0, d.default)((0, f.default)(m))), o.computed && (h = `[${h}]`), o.static && (h = `static:${h}`), h);
        }
        s.uid = 0, s.increment = function() {
          return s.uid >= Number.MAX_SAFE_INTEGER ? s.uid = 0 : s.uid++;
        };
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/toSequenceExpression.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f, d) {
          if (f == null || !f.length)
            return;
          const s = [], o = (0, i.default)(f, d, s);
          if (o) {
            for (const m of s)
              d.push(m);
            return o;
          }
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/toStatement.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/generated/index.js"), d = function(s, o) {
          if ((0, i.isStatement)(s))
            return s;
          let m, h = !1;
          if ((0, i.isClass)(s))
            h = !0, m = "ClassDeclaration";
          else if ((0, i.isFunction)(s))
            h = !0, m = "FunctionDeclaration";
          else if ((0, i.isAssignmentExpression)(s))
            return (0, f.expressionStatement)(s);
          if (h && !s.id && (m = !1), !m) {
            if (o)
              return !1;
            throw new Error(`cannot turn ${s.type} to a statement`);
          }
          return s.type = m, s;
        };
        r.default = d;
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/valueToNode.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isValidIdentifier.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/generated/index.js"), d = function o(m) {
          if (m === void 0)
            return (0, f.identifier)("undefined");
          if (m === !0 || m === !1)
            return (0, f.booleanLiteral)(m);
          if (m === null)
            return (0, f.nullLiteral)();
          if (typeof m == "string")
            return (0, f.stringLiteral)(m);
          if (typeof m == "number") {
            let h;
            if (Number.isFinite(m))
              h = (0, f.numericLiteral)(Math.abs(m));
            else {
              let y;
              y = Number.isNaN(m) ? (0, f.numericLiteral)(0) : (0, f.numericLiteral)(1), h = (0, f.binaryExpression)("/", y, (0, f.numericLiteral)(0));
            }
            return (m < 0 || Object.is(m, -0)) && (h = (0, f.unaryExpression)("-", h)), h;
          }
          if (function(h) {
            return s(h) === "[object RegExp]";
          }(m)) {
            const h = m.source, y = m.toString().match(/\/([a-z]+|)$/)[1];
            return (0, f.regExpLiteral)(h, y);
          }
          if (Array.isArray(m))
            return (0, f.arrayExpression)(m.map(o));
          if (function(h) {
            if (typeof h != "object" || h === null || Object.prototype.toString.call(h) !== "[object Object]")
              return !1;
            const y = Object.getPrototypeOf(h);
            return y === null || Object.getPrototypeOf(y) === null;
          }(m)) {
            const h = [];
            for (const y of Object.keys(m)) {
              let b;
              b = (0, i.default)(y) ? (0, f.identifier)(y) : (0, f.stringLiteral)(y), h.push((0, f.objectProperty)(b, o(m[y])));
            }
            return (0, f.objectExpression)(h);
          }
          throw new Error("don't know how to turn this value into a node");
        };
        r.default = d;
        const s = Function.call.bind(Object.prototype.toString);
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/core.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.patternLikeCommon = r.functionTypeAnnotationCommon = r.functionDeclarationCommon = r.functionCommon = r.classMethodOrPropertyCommon = r.classMethodOrDeclareMethodCommon = void 0;
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/is.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isValidIdentifier.js"), d = l("./node_modules/.pnpm/@babel+helper-validator-identifier@7.22.15/node_modules/@babel/helper-validator-identifier/lib/index.js"), s = l("./node_modules/.pnpm/@babel+helper-string-parser@7.22.5/node_modules/@babel/helper-string-parser/lib/index.js"), o = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/constants/index.js"), m = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/utils.js");
        const h = (0, m.defineAliasedType)("Standardized");
        h("ArrayExpression", { fields: { elements: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeOrValueType)("null", "Expression", "SpreadElement"))), default: Ve.process.env.BABEL_TYPES_8_BREAKING ? void 0 : [] } }, visitor: ["elements"], aliases: ["Expression"] }), h("AssignmentExpression", { fields: { operator: { validate: function() {
          if (!Ve.process.env.BABEL_TYPES_8_BREAKING)
            return (0, m.assertValueType)("string");
          const R = (0, m.assertOneOf)(...o.ASSIGNMENT_OPERATORS), N = (0, m.assertOneOf)("=");
          return function(C, I, D) {
            ((0, i.default)("Pattern", C.left) ? N : R)(C, I, D);
          };
        }() }, left: { validate: Ve.process.env.BABEL_TYPES_8_BREAKING ? (0, m.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, m.assertNodeType)("LVal") }, right: { validate: (0, m.assertNodeType)("Expression") } }, builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Expression"] }), h("BinaryExpression", { builder: ["operator", "left", "right"], fields: { operator: { validate: (0, m.assertOneOf)(...o.BINARY_OPERATORS) }, left: { validate: function() {
          const R = (0, m.assertNodeType)("Expression"), N = (0, m.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(C, I, D) {
            (C.operator === "in" ? N : R)(C, I, D);
          }, { oneOfNodeTypes: ["Expression", "PrivateName"] });
        }() }, right: { validate: (0, m.assertNodeType)("Expression") } }, visitor: ["left", "right"], aliases: ["Binary", "Expression"] }), h("InterpreterDirective", { builder: ["value"], fields: { value: { validate: (0, m.assertValueType)("string") } } }), h("Directive", { visitor: ["value"], fields: { value: { validate: (0, m.assertNodeType)("DirectiveLiteral") } } }), h("DirectiveLiteral", { builder: ["value"], fields: { value: { validate: (0, m.assertValueType)("string") } } }), h("BlockStatement", { builder: ["body", "directives"], visitor: ["directives", "body"], fields: { directives: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Directive"))), default: [] }, body: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "Block", "Statement"] }), h("BreakStatement", { visitor: ["label"], fields: { label: { validate: (0, m.assertNodeType)("Identifier"), optional: !0 } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] }), h("CallExpression", { visitor: ["callee", "arguments", "typeParameters", "typeArguments"], builder: ["callee", "arguments"], aliases: ["Expression"], fields: Object.assign({ callee: { validate: (0, m.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier") }, arguments: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder"))) } }, Ve.process.env.BABEL_TYPES_8_BREAKING ? {} : { optional: { validate: (0, m.assertOneOf)(!0, !1), optional: !0 } }, { typeArguments: { validate: (0, m.assertNodeType)("TypeParameterInstantiation"), optional: !0 }, typeParameters: { validate: (0, m.assertNodeType)("TSTypeParameterInstantiation"), optional: !0 } }) }), h("CatchClause", { visitor: ["param", "body"], fields: { param: { validate: (0, m.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), optional: !0 }, body: { validate: (0, m.assertNodeType)("BlockStatement") } }, aliases: ["Scopable", "BlockParent"] }), h("ConditionalExpression", { visitor: ["test", "consequent", "alternate"], fields: { test: { validate: (0, m.assertNodeType)("Expression") }, consequent: { validate: (0, m.assertNodeType)("Expression") }, alternate: { validate: (0, m.assertNodeType)("Expression") } }, aliases: ["Expression", "Conditional"] }), h("ContinueStatement", { visitor: ["label"], fields: { label: { validate: (0, m.assertNodeType)("Identifier"), optional: !0 } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] }), h("DebuggerStatement", { aliases: ["Statement"] }), h("DoWhileStatement", { visitor: ["test", "body"], fields: { test: { validate: (0, m.assertNodeType)("Expression") }, body: { validate: (0, m.assertNodeType)("Statement") } }, aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"] }), h("EmptyStatement", { aliases: ["Statement"] }), h("ExpressionStatement", { visitor: ["expression"], fields: { expression: { validate: (0, m.assertNodeType)("Expression") } }, aliases: ["Statement", "ExpressionWrapper"] }), h("File", { builder: ["program", "comments", "tokens"], visitor: ["program"], fields: { program: { validate: (0, m.assertNodeType)("Program") }, comments: { validate: Ve.process.env.BABEL_TYPES_8_BREAKING ? (0, m.assertEach)((0, m.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(() => {
        }, { each: { oneOfNodeTypes: ["CommentBlock", "CommentLine"] } }), optional: !0 }, tokens: { validate: (0, m.assertEach)(Object.assign(() => {
        }, { type: "any" })), optional: !0 } } }), h("ForInStatement", { visitor: ["left", "right", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: Ve.process.env.BABEL_TYPES_8_BREAKING ? (0, m.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, m.assertNodeType)("VariableDeclaration", "LVal") }, right: { validate: (0, m.assertNodeType)("Expression") }, body: { validate: (0, m.assertNodeType)("Statement") } } }), h("ForStatement", { visitor: ["init", "test", "update", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"], fields: { init: { validate: (0, m.assertNodeType)("VariableDeclaration", "Expression"), optional: !0 }, test: { validate: (0, m.assertNodeType)("Expression"), optional: !0 }, update: { validate: (0, m.assertNodeType)("Expression"), optional: !0 }, body: { validate: (0, m.assertNodeType)("Statement") } } });
        const y = () => ({ params: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Identifier", "Pattern", "RestElement"))) }, generator: { default: !1 }, async: { default: !1 } });
        r.functionCommon = y;
        const b = () => ({ returnType: { validate: (0, m.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: !0 }, typeParameters: { validate: (0, m.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: !0 } });
        r.functionTypeAnnotationCommon = b;
        const E = () => Object.assign({}, y(), { declare: { validate: (0, m.assertValueType)("boolean"), optional: !0 }, id: { validate: (0, m.assertNodeType)("Identifier"), optional: !0 } });
        r.functionDeclarationCommon = E, h("FunctionDeclaration", { builder: ["id", "params", "body", "generator", "async"], visitor: ["id", "params", "body", "returnType", "typeParameters"], fields: Object.assign({}, E(), b(), { body: { validate: (0, m.assertNodeType)("BlockStatement") }, predicate: { validate: (0, m.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: !0 } }), aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"], validate: function() {
          if (!Ve.process.env.BABEL_TYPES_8_BREAKING)
            return () => {
            };
          const R = (0, m.assertNodeType)("Identifier");
          return function(N, C, I) {
            (0, i.default)("ExportDefaultDeclaration", N) || R(I, "id", I.id);
          };
        }() }), h("FunctionExpression", { inherits: "FunctionDeclaration", aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, y(), b(), { id: { validate: (0, m.assertNodeType)("Identifier"), optional: !0 }, body: { validate: (0, m.assertNodeType)("BlockStatement") }, predicate: { validate: (0, m.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: !0 } }) });
        const S = () => ({ typeAnnotation: { validate: (0, m.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: !0 }, optional: { validate: (0, m.assertValueType)("boolean"), optional: !0 }, decorators: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Decorator"))), optional: !0 } });
        r.patternLikeCommon = S, h("Identifier", { builder: ["name"], visitor: ["typeAnnotation", "decorators"], aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"], fields: Object.assign({}, S(), { name: { validate: (0, m.chain)((0, m.assertValueType)("string"), Object.assign(function(R, N, C) {
          if (Ve.process.env.BABEL_TYPES_8_BREAKING && !(0, f.default)(C, !1))
            throw new TypeError(`"${C}" is not a valid identifier name`);
        }, { type: "string" })) } }), validate(R, N, C) {
          if (!Ve.process.env.BABEL_TYPES_8_BREAKING)
            return;
          const I = /\.(\w+)$/.exec(N);
          if (!I)
            return;
          const [, D] = I, j = { computed: !1 };
          if (D === "property") {
            if ((0, i.default)("MemberExpression", R, j) || (0, i.default)("OptionalMemberExpression", R, j))
              return;
          } else if (D === "key") {
            if ((0, i.default)("Property", R, j) || (0, i.default)("Method", R, j))
              return;
          } else if (D === "exported") {
            if ((0, i.default)("ExportSpecifier", R))
              return;
          } else if (D === "imported") {
            if ((0, i.default)("ImportSpecifier", R, { imported: C }))
              return;
          } else if (D === "meta" && (0, i.default)("MetaProperty", R, { meta: C }))
            return;
          if (((0, d.isKeyword)(C.name) || (0, d.isReservedWord)(C.name, !1)) && C.name !== "this")
            throw new TypeError(`"${C.name}" is not a valid identifier`);
        } }), h("IfStatement", { visitor: ["test", "consequent", "alternate"], aliases: ["Statement", "Conditional"], fields: { test: { validate: (0, m.assertNodeType)("Expression") }, consequent: { validate: (0, m.assertNodeType)("Statement") }, alternate: { optional: !0, validate: (0, m.assertNodeType)("Statement") } } }), h("LabeledStatement", { visitor: ["label", "body"], aliases: ["Statement"], fields: { label: { validate: (0, m.assertNodeType)("Identifier") }, body: { validate: (0, m.assertNodeType)("Statement") } } }), h("StringLiteral", { builder: ["value"], fields: { value: { validate: (0, m.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), h("NumericLiteral", { builder: ["value"], deprecatedAlias: "NumberLiteral", fields: { value: { validate: (0, m.chain)((0, m.assertValueType)("number"), Object.assign(function(R, N, C) {
        }, { type: "number" })) } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), h("NullLiteral", { aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), h("BooleanLiteral", { builder: ["value"], fields: { value: { validate: (0, m.assertValueType)("boolean") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), h("RegExpLiteral", { builder: ["pattern", "flags"], deprecatedAlias: "RegexLiteral", aliases: ["Expression", "Pureish", "Literal"], fields: { pattern: { validate: (0, m.assertValueType)("string") }, flags: { validate: (0, m.chain)((0, m.assertValueType)("string"), Object.assign(function(R, N, C) {
          if (!Ve.process.env.BABEL_TYPES_8_BREAKING)
            return;
          const I = /[^gimsuy]/.exec(C);
          if (I)
            throw new TypeError(`"${I[0]}" is not a valid RegExp flag`);
        }, { type: "string" })), default: "" } } }), h("LogicalExpression", { builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Binary", "Expression"], fields: { operator: { validate: (0, m.assertOneOf)(...o.LOGICAL_OPERATORS) }, left: { validate: (0, m.assertNodeType)("Expression") }, right: { validate: (0, m.assertNodeType)("Expression") } } }), h("MemberExpression", { builder: ["object", "property", "computed", ...Ve.process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]], visitor: ["object", "property"], aliases: ["Expression", "LVal"], fields: Object.assign({ object: { validate: (0, m.assertNodeType)("Expression", "Super") }, property: { validate: function() {
          const R = (0, m.assertNodeType)("Identifier", "PrivateName"), N = (0, m.assertNodeType)("Expression"), C = function(I, D, j) {
            (I.computed ? N : R)(I, D, j);
          };
          return C.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], C;
        }() }, computed: { default: !1 } }, Ve.process.env.BABEL_TYPES_8_BREAKING ? {} : { optional: { validate: (0, m.assertOneOf)(!0, !1), optional: !0 } }) }), h("NewExpression", { inherits: "CallExpression" }), h("Program", { visitor: ["directives", "body"], builder: ["body", "directives", "sourceType", "interpreter"], fields: { sourceFile: { validate: (0, m.assertValueType)("string") }, sourceType: { validate: (0, m.assertOneOf)("script", "module"), default: "script" }, interpreter: { validate: (0, m.assertNodeType)("InterpreterDirective"), default: null, optional: !0 }, directives: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Directive"))), default: [] }, body: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "Block"] }), h("ObjectExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement"))) } } }), h("ObjectMethod", { builder: ["kind", "key", "params", "body", "computed", "generator", "async"], fields: Object.assign({}, y(), b(), { kind: Object.assign({ validate: (0, m.assertOneOf)("method", "get", "set") }, Ve.process.env.BABEL_TYPES_8_BREAKING ? {} : { default: "method" }), computed: { default: !1 }, key: { validate: function() {
          const R = (0, m.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), N = (0, m.assertNodeType)("Expression"), C = function(I, D, j) {
            (I.computed ? N : R)(I, D, j);
          };
          return C.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], C;
        }() }, decorators: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Decorator"))), optional: !0 }, body: { validate: (0, m.assertNodeType)("BlockStatement") } }), visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"] }), h("ObjectProperty", { builder: ["key", "value", "computed", "shorthand", ...Ve.process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]], fields: { computed: { default: !1 }, key: { validate: function() {
          const R = (0, m.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), N = (0, m.assertNodeType)("Expression");
          return Object.assign(function(C, I, D) {
            (C.computed ? N : R)(C, I, D);
          }, { oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"] });
        }() }, value: { validate: (0, m.assertNodeType)("Expression", "PatternLike") }, shorthand: { validate: (0, m.chain)((0, m.assertValueType)("boolean"), Object.assign(function(R, N, C) {
          if (Ve.process.env.BABEL_TYPES_8_BREAKING && C && R.computed)
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }, { type: "boolean" }), function(R, N, C) {
          if (Ve.process.env.BABEL_TYPES_8_BREAKING && C && !(0, i.default)("Identifier", R.key))
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }), default: !1 }, decorators: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Decorator"))), optional: !0 } }, visitor: ["key", "value", "decorators"], aliases: ["UserWhitespacable", "Property", "ObjectMember"], validate: function() {
          const R = (0, m.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion"), N = (0, m.assertNodeType)("Expression");
          return function(C, I, D) {
            Ve.process.env.BABEL_TYPES_8_BREAKING && ((0, i.default)("ObjectPattern", C) ? R : N)(D, "value", D.value);
          };
        }() }), h("RestElement", { visitor: ["argument", "typeAnnotation"], builder: ["argument"], aliases: ["LVal", "PatternLike"], deprecatedAlias: "RestProperty", fields: Object.assign({}, S(), { argument: { validate: Ve.process.env.BABEL_TYPES_8_BREAKING ? (0, m.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, m.assertNodeType)("LVal") } }), validate(R, N) {
          if (!Ve.process.env.BABEL_TYPES_8_BREAKING)
            return;
          const C = /(\w+)\[(\d+)\]/.exec(N);
          if (!C)
            throw new Error("Internal Babel error: malformed key.");
          const [, I, D] = C;
          if (R[I].length > +D + 1)
            throw new TypeError(`RestElement must be last element of ${I}`);
        } }), h("ReturnStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, m.assertNodeType)("Expression"), optional: !0 } } }), h("SequenceExpression", { visitor: ["expressions"], fields: { expressions: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Expression"))) } }, aliases: ["Expression"] }), h("ParenthesizedExpression", { visitor: ["expression"], aliases: ["Expression", "ExpressionWrapper"], fields: { expression: { validate: (0, m.assertNodeType)("Expression") } } }), h("SwitchCase", { visitor: ["test", "consequent"], fields: { test: { validate: (0, m.assertNodeType)("Expression"), optional: !0 }, consequent: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Statement"))) } } }), h("SwitchStatement", { visitor: ["discriminant", "cases"], aliases: ["Statement", "BlockParent", "Scopable"], fields: { discriminant: { validate: (0, m.assertNodeType)("Expression") }, cases: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("SwitchCase"))) } } }), h("ThisExpression", { aliases: ["Expression"] }), h("ThrowStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, m.assertNodeType)("Expression") } } }), h("TryStatement", { visitor: ["block", "handler", "finalizer"], aliases: ["Statement"], fields: { block: { validate: (0, m.chain)((0, m.assertNodeType)("BlockStatement"), Object.assign(function(R) {
          if (Ve.process.env.BABEL_TYPES_8_BREAKING && !R.handler && !R.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, { oneOfNodeTypes: ["BlockStatement"] })) }, handler: { optional: !0, validate: (0, m.assertNodeType)("CatchClause") }, finalizer: { optional: !0, validate: (0, m.assertNodeType)("BlockStatement") } } }), h("UnaryExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: !0 }, argument: { validate: (0, m.assertNodeType)("Expression") }, operator: { validate: (0, m.assertOneOf)(...o.UNARY_OPERATORS) } }, visitor: ["argument"], aliases: ["UnaryLike", "Expression"] }), h("UpdateExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: !1 }, argument: { validate: Ve.process.env.BABEL_TYPES_8_BREAKING ? (0, m.assertNodeType)("Identifier", "MemberExpression") : (0, m.assertNodeType)("Expression") }, operator: { validate: (0, m.assertOneOf)(...o.UPDATE_OPERATORS) } }, visitor: ["argument"], aliases: ["Expression"] }), h("VariableDeclaration", { builder: ["kind", "declarations"], visitor: ["declarations"], aliases: ["Statement", "Declaration"], fields: { declare: { validate: (0, m.assertValueType)("boolean"), optional: !0 }, kind: { validate: (0, m.assertOneOf)("var", "let", "const", "using", "await using") }, declarations: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("VariableDeclarator"))) } }, validate(R, N, C) {
          if (Ve.process.env.BABEL_TYPES_8_BREAKING && (0, i.default)("ForXStatement", R, { left: C }) && C.declarations.length !== 1)
            throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${R.type}`);
        } }), h("VariableDeclarator", { visitor: ["id", "init"], fields: { id: { validate: function() {
          if (!Ve.process.env.BABEL_TYPES_8_BREAKING)
            return (0, m.assertNodeType)("LVal");
          const R = (0, m.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), N = (0, m.assertNodeType)("Identifier");
          return function(C, I, D) {
            (C.init ? R : N)(C, I, D);
          };
        }() }, definite: { optional: !0, validate: (0, m.assertValueType)("boolean") }, init: { optional: !0, validate: (0, m.assertNodeType)("Expression") } } }), h("WhileStatement", { visitor: ["test", "body"], aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"], fields: { test: { validate: (0, m.assertNodeType)("Expression") }, body: { validate: (0, m.assertNodeType)("Statement") } } }), h("WithStatement", { visitor: ["object", "body"], aliases: ["Statement"], fields: { object: { validate: (0, m.assertNodeType)("Expression") }, body: { validate: (0, m.assertNodeType)("Statement") } } }), h("AssignmentPattern", { visitor: ["left", "right", "decorators"], builder: ["left", "right"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, S(), { left: { validate: (0, m.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") }, right: { validate: (0, m.assertNodeType)("Expression") }, decorators: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Decorator"))), optional: !0 } }) }), h("ArrayPattern", { visitor: ["elements", "typeAnnotation"], builder: ["elements"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, S(), { elements: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeOrValueType)("null", "PatternLike", "LVal"))) } }) }), h("ArrowFunctionExpression", { builder: ["params", "body", "async"], visitor: ["params", "body", "returnType", "typeParameters"], aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, y(), b(), { expression: { validate: (0, m.assertValueType)("boolean") }, body: { validate: (0, m.assertNodeType)("BlockStatement", "Expression") }, predicate: { validate: (0, m.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: !0 } }) }), h("ClassBody", { visitor: ["body"], fields: { body: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock"))) } } }), h("ClassExpression", { builder: ["id", "superClass", "body", "decorators"], visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"], aliases: ["Scopable", "Class", "Expression"], fields: { id: { validate: (0, m.assertNodeType)("Identifier"), optional: !0 }, typeParameters: { validate: (0, m.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: !0 }, body: { validate: (0, m.assertNodeType)("ClassBody") }, superClass: { optional: !0, validate: (0, m.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, m.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: !0 }, implements: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))), optional: !0 }, decorators: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Decorator"))), optional: !0 }, mixins: { validate: (0, m.assertNodeType)("InterfaceExtends"), optional: !0 } } }), h("ClassDeclaration", { inherits: "ClassExpression", aliases: ["Scopable", "Class", "Statement", "Declaration"], fields: { id: { validate: (0, m.assertNodeType)("Identifier") }, typeParameters: { validate: (0, m.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: !0 }, body: { validate: (0, m.assertNodeType)("ClassBody") }, superClass: { optional: !0, validate: (0, m.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, m.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: !0 }, implements: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))), optional: !0 }, decorators: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Decorator"))), optional: !0 }, mixins: { validate: (0, m.assertNodeType)("InterfaceExtends"), optional: !0 }, declare: { validate: (0, m.assertValueType)("boolean"), optional: !0 }, abstract: { validate: (0, m.assertValueType)("boolean"), optional: !0 } }, validate: function() {
          const R = (0, m.assertNodeType)("Identifier");
          return function(N, C, I) {
            Ve.process.env.BABEL_TYPES_8_BREAKING && ((0, i.default)("ExportDefaultDeclaration", N) || R(I, "id", I.id));
          };
        }() }), h("ExportAllDeclaration", { builder: ["source"], visitor: ["source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { source: { validate: (0, m.assertNodeType)("StringLiteral") }, exportKind: (0, m.validateOptional)((0, m.assertOneOf)("type", "value")), attributes: { optional: !0, validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("ImportAttribute"))) }, assertions: { optional: !0, validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("ImportAttribute"))) } } }), h("ExportDefaultDeclaration", { visitor: ["declaration"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { declaration: { validate: (0, m.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression") }, exportKind: (0, m.validateOptional)((0, m.assertOneOf)("value")) } }), h("ExportNamedDeclaration", { builder: ["declaration", "specifiers", "source"], visitor: ["declaration", "specifiers", "source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { declaration: { optional: !0, validate: (0, m.chain)((0, m.assertNodeType)("Declaration"), Object.assign(function(R, N, C) {
          if (Ve.process.env.BABEL_TYPES_8_BREAKING && C && R.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }, { oneOfNodeTypes: ["Declaration"] }), function(R, N, C) {
          if (Ve.process.env.BABEL_TYPES_8_BREAKING && C && R.source)
            throw new TypeError("Cannot export a declaration from a source");
        }) }, attributes: { optional: !0, validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("ImportAttribute"))) }, assertions: { optional: !0, validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("ImportAttribute"))) }, specifiers: { default: [], validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)(function() {
          const R = (0, m.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), N = (0, m.assertNodeType)("ExportSpecifier");
          return Ve.process.env.BABEL_TYPES_8_BREAKING ? function(C, I, D) {
            (C.source ? R : N)(C, I, D);
          } : R;
        }())) }, source: { validate: (0, m.assertNodeType)("StringLiteral"), optional: !0 }, exportKind: (0, m.validateOptional)((0, m.assertOneOf)("type", "value")) } }), h("ExportSpecifier", { visitor: ["local", "exported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, m.assertNodeType)("Identifier") }, exported: { validate: (0, m.assertNodeType)("Identifier", "StringLiteral") }, exportKind: { validate: (0, m.assertOneOf)("type", "value"), optional: !0 } } }), h("ForOfStatement", { visitor: ["left", "right", "body"], builder: ["left", "right", "body", "await"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: function() {
          if (!Ve.process.env.BABEL_TYPES_8_BREAKING)
            return (0, m.assertNodeType)("VariableDeclaration", "LVal");
          const R = (0, m.assertNodeType)("VariableDeclaration"), N = (0, m.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return function(C, I, D) {
            (0, i.default)("VariableDeclaration", D) ? R(C, I, D) : N(C, I, D);
          };
        }() }, right: { validate: (0, m.assertNodeType)("Expression") }, body: { validate: (0, m.assertNodeType)("Statement") }, await: { default: !1 } } }), h("ImportDeclaration", { builder: ["specifiers", "source"], visitor: ["specifiers", "source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"], fields: { attributes: { optional: !0, validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("ImportAttribute"))) }, assertions: { optional: !0, validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("ImportAttribute"))) }, module: { optional: !0, validate: (0, m.assertValueType)("boolean") }, specifiers: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"))) }, source: { validate: (0, m.assertNodeType)("StringLiteral") }, importKind: { validate: (0, m.assertOneOf)("type", "typeof", "value"), optional: !0 } } }), h("ImportDefaultSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, m.assertNodeType)("Identifier") } } }), h("ImportNamespaceSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, m.assertNodeType)("Identifier") } } }), h("ImportSpecifier", { visitor: ["local", "imported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, m.assertNodeType)("Identifier") }, imported: { validate: (0, m.assertNodeType)("Identifier", "StringLiteral") }, importKind: { validate: (0, m.assertOneOf)("type", "typeof", "value"), optional: !0 } } }), h("MetaProperty", { visitor: ["meta", "property"], aliases: ["Expression"], fields: { meta: { validate: (0, m.chain)((0, m.assertNodeType)("Identifier"), Object.assign(function(R, N, C) {
          if (!Ve.process.env.BABEL_TYPES_8_BREAKING)
            return;
          let I;
          switch (C.name) {
            case "function":
              I = "sent";
              break;
            case "new":
              I = "target";
              break;
            case "import":
              I = "meta";
          }
          if (!(0, i.default)("Identifier", R.property, { name: I }))
            throw new TypeError("Unrecognised MetaProperty");
        }, { oneOfNodeTypes: ["Identifier"] })) }, property: { validate: (0, m.assertNodeType)("Identifier") } } });
        const g = () => ({ abstract: { validate: (0, m.assertValueType)("boolean"), optional: !0 }, accessibility: { validate: (0, m.assertOneOf)("public", "private", "protected"), optional: !0 }, static: { default: !1 }, override: { default: !1 }, computed: { default: !1 }, optional: { validate: (0, m.assertValueType)("boolean"), optional: !0 }, key: { validate: (0, m.chain)(function() {
          const R = (0, m.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"), N = (0, m.assertNodeType)("Expression");
          return function(C, I, D) {
            (C.computed ? N : R)(C, I, D);
          };
        }(), (0, m.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression")) } });
        r.classMethodOrPropertyCommon = g;
        const P = () => Object.assign({}, y(), g(), { params: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"))) }, kind: { validate: (0, m.assertOneOf)("get", "set", "method", "constructor"), default: "method" }, access: { validate: (0, m.chain)((0, m.assertValueType)("string"), (0, m.assertOneOf)("public", "private", "protected")), optional: !0 }, decorators: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Decorator"))), optional: !0 } });
        r.classMethodOrDeclareMethodCommon = P, h("ClassMethod", { aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"], builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"], visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], fields: Object.assign({}, P(), b(), { body: { validate: (0, m.assertNodeType)("BlockStatement") } }) }), h("ObjectPattern", { visitor: ["properties", "typeAnnotation", "decorators"], builder: ["properties"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, S(), { properties: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("RestElement", "ObjectProperty"))) } }) }), h("SpreadElement", { visitor: ["argument"], aliases: ["UnaryLike"], deprecatedAlias: "SpreadProperty", fields: { argument: { validate: (0, m.assertNodeType)("Expression") } } }), h("Super", { aliases: ["Expression"] }), h("TaggedTemplateExpression", { visitor: ["tag", "quasi", "typeParameters"], builder: ["tag", "quasi"], aliases: ["Expression"], fields: { tag: { validate: (0, m.assertNodeType)("Expression") }, quasi: { validate: (0, m.assertNodeType)("TemplateLiteral") }, typeParameters: { validate: (0, m.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: !0 } } }), h("TemplateElement", { builder: ["value", "tail"], fields: { value: { validate: (0, m.chain)((0, m.assertShape)({ raw: { validate: (0, m.assertValueType)("string") }, cooked: { validate: (0, m.assertValueType)("string"), optional: !0 } }), function(R) {
          const N = R.value.raw;
          let C = !1;
          const I = () => {
            throw new Error("Internal @babel/types error.");
          }, { str: D, firstInvalidLoc: j } = (0, s.readStringContents)("template", N, 0, 0, 0, { unterminated() {
            C = !0;
          }, strictNumericEscape: I, invalidEscapeSequence: I, numericSeparatorInEscapeSequence: I, unexpectedNumericSeparator: I, invalidDigit: I, invalidCodePoint: I });
          if (!C)
            throw new Error("Invalid raw");
          R.value.cooked = j ? null : D;
        }) }, tail: { default: !1 } } }), h("TemplateLiteral", { visitor: ["quasis", "expressions"], aliases: ["Expression", "Literal"], fields: { quasis: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("TemplateElement"))) }, expressions: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Expression", "TSType")), function(R, N, C) {
          if (R.quasis.length !== C.length + 1)
            throw new TypeError(`Number of ${R.type} quasis should be exactly one more than the number of expressions.
Expected ${C.length + 1} quasis but got ${R.quasis.length}`);
        }) } } }), h("YieldExpression", { builder: ["argument", "delegate"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { delegate: { validate: (0, m.chain)((0, m.assertValueType)("boolean"), Object.assign(function(R, N, C) {
          if (Ve.process.env.BABEL_TYPES_8_BREAKING && C && !R.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, { type: "boolean" })), default: !1 }, argument: { optional: !0, validate: (0, m.assertNodeType)("Expression") } } }), h("AwaitExpression", { builder: ["argument"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { argument: { validate: (0, m.assertNodeType)("Expression") } } }), h("Import", { aliases: ["Expression"] }), h("BigIntLiteral", { builder: ["value"], fields: { value: { validate: (0, m.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), h("ExportNamespaceSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, m.assertNodeType)("Identifier") } } }), h("OptionalMemberExpression", { builder: ["object", "property", "computed", "optional"], visitor: ["object", "property"], aliases: ["Expression"], fields: { object: { validate: (0, m.assertNodeType)("Expression") }, property: { validate: function() {
          const R = (0, m.assertNodeType)("Identifier"), N = (0, m.assertNodeType)("Expression");
          return Object.assign(function(C, I, D) {
            (C.computed ? N : R)(C, I, D);
          }, { oneOfNodeTypes: ["Expression", "Identifier"] });
        }() }, computed: { default: !1 }, optional: { validate: Ve.process.env.BABEL_TYPES_8_BREAKING ? (0, m.chain)((0, m.assertValueType)("boolean"), (0, m.assertOptionalChainStart)()) : (0, m.assertValueType)("boolean") } } }), h("OptionalCallExpression", { visitor: ["callee", "arguments", "typeParameters", "typeArguments"], builder: ["callee", "arguments", "optional"], aliases: ["Expression"], fields: { callee: { validate: (0, m.assertNodeType)("Expression") }, arguments: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder"))) }, optional: { validate: Ve.process.env.BABEL_TYPES_8_BREAKING ? (0, m.chain)((0, m.assertValueType)("boolean"), (0, m.assertOptionalChainStart)()) : (0, m.assertValueType)("boolean") }, typeArguments: { validate: (0, m.assertNodeType)("TypeParameterInstantiation"), optional: !0 }, typeParameters: { validate: (0, m.assertNodeType)("TSTypeParameterInstantiation"), optional: !0 } } }), h("ClassProperty", { visitor: ["key", "value", "typeAnnotation", "decorators"], builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"], aliases: ["Property"], fields: Object.assign({}, g(), { value: { validate: (0, m.assertNodeType)("Expression"), optional: !0 }, definite: { validate: (0, m.assertValueType)("boolean"), optional: !0 }, typeAnnotation: { validate: (0, m.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: !0 }, decorators: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Decorator"))), optional: !0 }, readonly: { validate: (0, m.assertValueType)("boolean"), optional: !0 }, declare: { validate: (0, m.assertValueType)("boolean"), optional: !0 }, variance: { validate: (0, m.assertNodeType)("Variance"), optional: !0 } }) }), h("ClassAccessorProperty", { visitor: ["key", "value", "typeAnnotation", "decorators"], builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"], aliases: ["Property", "Accessor"], fields: Object.assign({}, g(), { key: { validate: (0, m.chain)(function() {
          const R = (0, m.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), N = (0, m.assertNodeType)("Expression");
          return function(C, I, D) {
            (C.computed ? N : R)(C, I, D);
          };
        }(), (0, m.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName")) }, value: { validate: (0, m.assertNodeType)("Expression"), optional: !0 }, definite: { validate: (0, m.assertValueType)("boolean"), optional: !0 }, typeAnnotation: { validate: (0, m.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: !0 }, decorators: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Decorator"))), optional: !0 }, readonly: { validate: (0, m.assertValueType)("boolean"), optional: !0 }, declare: { validate: (0, m.assertValueType)("boolean"), optional: !0 }, variance: { validate: (0, m.assertNodeType)("Variance"), optional: !0 } }) }), h("ClassPrivateProperty", { visitor: ["key", "value", "decorators", "typeAnnotation"], builder: ["key", "value", "decorators", "static"], aliases: ["Property", "Private"], fields: { key: { validate: (0, m.assertNodeType)("PrivateName") }, value: { validate: (0, m.assertNodeType)("Expression"), optional: !0 }, typeAnnotation: { validate: (0, m.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: !0 }, decorators: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Decorator"))), optional: !0 }, static: { validate: (0, m.assertValueType)("boolean"), default: !1 }, readonly: { validate: (0, m.assertValueType)("boolean"), optional: !0 }, definite: { validate: (0, m.assertValueType)("boolean"), optional: !0 }, variance: { validate: (0, m.assertNodeType)("Variance"), optional: !0 } } }), h("ClassPrivateMethod", { builder: ["kind", "key", "params", "body", "static"], visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"], fields: Object.assign({}, P(), b(), { kind: { validate: (0, m.assertOneOf)("get", "set", "method"), default: "method" }, key: { validate: (0, m.assertNodeType)("PrivateName") }, body: { validate: (0, m.assertNodeType)("BlockStatement") } }) }), h("PrivateName", { visitor: ["id"], aliases: ["Private"], fields: { id: { validate: (0, m.assertNodeType)("Identifier") } } }), h("StaticBlock", { visitor: ["body"], fields: { body: { validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "FunctionParent"] });
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/deprecated-aliases.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.DEPRECATED_ALIASES = void 0, r.DEPRECATED_ALIASES = { ModuleDeclaration: "ImportOrExportDeclaration" };
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/experimental.js": (u, r, l) => {
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/utils.js");
        (0, i.default)("ArgumentPlaceholder", {}), (0, i.default)("BindExpression", { visitor: ["object", "callee"], aliases: ["Expression"], fields: Ve.process.env.BABEL_TYPES_8_BREAKING ? { object: { validate: (0, i.assertNodeType)("Expression") }, callee: { validate: (0, i.assertNodeType)("Expression") } } : { object: { validate: Object.assign(() => {
        }, { oneOfNodeTypes: ["Expression"] }) }, callee: { validate: Object.assign(() => {
        }, { oneOfNodeTypes: ["Expression"] }) } } }), (0, i.default)("ImportAttribute", { visitor: ["key", "value"], fields: { key: { validate: (0, i.assertNodeType)("Identifier", "StringLiteral") }, value: { validate: (0, i.assertNodeType)("StringLiteral") } } }), (0, i.default)("Decorator", { visitor: ["expression"], fields: { expression: { validate: (0, i.assertNodeType)("Expression") } } }), (0, i.default)("DoExpression", { visitor: ["body"], builder: ["body", "async"], aliases: ["Expression"], fields: { body: { validate: (0, i.assertNodeType)("BlockStatement") }, async: { validate: (0, i.assertValueType)("boolean"), default: !1 } } }), (0, i.default)("ExportDefaultSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, i.assertNodeType)("Identifier") } } }), (0, i.default)("RecordExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: { validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("ObjectProperty", "SpreadElement"))) } } }), (0, i.default)("TupleExpression", { fields: { elements: { validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("Expression", "SpreadElement"))), default: [] } }, visitor: ["elements"], aliases: ["Expression"] }), (0, i.default)("DecimalLiteral", { builder: ["value"], fields: { value: { validate: (0, i.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), (0, i.default)("ModuleExpression", { visitor: ["body"], fields: { body: { validate: (0, i.assertNodeType)("Program") } }, aliases: ["Expression"] }), (0, i.default)("TopicReference", { aliases: ["Expression"] }), (0, i.default)("PipelineTopicExpression", { builder: ["expression"], visitor: ["expression"], fields: { expression: { validate: (0, i.assertNodeType)("Expression") } }, aliases: ["Expression"] }), (0, i.default)("PipelineBareFunction", { builder: ["callee"], visitor: ["callee"], fields: { callee: { validate: (0, i.assertNodeType)("Expression") } }, aliases: ["Expression"] }), (0, i.default)("PipelinePrimaryTopicReference", { aliases: ["Expression"] });
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/flow.js": (u, r, l) => {
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/utils.js");
        const f = (0, i.defineAliasedType)("Flow"), d = (s) => {
          const o = s === "DeclareClass";
          f(s, { builder: ["id", "typeParameters", "extends", "body"], visitor: ["id", "typeParameters", "extends", ...o ? ["mixins", "implements"] : [], "body"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: Object.assign({ id: (0, i.validateType)("Identifier"), typeParameters: (0, i.validateOptionalType)("TypeParameterDeclaration"), extends: (0, i.validateOptional)((0, i.arrayOfType)("InterfaceExtends")) }, o ? { mixins: (0, i.validateOptional)((0, i.arrayOfType)("InterfaceExtends")), implements: (0, i.validateOptional)((0, i.arrayOfType)("ClassImplements")) } : {}, { body: (0, i.validateType)("ObjectTypeAnnotation") }) });
        };
        f("AnyTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), f("ArrayTypeAnnotation", { visitor: ["elementType"], aliases: ["FlowType"], fields: { elementType: (0, i.validateType)("FlowType") } }), f("BooleanTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), f("BooleanLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, i.validate)((0, i.assertValueType)("boolean")) } }), f("NullLiteralTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), f("ClassImplements", { visitor: ["id", "typeParameters"], fields: { id: (0, i.validateType)("Identifier"), typeParameters: (0, i.validateOptionalType)("TypeParameterInstantiation") } }), d("DeclareClass"), f("DeclareFunction", { visitor: ["id"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, i.validateType)("Identifier"), predicate: (0, i.validateOptionalType)("DeclaredPredicate") } }), d("DeclareInterface"), f("DeclareModule", { builder: ["id", "body", "kind"], visitor: ["id", "body"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, i.validateType)(["Identifier", "StringLiteral"]), body: (0, i.validateType)("BlockStatement"), kind: (0, i.validateOptional)((0, i.assertOneOf)("CommonJS", "ES")) } }), f("DeclareModuleExports", { visitor: ["typeAnnotation"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { typeAnnotation: (0, i.validateType)("TypeAnnotation") } }), f("DeclareTypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, i.validateType)("Identifier"), typeParameters: (0, i.validateOptionalType)("TypeParameterDeclaration"), right: (0, i.validateType)("FlowType") } }), f("DeclareOpaqueType", { visitor: ["id", "typeParameters", "supertype"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, i.validateType)("Identifier"), typeParameters: (0, i.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, i.validateOptionalType)("FlowType"), impltype: (0, i.validateOptionalType)("FlowType") } }), f("DeclareVariable", { visitor: ["id"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, i.validateType)("Identifier") } }), f("DeclareExportDeclaration", { visitor: ["declaration", "specifiers", "source"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { declaration: (0, i.validateOptionalType)("Flow"), specifiers: (0, i.validateOptional)((0, i.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])), source: (0, i.validateOptionalType)("StringLiteral"), default: (0, i.validateOptional)((0, i.assertValueType)("boolean")) } }), f("DeclareExportAllDeclaration", { visitor: ["source"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { source: (0, i.validateType)("StringLiteral"), exportKind: (0, i.validateOptional)((0, i.assertOneOf)("type", "value")) } }), f("DeclaredPredicate", { visitor: ["value"], aliases: ["FlowPredicate"], fields: { value: (0, i.validateType)("Flow") } }), f("ExistsTypeAnnotation", { aliases: ["FlowType"] }), f("FunctionTypeAnnotation", { visitor: ["typeParameters", "params", "rest", "returnType"], aliases: ["FlowType"], fields: { typeParameters: (0, i.validateOptionalType)("TypeParameterDeclaration"), params: (0, i.validate)((0, i.arrayOfType)("FunctionTypeParam")), rest: (0, i.validateOptionalType)("FunctionTypeParam"), this: (0, i.validateOptionalType)("FunctionTypeParam"), returnType: (0, i.validateType)("FlowType") } }), f("FunctionTypeParam", { visitor: ["name", "typeAnnotation"], fields: { name: (0, i.validateOptionalType)("Identifier"), typeAnnotation: (0, i.validateType)("FlowType"), optional: (0, i.validateOptional)((0, i.assertValueType)("boolean")) } }), f("GenericTypeAnnotation", { visitor: ["id", "typeParameters"], aliases: ["FlowType"], fields: { id: (0, i.validateType)(["Identifier", "QualifiedTypeIdentifier"]), typeParameters: (0, i.validateOptionalType)("TypeParameterInstantiation") } }), f("InferredPredicate", { aliases: ["FlowPredicate"] }), f("InterfaceExtends", { visitor: ["id", "typeParameters"], fields: { id: (0, i.validateType)(["Identifier", "QualifiedTypeIdentifier"]), typeParameters: (0, i.validateOptionalType)("TypeParameterInstantiation") } }), d("InterfaceDeclaration"), f("InterfaceTypeAnnotation", { visitor: ["extends", "body"], aliases: ["FlowType"], fields: { extends: (0, i.validateOptional)((0, i.arrayOfType)("InterfaceExtends")), body: (0, i.validateType)("ObjectTypeAnnotation") } }), f("IntersectionTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, i.validate)((0, i.arrayOfType)("FlowType")) } }), f("MixedTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), f("EmptyTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), f("NullableTypeAnnotation", { visitor: ["typeAnnotation"], aliases: ["FlowType"], fields: { typeAnnotation: (0, i.validateType)("FlowType") } }), f("NumberLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, i.validate)((0, i.assertValueType)("number")) } }), f("NumberTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), f("ObjectTypeAnnotation", { visitor: ["properties", "indexers", "callProperties", "internalSlots"], aliases: ["FlowType"], builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"], fields: { properties: (0, i.validate)((0, i.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])), indexers: { validate: (0, i.arrayOfType)("ObjectTypeIndexer"), optional: !0, default: [] }, callProperties: { validate: (0, i.arrayOfType)("ObjectTypeCallProperty"), optional: !0, default: [] }, internalSlots: { validate: (0, i.arrayOfType)("ObjectTypeInternalSlot"), optional: !0, default: [] }, exact: { validate: (0, i.assertValueType)("boolean"), default: !1 }, inexact: (0, i.validateOptional)((0, i.assertValueType)("boolean")) } }), f("ObjectTypeInternalSlot", { visitor: ["id", "value", "optional", "static", "method"], aliases: ["UserWhitespacable"], fields: { id: (0, i.validateType)("Identifier"), value: (0, i.validateType)("FlowType"), optional: (0, i.validate)((0, i.assertValueType)("boolean")), static: (0, i.validate)((0, i.assertValueType)("boolean")), method: (0, i.validate)((0, i.assertValueType)("boolean")) } }), f("ObjectTypeCallProperty", { visitor: ["value"], aliases: ["UserWhitespacable"], fields: { value: (0, i.validateType)("FlowType"), static: (0, i.validate)((0, i.assertValueType)("boolean")) } }), f("ObjectTypeIndexer", { visitor: ["id", "key", "value", "variance"], aliases: ["UserWhitespacable"], fields: { id: (0, i.validateOptionalType)("Identifier"), key: (0, i.validateType)("FlowType"), value: (0, i.validateType)("FlowType"), static: (0, i.validate)((0, i.assertValueType)("boolean")), variance: (0, i.validateOptionalType)("Variance") } }), f("ObjectTypeProperty", { visitor: ["key", "value", "variance"], aliases: ["UserWhitespacable"], fields: { key: (0, i.validateType)(["Identifier", "StringLiteral"]), value: (0, i.validateType)("FlowType"), kind: (0, i.validate)((0, i.assertOneOf)("init", "get", "set")), static: (0, i.validate)((0, i.assertValueType)("boolean")), proto: (0, i.validate)((0, i.assertValueType)("boolean")), optional: (0, i.validate)((0, i.assertValueType)("boolean")), variance: (0, i.validateOptionalType)("Variance"), method: (0, i.validate)((0, i.assertValueType)("boolean")) } }), f("ObjectTypeSpreadProperty", { visitor: ["argument"], aliases: ["UserWhitespacable"], fields: { argument: (0, i.validateType)("FlowType") } }), f("OpaqueType", { visitor: ["id", "typeParameters", "supertype", "impltype"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, i.validateType)("Identifier"), typeParameters: (0, i.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, i.validateOptionalType)("FlowType"), impltype: (0, i.validateType)("FlowType") } }), f("QualifiedTypeIdentifier", { visitor: ["id", "qualification"], fields: { id: (0, i.validateType)("Identifier"), qualification: (0, i.validateType)(["Identifier", "QualifiedTypeIdentifier"]) } }), f("StringLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, i.validate)((0, i.assertValueType)("string")) } }), f("StringTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), f("SymbolTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), f("ThisTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), f("TupleTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, i.validate)((0, i.arrayOfType)("FlowType")) } }), f("TypeofTypeAnnotation", { visitor: ["argument"], aliases: ["FlowType"], fields: { argument: (0, i.validateType)("FlowType") } }), f("TypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, i.validateType)("Identifier"), typeParameters: (0, i.validateOptionalType)("TypeParameterDeclaration"), right: (0, i.validateType)("FlowType") } }), f("TypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, i.validateType)("FlowType") } }), f("TypeCastExpression", { visitor: ["expression", "typeAnnotation"], aliases: ["ExpressionWrapper", "Expression"], fields: { expression: (0, i.validateType)("Expression"), typeAnnotation: (0, i.validateType)("TypeAnnotation") } }), f("TypeParameter", { visitor: ["bound", "default", "variance"], fields: { name: (0, i.validate)((0, i.assertValueType)("string")), bound: (0, i.validateOptionalType)("TypeAnnotation"), default: (0, i.validateOptionalType)("FlowType"), variance: (0, i.validateOptionalType)("Variance") } }), f("TypeParameterDeclaration", { visitor: ["params"], fields: { params: (0, i.validate)((0, i.arrayOfType)("TypeParameter")) } }), f("TypeParameterInstantiation", { visitor: ["params"], fields: { params: (0, i.validate)((0, i.arrayOfType)("FlowType")) } }), f("UnionTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, i.validate)((0, i.arrayOfType)("FlowType")) } }), f("Variance", { builder: ["kind"], fields: { kind: (0, i.validate)((0, i.assertOneOf)("minus", "plus")) } }), f("VoidTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), f("EnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: { id: (0, i.validateType)("Identifier"), body: (0, i.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"]) } }), f("EnumBooleanBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, i.validate)((0, i.assertValueType)("boolean")), members: (0, i.validateArrayOfType)("EnumBooleanMember"), hasUnknownMembers: (0, i.validate)((0, i.assertValueType)("boolean")) } }), f("EnumNumberBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, i.validate)((0, i.assertValueType)("boolean")), members: (0, i.validateArrayOfType)("EnumNumberMember"), hasUnknownMembers: (0, i.validate)((0, i.assertValueType)("boolean")) } }), f("EnumStringBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, i.validate)((0, i.assertValueType)("boolean")), members: (0, i.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]), hasUnknownMembers: (0, i.validate)((0, i.assertValueType)("boolean")) } }), f("EnumSymbolBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { members: (0, i.validateArrayOfType)("EnumDefaultedMember"), hasUnknownMembers: (0, i.validate)((0, i.assertValueType)("boolean")) } }), f("EnumBooleanMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, i.validateType)("Identifier"), init: (0, i.validateType)("BooleanLiteral") } }), f("EnumNumberMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, i.validateType)("Identifier"), init: (0, i.validateType)("NumericLiteral") } }), f("EnumStringMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, i.validateType)("Identifier"), init: (0, i.validateType)("StringLiteral") } }), f("EnumDefaultedMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, i.validateType)("Identifier") } }), f("IndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["FlowType"], fields: { objectType: (0, i.validateType)("FlowType"), indexType: (0, i.validateType)("FlowType") } }), f("OptionalIndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["FlowType"], fields: { objectType: (0, i.validateType)("FlowType"), indexType: (0, i.validateType)("FlowType"), optional: (0, i.validate)((0, i.assertValueType)("boolean")) } });
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), Object.defineProperty(r, "ALIAS_KEYS", { enumerable: !0, get: function() {
          return f.ALIAS_KEYS;
        } }), Object.defineProperty(r, "BUILDER_KEYS", { enumerable: !0, get: function() {
          return f.BUILDER_KEYS;
        } }), Object.defineProperty(r, "DEPRECATED_ALIASES", { enumerable: !0, get: function() {
          return s.DEPRECATED_ALIASES;
        } }), Object.defineProperty(r, "DEPRECATED_KEYS", { enumerable: !0, get: function() {
          return f.DEPRECATED_KEYS;
        } }), Object.defineProperty(r, "FLIPPED_ALIAS_KEYS", { enumerable: !0, get: function() {
          return f.FLIPPED_ALIAS_KEYS;
        } }), Object.defineProperty(r, "NODE_FIELDS", { enumerable: !0, get: function() {
          return f.NODE_FIELDS;
        } }), Object.defineProperty(r, "NODE_PARENT_VALIDATIONS", { enumerable: !0, get: function() {
          return f.NODE_PARENT_VALIDATIONS;
        } }), Object.defineProperty(r, "PLACEHOLDERS", { enumerable: !0, get: function() {
          return d.PLACEHOLDERS;
        } }), Object.defineProperty(r, "PLACEHOLDERS_ALIAS", { enumerable: !0, get: function() {
          return d.PLACEHOLDERS_ALIAS;
        } }), Object.defineProperty(r, "PLACEHOLDERS_FLIPPED_ALIAS", { enumerable: !0, get: function() {
          return d.PLACEHOLDERS_FLIPPED_ALIAS;
        } }), r.TYPES = void 0, Object.defineProperty(r, "VISITOR_KEYS", { enumerable: !0, get: function() {
          return f.VISITOR_KEYS;
        } });
        var i = l("./node_modules/.pnpm/to-fast-properties@2.0.0/node_modules/to-fast-properties/index.js");
        l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/core.js"), l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/flow.js"), l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/jsx.js"), l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/misc.js"), l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/experimental.js"), l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/typescript.js");
        var f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/utils.js"), d = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/placeholders.js"), s = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/deprecated-aliases.js");
        Object.keys(s.DEPRECATED_ALIASES).forEach((m) => {
          f.FLIPPED_ALIAS_KEYS[m] = f.FLIPPED_ALIAS_KEYS[s.DEPRECATED_ALIASES[m]];
        }), i(f.VISITOR_KEYS), i(f.ALIAS_KEYS), i(f.FLIPPED_ALIAS_KEYS), i(f.NODE_FIELDS), i(f.BUILDER_KEYS), i(f.DEPRECATED_KEYS), i(d.PLACEHOLDERS_ALIAS), i(d.PLACEHOLDERS_FLIPPED_ALIAS);
        const o = [].concat(Object.keys(f.VISITOR_KEYS), Object.keys(f.FLIPPED_ALIAS_KEYS), Object.keys(f.DEPRECATED_KEYS));
        r.TYPES = o;
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/jsx.js": (u, r, l) => {
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/utils.js");
        const f = (0, i.defineAliasedType)("JSX");
        f("JSXAttribute", { visitor: ["name", "value"], aliases: ["Immutable"], fields: { name: { validate: (0, i.assertNodeType)("JSXIdentifier", "JSXNamespacedName") }, value: { optional: !0, validate: (0, i.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer") } } }), f("JSXClosingElement", { visitor: ["name"], aliases: ["Immutable"], fields: { name: { validate: (0, i.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") } } }), f("JSXElement", { builder: ["openingElement", "closingElement", "children", "selfClosing"], visitor: ["openingElement", "children", "closingElement"], aliases: ["Immutable", "Expression"], fields: Object.assign({ openingElement: { validate: (0, i.assertNodeType)("JSXOpeningElement") }, closingElement: { optional: !0, validate: (0, i.assertNodeType)("JSXClosingElement") }, children: { validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment"))) } }, { selfClosing: { validate: (0, i.assertValueType)("boolean"), optional: !0 } }) }), f("JSXEmptyExpression", {}), f("JSXExpressionContainer", { visitor: ["expression"], aliases: ["Immutable"], fields: { expression: { validate: (0, i.assertNodeType)("Expression", "JSXEmptyExpression") } } }), f("JSXSpreadChild", { visitor: ["expression"], aliases: ["Immutable"], fields: { expression: { validate: (0, i.assertNodeType)("Expression") } } }), f("JSXIdentifier", { builder: ["name"], fields: { name: { validate: (0, i.assertValueType)("string") } } }), f("JSXMemberExpression", { visitor: ["object", "property"], fields: { object: { validate: (0, i.assertNodeType)("JSXMemberExpression", "JSXIdentifier") }, property: { validate: (0, i.assertNodeType)("JSXIdentifier") } } }), f("JSXNamespacedName", { visitor: ["namespace", "name"], fields: { namespace: { validate: (0, i.assertNodeType)("JSXIdentifier") }, name: { validate: (0, i.assertNodeType)("JSXIdentifier") } } }), f("JSXOpeningElement", { builder: ["name", "attributes", "selfClosing"], visitor: ["name", "attributes"], aliases: ["Immutable"], fields: { name: { validate: (0, i.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") }, selfClosing: { default: !1 }, attributes: { validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("JSXAttribute", "JSXSpreadAttribute"))) }, typeParameters: { validate: (0, i.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: !0 } } }), f("JSXSpreadAttribute", { visitor: ["argument"], fields: { argument: { validate: (0, i.assertNodeType)("Expression") } } }), f("JSXText", { aliases: ["Immutable"], builder: ["value"], fields: { value: { validate: (0, i.assertValueType)("string") } } }), f("JSXFragment", { builder: ["openingFragment", "closingFragment", "children"], visitor: ["openingFragment", "children", "closingFragment"], aliases: ["Immutable", "Expression"], fields: { openingFragment: { validate: (0, i.assertNodeType)("JSXOpeningFragment") }, closingFragment: { validate: (0, i.assertNodeType)("JSXClosingFragment") }, children: { validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment"))) } } }), f("JSXOpeningFragment", { aliases: ["Immutable"] }), f("JSXClosingFragment", { aliases: ["Immutable"] });
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/misc.js": (u, r, l) => {
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/utils.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/placeholders.js");
        const d = (0, i.defineAliasedType)("Miscellaneous");
        d("Noop", { visitor: [] }), d("Placeholder", { visitor: [], builder: ["expectedNode", "name"], fields: { name: { validate: (0, i.assertNodeType)("Identifier") }, expectedNode: { validate: (0, i.assertOneOf)(...f.PLACEHOLDERS) } } }), d("V8IntrinsicIdentifier", { builder: ["name"], fields: { name: { validate: (0, i.assertValueType)("string") } } });
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/placeholders.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.PLACEHOLDERS_FLIPPED_ALIAS = r.PLACEHOLDERS_ALIAS = r.PLACEHOLDERS = void 0;
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/utils.js");
        const f = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
        r.PLACEHOLDERS = f;
        const d = { Declaration: ["Statement"], Pattern: ["PatternLike", "LVal"] };
        r.PLACEHOLDERS_ALIAS = d;
        for (const o of f) {
          const m = i.ALIAS_KEYS[o];
          m != null && m.length && (d[o] = m);
        }
        const s = {};
        r.PLACEHOLDERS_FLIPPED_ALIAS = s, Object.keys(d).forEach((o) => {
          d[o].forEach((m) => {
            Object.hasOwnProperty.call(s, m) || (s[m] = []), s[m].push(o);
          });
        });
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/typescript.js": (u, r, l) => {
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/utils.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/core.js"), d = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/is.js");
        const s = (0, i.defineAliasedType)("TypeScript"), o = (0, i.assertValueType)("boolean"), m = () => ({ returnType: { validate: (0, i.assertNodeType)("TSTypeAnnotation", "Noop"), optional: !0 }, typeParameters: { validate: (0, i.assertNodeType)("TSTypeParameterDeclaration", "Noop"), optional: !0 } });
        s("TSParameterProperty", { aliases: ["LVal"], visitor: ["parameter"], fields: { accessibility: { validate: (0, i.assertOneOf)("public", "private", "protected"), optional: !0 }, readonly: { validate: (0, i.assertValueType)("boolean"), optional: !0 }, parameter: { validate: (0, i.assertNodeType)("Identifier", "AssignmentPattern") }, override: { validate: (0, i.assertValueType)("boolean"), optional: !0 }, decorators: { validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("Decorator"))), optional: !0 } } }), s("TSDeclareFunction", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "params", "returnType"], fields: Object.assign({}, (0, f.functionDeclarationCommon)(), m()) }), s("TSDeclareMethod", { visitor: ["decorators", "key", "typeParameters", "params", "returnType"], fields: Object.assign({}, (0, f.classMethodOrDeclareMethodCommon)(), m()) }), s("TSQualifiedName", { aliases: ["TSEntityName"], visitor: ["left", "right"], fields: { left: (0, i.validateType)("TSEntityName"), right: (0, i.validateType)("Identifier") } });
        const h = () => ({ typeParameters: (0, i.validateOptionalType)("TSTypeParameterDeclaration"), parameters: (0, i.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]), typeAnnotation: (0, i.validateOptionalType)("TSTypeAnnotation") }), y = { aliases: ["TSTypeElement"], visitor: ["typeParameters", "parameters", "typeAnnotation"], fields: h() };
        s("TSCallSignatureDeclaration", y), s("TSConstructSignatureDeclaration", y);
        const b = () => ({ key: (0, i.validateType)("Expression"), computed: { default: !1 }, optional: (0, i.validateOptional)(o) });
        s("TSPropertySignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeAnnotation", "initializer"], fields: Object.assign({}, b(), { readonly: (0, i.validateOptional)(o), typeAnnotation: (0, i.validateOptionalType)("TSTypeAnnotation"), initializer: (0, i.validateOptionalType)("Expression"), kind: { validate: (0, i.assertOneOf)("get", "set") } }) }), s("TSMethodSignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeParameters", "parameters", "typeAnnotation"], fields: Object.assign({}, h(), b(), { kind: { validate: (0, i.assertOneOf)("method", "get", "set") } }) }), s("TSIndexSignature", { aliases: ["TSTypeElement"], visitor: ["parameters", "typeAnnotation"], fields: { readonly: (0, i.validateOptional)(o), static: (0, i.validateOptional)(o), parameters: (0, i.validateArrayOfType)("Identifier"), typeAnnotation: (0, i.validateOptionalType)("TSTypeAnnotation") } });
        const E = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
        for (const R of E)
          s(R, { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
        s("TSThisType", { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
        const S = { aliases: ["TSType"], visitor: ["typeParameters", "parameters", "typeAnnotation"] };
        s("TSFunctionType", Object.assign({}, S, { fields: h() })), s("TSConstructorType", Object.assign({}, S, { fields: Object.assign({}, h(), { abstract: (0, i.validateOptional)(o) }) })), s("TSTypeReference", { aliases: ["TSType"], visitor: ["typeName", "typeParameters"], fields: { typeName: (0, i.validateType)("TSEntityName"), typeParameters: (0, i.validateOptionalType)("TSTypeParameterInstantiation") } }), s("TSTypePredicate", { aliases: ["TSType"], visitor: ["parameterName", "typeAnnotation"], builder: ["parameterName", "typeAnnotation", "asserts"], fields: { parameterName: (0, i.validateType)(["Identifier", "TSThisType"]), typeAnnotation: (0, i.validateOptionalType)("TSTypeAnnotation"), asserts: (0, i.validateOptional)(o) } }), s("TSTypeQuery", { aliases: ["TSType"], visitor: ["exprName", "typeParameters"], fields: { exprName: (0, i.validateType)(["TSEntityName", "TSImportType"]), typeParameters: (0, i.validateOptionalType)("TSTypeParameterInstantiation") } }), s("TSTypeLiteral", { aliases: ["TSType"], visitor: ["members"], fields: { members: (0, i.validateArrayOfType)("TSTypeElement") } }), s("TSArrayType", { aliases: ["TSType"], visitor: ["elementType"], fields: { elementType: (0, i.validateType)("TSType") } }), s("TSTupleType", { aliases: ["TSType"], visitor: ["elementTypes"], fields: { elementTypes: (0, i.validateArrayOfType)(["TSType", "TSNamedTupleMember"]) } }), s("TSOptionalType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, i.validateType)("TSType") } }), s("TSRestType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, i.validateType)("TSType") } }), s("TSNamedTupleMember", { visitor: ["label", "elementType"], builder: ["label", "elementType", "optional"], fields: { label: (0, i.validateType)("Identifier"), optional: { validate: o, default: !1 }, elementType: (0, i.validateType)("TSType") } });
        const g = { aliases: ["TSType"], visitor: ["types"], fields: { types: (0, i.validateArrayOfType)("TSType") } };
        s("TSUnionType", g), s("TSIntersectionType", g), s("TSConditionalType", { aliases: ["TSType"], visitor: ["checkType", "extendsType", "trueType", "falseType"], fields: { checkType: (0, i.validateType)("TSType"), extendsType: (0, i.validateType)("TSType"), trueType: (0, i.validateType)("TSType"), falseType: (0, i.validateType)("TSType") } }), s("TSInferType", { aliases: ["TSType"], visitor: ["typeParameter"], fields: { typeParameter: (0, i.validateType)("TSTypeParameter") } }), s("TSParenthesizedType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, i.validateType)("TSType") } }), s("TSTypeOperator", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { operator: (0, i.validate)((0, i.assertValueType)("string")), typeAnnotation: (0, i.validateType)("TSType") } }), s("TSIndexedAccessType", { aliases: ["TSType"], visitor: ["objectType", "indexType"], fields: { objectType: (0, i.validateType)("TSType"), indexType: (0, i.validateType)("TSType") } }), s("TSMappedType", { aliases: ["TSType"], visitor: ["typeParameter", "typeAnnotation", "nameType"], fields: { readonly: (0, i.validateOptional)((0, i.assertOneOf)(!0, !1, "+", "-")), typeParameter: (0, i.validateType)("TSTypeParameter"), optional: (0, i.validateOptional)((0, i.assertOneOf)(!0, !1, "+", "-")), typeAnnotation: (0, i.validateOptionalType)("TSType"), nameType: (0, i.validateOptionalType)("TSType") } }), s("TSLiteralType", { aliases: ["TSType", "TSBaseType"], visitor: ["literal"], fields: { literal: { validate: function() {
          const R = (0, i.assertNodeType)("NumericLiteral", "BigIntLiteral"), N = (0, i.assertOneOf)("-"), C = (0, i.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function I(D, j, F) {
            (0, d.default)("UnaryExpression", F) ? (N(F, "operator", F.operator), R(F, "argument", F.argument)) : C(D, j, F);
          }
          return I.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"], I;
        }() } } }), s("TSExpressionWithTypeArguments", { aliases: ["TSType"], visitor: ["expression", "typeParameters"], fields: { expression: (0, i.validateType)("TSEntityName"), typeParameters: (0, i.validateOptionalType)("TSTypeParameterInstantiation") } }), s("TSInterfaceDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "extends", "body"], fields: { declare: (0, i.validateOptional)(o), id: (0, i.validateType)("Identifier"), typeParameters: (0, i.validateOptionalType)("TSTypeParameterDeclaration"), extends: (0, i.validateOptional)((0, i.arrayOfType)("TSExpressionWithTypeArguments")), body: (0, i.validateType)("TSInterfaceBody") } }), s("TSInterfaceBody", { visitor: ["body"], fields: { body: (0, i.validateArrayOfType)("TSTypeElement") } }), s("TSTypeAliasDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "typeAnnotation"], fields: { declare: (0, i.validateOptional)(o), id: (0, i.validateType)("Identifier"), typeParameters: (0, i.validateOptionalType)("TSTypeParameterDeclaration"), typeAnnotation: (0, i.validateType)("TSType") } }), s("TSInstantiationExpression", { aliases: ["Expression"], visitor: ["expression", "typeParameters"], fields: { expression: (0, i.validateType)("Expression"), typeParameters: (0, i.validateOptionalType)("TSTypeParameterInstantiation") } });
        const P = { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["expression", "typeAnnotation"], fields: { expression: (0, i.validateType)("Expression"), typeAnnotation: (0, i.validateType)("TSType") } };
        s("TSAsExpression", P), s("TSSatisfiesExpression", P), s("TSTypeAssertion", { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["typeAnnotation", "expression"], fields: { typeAnnotation: (0, i.validateType)("TSType"), expression: (0, i.validateType)("Expression") } }), s("TSEnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "members"], fields: { declare: (0, i.validateOptional)(o), const: (0, i.validateOptional)(o), id: (0, i.validateType)("Identifier"), members: (0, i.validateArrayOfType)("TSEnumMember"), initializer: (0, i.validateOptionalType)("Expression") } }), s("TSEnumMember", { visitor: ["id", "initializer"], fields: { id: (0, i.validateType)(["Identifier", "StringLiteral"]), initializer: (0, i.validateOptionalType)("Expression") } }), s("TSModuleDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: { declare: (0, i.validateOptional)(o), global: (0, i.validateOptional)(o), id: (0, i.validateType)(["Identifier", "StringLiteral"]), body: (0, i.validateType)(["TSModuleBlock", "TSModuleDeclaration"]) } }), s("TSModuleBlock", { aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"], visitor: ["body"], fields: { body: (0, i.validateArrayOfType)("Statement") } }), s("TSImportType", { aliases: ["TSType"], visitor: ["argument", "qualifier", "typeParameters"], fields: { argument: (0, i.validateType)("StringLiteral"), qualifier: (0, i.validateOptionalType)("TSEntityName"), typeParameters: (0, i.validateOptionalType)("TSTypeParameterInstantiation") } }), s("TSImportEqualsDeclaration", { aliases: ["Statement"], visitor: ["id", "moduleReference"], fields: { isExport: (0, i.validate)(o), id: (0, i.validateType)("Identifier"), moduleReference: (0, i.validateType)(["TSEntityName", "TSExternalModuleReference"]), importKind: { validate: (0, i.assertOneOf)("type", "value"), optional: !0 } } }), s("TSExternalModuleReference", { visitor: ["expression"], fields: { expression: (0, i.validateType)("StringLiteral") } }), s("TSNonNullExpression", { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["expression"], fields: { expression: (0, i.validateType)("Expression") } }), s("TSExportAssignment", { aliases: ["Statement"], visitor: ["expression"], fields: { expression: (0, i.validateType)("Expression") } }), s("TSNamespaceExportDeclaration", { aliases: ["Statement"], visitor: ["id"], fields: { id: (0, i.validateType)("Identifier") } }), s("TSTypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: { validate: (0, i.assertNodeType)("TSType") } } }), s("TSTypeParameterInstantiation", { visitor: ["params"], fields: { params: { validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("TSType"))) } } }), s("TSTypeParameterDeclaration", { visitor: ["params"], fields: { params: { validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("TSTypeParameter"))) } } }), s("TSTypeParameter", { builder: ["constraint", "default", "name"], visitor: ["constraint", "default"], fields: { name: { validate: (0, i.assertValueType)("string") }, in: { validate: (0, i.assertValueType)("boolean"), optional: !0 }, out: { validate: (0, i.assertValueType)("boolean"), optional: !0 }, const: { validate: (0, i.assertValueType)("boolean"), optional: !0 }, constraint: { validate: (0, i.assertNodeType)("TSType"), optional: !0 }, default: { validate: (0, i.assertNodeType)("TSType"), optional: !0 } } });
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/utils.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.VISITOR_KEYS = r.NODE_PARENT_VALIDATIONS = r.NODE_FIELDS = r.FLIPPED_ALIAS_KEYS = r.DEPRECATED_KEYS = r.BUILDER_KEYS = r.ALIAS_KEYS = void 0, r.arrayOf = P, r.arrayOfType = R, r.assertEach = N, r.assertNodeOrValueType = function(...v) {
          function w(O, G, W) {
            for (const U of v)
              if (E(W) === U || (0, i.default)(U, W))
                return void (0, f.validateChild)(O, G, W);
            throw new TypeError(`Property ${G} of ${O.type} expected node to be of a type ${JSON.stringify(v)} but instead got ${JSON.stringify(W == null ? void 0 : W.type)}`);
          }
          return w.oneOfNodeOrValueTypes = v, w;
        }, r.assertNodeType = C, r.assertOneOf = function(...v) {
          function w(O, G, W) {
            if (v.indexOf(W) < 0)
              throw new TypeError(`Property ${G} expected value to be one of ${JSON.stringify(v)} but got ${JSON.stringify(W)}`);
          }
          return w.oneOf = v, w;
        }, r.assertOptionalChainStart = function() {
          return function(v) {
            var w;
            let O = v;
            for (; v; ) {
              const { type: G } = O;
              if (G !== "OptionalCallExpression") {
                if (G !== "OptionalMemberExpression")
                  break;
                if (O.optional)
                  return;
                O = O.object;
              } else {
                if (O.optional)
                  return;
                O = O.callee;
              }
            }
            throw new TypeError(`Non-optional ${v.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(w = O) == null ? void 0 : w.type}`);
          };
        }, r.assertShape = function(v) {
          function w(O, G, W) {
            const U = [];
            for (const M of Object.keys(v))
              try {
                (0, f.validateField)(O, M, W[M], v[M]);
              } catch (B) {
                if (B instanceof TypeError) {
                  U.push(B.message);
                  continue;
                }
                throw B;
              }
            if (U.length)
              throw new TypeError(`Property ${G} of ${O.type} expected to have the following:
${U.join(`
`)}`);
          }
          return w.shapeOf = v, w;
        }, r.assertValueType = I, r.chain = D, r.default = T, r.defineAliasedType = function(...v) {
          return (w, O = {}) => {
            let G = O.aliases;
            var W;
            G || (O.inherits && (G = (W = _[O.inherits].aliases) == null ? void 0 : W.slice()), G != null || (G = []), O.aliases = G);
            const U = v.filter((M) => !G.includes(M));
            G.unshift(...U), T(w, O);
          };
        }, r.typeIs = g, r.validate = S, r.validateArrayOfType = function(v) {
          return S(R(v));
        }, r.validateOptional = function(v) {
          return { validate: v, optional: !0 };
        }, r.validateOptionalType = function(v) {
          return { validate: g(v), optional: !0 };
        }, r.validateType = function(v) {
          return S(g(v));
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/is.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/validate.js");
        const d = {};
        r.VISITOR_KEYS = d;
        const s = {};
        r.ALIAS_KEYS = s;
        const o = {};
        r.FLIPPED_ALIAS_KEYS = o;
        const m = {};
        r.NODE_FIELDS = m;
        const h = {};
        r.BUILDER_KEYS = h;
        const y = {};
        r.DEPRECATED_KEYS = y;
        const b = {};
        function E(v) {
          return Array.isArray(v) ? "array" : v === null ? "null" : typeof v;
        }
        function S(v) {
          return { validate: v };
        }
        function g(v) {
          return typeof v == "string" ? C(v) : C(...v);
        }
        function P(v) {
          return D(I("array"), N(v));
        }
        function R(v) {
          return P(g(v));
        }
        function N(v) {
          function w(O, G, W) {
            if (Array.isArray(W))
              for (let U = 0; U < W.length; U++) {
                const M = `${G}[${U}]`, B = W[U];
                v(O, M, B), Ve.process.env.BABEL_TYPES_8_BREAKING && (0, f.validateChild)(O, M, B);
              }
          }
          return w.each = v, w;
        }
        function C(...v) {
          function w(O, G, W) {
            for (const U of v)
              if ((0, i.default)(U, W))
                return void (0, f.validateChild)(O, G, W);
            throw new TypeError(`Property ${G} of ${O.type} expected node to be of a type ${JSON.stringify(v)} but instead got ${JSON.stringify(W == null ? void 0 : W.type)}`);
          }
          return w.oneOfNodeTypes = v, w;
        }
        function I(v) {
          function w(O, G, W) {
            if (E(W) !== v)
              throw new TypeError(`Property ${G} expected type of ${v} but got ${E(W)}`);
          }
          return w.type = v, w;
        }
        function D(...v) {
          function w(...O) {
            for (const G of v)
              G(...O);
          }
          if (w.chainOf = v, v.length >= 2 && "type" in v[0] && v[0].type === "array" && !("each" in v[1]))
            throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
          return w;
        }
        r.NODE_PARENT_VALIDATIONS = b;
        const j = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], F = ["default", "optional", "deprecated", "validate"], _ = {};
        function T(v, w = {}) {
          const O = w.inherits && _[w.inherits] || {};
          let G = w.fields;
          if (!G && (G = {}, O.fields)) {
            const B = Object.getOwnPropertyNames(O.fields);
            for (const k of B) {
              const K = O.fields[k], te = K.default;
              if (Array.isArray(te) ? te.length > 0 : te && typeof te == "object")
                throw new Error("field defaults can only be primitives or empty arrays currently");
              G[k] = { default: Array.isArray(te) ? [] : te, optional: K.optional, deprecated: K.deprecated, validate: K.validate };
            }
          }
          const W = w.visitor || O.visitor || [], U = w.aliases || O.aliases || [], M = w.builder || O.builder || w.visitor || [];
          for (const B of Object.keys(w))
            if (j.indexOf(B) === -1)
              throw new Error(`Unknown type option "${B}" on ${v}`);
          w.deprecatedAlias && (y[w.deprecatedAlias] = v);
          for (const B of W.concat(M))
            G[B] = G[B] || {};
          for (const B of Object.keys(G)) {
            const k = G[B];
            k.default !== void 0 && M.indexOf(B) === -1 && (k.optional = !0), k.default === void 0 ? k.default = null : k.validate || k.default == null || (k.validate = I(E(k.default)));
            for (const K of Object.keys(k))
              if (F.indexOf(K) === -1)
                throw new Error(`Unknown field key "${K}" on ${v}.${B}`);
          }
          d[v] = w.visitor = W, h[v] = w.builder = M, m[v] = w.fields = G, s[v] = w.aliases = U, U.forEach((B) => {
            o[B] = o[B] || [], o[B].push(v);
          }), w.validate && (b[v] = w.validate), _[v] = w;
        }
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 });
        var i = { react: !0, assertNode: !0, createTypeAnnotationBasedOnTypeof: !0, createUnionTypeAnnotation: !0, createFlowUnionType: !0, createTSUnionType: !0, cloneNode: !0, clone: !0, cloneDeep: !0, cloneDeepWithoutLoc: !0, cloneWithoutLoc: !0, addComment: !0, addComments: !0, inheritInnerComments: !0, inheritLeadingComments: !0, inheritsComments: !0, inheritTrailingComments: !0, removeComments: !0, ensureBlock: !0, toBindingIdentifierName: !0, toBlock: !0, toComputedKey: !0, toExpression: !0, toIdentifier: !0, toKeyAlias: !0, toSequenceExpression: !0, toStatement: !0, valueToNode: !0, appendToMemberExpression: !0, inherits: !0, prependToMemberExpression: !0, removeProperties: !0, removePropertiesDeep: !0, removeTypeDuplicates: !0, getBindingIdentifiers: !0, getOuterBindingIdentifiers: !0, traverse: !0, traverseFast: !0, shallowEqual: !0, is: !0, isBinding: !0, isBlockScoped: !0, isImmutable: !0, isLet: !0, isNode: !0, isNodesEquivalent: !0, isPlaceholderType: !0, isReferenced: !0, isScope: !0, isSpecifierDefault: !0, isType: !0, isValidES3Identifier: !0, isValidIdentifier: !0, isVar: !0, matchesPattern: !0, validate: !0, buildMatchMemberExpression: !0, __internal__deprecationWarning: !0 };
        Object.defineProperty(r, "__internal__deprecationWarning", { enumerable: !0, get: function() {
          return ct.default;
        } }), Object.defineProperty(r, "addComment", { enumerable: !0, get: function() {
          return I.default;
        } }), Object.defineProperty(r, "addComments", { enumerable: !0, get: function() {
          return D.default;
        } }), Object.defineProperty(r, "appendToMemberExpression", { enumerable: !0, get: function() {
          return Y.default;
        } }), Object.defineProperty(r, "assertNode", { enumerable: !0, get: function() {
          return o.default;
        } }), Object.defineProperty(r, "buildMatchMemberExpression", { enumerable: !0, get: function() {
          return Ye.default;
        } }), Object.defineProperty(r, "clone", { enumerable: !0, get: function() {
          return P.default;
        } }), Object.defineProperty(r, "cloneDeep", { enumerable: !0, get: function() {
          return R.default;
        } }), Object.defineProperty(r, "cloneDeepWithoutLoc", { enumerable: !0, get: function() {
          return N.default;
        } }), Object.defineProperty(r, "cloneNode", { enumerable: !0, get: function() {
          return g.default;
        } }), Object.defineProperty(r, "cloneWithoutLoc", { enumerable: !0, get: function() {
          return C.default;
        } }), Object.defineProperty(r, "createFlowUnionType", { enumerable: !0, get: function() {
          return y.default;
        } }), Object.defineProperty(r, "createTSUnionType", { enumerable: !0, get: function() {
          return b.default;
        } }), Object.defineProperty(r, "createTypeAnnotationBasedOnTypeof", { enumerable: !0, get: function() {
          return h.default;
        } }), Object.defineProperty(r, "createUnionTypeAnnotation", { enumerable: !0, get: function() {
          return y.default;
        } }), Object.defineProperty(r, "ensureBlock", { enumerable: !0, get: function() {
          return G.default;
        } }), Object.defineProperty(r, "getBindingIdentifiers", { enumerable: !0, get: function() {
          return ve.default;
        } }), Object.defineProperty(r, "getOuterBindingIdentifiers", { enumerable: !0, get: function() {
          return de.default;
        } }), Object.defineProperty(r, "inheritInnerComments", { enumerable: !0, get: function() {
          return j.default;
        } }), Object.defineProperty(r, "inheritLeadingComments", { enumerable: !0, get: function() {
          return F.default;
        } }), Object.defineProperty(r, "inheritTrailingComments", { enumerable: !0, get: function() {
          return T.default;
        } }), Object.defineProperty(r, "inherits", { enumerable: !0, get: function() {
          return H.default;
        } }), Object.defineProperty(r, "inheritsComments", { enumerable: !0, get: function() {
          return _.default;
        } }), Object.defineProperty(r, "is", { enumerable: !0, get: function() {
          return le.default;
        } }), Object.defineProperty(r, "isBinding", { enumerable: !0, get: function() {
          return ue.default;
        } }), Object.defineProperty(r, "isBlockScoped", { enumerable: !0, get: function() {
          return ie.default;
        } }), Object.defineProperty(r, "isImmutable", { enumerable: !0, get: function() {
          return we.default;
        } }), Object.defineProperty(r, "isLet", { enumerable: !0, get: function() {
          return De.default;
        } }), Object.defineProperty(r, "isNode", { enumerable: !0, get: function() {
          return Ee.default;
        } }), Object.defineProperty(r, "isNodesEquivalent", { enumerable: !0, get: function() {
          return Ae.default;
        } }), Object.defineProperty(r, "isPlaceholderType", { enumerable: !0, get: function() {
          return Me.default;
        } }), Object.defineProperty(r, "isReferenced", { enumerable: !0, get: function() {
          return me.default;
        } }), Object.defineProperty(r, "isScope", { enumerable: !0, get: function() {
          return se.default;
        } }), Object.defineProperty(r, "isSpecifierDefault", { enumerable: !0, get: function() {
          return Z.default;
        } }), Object.defineProperty(r, "isType", { enumerable: !0, get: function() {
          return pe.default;
        } }), Object.defineProperty(r, "isValidES3Identifier", { enumerable: !0, get: function() {
          return be.default;
        } }), Object.defineProperty(r, "isValidIdentifier", { enumerable: !0, get: function() {
          return _e.default;
        } }), Object.defineProperty(r, "isVar", { enumerable: !0, get: function() {
          return Ie.default;
        } }), Object.defineProperty(r, "matchesPattern", { enumerable: !0, get: function() {
          return We.default;
        } }), Object.defineProperty(r, "prependToMemberExpression", { enumerable: !0, get: function() {
          return Q.default;
        } }), r.react = void 0, Object.defineProperty(r, "removeComments", { enumerable: !0, get: function() {
          return v.default;
        } }), Object.defineProperty(r, "removeProperties", { enumerable: !0, get: function() {
          return X.default;
        } }), Object.defineProperty(r, "removePropertiesDeep", { enumerable: !0, get: function() {
          return ne.default;
        } }), Object.defineProperty(r, "removeTypeDuplicates", { enumerable: !0, get: function() {
          return ye.default;
        } }), Object.defineProperty(r, "shallowEqual", { enumerable: !0, get: function() {
          return ae.default;
        } }), Object.defineProperty(r, "toBindingIdentifierName", { enumerable: !0, get: function() {
          return W.default;
        } }), Object.defineProperty(r, "toBlock", { enumerable: !0, get: function() {
          return U.default;
        } }), Object.defineProperty(r, "toComputedKey", { enumerable: !0, get: function() {
          return M.default;
        } }), Object.defineProperty(r, "toExpression", { enumerable: !0, get: function() {
          return B.default;
        } }), Object.defineProperty(r, "toIdentifier", { enumerable: !0, get: function() {
          return k.default;
        } }), Object.defineProperty(r, "toKeyAlias", { enumerable: !0, get: function() {
          return K.default;
        } }), Object.defineProperty(r, "toSequenceExpression", { enumerable: !0, get: function() {
          return te.default;
        } }), Object.defineProperty(r, "toStatement", { enumerable: !0, get: function() {
          return z.default;
        } }), Object.defineProperty(r, "traverse", { enumerable: !0, get: function() {
          return oe.default;
        } }), Object.defineProperty(r, "traverseFast", { enumerable: !0, get: function() {
          return re.default;
        } }), Object.defineProperty(r, "validate", { enumerable: !0, get: function() {
          return tt.default;
        } }), Object.defineProperty(r, "valueToNode", { enumerable: !0, get: function() {
          return q.default;
        } });
        var f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/react/isReactComponent.js"), d = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/react/isCompatTag.js"), s = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/react/buildChildren.js"), o = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/asserts/assertNode.js"), m = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/asserts/generated/index.js");
        Object.keys(m).forEach(function(Xe) {
          Xe !== "default" && Xe !== "__esModule" && (Object.prototype.hasOwnProperty.call(i, Xe) || Xe in r && r[Xe] === m[Xe] || Object.defineProperty(r, Xe, { enumerable: !0, get: function() {
            return m[Xe];
          } }));
        });
        var h = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"), y = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"), b = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"), E = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/generated/index.js");
        Object.keys(E).forEach(function(Xe) {
          Xe !== "default" && Xe !== "__esModule" && (Object.prototype.hasOwnProperty.call(i, Xe) || Xe in r && r[Xe] === E[Xe] || Object.defineProperty(r, Xe, { enumerable: !0, get: function() {
            return E[Xe];
          } }));
        });
        var S = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/generated/uppercase.js");
        Object.keys(S).forEach(function(Xe) {
          Xe !== "default" && Xe !== "__esModule" && (Object.prototype.hasOwnProperty.call(i, Xe) || Xe in r && r[Xe] === S[Xe] || Object.defineProperty(r, Xe, { enumerable: !0, get: function() {
            return S[Xe];
          } }));
        });
        var g = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/clone/cloneNode.js"), P = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/clone/clone.js"), R = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/clone/cloneDeep.js"), N = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"), C = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"), I = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/comments/addComment.js"), D = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/comments/addComments.js"), j = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/comments/inheritInnerComments.js"), F = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/comments/inheritLeadingComments.js"), _ = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/comments/inheritsComments.js"), T = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/comments/inheritTrailingComments.js"), v = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/comments/removeComments.js"), w = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/constants/generated/index.js");
        Object.keys(w).forEach(function(Xe) {
          Xe !== "default" && Xe !== "__esModule" && (Object.prototype.hasOwnProperty.call(i, Xe) || Xe in r && r[Xe] === w[Xe] || Object.defineProperty(r, Xe, { enumerable: !0, get: function() {
            return w[Xe];
          } }));
        });
        var O = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/constants/index.js");
        Object.keys(O).forEach(function(Xe) {
          Xe !== "default" && Xe !== "__esModule" && (Object.prototype.hasOwnProperty.call(i, Xe) || Xe in r && r[Xe] === O[Xe] || Object.defineProperty(r, Xe, { enumerable: !0, get: function() {
            return O[Xe];
          } }));
        });
        var G = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/ensureBlock.js"), W = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"), U = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/toBlock.js"), M = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/toComputedKey.js"), B = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/toExpression.js"), k = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/toIdentifier.js"), K = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/toKeyAlias.js"), te = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/toSequenceExpression.js"), z = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/toStatement.js"), q = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/converters/valueToNode.js"), $ = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/index.js");
        Object.keys($).forEach(function(Xe) {
          Xe !== "default" && Xe !== "__esModule" && (Object.prototype.hasOwnProperty.call(i, Xe) || Xe in r && r[Xe] === $[Xe] || Object.defineProperty(r, Xe, { enumerable: !0, get: function() {
            return $[Xe];
          } }));
        });
        var Y = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"), H = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/modifications/inherits.js"), Q = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"), X = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/modifications/removeProperties.js"), ne = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"), ye = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"), ve = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"), de = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"), oe = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/traverse/traverse.js");
        Object.keys(oe).forEach(function(Xe) {
          Xe !== "default" && Xe !== "__esModule" && (Object.prototype.hasOwnProperty.call(i, Xe) || Xe in r && r[Xe] === oe[Xe] || Object.defineProperty(r, Xe, { enumerable: !0, get: function() {
            return oe[Xe];
          } }));
        });
        var re = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/traverse/traverseFast.js"), ae = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/utils/shallowEqual.js"), le = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/is.js"), ue = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isBinding.js"), ie = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isBlockScoped.js"), we = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isImmutable.js"), De = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isLet.js"), Ee = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isNode.js"), Ae = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isNodesEquivalent.js"), Me = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isPlaceholderType.js"), me = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isReferenced.js"), se = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isScope.js"), Z = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isSpecifierDefault.js"), pe = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isType.js"), be = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isValidES3Identifier.js"), _e = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isValidIdentifier.js"), Ie = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isVar.js"), We = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/matchesPattern.js"), tt = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/validate.js"), Ye = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"), ht = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js");
        Object.keys(ht).forEach(function(Xe) {
          Xe !== "default" && Xe !== "__esModule" && (Object.prototype.hasOwnProperty.call(i, Xe) || Xe in r && r[Xe] === ht[Xe] || Object.defineProperty(r, Xe, { enumerable: !0, get: function() {
            return ht[Xe];
          } }));
        });
        var ct = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/utils/deprecationWarning.js");
        const st = { isReactComponent: f.default, isCompatTag: d.default, buildChildren: s.default };
        r.react = st;
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f, d, s = !1) {
          return f.object = (0, i.memberExpression)(f.object, f.property, f.computed), f.property = d, f.computed = !!s, f;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function d(s) {
          const o = Array.from(s), m = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Set(), b = [];
          for (let E = 0; E < o.length; E++) {
            const S = o[E];
            if (S && !(b.indexOf(S) >= 0)) {
              if ((0, i.isAnyTypeAnnotation)(S))
                return [S];
              if ((0, i.isFlowBaseAnnotation)(S))
                h.set(S.type, S);
              else if ((0, i.isUnionTypeAnnotation)(S))
                y.has(S.types) || (o.push(...S.types), y.add(S.types));
              else if ((0, i.isGenericTypeAnnotation)(S)) {
                const g = f(S.id);
                if (m.has(g)) {
                  let P = m.get(g);
                  P.typeParameters ? S.typeParameters && (P.typeParameters.params.push(...S.typeParameters.params), P.typeParameters.params = d(P.typeParameters.params)) : P = S.typeParameters;
                } else
                  m.set(g, S);
              } else
                b.push(S);
            }
          }
          for (const [, E] of h)
            b.push(E);
          for (const [, E] of m)
            b.push(E);
          return b;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js");
        function f(d) {
          return (0, i.isIdentifier)(d) ? d.name : `${d.id.name}.${f(d.qualification)}`;
        }
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/modifications/inherits.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(d, s) {
          if (!d || !s)
            return d;
          for (const o of i.INHERIT_KEYS.optional)
            d[o] == null && (d[o] = s[o]);
          for (const o of Object.keys(s))
            o[0] === "_" && o !== "__clone" && (d[o] = s[o]);
          for (const o of i.INHERIT_KEYS.force)
            d[o] = s[o];
          return (0, f.default)(d, s), d;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/constants/index.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/comments/inheritsComments.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(d, s) {
          if ((0, f.isSuper)(d.object))
            throw new Error("Cannot prepend node to super property access (`super.foo`).");
          return d.object = (0, i.memberExpression)(s, d.object), d;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/generated/index.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/modifications/removeProperties.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(s, o = {}) {
          const m = o.preserveComments ? f : d;
          for (const y of m)
            s[y] != null && (s[y] = void 0);
          for (const y of Object.keys(s))
            y[0] === "_" && s[y] != null && (s[y] = void 0);
          const h = Object.getOwnPropertySymbols(s);
          for (const y of h)
            s[y] = null;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/constants/index.js");
        const f = ["tokens", "start", "end", "loc", "raw", "rawValue"], d = [...i.COMMENT_KEYS, "comments", ...f];
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(d, s) {
          return (0, i.default)(d, f.default, s), d;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/traverse/traverseFast.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/modifications/removeProperties.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function d(s) {
          const o = Array.from(s), m = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Set(), b = [];
          for (let E = 0; E < o.length; E++) {
            const S = o[E];
            if (S && !(b.indexOf(S) >= 0)) {
              if ((0, i.isTSAnyKeyword)(S))
                return [S];
              if ((0, i.isTSBaseType)(S))
                h.set(S.type, S);
              else if ((0, i.isTSUnionType)(S))
                y.has(S.types) || (o.push(...S.types), y.add(S.types));
              else if ((0, i.isTSTypeReference)(S) && S.typeParameters) {
                const g = f(S.typeName);
                if (m.has(g)) {
                  let P = m.get(g);
                  P.typeParameters ? S.typeParameters && (P.typeParameters.params.push(...S.typeParameters.params), P.typeParameters.params = d(P.typeParameters.params)) : P = S.typeParameters;
                } else
                  m.set(g, S);
              } else
                b.push(S);
            }
          }
          for (const [, E] of h)
            b.push(E);
          for (const [, E] of m)
            b.push(E);
          return b;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js");
        function f(d) {
          return (0, i.isIdentifier)(d) ? d.name : `${d.right.name}.${f(d.left)}`;
        }
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = f;
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js");
        function f(d, s, o) {
          const m = [].concat(d), h = /* @__PURE__ */ Object.create(null);
          for (; m.length; ) {
            const y = m.shift();
            if (!y)
              continue;
            const b = f.keys[y.type];
            if ((0, i.isIdentifier)(y))
              s ? (h[y.name] = h[y.name] || []).push(y) : h[y.name] = y;
            else if (!(0, i.isExportDeclaration)(y) || (0, i.isExportAllDeclaration)(y)) {
              if (o) {
                if ((0, i.isFunctionDeclaration)(y)) {
                  m.push(y.id);
                  continue;
                }
                if ((0, i.isFunctionExpression)(y))
                  continue;
              }
              if (b)
                for (let E = 0; E < b.length; E++) {
                  const S = y[b[E]];
                  S && (Array.isArray(S) ? m.push(...S) : m.push(S));
                }
            } else
              (0, i.isDeclaration)(y.declaration) && m.push(y.declaration);
          }
          return h;
        }
        f.keys = { DeclareClass: ["id"], DeclareFunction: ["id"], DeclareModule: ["id"], DeclareVariable: ["id"], DeclareInterface: ["id"], DeclareTypeAlias: ["id"], DeclareOpaqueType: ["id"], InterfaceDeclaration: ["id"], TypeAlias: ["id"], OpaqueType: ["id"], CatchClause: ["param"], LabeledStatement: ["label"], UnaryExpression: ["argument"], AssignmentExpression: ["left"], ImportSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportDefaultSpecifier: ["local"], ImportDeclaration: ["specifiers"], ExportSpecifier: ["exported"], ExportNamespaceSpecifier: ["exported"], ExportDefaultSpecifier: ["exported"], FunctionDeclaration: ["id", "params"], FunctionExpression: ["id", "params"], ArrowFunctionExpression: ["params"], ObjectMethod: ["params"], ClassMethod: ["params"], ClassPrivateMethod: ["params"], ForInStatement: ["left"], ForOfStatement: ["left"], ClassDeclaration: ["id"], ClassExpression: ["id"], RestElement: ["argument"], UpdateExpression: ["argument"], ObjectProperty: ["value"], AssignmentPattern: ["left"], ArrayPattern: ["elements"], ObjectPattern: ["properties"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id"] };
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"), f = function(d, s) {
          return (0, i.default)(d, s, !0);
        };
        r.default = f;
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/traverse/traverse.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(d, s, o) {
          typeof s == "function" && (s = { enter: s });
          const { enter: m, exit: h } = s;
          f(d, m, h, o, []);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/index.js");
        function f(d, s, o, m, h) {
          const y = i.VISITOR_KEYS[d.type];
          if (y) {
            s && s(d, h, m);
            for (const b of y) {
              const E = d[b];
              if (Array.isArray(E))
                for (let S = 0; S < E.length; S++) {
                  const g = E[S];
                  g && (h.push({ node: d, key: b, index: S }), f(g, s, o, m, h), h.pop());
                }
              else
                E && (h.push({ node: d, key: b }), f(E, s, o, m, h), h.pop());
            }
            o && o(d, h, m);
          }
        }
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/traverse/traverseFast.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function f(d, s, o) {
          if (!d)
            return;
          const m = i.VISITOR_KEYS[d.type];
          if (m) {
            s(d, o = o || {});
            for (const h of m) {
              const y = d[h];
              if (Array.isArray(y))
                for (const b of y)
                  f(b, s, o);
              else
                f(y, s, o);
            }
          }
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/utils/deprecationWarning.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(i, f, d = "") {
          if (l.has(i))
            return;
          l.add(i);
          const { internal: s, trace: o } = function(m, h) {
            const { stackTraceLimit: y, prepareStackTrace: b } = Error;
            let E;
            if (Error.stackTraceLimit = 1 + m + h, Error.prepareStackTrace = function(g, P) {
              E = P;
            }, new Error().stack, Error.stackTraceLimit = y, Error.prepareStackTrace = b, !E)
              return { internal: !1, trace: "" };
            const S = E.slice(1 + m, 1 + m + h);
            return { internal: /[\\/]@babel[\\/]/.test(S[1].getFileName()), trace: S.map((g) => `    at ${g}`).join(`
`) };
          }(1, 2);
          s || console.warn(`${d}\`${i}\` has been deprecated, please migrate to \`${f}\`
${o}`);
        };
        const l = /* @__PURE__ */ new Set();
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/utils/inherit.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(l, i, f) {
          i && f && (i[l] = Array.from(new Set([].concat(i[l], f[l]).filter(Boolean))));
        };
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(d, s) {
          const o = d.value.split(/\r\n|\n|\r/);
          let m = 0;
          for (let y = 0; y < o.length; y++)
            o[y].match(/[^ \t]/) && (m = y);
          let h = "";
          for (let y = 0; y < o.length; y++) {
            const b = o[y], E = y === 0, S = y === o.length - 1, g = y === m;
            let P = b.replace(/\t/g, " ");
            E || (P = P.replace(/^[ ]+/, "")), S || (P = P.replace(/[ ]+$/, "")), P && (g || (P += " "), h += P);
          }
          h && s.push((0, f.inherits)((0, i.stringLiteral)(h), d));
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/builders/generated/index.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/utils/shallowEqual.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(l, i) {
          const f = Object.keys(i);
          for (const d of f)
            if (l[d] !== i[d])
              return !1;
          return !0;
        };
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f, d) {
          const s = f.split(".");
          return (o) => (0, i.default)(o, s, d);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/matchesPattern.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.isAccessor = function(s, o) {
          return !s || s.type !== "ClassAccessorProperty" ? !1 : o == null || (0, i.default)(s, o);
        }, r.isAnyTypeAnnotation = function(s, o) {
          return !!s && s.type === "AnyTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isArgumentPlaceholder = function(s, o) {
          return !!s && s.type === "ArgumentPlaceholder" && (o == null || (0, i.default)(s, o));
        }, r.isArrayExpression = function(s, o) {
          return !!s && s.type === "ArrayExpression" && (o == null || (0, i.default)(s, o));
        }, r.isArrayPattern = function(s, o) {
          return !!s && s.type === "ArrayPattern" && (o == null || (0, i.default)(s, o));
        }, r.isArrayTypeAnnotation = function(s, o) {
          return !!s && s.type === "ArrayTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isArrowFunctionExpression = function(s, o) {
          return !!s && s.type === "ArrowFunctionExpression" && (o == null || (0, i.default)(s, o));
        }, r.isAssignmentExpression = function(s, o) {
          return !!s && s.type === "AssignmentExpression" && (o == null || (0, i.default)(s, o));
        }, r.isAssignmentPattern = function(s, o) {
          return !!s && s.type === "AssignmentPattern" && (o == null || (0, i.default)(s, o));
        }, r.isAwaitExpression = function(s, o) {
          return !!s && s.type === "AwaitExpression" && (o == null || (0, i.default)(s, o));
        }, r.isBigIntLiteral = function(s, o) {
          return !!s && s.type === "BigIntLiteral" && (o == null || (0, i.default)(s, o));
        }, r.isBinary = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "BinaryExpression":
            case "LogicalExpression":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isBinaryExpression = function(s, o) {
          return !!s && s.type === "BinaryExpression" && (o == null || (0, i.default)(s, o));
        }, r.isBindExpression = function(s, o) {
          return !!s && s.type === "BindExpression" && (o == null || (0, i.default)(s, o));
        }, r.isBlock = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "BlockStatement":
            case "Program":
            case "TSModuleBlock":
              break;
            case "Placeholder":
              if (s.expectedNode === "BlockStatement")
                break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isBlockParent = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "BlockStatement":
            case "CatchClause":
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "Program":
            case "ObjectMethod":
            case "SwitchStatement":
            case "WhileStatement":
            case "ArrowFunctionExpression":
            case "ForOfStatement":
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "StaticBlock":
            case "TSModuleBlock":
              break;
            case "Placeholder":
              if (s.expectedNode === "BlockStatement")
                break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isBlockStatement = function(s, o) {
          return !!s && s.type === "BlockStatement" && (o == null || (0, i.default)(s, o));
        }, r.isBooleanLiteral = function(s, o) {
          return !!s && s.type === "BooleanLiteral" && (o == null || (0, i.default)(s, o));
        }, r.isBooleanLiteralTypeAnnotation = function(s, o) {
          return !!s && s.type === "BooleanLiteralTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isBooleanTypeAnnotation = function(s, o) {
          return !!s && s.type === "BooleanTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isBreakStatement = function(s, o) {
          return !!s && s.type === "BreakStatement" && (o == null || (0, i.default)(s, o));
        }, r.isCallExpression = function(s, o) {
          return !!s && s.type === "CallExpression" && (o == null || (0, i.default)(s, o));
        }, r.isCatchClause = function(s, o) {
          return !!s && s.type === "CatchClause" && (o == null || (0, i.default)(s, o));
        }, r.isClass = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "ClassExpression":
            case "ClassDeclaration":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isClassAccessorProperty = function(s, o) {
          return !!s && s.type === "ClassAccessorProperty" && (o == null || (0, i.default)(s, o));
        }, r.isClassBody = function(s, o) {
          return !!s && s.type === "ClassBody" && (o == null || (0, i.default)(s, o));
        }, r.isClassDeclaration = function(s, o) {
          return !!s && s.type === "ClassDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isClassExpression = function(s, o) {
          return !!s && s.type === "ClassExpression" && (o == null || (0, i.default)(s, o));
        }, r.isClassImplements = function(s, o) {
          return !!s && s.type === "ClassImplements" && (o == null || (0, i.default)(s, o));
        }, r.isClassMethod = function(s, o) {
          return !!s && s.type === "ClassMethod" && (o == null || (0, i.default)(s, o));
        }, r.isClassPrivateMethod = function(s, o) {
          return !!s && s.type === "ClassPrivateMethod" && (o == null || (0, i.default)(s, o));
        }, r.isClassPrivateProperty = function(s, o) {
          return !!s && s.type === "ClassPrivateProperty" && (o == null || (0, i.default)(s, o));
        }, r.isClassProperty = function(s, o) {
          return !!s && s.type === "ClassProperty" && (o == null || (0, i.default)(s, o));
        }, r.isCompletionStatement = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "BreakStatement":
            case "ContinueStatement":
            case "ReturnStatement":
            case "ThrowStatement":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isConditional = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "ConditionalExpression":
            case "IfStatement":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isConditionalExpression = function(s, o) {
          return !!s && s.type === "ConditionalExpression" && (o == null || (0, i.default)(s, o));
        }, r.isContinueStatement = function(s, o) {
          return !!s && s.type === "ContinueStatement" && (o == null || (0, i.default)(s, o));
        }, r.isDebuggerStatement = function(s, o) {
          return !!s && s.type === "DebuggerStatement" && (o == null || (0, i.default)(s, o));
        }, r.isDecimalLiteral = function(s, o) {
          return !!s && s.type === "DecimalLiteral" && (o == null || (0, i.default)(s, o));
        }, r.isDeclaration = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "FunctionDeclaration":
            case "VariableDeclaration":
            case "ClassDeclaration":
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "InterfaceDeclaration":
            case "OpaqueType":
            case "TypeAlias":
            case "EnumDeclaration":
            case "TSDeclareFunction":
            case "TSInterfaceDeclaration":
            case "TSTypeAliasDeclaration":
            case "TSEnumDeclaration":
            case "TSModuleDeclaration":
              break;
            case "Placeholder":
              if (s.expectedNode === "Declaration")
                break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isDeclareClass = function(s, o) {
          return !!s && s.type === "DeclareClass" && (o == null || (0, i.default)(s, o));
        }, r.isDeclareExportAllDeclaration = function(s, o) {
          return !!s && s.type === "DeclareExportAllDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isDeclareExportDeclaration = function(s, o) {
          return !!s && s.type === "DeclareExportDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isDeclareFunction = function(s, o) {
          return !!s && s.type === "DeclareFunction" && (o == null || (0, i.default)(s, o));
        }, r.isDeclareInterface = function(s, o) {
          return !!s && s.type === "DeclareInterface" && (o == null || (0, i.default)(s, o));
        }, r.isDeclareModule = function(s, o) {
          return !!s && s.type === "DeclareModule" && (o == null || (0, i.default)(s, o));
        }, r.isDeclareModuleExports = function(s, o) {
          return !!s && s.type === "DeclareModuleExports" && (o == null || (0, i.default)(s, o));
        }, r.isDeclareOpaqueType = function(s, o) {
          return !!s && s.type === "DeclareOpaqueType" && (o == null || (0, i.default)(s, o));
        }, r.isDeclareTypeAlias = function(s, o) {
          return !!s && s.type === "DeclareTypeAlias" && (o == null || (0, i.default)(s, o));
        }, r.isDeclareVariable = function(s, o) {
          return !!s && s.type === "DeclareVariable" && (o == null || (0, i.default)(s, o));
        }, r.isDeclaredPredicate = function(s, o) {
          return !!s && s.type === "DeclaredPredicate" && (o == null || (0, i.default)(s, o));
        }, r.isDecorator = function(s, o) {
          return !!s && s.type === "Decorator" && (o == null || (0, i.default)(s, o));
        }, r.isDirective = function(s, o) {
          return !!s && s.type === "Directive" && (o == null || (0, i.default)(s, o));
        }, r.isDirectiveLiteral = function(s, o) {
          return !!s && s.type === "DirectiveLiteral" && (o == null || (0, i.default)(s, o));
        }, r.isDoExpression = function(s, o) {
          return !!s && s.type === "DoExpression" && (o == null || (0, i.default)(s, o));
        }, r.isDoWhileStatement = function(s, o) {
          return !!s && s.type === "DoWhileStatement" && (o == null || (0, i.default)(s, o));
        }, r.isEmptyStatement = function(s, o) {
          return !!s && s.type === "EmptyStatement" && (o == null || (0, i.default)(s, o));
        }, r.isEmptyTypeAnnotation = function(s, o) {
          return !!s && s.type === "EmptyTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isEnumBody = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "EnumBooleanBody":
            case "EnumNumberBody":
            case "EnumStringBody":
            case "EnumSymbolBody":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isEnumBooleanBody = function(s, o) {
          return !!s && s.type === "EnumBooleanBody" && (o == null || (0, i.default)(s, o));
        }, r.isEnumBooleanMember = function(s, o) {
          return !!s && s.type === "EnumBooleanMember" && (o == null || (0, i.default)(s, o));
        }, r.isEnumDeclaration = function(s, o) {
          return !!s && s.type === "EnumDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isEnumDefaultedMember = function(s, o) {
          return !!s && s.type === "EnumDefaultedMember" && (o == null || (0, i.default)(s, o));
        }, r.isEnumMember = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "EnumBooleanMember":
            case "EnumNumberMember":
            case "EnumStringMember":
            case "EnumDefaultedMember":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isEnumNumberBody = function(s, o) {
          return !!s && s.type === "EnumNumberBody" && (o == null || (0, i.default)(s, o));
        }, r.isEnumNumberMember = function(s, o) {
          return !!s && s.type === "EnumNumberMember" && (o == null || (0, i.default)(s, o));
        }, r.isEnumStringBody = function(s, o) {
          return !!s && s.type === "EnumStringBody" && (o == null || (0, i.default)(s, o));
        }, r.isEnumStringMember = function(s, o) {
          return !!s && s.type === "EnumStringMember" && (o == null || (0, i.default)(s, o));
        }, r.isEnumSymbolBody = function(s, o) {
          return !!s && s.type === "EnumSymbolBody" && (o == null || (0, i.default)(s, o));
        }, r.isExistsTypeAnnotation = function(s, o) {
          return !!s && s.type === "ExistsTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isExportAllDeclaration = function(s, o) {
          return !!s && s.type === "ExportAllDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isExportDeclaration = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isExportDefaultDeclaration = function(s, o) {
          return !!s && s.type === "ExportDefaultDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isExportDefaultSpecifier = function(s, o) {
          return !!s && s.type === "ExportDefaultSpecifier" && (o == null || (0, i.default)(s, o));
        }, r.isExportNamedDeclaration = function(s, o) {
          return !!s && s.type === "ExportNamedDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isExportNamespaceSpecifier = function(s, o) {
          return !!s && s.type === "ExportNamespaceSpecifier" && (o == null || (0, i.default)(s, o));
        }, r.isExportSpecifier = function(s, o) {
          return !!s && s.type === "ExportSpecifier" && (o == null || (0, i.default)(s, o));
        }, r.isExpression = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "ArrayExpression":
            case "AssignmentExpression":
            case "BinaryExpression":
            case "CallExpression":
            case "ConditionalExpression":
            case "FunctionExpression":
            case "Identifier":
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "LogicalExpression":
            case "MemberExpression":
            case "NewExpression":
            case "ObjectExpression":
            case "SequenceExpression":
            case "ParenthesizedExpression":
            case "ThisExpression":
            case "UnaryExpression":
            case "UpdateExpression":
            case "ArrowFunctionExpression":
            case "ClassExpression":
            case "MetaProperty":
            case "Super":
            case "TaggedTemplateExpression":
            case "TemplateLiteral":
            case "YieldExpression":
            case "AwaitExpression":
            case "Import":
            case "BigIntLiteral":
            case "OptionalMemberExpression":
            case "OptionalCallExpression":
            case "TypeCastExpression":
            case "JSXElement":
            case "JSXFragment":
            case "BindExpression":
            case "DoExpression":
            case "RecordExpression":
            case "TupleExpression":
            case "DecimalLiteral":
            case "ModuleExpression":
            case "TopicReference":
            case "PipelineTopicExpression":
            case "PipelineBareFunction":
            case "PipelinePrimaryTopicReference":
            case "TSInstantiationExpression":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              break;
            case "Placeholder":
              switch (s.expectedNode) {
                case "Expression":
                case "Identifier":
                case "StringLiteral":
                  break;
                default:
                  return !1;
              }
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isExpressionStatement = function(s, o) {
          return !!s && s.type === "ExpressionStatement" && (o == null || (0, i.default)(s, o));
        }, r.isExpressionWrapper = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "ExpressionStatement":
            case "ParenthesizedExpression":
            case "TypeCastExpression":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isFile = function(s, o) {
          return !!s && s.type === "File" && (o == null || (0, i.default)(s, o));
        }, r.isFlow = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "AnyTypeAnnotation":
            case "ArrayTypeAnnotation":
            case "BooleanTypeAnnotation":
            case "BooleanLiteralTypeAnnotation":
            case "NullLiteralTypeAnnotation":
            case "ClassImplements":
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "DeclaredPredicate":
            case "ExistsTypeAnnotation":
            case "FunctionTypeAnnotation":
            case "FunctionTypeParam":
            case "GenericTypeAnnotation":
            case "InferredPredicate":
            case "InterfaceExtends":
            case "InterfaceDeclaration":
            case "InterfaceTypeAnnotation":
            case "IntersectionTypeAnnotation":
            case "MixedTypeAnnotation":
            case "EmptyTypeAnnotation":
            case "NullableTypeAnnotation":
            case "NumberLiteralTypeAnnotation":
            case "NumberTypeAnnotation":
            case "ObjectTypeAnnotation":
            case "ObjectTypeInternalSlot":
            case "ObjectTypeCallProperty":
            case "ObjectTypeIndexer":
            case "ObjectTypeProperty":
            case "ObjectTypeSpreadProperty":
            case "OpaqueType":
            case "QualifiedTypeIdentifier":
            case "StringLiteralTypeAnnotation":
            case "StringTypeAnnotation":
            case "SymbolTypeAnnotation":
            case "ThisTypeAnnotation":
            case "TupleTypeAnnotation":
            case "TypeofTypeAnnotation":
            case "TypeAlias":
            case "TypeAnnotation":
            case "TypeCastExpression":
            case "TypeParameter":
            case "TypeParameterDeclaration":
            case "TypeParameterInstantiation":
            case "UnionTypeAnnotation":
            case "Variance":
            case "VoidTypeAnnotation":
            case "EnumDeclaration":
            case "EnumBooleanBody":
            case "EnumNumberBody":
            case "EnumStringBody":
            case "EnumSymbolBody":
            case "EnumBooleanMember":
            case "EnumNumberMember":
            case "EnumStringMember":
            case "EnumDefaultedMember":
            case "IndexedAccessType":
            case "OptionalIndexedAccessType":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isFlowBaseAnnotation = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "AnyTypeAnnotation":
            case "BooleanTypeAnnotation":
            case "NullLiteralTypeAnnotation":
            case "MixedTypeAnnotation":
            case "EmptyTypeAnnotation":
            case "NumberTypeAnnotation":
            case "StringTypeAnnotation":
            case "SymbolTypeAnnotation":
            case "ThisTypeAnnotation":
            case "VoidTypeAnnotation":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isFlowDeclaration = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "InterfaceDeclaration":
            case "OpaqueType":
            case "TypeAlias":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isFlowPredicate = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "DeclaredPredicate":
            case "InferredPredicate":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isFlowType = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "AnyTypeAnnotation":
            case "ArrayTypeAnnotation":
            case "BooleanTypeAnnotation":
            case "BooleanLiteralTypeAnnotation":
            case "NullLiteralTypeAnnotation":
            case "ExistsTypeAnnotation":
            case "FunctionTypeAnnotation":
            case "GenericTypeAnnotation":
            case "InterfaceTypeAnnotation":
            case "IntersectionTypeAnnotation":
            case "MixedTypeAnnotation":
            case "EmptyTypeAnnotation":
            case "NullableTypeAnnotation":
            case "NumberLiteralTypeAnnotation":
            case "NumberTypeAnnotation":
            case "ObjectTypeAnnotation":
            case "StringLiteralTypeAnnotation":
            case "StringTypeAnnotation":
            case "SymbolTypeAnnotation":
            case "ThisTypeAnnotation":
            case "TupleTypeAnnotation":
            case "TypeofTypeAnnotation":
            case "UnionTypeAnnotation":
            case "VoidTypeAnnotation":
            case "IndexedAccessType":
            case "OptionalIndexedAccessType":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isFor = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "ForInStatement":
            case "ForStatement":
            case "ForOfStatement":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isForInStatement = function(s, o) {
          return !!s && s.type === "ForInStatement" && (o == null || (0, i.default)(s, o));
        }, r.isForOfStatement = function(s, o) {
          return !!s && s.type === "ForOfStatement" && (o == null || (0, i.default)(s, o));
        }, r.isForStatement = function(s, o) {
          return !!s && s.type === "ForStatement" && (o == null || (0, i.default)(s, o));
        }, r.isForXStatement = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "ForInStatement":
            case "ForOfStatement":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isFunction = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ObjectMethod":
            case "ArrowFunctionExpression":
            case "ClassMethod":
            case "ClassPrivateMethod":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isFunctionDeclaration = function(s, o) {
          return !!s && s.type === "FunctionDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isFunctionExpression = function(s, o) {
          return !!s && s.type === "FunctionExpression" && (o == null || (0, i.default)(s, o));
        }, r.isFunctionParent = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ObjectMethod":
            case "ArrowFunctionExpression":
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "StaticBlock":
            case "TSModuleBlock":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isFunctionTypeAnnotation = function(s, o) {
          return !!s && s.type === "FunctionTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isFunctionTypeParam = function(s, o) {
          return !!s && s.type === "FunctionTypeParam" && (o == null || (0, i.default)(s, o));
        }, r.isGenericTypeAnnotation = function(s, o) {
          return !!s && s.type === "GenericTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isIdentifier = function(s, o) {
          return !!s && s.type === "Identifier" && (o == null || (0, i.default)(s, o));
        }, r.isIfStatement = function(s, o) {
          return !!s && s.type === "IfStatement" && (o == null || (0, i.default)(s, o));
        }, r.isImmutable = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "BigIntLiteral":
            case "JSXAttribute":
            case "JSXClosingElement":
            case "JSXElement":
            case "JSXExpressionContainer":
            case "JSXSpreadChild":
            case "JSXOpeningElement":
            case "JSXText":
            case "JSXFragment":
            case "JSXOpeningFragment":
            case "JSXClosingFragment":
            case "DecimalLiteral":
              break;
            case "Placeholder":
              if (s.expectedNode === "StringLiteral")
                break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isImport = function(s, o) {
          return !!s && s.type === "Import" && (o == null || (0, i.default)(s, o));
        }, r.isImportAttribute = function(s, o) {
          return !!s && s.type === "ImportAttribute" && (o == null || (0, i.default)(s, o));
        }, r.isImportDeclaration = function(s, o) {
          return !!s && s.type === "ImportDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isImportDefaultSpecifier = function(s, o) {
          return !!s && s.type === "ImportDefaultSpecifier" && (o == null || (0, i.default)(s, o));
        }, r.isImportNamespaceSpecifier = function(s, o) {
          return !!s && s.type === "ImportNamespaceSpecifier" && (o == null || (0, i.default)(s, o));
        }, r.isImportOrExportDeclaration = d, r.isImportSpecifier = function(s, o) {
          return !!s && s.type === "ImportSpecifier" && (o == null || (0, i.default)(s, o));
        }, r.isIndexedAccessType = function(s, o) {
          return !!s && s.type === "IndexedAccessType" && (o == null || (0, i.default)(s, o));
        }, r.isInferredPredicate = function(s, o) {
          return !!s && s.type === "InferredPredicate" && (o == null || (0, i.default)(s, o));
        }, r.isInterfaceDeclaration = function(s, o) {
          return !!s && s.type === "InterfaceDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isInterfaceExtends = function(s, o) {
          return !!s && s.type === "InterfaceExtends" && (o == null || (0, i.default)(s, o));
        }, r.isInterfaceTypeAnnotation = function(s, o) {
          return !!s && s.type === "InterfaceTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isInterpreterDirective = function(s, o) {
          return !!s && s.type === "InterpreterDirective" && (o == null || (0, i.default)(s, o));
        }, r.isIntersectionTypeAnnotation = function(s, o) {
          return !!s && s.type === "IntersectionTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isJSX = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "JSXAttribute":
            case "JSXClosingElement":
            case "JSXElement":
            case "JSXEmptyExpression":
            case "JSXExpressionContainer":
            case "JSXSpreadChild":
            case "JSXIdentifier":
            case "JSXMemberExpression":
            case "JSXNamespacedName":
            case "JSXOpeningElement":
            case "JSXSpreadAttribute":
            case "JSXText":
            case "JSXFragment":
            case "JSXOpeningFragment":
            case "JSXClosingFragment":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isJSXAttribute = function(s, o) {
          return !!s && s.type === "JSXAttribute" && (o == null || (0, i.default)(s, o));
        }, r.isJSXClosingElement = function(s, o) {
          return !!s && s.type === "JSXClosingElement" && (o == null || (0, i.default)(s, o));
        }, r.isJSXClosingFragment = function(s, o) {
          return !!s && s.type === "JSXClosingFragment" && (o == null || (0, i.default)(s, o));
        }, r.isJSXElement = function(s, o) {
          return !!s && s.type === "JSXElement" && (o == null || (0, i.default)(s, o));
        }, r.isJSXEmptyExpression = function(s, o) {
          return !!s && s.type === "JSXEmptyExpression" && (o == null || (0, i.default)(s, o));
        }, r.isJSXExpressionContainer = function(s, o) {
          return !!s && s.type === "JSXExpressionContainer" && (o == null || (0, i.default)(s, o));
        }, r.isJSXFragment = function(s, o) {
          return !!s && s.type === "JSXFragment" && (o == null || (0, i.default)(s, o));
        }, r.isJSXIdentifier = function(s, o) {
          return !!s && s.type === "JSXIdentifier" && (o == null || (0, i.default)(s, o));
        }, r.isJSXMemberExpression = function(s, o) {
          return !!s && s.type === "JSXMemberExpression" && (o == null || (0, i.default)(s, o));
        }, r.isJSXNamespacedName = function(s, o) {
          return !!s && s.type === "JSXNamespacedName" && (o == null || (0, i.default)(s, o));
        }, r.isJSXOpeningElement = function(s, o) {
          return !!s && s.type === "JSXOpeningElement" && (o == null || (0, i.default)(s, o));
        }, r.isJSXOpeningFragment = function(s, o) {
          return !!s && s.type === "JSXOpeningFragment" && (o == null || (0, i.default)(s, o));
        }, r.isJSXSpreadAttribute = function(s, o) {
          return !!s && s.type === "JSXSpreadAttribute" && (o == null || (0, i.default)(s, o));
        }, r.isJSXSpreadChild = function(s, o) {
          return !!s && s.type === "JSXSpreadChild" && (o == null || (0, i.default)(s, o));
        }, r.isJSXText = function(s, o) {
          return !!s && s.type === "JSXText" && (o == null || (0, i.default)(s, o));
        }, r.isLVal = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "Identifier":
            case "MemberExpression":
            case "RestElement":
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ObjectPattern":
            case "TSParameterProperty":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              break;
            case "Placeholder":
              switch (s.expectedNode) {
                case "Pattern":
                case "Identifier":
                  break;
                default:
                  return !1;
              }
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isLabeledStatement = function(s, o) {
          return !!s && s.type === "LabeledStatement" && (o == null || (0, i.default)(s, o));
        }, r.isLiteral = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "TemplateLiteral":
            case "BigIntLiteral":
            case "DecimalLiteral":
              break;
            case "Placeholder":
              if (s.expectedNode === "StringLiteral")
                break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isLogicalExpression = function(s, o) {
          return !!s && s.type === "LogicalExpression" && (o == null || (0, i.default)(s, o));
        }, r.isLoop = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForStatement":
            case "WhileStatement":
            case "ForOfStatement":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isMemberExpression = function(s, o) {
          return !!s && s.type === "MemberExpression" && (o == null || (0, i.default)(s, o));
        }, r.isMetaProperty = function(s, o) {
          return !!s && s.type === "MetaProperty" && (o == null || (0, i.default)(s, o));
        }, r.isMethod = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isMiscellaneous = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "Noop":
            case "Placeholder":
            case "V8IntrinsicIdentifier":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isMixedTypeAnnotation = function(s, o) {
          return !!s && s.type === "MixedTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isModuleDeclaration = function(s, o) {
          return (0, f.default)("isModuleDeclaration", "isImportOrExportDeclaration"), d(s, o);
        }, r.isModuleExpression = function(s, o) {
          return !!s && s.type === "ModuleExpression" && (o == null || (0, i.default)(s, o));
        }, r.isModuleSpecifier = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "ExportSpecifier":
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "ExportNamespaceSpecifier":
            case "ExportDefaultSpecifier":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isNewExpression = function(s, o) {
          return !!s && s.type === "NewExpression" && (o == null || (0, i.default)(s, o));
        }, r.isNoop = function(s, o) {
          return !!s && s.type === "Noop" && (o == null || (0, i.default)(s, o));
        }, r.isNullLiteral = function(s, o) {
          return !!s && s.type === "NullLiteral" && (o == null || (0, i.default)(s, o));
        }, r.isNullLiteralTypeAnnotation = function(s, o) {
          return !!s && s.type === "NullLiteralTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isNullableTypeAnnotation = function(s, o) {
          return !!s && s.type === "NullableTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isNumberLiteral = function(s, o) {
          return (0, f.default)("isNumberLiteral", "isNumericLiteral"), !!s && s.type === "NumberLiteral" && (o == null || (0, i.default)(s, o));
        }, r.isNumberLiteralTypeAnnotation = function(s, o) {
          return !!s && s.type === "NumberLiteralTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isNumberTypeAnnotation = function(s, o) {
          return !!s && s.type === "NumberTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isNumericLiteral = function(s, o) {
          return !!s && s.type === "NumericLiteral" && (o == null || (0, i.default)(s, o));
        }, r.isObjectExpression = function(s, o) {
          return !!s && s.type === "ObjectExpression" && (o == null || (0, i.default)(s, o));
        }, r.isObjectMember = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "ObjectMethod":
            case "ObjectProperty":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isObjectMethod = function(s, o) {
          return !!s && s.type === "ObjectMethod" && (o == null || (0, i.default)(s, o));
        }, r.isObjectPattern = function(s, o) {
          return !!s && s.type === "ObjectPattern" && (o == null || (0, i.default)(s, o));
        }, r.isObjectProperty = function(s, o) {
          return !!s && s.type === "ObjectProperty" && (o == null || (0, i.default)(s, o));
        }, r.isObjectTypeAnnotation = function(s, o) {
          return !!s && s.type === "ObjectTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isObjectTypeCallProperty = function(s, o) {
          return !!s && s.type === "ObjectTypeCallProperty" && (o == null || (0, i.default)(s, o));
        }, r.isObjectTypeIndexer = function(s, o) {
          return !!s && s.type === "ObjectTypeIndexer" && (o == null || (0, i.default)(s, o));
        }, r.isObjectTypeInternalSlot = function(s, o) {
          return !!s && s.type === "ObjectTypeInternalSlot" && (o == null || (0, i.default)(s, o));
        }, r.isObjectTypeProperty = function(s, o) {
          return !!s && s.type === "ObjectTypeProperty" && (o == null || (0, i.default)(s, o));
        }, r.isObjectTypeSpreadProperty = function(s, o) {
          return !!s && s.type === "ObjectTypeSpreadProperty" && (o == null || (0, i.default)(s, o));
        }, r.isOpaqueType = function(s, o) {
          return !!s && s.type === "OpaqueType" && (o == null || (0, i.default)(s, o));
        }, r.isOptionalCallExpression = function(s, o) {
          return !!s && s.type === "OptionalCallExpression" && (o == null || (0, i.default)(s, o));
        }, r.isOptionalIndexedAccessType = function(s, o) {
          return !!s && s.type === "OptionalIndexedAccessType" && (o == null || (0, i.default)(s, o));
        }, r.isOptionalMemberExpression = function(s, o) {
          return !!s && s.type === "OptionalMemberExpression" && (o == null || (0, i.default)(s, o));
        }, r.isParenthesizedExpression = function(s, o) {
          return !!s && s.type === "ParenthesizedExpression" && (o == null || (0, i.default)(s, o));
        }, r.isPattern = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ObjectPattern":
              break;
            case "Placeholder":
              if (s.expectedNode === "Pattern")
                break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isPatternLike = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "Identifier":
            case "RestElement":
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ObjectPattern":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              break;
            case "Placeholder":
              switch (s.expectedNode) {
                case "Pattern":
                case "Identifier":
                  break;
                default:
                  return !1;
              }
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isPipelineBareFunction = function(s, o) {
          return !!s && s.type === "PipelineBareFunction" && (o == null || (0, i.default)(s, o));
        }, r.isPipelinePrimaryTopicReference = function(s, o) {
          return !!s && s.type === "PipelinePrimaryTopicReference" && (o == null || (0, i.default)(s, o));
        }, r.isPipelineTopicExpression = function(s, o) {
          return !!s && s.type === "PipelineTopicExpression" && (o == null || (0, i.default)(s, o));
        }, r.isPlaceholder = function(s, o) {
          return !!s && s.type === "Placeholder" && (o == null || (0, i.default)(s, o));
        }, r.isPrivate = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "ClassPrivateProperty":
            case "ClassPrivateMethod":
            case "PrivateName":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isPrivateName = function(s, o) {
          return !!s && s.type === "PrivateName" && (o == null || (0, i.default)(s, o));
        }, r.isProgram = function(s, o) {
          return !!s && s.type === "Program" && (o == null || (0, i.default)(s, o));
        }, r.isProperty = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "ObjectProperty":
            case "ClassProperty":
            case "ClassAccessorProperty":
            case "ClassPrivateProperty":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isPureish = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "ArrowFunctionExpression":
            case "BigIntLiteral":
            case "DecimalLiteral":
              break;
            case "Placeholder":
              if (s.expectedNode === "StringLiteral")
                break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isQualifiedTypeIdentifier = function(s, o) {
          return !!s && s.type === "QualifiedTypeIdentifier" && (o == null || (0, i.default)(s, o));
        }, r.isRecordExpression = function(s, o) {
          return !!s && s.type === "RecordExpression" && (o == null || (0, i.default)(s, o));
        }, r.isRegExpLiteral = function(s, o) {
          return !!s && s.type === "RegExpLiteral" && (o == null || (0, i.default)(s, o));
        }, r.isRegexLiteral = function(s, o) {
          return (0, f.default)("isRegexLiteral", "isRegExpLiteral"), !!s && s.type === "RegexLiteral" && (o == null || (0, i.default)(s, o));
        }, r.isRestElement = function(s, o) {
          return !!s && s.type === "RestElement" && (o == null || (0, i.default)(s, o));
        }, r.isRestProperty = function(s, o) {
          return (0, f.default)("isRestProperty", "isRestElement"), !!s && s.type === "RestProperty" && (o == null || (0, i.default)(s, o));
        }, r.isReturnStatement = function(s, o) {
          return !!s && s.type === "ReturnStatement" && (o == null || (0, i.default)(s, o));
        }, r.isScopable = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "BlockStatement":
            case "CatchClause":
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "Program":
            case "ObjectMethod":
            case "SwitchStatement":
            case "WhileStatement":
            case "ArrowFunctionExpression":
            case "ClassExpression":
            case "ClassDeclaration":
            case "ForOfStatement":
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "StaticBlock":
            case "TSModuleBlock":
              break;
            case "Placeholder":
              if (s.expectedNode === "BlockStatement")
                break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isSequenceExpression = function(s, o) {
          return !!s && s.type === "SequenceExpression" && (o == null || (0, i.default)(s, o));
        }, r.isSpreadElement = function(s, o) {
          return !!s && s.type === "SpreadElement" && (o == null || (0, i.default)(s, o));
        }, r.isSpreadProperty = function(s, o) {
          return (0, f.default)("isSpreadProperty", "isSpreadElement"), !!s && s.type === "SpreadProperty" && (o == null || (0, i.default)(s, o));
        }, r.isStandardized = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "ArrayExpression":
            case "AssignmentExpression":
            case "BinaryExpression":
            case "InterpreterDirective":
            case "Directive":
            case "DirectiveLiteral":
            case "BlockStatement":
            case "BreakStatement":
            case "CallExpression":
            case "CatchClause":
            case "ConditionalExpression":
            case "ContinueStatement":
            case "DebuggerStatement":
            case "DoWhileStatement":
            case "EmptyStatement":
            case "ExpressionStatement":
            case "File":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "Identifier":
            case "IfStatement":
            case "LabeledStatement":
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "LogicalExpression":
            case "MemberExpression":
            case "NewExpression":
            case "Program":
            case "ObjectExpression":
            case "ObjectMethod":
            case "ObjectProperty":
            case "RestElement":
            case "ReturnStatement":
            case "SequenceExpression":
            case "ParenthesizedExpression":
            case "SwitchCase":
            case "SwitchStatement":
            case "ThisExpression":
            case "ThrowStatement":
            case "TryStatement":
            case "UnaryExpression":
            case "UpdateExpression":
            case "VariableDeclaration":
            case "VariableDeclarator":
            case "WhileStatement":
            case "WithStatement":
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ArrowFunctionExpression":
            case "ClassBody":
            case "ClassExpression":
            case "ClassDeclaration":
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ExportSpecifier":
            case "ForOfStatement":
            case "ImportDeclaration":
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "MetaProperty":
            case "ClassMethod":
            case "ObjectPattern":
            case "SpreadElement":
            case "Super":
            case "TaggedTemplateExpression":
            case "TemplateElement":
            case "TemplateLiteral":
            case "YieldExpression":
            case "AwaitExpression":
            case "Import":
            case "BigIntLiteral":
            case "ExportNamespaceSpecifier":
            case "OptionalMemberExpression":
            case "OptionalCallExpression":
            case "ClassProperty":
            case "ClassAccessorProperty":
            case "ClassPrivateProperty":
            case "ClassPrivateMethod":
            case "PrivateName":
            case "StaticBlock":
              break;
            case "Placeholder":
              switch (s.expectedNode) {
                case "Identifier":
                case "StringLiteral":
                case "BlockStatement":
                case "ClassBody":
                  break;
                default:
                  return !1;
              }
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isStatement = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "BlockStatement":
            case "BreakStatement":
            case "ContinueStatement":
            case "DebuggerStatement":
            case "DoWhileStatement":
            case "EmptyStatement":
            case "ExpressionStatement":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "IfStatement":
            case "LabeledStatement":
            case "ReturnStatement":
            case "SwitchStatement":
            case "ThrowStatement":
            case "TryStatement":
            case "VariableDeclaration":
            case "WhileStatement":
            case "WithStatement":
            case "ClassDeclaration":
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ForOfStatement":
            case "ImportDeclaration":
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "InterfaceDeclaration":
            case "OpaqueType":
            case "TypeAlias":
            case "EnumDeclaration":
            case "TSDeclareFunction":
            case "TSInterfaceDeclaration":
            case "TSTypeAliasDeclaration":
            case "TSEnumDeclaration":
            case "TSModuleDeclaration":
            case "TSImportEqualsDeclaration":
            case "TSExportAssignment":
            case "TSNamespaceExportDeclaration":
              break;
            case "Placeholder":
              switch (s.expectedNode) {
                case "Statement":
                case "Declaration":
                case "BlockStatement":
                  break;
                default:
                  return !1;
              }
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isStaticBlock = function(s, o) {
          return !!s && s.type === "StaticBlock" && (o == null || (0, i.default)(s, o));
        }, r.isStringLiteral = function(s, o) {
          return !!s && s.type === "StringLiteral" && (o == null || (0, i.default)(s, o));
        }, r.isStringLiteralTypeAnnotation = function(s, o) {
          return !!s && s.type === "StringLiteralTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isStringTypeAnnotation = function(s, o) {
          return !!s && s.type === "StringTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isSuper = function(s, o) {
          return !!s && s.type === "Super" && (o == null || (0, i.default)(s, o));
        }, r.isSwitchCase = function(s, o) {
          return !!s && s.type === "SwitchCase" && (o == null || (0, i.default)(s, o));
        }, r.isSwitchStatement = function(s, o) {
          return !!s && s.type === "SwitchStatement" && (o == null || (0, i.default)(s, o));
        }, r.isSymbolTypeAnnotation = function(s, o) {
          return !!s && s.type === "SymbolTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isTSAnyKeyword = function(s, o) {
          return !!s && s.type === "TSAnyKeyword" && (o == null || (0, i.default)(s, o));
        }, r.isTSArrayType = function(s, o) {
          return !!s && s.type === "TSArrayType" && (o == null || (0, i.default)(s, o));
        }, r.isTSAsExpression = function(s, o) {
          return !!s && s.type === "TSAsExpression" && (o == null || (0, i.default)(s, o));
        }, r.isTSBaseType = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "TSAnyKeyword":
            case "TSBooleanKeyword":
            case "TSBigIntKeyword":
            case "TSIntrinsicKeyword":
            case "TSNeverKeyword":
            case "TSNullKeyword":
            case "TSNumberKeyword":
            case "TSObjectKeyword":
            case "TSStringKeyword":
            case "TSSymbolKeyword":
            case "TSUndefinedKeyword":
            case "TSUnknownKeyword":
            case "TSVoidKeyword":
            case "TSThisType":
            case "TSLiteralType":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isTSBigIntKeyword = function(s, o) {
          return !!s && s.type === "TSBigIntKeyword" && (o == null || (0, i.default)(s, o));
        }, r.isTSBooleanKeyword = function(s, o) {
          return !!s && s.type === "TSBooleanKeyword" && (o == null || (0, i.default)(s, o));
        }, r.isTSCallSignatureDeclaration = function(s, o) {
          return !!s && s.type === "TSCallSignatureDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isTSConditionalType = function(s, o) {
          return !!s && s.type === "TSConditionalType" && (o == null || (0, i.default)(s, o));
        }, r.isTSConstructSignatureDeclaration = function(s, o) {
          return !!s && s.type === "TSConstructSignatureDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isTSConstructorType = function(s, o) {
          return !!s && s.type === "TSConstructorType" && (o == null || (0, i.default)(s, o));
        }, r.isTSDeclareFunction = function(s, o) {
          return !!s && s.type === "TSDeclareFunction" && (o == null || (0, i.default)(s, o));
        }, r.isTSDeclareMethod = function(s, o) {
          return !!s && s.type === "TSDeclareMethod" && (o == null || (0, i.default)(s, o));
        }, r.isTSEntityName = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "Identifier":
            case "TSQualifiedName":
              break;
            case "Placeholder":
              if (s.expectedNode === "Identifier")
                break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isTSEnumDeclaration = function(s, o) {
          return !!s && s.type === "TSEnumDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isTSEnumMember = function(s, o) {
          return !!s && s.type === "TSEnumMember" && (o == null || (0, i.default)(s, o));
        }, r.isTSExportAssignment = function(s, o) {
          return !!s && s.type === "TSExportAssignment" && (o == null || (0, i.default)(s, o));
        }, r.isTSExpressionWithTypeArguments = function(s, o) {
          return !!s && s.type === "TSExpressionWithTypeArguments" && (o == null || (0, i.default)(s, o));
        }, r.isTSExternalModuleReference = function(s, o) {
          return !!s && s.type === "TSExternalModuleReference" && (o == null || (0, i.default)(s, o));
        }, r.isTSFunctionType = function(s, o) {
          return !!s && s.type === "TSFunctionType" && (o == null || (0, i.default)(s, o));
        }, r.isTSImportEqualsDeclaration = function(s, o) {
          return !!s && s.type === "TSImportEqualsDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isTSImportType = function(s, o) {
          return !!s && s.type === "TSImportType" && (o == null || (0, i.default)(s, o));
        }, r.isTSIndexSignature = function(s, o) {
          return !!s && s.type === "TSIndexSignature" && (o == null || (0, i.default)(s, o));
        }, r.isTSIndexedAccessType = function(s, o) {
          return !!s && s.type === "TSIndexedAccessType" && (o == null || (0, i.default)(s, o));
        }, r.isTSInferType = function(s, o) {
          return !!s && s.type === "TSInferType" && (o == null || (0, i.default)(s, o));
        }, r.isTSInstantiationExpression = function(s, o) {
          return !!s && s.type === "TSInstantiationExpression" && (o == null || (0, i.default)(s, o));
        }, r.isTSInterfaceBody = function(s, o) {
          return !!s && s.type === "TSInterfaceBody" && (o == null || (0, i.default)(s, o));
        }, r.isTSInterfaceDeclaration = function(s, o) {
          return !!s && s.type === "TSInterfaceDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isTSIntersectionType = function(s, o) {
          return !!s && s.type === "TSIntersectionType" && (o == null || (0, i.default)(s, o));
        }, r.isTSIntrinsicKeyword = function(s, o) {
          return !!s && s.type === "TSIntrinsicKeyword" && (o == null || (0, i.default)(s, o));
        }, r.isTSLiteralType = function(s, o) {
          return !!s && s.type === "TSLiteralType" && (o == null || (0, i.default)(s, o));
        }, r.isTSMappedType = function(s, o) {
          return !!s && s.type === "TSMappedType" && (o == null || (0, i.default)(s, o));
        }, r.isTSMethodSignature = function(s, o) {
          return !!s && s.type === "TSMethodSignature" && (o == null || (0, i.default)(s, o));
        }, r.isTSModuleBlock = function(s, o) {
          return !!s && s.type === "TSModuleBlock" && (o == null || (0, i.default)(s, o));
        }, r.isTSModuleDeclaration = function(s, o) {
          return !!s && s.type === "TSModuleDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isTSNamedTupleMember = function(s, o) {
          return !!s && s.type === "TSNamedTupleMember" && (o == null || (0, i.default)(s, o));
        }, r.isTSNamespaceExportDeclaration = function(s, o) {
          return !!s && s.type === "TSNamespaceExportDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isTSNeverKeyword = function(s, o) {
          return !!s && s.type === "TSNeverKeyword" && (o == null || (0, i.default)(s, o));
        }, r.isTSNonNullExpression = function(s, o) {
          return !!s && s.type === "TSNonNullExpression" && (o == null || (0, i.default)(s, o));
        }, r.isTSNullKeyword = function(s, o) {
          return !!s && s.type === "TSNullKeyword" && (o == null || (0, i.default)(s, o));
        }, r.isTSNumberKeyword = function(s, o) {
          return !!s && s.type === "TSNumberKeyword" && (o == null || (0, i.default)(s, o));
        }, r.isTSObjectKeyword = function(s, o) {
          return !!s && s.type === "TSObjectKeyword" && (o == null || (0, i.default)(s, o));
        }, r.isTSOptionalType = function(s, o) {
          return !!s && s.type === "TSOptionalType" && (o == null || (0, i.default)(s, o));
        }, r.isTSParameterProperty = function(s, o) {
          return !!s && s.type === "TSParameterProperty" && (o == null || (0, i.default)(s, o));
        }, r.isTSParenthesizedType = function(s, o) {
          return !!s && s.type === "TSParenthesizedType" && (o == null || (0, i.default)(s, o));
        }, r.isTSPropertySignature = function(s, o) {
          return !!s && s.type === "TSPropertySignature" && (o == null || (0, i.default)(s, o));
        }, r.isTSQualifiedName = function(s, o) {
          return !!s && s.type === "TSQualifiedName" && (o == null || (0, i.default)(s, o));
        }, r.isTSRestType = function(s, o) {
          return !!s && s.type === "TSRestType" && (o == null || (0, i.default)(s, o));
        }, r.isTSSatisfiesExpression = function(s, o) {
          return !!s && s.type === "TSSatisfiesExpression" && (o == null || (0, i.default)(s, o));
        }, r.isTSStringKeyword = function(s, o) {
          return !!s && s.type === "TSStringKeyword" && (o == null || (0, i.default)(s, o));
        }, r.isTSSymbolKeyword = function(s, o) {
          return !!s && s.type === "TSSymbolKeyword" && (o == null || (0, i.default)(s, o));
        }, r.isTSThisType = function(s, o) {
          return !!s && s.type === "TSThisType" && (o == null || (0, i.default)(s, o));
        }, r.isTSTupleType = function(s, o) {
          return !!s && s.type === "TSTupleType" && (o == null || (0, i.default)(s, o));
        }, r.isTSType = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "TSAnyKeyword":
            case "TSBooleanKeyword":
            case "TSBigIntKeyword":
            case "TSIntrinsicKeyword":
            case "TSNeverKeyword":
            case "TSNullKeyword":
            case "TSNumberKeyword":
            case "TSObjectKeyword":
            case "TSStringKeyword":
            case "TSSymbolKeyword":
            case "TSUndefinedKeyword":
            case "TSUnknownKeyword":
            case "TSVoidKeyword":
            case "TSThisType":
            case "TSFunctionType":
            case "TSConstructorType":
            case "TSTypeReference":
            case "TSTypePredicate":
            case "TSTypeQuery":
            case "TSTypeLiteral":
            case "TSArrayType":
            case "TSTupleType":
            case "TSOptionalType":
            case "TSRestType":
            case "TSUnionType":
            case "TSIntersectionType":
            case "TSConditionalType":
            case "TSInferType":
            case "TSParenthesizedType":
            case "TSTypeOperator":
            case "TSIndexedAccessType":
            case "TSMappedType":
            case "TSLiteralType":
            case "TSExpressionWithTypeArguments":
            case "TSImportType":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isTSTypeAliasDeclaration = function(s, o) {
          return !!s && s.type === "TSTypeAliasDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isTSTypeAnnotation = function(s, o) {
          return !!s && s.type === "TSTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isTSTypeAssertion = function(s, o) {
          return !!s && s.type === "TSTypeAssertion" && (o == null || (0, i.default)(s, o));
        }, r.isTSTypeElement = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "TSCallSignatureDeclaration":
            case "TSConstructSignatureDeclaration":
            case "TSPropertySignature":
            case "TSMethodSignature":
            case "TSIndexSignature":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isTSTypeLiteral = function(s, o) {
          return !!s && s.type === "TSTypeLiteral" && (o == null || (0, i.default)(s, o));
        }, r.isTSTypeOperator = function(s, o) {
          return !!s && s.type === "TSTypeOperator" && (o == null || (0, i.default)(s, o));
        }, r.isTSTypeParameter = function(s, o) {
          return !!s && s.type === "TSTypeParameter" && (o == null || (0, i.default)(s, o));
        }, r.isTSTypeParameterDeclaration = function(s, o) {
          return !!s && s.type === "TSTypeParameterDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isTSTypeParameterInstantiation = function(s, o) {
          return !!s && s.type === "TSTypeParameterInstantiation" && (o == null || (0, i.default)(s, o));
        }, r.isTSTypePredicate = function(s, o) {
          return !!s && s.type === "TSTypePredicate" && (o == null || (0, i.default)(s, o));
        }, r.isTSTypeQuery = function(s, o) {
          return !!s && s.type === "TSTypeQuery" && (o == null || (0, i.default)(s, o));
        }, r.isTSTypeReference = function(s, o) {
          return !!s && s.type === "TSTypeReference" && (o == null || (0, i.default)(s, o));
        }, r.isTSUndefinedKeyword = function(s, o) {
          return !!s && s.type === "TSUndefinedKeyword" && (o == null || (0, i.default)(s, o));
        }, r.isTSUnionType = function(s, o) {
          return !!s && s.type === "TSUnionType" && (o == null || (0, i.default)(s, o));
        }, r.isTSUnknownKeyword = function(s, o) {
          return !!s && s.type === "TSUnknownKeyword" && (o == null || (0, i.default)(s, o));
        }, r.isTSVoidKeyword = function(s, o) {
          return !!s && s.type === "TSVoidKeyword" && (o == null || (0, i.default)(s, o));
        }, r.isTaggedTemplateExpression = function(s, o) {
          return !!s && s.type === "TaggedTemplateExpression" && (o == null || (0, i.default)(s, o));
        }, r.isTemplateElement = function(s, o) {
          return !!s && s.type === "TemplateElement" && (o == null || (0, i.default)(s, o));
        }, r.isTemplateLiteral = function(s, o) {
          return !!s && s.type === "TemplateLiteral" && (o == null || (0, i.default)(s, o));
        }, r.isTerminatorless = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "BreakStatement":
            case "ContinueStatement":
            case "ReturnStatement":
            case "ThrowStatement":
            case "YieldExpression":
            case "AwaitExpression":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isThisExpression = function(s, o) {
          return !!s && s.type === "ThisExpression" && (o == null || (0, i.default)(s, o));
        }, r.isThisTypeAnnotation = function(s, o) {
          return !!s && s.type === "ThisTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isThrowStatement = function(s, o) {
          return !!s && s.type === "ThrowStatement" && (o == null || (0, i.default)(s, o));
        }, r.isTopicReference = function(s, o) {
          return !!s && s.type === "TopicReference" && (o == null || (0, i.default)(s, o));
        }, r.isTryStatement = function(s, o) {
          return !!s && s.type === "TryStatement" && (o == null || (0, i.default)(s, o));
        }, r.isTupleExpression = function(s, o) {
          return !!s && s.type === "TupleExpression" && (o == null || (0, i.default)(s, o));
        }, r.isTupleTypeAnnotation = function(s, o) {
          return !!s && s.type === "TupleTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isTypeAlias = function(s, o) {
          return !!s && s.type === "TypeAlias" && (o == null || (0, i.default)(s, o));
        }, r.isTypeAnnotation = function(s, o) {
          return !!s && s.type === "TypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isTypeCastExpression = function(s, o) {
          return !!s && s.type === "TypeCastExpression" && (o == null || (0, i.default)(s, o));
        }, r.isTypeParameter = function(s, o) {
          return !!s && s.type === "TypeParameter" && (o == null || (0, i.default)(s, o));
        }, r.isTypeParameterDeclaration = function(s, o) {
          return !!s && s.type === "TypeParameterDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isTypeParameterInstantiation = function(s, o) {
          return !!s && s.type === "TypeParameterInstantiation" && (o == null || (0, i.default)(s, o));
        }, r.isTypeScript = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "TSParameterProperty":
            case "TSDeclareFunction":
            case "TSDeclareMethod":
            case "TSQualifiedName":
            case "TSCallSignatureDeclaration":
            case "TSConstructSignatureDeclaration":
            case "TSPropertySignature":
            case "TSMethodSignature":
            case "TSIndexSignature":
            case "TSAnyKeyword":
            case "TSBooleanKeyword":
            case "TSBigIntKeyword":
            case "TSIntrinsicKeyword":
            case "TSNeverKeyword":
            case "TSNullKeyword":
            case "TSNumberKeyword":
            case "TSObjectKeyword":
            case "TSStringKeyword":
            case "TSSymbolKeyword":
            case "TSUndefinedKeyword":
            case "TSUnknownKeyword":
            case "TSVoidKeyword":
            case "TSThisType":
            case "TSFunctionType":
            case "TSConstructorType":
            case "TSTypeReference":
            case "TSTypePredicate":
            case "TSTypeQuery":
            case "TSTypeLiteral":
            case "TSArrayType":
            case "TSTupleType":
            case "TSOptionalType":
            case "TSRestType":
            case "TSNamedTupleMember":
            case "TSUnionType":
            case "TSIntersectionType":
            case "TSConditionalType":
            case "TSInferType":
            case "TSParenthesizedType":
            case "TSTypeOperator":
            case "TSIndexedAccessType":
            case "TSMappedType":
            case "TSLiteralType":
            case "TSExpressionWithTypeArguments":
            case "TSInterfaceDeclaration":
            case "TSInterfaceBody":
            case "TSTypeAliasDeclaration":
            case "TSInstantiationExpression":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSEnumDeclaration":
            case "TSEnumMember":
            case "TSModuleDeclaration":
            case "TSModuleBlock":
            case "TSImportType":
            case "TSImportEqualsDeclaration":
            case "TSExternalModuleReference":
            case "TSNonNullExpression":
            case "TSExportAssignment":
            case "TSNamespaceExportDeclaration":
            case "TSTypeAnnotation":
            case "TSTypeParameterInstantiation":
            case "TSTypeParameterDeclaration":
            case "TSTypeParameter":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isTypeofTypeAnnotation = function(s, o) {
          return !!s && s.type === "TypeofTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isUnaryExpression = function(s, o) {
          return !!s && s.type === "UnaryExpression" && (o == null || (0, i.default)(s, o));
        }, r.isUnaryLike = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "UnaryExpression":
            case "SpreadElement":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isUnionTypeAnnotation = function(s, o) {
          return !!s && s.type === "UnionTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isUpdateExpression = function(s, o) {
          return !!s && s.type === "UpdateExpression" && (o == null || (0, i.default)(s, o));
        }, r.isUserWhitespacable = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "ObjectMethod":
            case "ObjectProperty":
            case "ObjectTypeInternalSlot":
            case "ObjectTypeCallProperty":
            case "ObjectTypeIndexer":
            case "ObjectTypeProperty":
            case "ObjectTypeSpreadProperty":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isV8IntrinsicIdentifier = function(s, o) {
          return !!s && s.type === "V8IntrinsicIdentifier" && (o == null || (0, i.default)(s, o));
        }, r.isVariableDeclaration = function(s, o) {
          return !!s && s.type === "VariableDeclaration" && (o == null || (0, i.default)(s, o));
        }, r.isVariableDeclarator = function(s, o) {
          return !!s && s.type === "VariableDeclarator" && (o == null || (0, i.default)(s, o));
        }, r.isVariance = function(s, o) {
          return !!s && s.type === "Variance" && (o == null || (0, i.default)(s, o));
        }, r.isVoidTypeAnnotation = function(s, o) {
          return !!s && s.type === "VoidTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, r.isWhile = function(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "DoWhileStatement":
            case "WhileStatement":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, r.isWhileStatement = function(s, o) {
          return !!s && s.type === "WhileStatement" && (o == null || (0, i.default)(s, o));
        }, r.isWithStatement = function(s, o) {
          return !!s && s.type === "WithStatement" && (o == null || (0, i.default)(s, o));
        }, r.isYieldExpression = function(s, o) {
          return !!s && s.type === "YieldExpression" && (o == null || (0, i.default)(s, o));
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/utils/shallowEqual.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/utils/deprecationWarning.js");
        function d(s, o) {
          if (!s)
            return !1;
          switch (s.type) {
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/is.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(o, m, h) {
          return m ? (0, f.default)(m.type, o) ? h === void 0 || (0, i.default)(m, h) : !h && m.type === "Placeholder" && o in s.FLIPPED_ALIAS_KEYS && (0, d.default)(m.expectedNode, o) : !1;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/utils/shallowEqual.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isType.js"), d = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isPlaceholderType.js"), s = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isBinding.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f, d, s) {
          if (s && f.type === "Identifier" && d.type === "ObjectProperty" && s.type === "ObjectExpression")
            return !1;
          const o = i.default.keys[d.type];
          if (o)
            for (let m = 0; m < o.length; m++) {
              const h = d[o[m]];
              if (Array.isArray(h)) {
                if (h.indexOf(f) >= 0)
                  return !0;
              } else if (h === f)
                return !0;
            }
          return !1;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isBlockScoped.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(d) {
          return (0, i.isFunctionDeclaration)(d) || (0, i.isClassDeclaration)(d) || (0, f.default)(d);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isLet.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isImmutable.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(d) {
          return (0, i.default)(d.type, "Immutable") ? !0 : (0, f.isIdentifier)(d) ? d.name === "undefined" : !1;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isType.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isLet.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(d) {
          return (0, i.isVariableDeclaration)(d) && (d.kind !== "var" || d[f.BLOCK_SCOPED_SYMBOL]);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/constants/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isNode.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f) {
          return !(!f || !i.VISITOR_KEYS[f.type]);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isNodesEquivalent.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function f(d, s) {
          if (typeof d != "object" || typeof s != "object" || d == null || s == null)
            return d === s;
          if (d.type !== s.type)
            return !1;
          const o = Object.keys(i.NODE_FIELDS[d.type] || d.type), m = i.VISITOR_KEYS[d.type];
          for (const h of o) {
            const y = d[h], b = s[h];
            if (typeof y != typeof b)
              return !1;
            if (y != null || b != null) {
              if (y == null || b == null)
                return !1;
              if (Array.isArray(y)) {
                if (!Array.isArray(b) || y.length !== b.length)
                  return !1;
                for (let E = 0; E < y.length; E++)
                  if (!f(y[E], b[E]))
                    return !1;
              } else if (typeof y != "object" || m != null && m.includes(h)) {
                if (!f(y, b))
                  return !1;
              } else
                for (const E of Object.keys(y))
                  if (y[E] !== b[E])
                    return !1;
            }
          }
          return !0;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isPlaceholderType.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f, d) {
          if (f === d)
            return !0;
          const s = i.PLACEHOLDERS_ALIAS[f];
          if (s) {
            for (const o of s)
              if (d === o)
                return !0;
          }
          return !1;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isReferenced.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(l, i, f) {
          switch (i.type) {
            case "MemberExpression":
            case "OptionalMemberExpression":
              return i.property === l ? !!i.computed : i.object === l;
            case "JSXMemberExpression":
              return i.object === l;
            case "VariableDeclarator":
              return i.init === l;
            case "ArrowFunctionExpression":
              return i.body === l;
            case "PrivateName":
            case "LabeledStatement":
            case "CatchClause":
            case "RestElement":
            case "BreakStatement":
            case "ContinueStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ExportNamespaceSpecifier":
            case "ExportDefaultSpecifier":
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "ImportAttribute":
            case "JSXAttribute":
            case "ObjectPattern":
            case "ArrayPattern":
            case "MetaProperty":
              return !1;
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "ObjectMethod":
              return i.key === l && !!i.computed;
            case "ObjectProperty":
              return i.key === l ? !!i.computed : !f || f.type !== "ObjectPattern";
            case "ClassProperty":
            case "ClassAccessorProperty":
            case "TSPropertySignature":
              return i.key !== l || !!i.computed;
            case "ClassPrivateProperty":
            case "ObjectTypeProperty":
              return i.key !== l;
            case "ClassDeclaration":
            case "ClassExpression":
              return i.superClass === l;
            case "AssignmentExpression":
            case "AssignmentPattern":
              return i.right === l;
            case "ExportSpecifier":
              return (f == null || !f.source) && i.local === l;
            case "TSEnumMember":
              return i.id !== l;
          }
          return !0;
        };
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isScope.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f, d) {
          return (0, i.isBlockStatement)(f) && ((0, i.isFunction)(d) || (0, i.isCatchClause)(d)) ? !1 : (0, i.isPattern)(f) && ((0, i.isFunction)(d) || (0, i.isCatchClause)(d)) ? !0 : (0, i.isScopable)(f);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isSpecifierDefault.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f) {
          return (0, i.isImportDefaultSpecifier)(f) || (0, i.isIdentifier)(f.imported || f.exported, { name: "default" });
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isType.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f, d) {
          if (f === d)
            return !0;
          if (f == null || i.ALIAS_KEYS[d])
            return !1;
          const s = i.FLIPPED_ALIAS_KEYS[d];
          if (s) {
            if (s[0] === f)
              return !0;
            for (const o of s)
              if (f === o)
                return !0;
          }
          return !1;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isValidES3Identifier.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(d) {
          return (0, i.default)(d) && !f.has(d);
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isValidIdentifier.js");
        const f = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isValidIdentifier.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f, d = !0) {
          return typeof f != "string" || d && ((0, i.isKeyword)(f) || (0, i.isStrictReservedWord)(f, !0)) ? !1 : (0, i.isIdentifierName)(f);
        };
        var i = l("./node_modules/.pnpm/@babel+helper-validator-identifier@7.22.15/node_modules/@babel/helper-validator-identifier/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/isVar.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(d) {
          return (0, i.isVariableDeclaration)(d, { kind: "var" }) && !d[f.BLOCK_SCOPED_SYMBOL];
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js"), f = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/constants/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/matchesPattern.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(f, d, s) {
          if (!(0, i.isMemberExpression)(f))
            return !1;
          const o = Array.isArray(d) ? d : d.split("."), m = [];
          let h;
          for (h = f; (0, i.isMemberExpression)(h); h = h.object)
            m.push(h.property);
          if (m.push(h), m.length < o.length || !s && m.length > o.length)
            return !1;
          for (let y = 0, b = m.length - 1; y < o.length; y++, b--) {
            const E = m[b];
            let S;
            if ((0, i.isIdentifier)(E))
              S = E.name;
            else if ((0, i.isStringLiteral)(E))
              S = E.value;
            else {
              if (!(0, i.isThisExpression)(E))
                return !1;
              S = "this";
            }
            if (o[y] !== S)
              return !1;
          }
          return !0;
        };
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/react/isCompatTag.js": (u, r) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(l) {
          return !!l && /^[a-z]/.test(l);
        };
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/react/isReactComponent.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = void 0;
        var i = (0, l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js").default)("React.Component");
        r.default = i;
      }, "./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/validators/validate.js": (u, r, l) => {
        Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function(s, o, m) {
          if (!s)
            return;
          const h = i.NODE_FIELDS[s.type];
          if (!h)
            return;
          const y = h[o];
          f(s, o, m, y), d(s, o, m);
        }, r.validateChild = d, r.validateField = f;
        var i = l("./node_modules/.pnpm/@babel+types@7.22.15/node_modules/@babel/types/lib/definitions/index.js");
        function f(s, o, m, h) {
          h != null && h.validate && (h.optional && m == null || h.validate(s, o, m));
        }
        function d(s, o, m) {
          if (m == null)
            return;
          const h = i.NODE_PARENT_VALIDATIONS[m.type];
          h && h(s, o, m);
        }
      }, "./node_modules/.pnpm/json5@2.2.3/node_modules/json5/dist/index.mjs": (u, r, l) => {
        l.r(r), l.d(r, { default: () => z });
        var i = { Space_Separator: /[\u1680\u2000-\u200A\u202F\u205F\u3000]/, ID_Start: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/, ID_Continue: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ }, f = { isSpaceSeparator: (q) => typeof q == "string" && i.Space_Separator.test(q), isIdStartChar: (q) => typeof q == "string" && (q >= "a" && q <= "z" || q >= "A" && q <= "Z" || q === "$" || q === "_" || i.ID_Start.test(q)), isIdContinueChar: (q) => typeof q == "string" && (q >= "a" && q <= "z" || q >= "A" && q <= "Z" || q >= "0" && q <= "9" || q === "$" || q === "_" || q === "" || q === "" || i.ID_Continue.test(q)), isDigit: (q) => typeof q == "string" && /[0-9]/.test(q), isHexDigit: (q) => typeof q == "string" && /[0-9A-Fa-f]/.test(q) };
        let d, s, o, m, h, y, b, E, S;
        function g(q, $, Y) {
          const H = q[$];
          if (H != null && typeof H == "object")
            if (Array.isArray(H))
              for (let Q = 0; Q < H.length; Q++) {
                const X = String(Q), ne = g(H, X, Y);
                ne === void 0 ? delete H[X] : Object.defineProperty(H, X, { value: ne, writable: !0, enumerable: !0, configurable: !0 });
              }
            else
              for (const Q in H) {
                const X = g(H, Q, Y);
                X === void 0 ? delete H[Q] : Object.defineProperty(H, Q, { value: X, writable: !0, enumerable: !0, configurable: !0 });
              }
          return Y.call(q, $, H);
        }
        let P, R, N, C, I;
        function D() {
          for (P = "default", R = "", N = !1, C = 1; ; ) {
            I = j();
            const q = _[P]();
            if (q)
              return q;
          }
        }
        function j() {
          if (d[m])
            return String.fromCodePoint(d.codePointAt(m));
        }
        function F() {
          const q = j();
          return q === `
` ? (h++, y = 0) : q ? y += q.length : y++, q && (m += q.length), q;
        }
        const _ = { default() {
          switch (I) {
            case "	":
            case "\v":
            case "\f":
            case " ":
            case "":
            case "\uFEFF":
            case `
`:
            case "\r":
            case "\u2028":
            case "\u2029":
              return void F();
            case "/":
              return F(), void (P = "comment");
            case void 0:
              return F(), T("eof");
          }
          if (!f.isSpaceSeparator(I))
            return _[s]();
          F();
        }, comment() {
          switch (I) {
            case "*":
              return F(), void (P = "multiLineComment");
            case "/":
              return F(), void (P = "singleLineComment");
          }
          throw U(F());
        }, multiLineComment() {
          switch (I) {
            case "*":
              return F(), void (P = "multiLineCommentAsterisk");
            case void 0:
              throw U(F());
          }
          F();
        }, multiLineCommentAsterisk() {
          switch (I) {
            case "*":
              return void F();
            case "/":
              return F(), void (P = "default");
            case void 0:
              throw U(F());
          }
          F(), P = "multiLineComment";
        }, singleLineComment() {
          switch (I) {
            case `
`:
            case "\r":
            case "\u2028":
            case "\u2029":
              return F(), void (P = "default");
            case void 0:
              return F(), T("eof");
          }
          F();
        }, value() {
          switch (I) {
            case "{":
            case "[":
              return T("punctuator", F());
            case "n":
              return F(), v("ull"), T("null", null);
            case "t":
              return F(), v("rue"), T("boolean", !0);
            case "f":
              return F(), v("alse"), T("boolean", !1);
            case "-":
            case "+":
              return F() === "-" && (C = -1), void (P = "sign");
            case ".":
              return R = F(), void (P = "decimalPointLeading");
            case "0":
              return R = F(), void (P = "zero");
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              return R = F(), void (P = "decimalInteger");
            case "I":
              return F(), v("nfinity"), T("numeric", 1 / 0);
            case "N":
              return F(), v("aN"), T("numeric", NaN);
            case '"':
            case "'":
              return N = F() === '"', R = "", void (P = "string");
          }
          throw U(F());
        }, identifierNameStartEscape() {
          if (I !== "u")
            throw U(F());
          F();
          const q = w();
          switch (q) {
            case "$":
            case "_":
              break;
            default:
              if (!f.isIdStartChar(q))
                throw B();
          }
          R += q, P = "identifierName";
        }, identifierName() {
          switch (I) {
            case "$":
            case "_":
            case "":
            case "":
              return void (R += F());
            case "\\":
              return F(), void (P = "identifierNameEscape");
          }
          if (!f.isIdContinueChar(I))
            return T("identifier", R);
          R += F();
        }, identifierNameEscape() {
          if (I !== "u")
            throw U(F());
          F();
          const q = w();
          switch (q) {
            case "$":
            case "_":
            case "":
            case "":
              break;
            default:
              if (!f.isIdContinueChar(q))
                throw B();
          }
          R += q, P = "identifierName";
        }, sign() {
          switch (I) {
            case ".":
              return R = F(), void (P = "decimalPointLeading");
            case "0":
              return R = F(), void (P = "zero");
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              return R = F(), void (P = "decimalInteger");
            case "I":
              return F(), v("nfinity"), T("numeric", C * (1 / 0));
            case "N":
              return F(), v("aN"), T("numeric", NaN);
          }
          throw U(F());
        }, zero() {
          switch (I) {
            case ".":
              return R += F(), void (P = "decimalPoint");
            case "e":
            case "E":
              return R += F(), void (P = "decimalExponent");
            case "x":
            case "X":
              return R += F(), void (P = "hexadecimal");
          }
          return T("numeric", 0 * C);
        }, decimalInteger() {
          switch (I) {
            case ".":
              return R += F(), void (P = "decimalPoint");
            case "e":
            case "E":
              return R += F(), void (P = "decimalExponent");
          }
          if (!f.isDigit(I))
            return T("numeric", C * Number(R));
          R += F();
        }, decimalPointLeading() {
          if (f.isDigit(I))
            return R += F(), void (P = "decimalFraction");
          throw U(F());
        }, decimalPoint() {
          switch (I) {
            case "e":
            case "E":
              return R += F(), void (P = "decimalExponent");
          }
          return f.isDigit(I) ? (R += F(), void (P = "decimalFraction")) : T("numeric", C * Number(R));
        }, decimalFraction() {
          switch (I) {
            case "e":
            case "E":
              return R += F(), void (P = "decimalExponent");
          }
          if (!f.isDigit(I))
            return T("numeric", C * Number(R));
          R += F();
        }, decimalExponent() {
          switch (I) {
            case "+":
            case "-":
              return R += F(), void (P = "decimalExponentSign");
          }
          if (f.isDigit(I))
            return R += F(), void (P = "decimalExponentInteger");
          throw U(F());
        }, decimalExponentSign() {
          if (f.isDigit(I))
            return R += F(), void (P = "decimalExponentInteger");
          throw U(F());
        }, decimalExponentInteger() {
          if (!f.isDigit(I))
            return T("numeric", C * Number(R));
          R += F();
        }, hexadecimal() {
          if (f.isHexDigit(I))
            return R += F(), void (P = "hexadecimalInteger");
          throw U(F());
        }, hexadecimalInteger() {
          if (!f.isHexDigit(I))
            return T("numeric", C * Number(R));
          R += F();
        }, string() {
          switch (I) {
            case "\\":
              return F(), void (R += function() {
                switch (j()) {
                  case "b":
                    return F(), "\b";
                  case "f":
                    return F(), "\f";
                  case "n":
                    return F(), `
`;
                  case "r":
                    return F(), "\r";
                  case "t":
                    return F(), "	";
                  case "v":
                    return F(), "\v";
                  case "0":
                    if (F(), f.isDigit(j()))
                      throw U(F());
                    return "\0";
                  case "x":
                    return F(), function() {
                      let q = "", $ = j();
                      if (!f.isHexDigit($) || (q += F(), $ = j(), !f.isHexDigit($)))
                        throw U(F());
                      return q += F(), String.fromCodePoint(parseInt(q, 16));
                    }();
                  case "u":
                    return F(), w();
                  case `
`:
                  case "\u2028":
                  case "\u2029":
                    return F(), "";
                  case "\r":
                    return F(), j() === `
` && F(), "";
                  case "1":
                  case "2":
                  case "3":
                  case "4":
                  case "5":
                  case "6":
                  case "7":
                  case "8":
                  case "9":
                  case void 0:
                    throw U(F());
                }
                return F();
              }());
            case '"':
              return N ? (F(), T("string", R)) : void (R += F());
            case "'":
              return N ? void (R += F()) : (F(), T("string", R));
            case `
`:
            case "\r":
              throw U(F());
            case "\u2028":
            case "\u2029":
              (function(q) {
                console.warn(`JSON5: '${k(q)}' in strings is not valid ECMAScript; consider escaping`);
              })(I);
              break;
            case void 0:
              throw U(F());
          }
          R += F();
        }, start() {
          switch (I) {
            case "{":
            case "[":
              return T("punctuator", F());
          }
          P = "value";
        }, beforePropertyName() {
          switch (I) {
            case "$":
            case "_":
              return R = F(), void (P = "identifierName");
            case "\\":
              return F(), void (P = "identifierNameStartEscape");
            case "}":
              return T("punctuator", F());
            case '"':
            case "'":
              return N = F() === '"', void (P = "string");
          }
          if (f.isIdStartChar(I))
            return R += F(), void (P = "identifierName");
          throw U(F());
        }, afterPropertyName() {
          if (I === ":")
            return T("punctuator", F());
          throw U(F());
        }, beforePropertyValue() {
          P = "value";
        }, afterPropertyValue() {
          switch (I) {
            case ",":
            case "}":
              return T("punctuator", F());
          }
          throw U(F());
        }, beforeArrayValue() {
          if (I === "]")
            return T("punctuator", F());
          P = "value";
        }, afterArrayValue() {
          switch (I) {
            case ",":
            case "]":
              return T("punctuator", F());
          }
          throw U(F());
        }, end() {
          throw U(F());
        } };
        function T(q, $) {
          return { type: q, value: $, line: h, column: y };
        }
        function v(q) {
          for (const $ of q) {
            if (j() !== $)
              throw U(F());
            F();
          }
        }
        function w() {
          let q = "", $ = 4;
          for (; $-- > 0; ) {
            const Y = j();
            if (!f.isHexDigit(Y))
              throw U(F());
            q += F();
          }
          return String.fromCodePoint(parseInt(q, 16));
        }
        const O = { start() {
          if (b.type === "eof")
            throw M();
          G();
        }, beforePropertyName() {
          switch (b.type) {
            case "identifier":
            case "string":
              return E = b.value, void (s = "afterPropertyName");
            case "punctuator":
              return void W();
            case "eof":
              throw M();
          }
        }, afterPropertyName() {
          if (b.type === "eof")
            throw M();
          s = "beforePropertyValue";
        }, beforePropertyValue() {
          if (b.type === "eof")
            throw M();
          G();
        }, beforeArrayValue() {
          if (b.type === "eof")
            throw M();
          b.type !== "punctuator" || b.value !== "]" ? G() : W();
        }, afterPropertyValue() {
          if (b.type === "eof")
            throw M();
          switch (b.value) {
            case ",":
              return void (s = "beforePropertyName");
            case "}":
              W();
          }
        }, afterArrayValue() {
          if (b.type === "eof")
            throw M();
          switch (b.value) {
            case ",":
              return void (s = "beforeArrayValue");
            case "]":
              W();
          }
        }, end() {
        } };
        function G() {
          let q;
          switch (b.type) {
            case "punctuator":
              switch (b.value) {
                case "{":
                  q = {};
                  break;
                case "[":
                  q = [];
              }
              break;
            case "null":
            case "boolean":
            case "numeric":
            case "string":
              q = b.value;
          }
          if (S === void 0)
            S = q;
          else {
            const $ = o[o.length - 1];
            Array.isArray($) ? $.push(q) : Object.defineProperty($, E, { value: q, writable: !0, enumerable: !0, configurable: !0 });
          }
          if (q !== null && typeof q == "object")
            o.push(q), s = Array.isArray(q) ? "beforeArrayValue" : "beforePropertyName";
          else {
            const $ = o[o.length - 1];
            s = $ == null ? "end" : Array.isArray($) ? "afterArrayValue" : "afterPropertyValue";
          }
        }
        function W() {
          o.pop();
          const q = o[o.length - 1];
          s = q == null ? "end" : Array.isArray(q) ? "afterArrayValue" : "afterPropertyValue";
        }
        function U(q) {
          return K(q === void 0 ? `JSON5: invalid end of input at ${h}:${y}` : `JSON5: invalid character '${k(q)}' at ${h}:${y}`);
        }
        function M() {
          return K(`JSON5: invalid end of input at ${h}:${y}`);
        }
        function B() {
          return y -= 5, K(`JSON5: invalid identifier character at ${h}:${y}`);
        }
        function k(q) {
          const $ = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
          if ($[q])
            return $[q];
          if (q < " ") {
            const Y = q.charCodeAt(0).toString(16);
            return "\\x" + ("00" + Y).substring(Y.length);
          }
          return q;
        }
        function K(q) {
          const $ = new SyntaxError(q);
          return $.lineNumber = h, $.columnNumber = y, $;
        }
        const z = { parse: function(q, $) {
          d = String(q), s = "start", o = [], m = 0, h = 1, y = 0, b = void 0, E = void 0, S = void 0;
          do
            b = D(), O[s]();
          while (b.type !== "eof");
          return typeof $ == "function" ? g({ "": S }, "", $) : S;
        }, stringify: function(q, $, Y) {
          const H = [];
          let Q, X, ne, ye = "", ve = "";
          if ($ == null || typeof $ != "object" || Array.isArray($) || (Y = $.space, ne = $.quote, $ = $.replacer), typeof $ == "function")
            X = $;
          else if (Array.isArray($)) {
            Q = [];
            for (const ae of $) {
              let le;
              typeof ae == "string" ? le = ae : (typeof ae == "number" || ae instanceof String || ae instanceof Number) && (le = String(ae)), le !== void 0 && Q.indexOf(le) < 0 && Q.push(le);
            }
          }
          return Y instanceof Number ? Y = Number(Y) : Y instanceof String && (Y = String(Y)), typeof Y == "number" ? Y > 0 && (Y = Math.min(10, Math.floor(Y)), ve = "          ".substr(0, Y)) : typeof Y == "string" && (ve = Y.substr(0, 10)), de("", { "": q });
          function de(ae, le) {
            let ue = le[ae];
            switch (ue != null && (typeof ue.toJSON5 == "function" ? ue = ue.toJSON5(ae) : typeof ue.toJSON == "function" && (ue = ue.toJSON(ae))), X && (ue = X.call(le, ae, ue)), ue instanceof Number ? ue = Number(ue) : ue instanceof String ? ue = String(ue) : ue instanceof Boolean && (ue = ue.valueOf()), ue) {
              case null:
                return "null";
              case !0:
                return "true";
              case !1:
                return "false";
            }
            return typeof ue == "string" ? oe(ue) : typeof ue == "number" ? String(ue) : typeof ue == "object" ? Array.isArray(ue) ? function(ie) {
              if (H.indexOf(ie) >= 0)
                throw TypeError("Converting circular structure to JSON5");
              H.push(ie);
              let we = ye;
              ye += ve;
              let De, Ee = [];
              for (let Ae = 0; Ae < ie.length; Ae++) {
                const Me = de(String(Ae), ie);
                Ee.push(Me !== void 0 ? Me : "null");
              }
              if (Ee.length === 0)
                De = "[]";
              else if (ve === "")
                De = "[" + Ee.join(",") + "]";
              else {
                let Ae = `,
` + ye, Me = Ee.join(Ae);
                De = `[
` + ye + Me + `,
` + we + "]";
              }
              return H.pop(), ye = we, De;
            }(ue) : function(ie) {
              if (H.indexOf(ie) >= 0)
                throw TypeError("Converting circular structure to JSON5");
              H.push(ie);
              let we = ye;
              ye += ve;
              let De, Ee = Q || Object.keys(ie), Ae = [];
              for (const Me of Ee) {
                const me = de(Me, ie);
                if (me !== void 0) {
                  let se = re(Me) + ":";
                  ve !== "" && (se += " "), se += me, Ae.push(se);
                }
              }
              if (Ae.length === 0)
                De = "{}";
              else {
                let Me;
                if (ve === "")
                  Me = Ae.join(","), De = "{" + Me + "}";
                else {
                  let me = `,
` + ye;
                  Me = Ae.join(me), De = `{
` + ye + Me + `,
` + we + "}";
                }
              }
              return H.pop(), ye = we, De;
            }(ue) : void 0;
          }
          function oe(ae) {
            const le = { "'": 0.1, '"': 0.2 }, ue = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
            let ie = "";
            for (let De = 0; De < ae.length; De++) {
              const Ee = ae[De];
              switch (Ee) {
                case "'":
                case '"':
                  le[Ee]++, ie += Ee;
                  continue;
                case "\0":
                  if (f.isDigit(ae[De + 1])) {
                    ie += "\\x00";
                    continue;
                  }
              }
              if (ue[Ee])
                ie += ue[Ee];
              else if (Ee < " ") {
                let Ae = Ee.charCodeAt(0).toString(16);
                ie += "\\x" + ("00" + Ae).substring(Ae.length);
              } else
                ie += Ee;
            }
            const we = ne || Object.keys(le).reduce((De, Ee) => le[De] < le[Ee] ? De : Ee);
            return ie = ie.replace(new RegExp(we, "g"), ue[we]), we + ie + we;
          }
          function re(ae) {
            if (ae.length === 0)
              return oe(ae);
            const le = String.fromCodePoint(ae.codePointAt(0));
            if (!f.isIdStartChar(le))
              return oe(ae);
            for (let ue = le.length; ue < ae.length; ue++)
              if (!f.isIdContinueChar(String.fromCodePoint(ae.codePointAt(ue))))
                return oe(ae);
            return ae;
          }
        } };
      }, "./node_modules/.pnpm/@babel+preset-typescript@7.22.15_@babel+core@7.22.15/node_modules/@babel/preset-typescript/package.json": (u) => {
        u.exports = JSON.parse('{"name":"@babel/preset-typescript","version":"7.22.15","description":"Babel preset for TypeScript.","repository":{"type":"git","url":"https://github.com/babel/babel.git","directory":"packages/babel-preset-typescript"},"license":"MIT","publishConfig":{"access":"public"},"main":"./lib/index.js","keywords":["babel-preset","typescript"],"dependencies":{"@babel/helper-plugin-utils":"^7.22.5","@babel/helper-validator-option":"^7.22.15","@babel/plugin-syntax-jsx":"^7.22.5","@babel/plugin-transform-modules-commonjs":"^7.22.15","@babel/plugin-transform-typescript":"^7.22.15"},"peerDependencies":{"@babel/core":"^7.0.0-0"},"devDependencies":{"@babel/core":"^7.22.15","@babel/helper-plugin-test-runner":"^7.22.5"},"homepage":"https://babel.dev/docs/en/next/babel-preset-typescript","bugs":"https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22area%3A%20typescript%22+is%3Aopen","engines":{"node":">=6.9.0"},"author":"The Babel Team (https://babel.dev/team)","type":"commonjs"}');
      }, "./node_modules/.pnpm/globals@11.12.0/node_modules/globals/globals.json": (u) => {
        u.exports = JSON.parse('{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}');
      } }, n = {};
      function a(u) {
        var r = n[u];
        if (r !== void 0)
          return r.exports;
        var l = n[u] = { exports: {} };
        return e[u].call(l.exports, l, l.exports, a), l.exports;
      }
      a.d = (u, r) => {
        for (var l in r)
          a.o(r, l) && !a.o(u, l) && Object.defineProperty(u, l, { enumerable: !0, get: r[l] });
      }, a.o = (u, r) => Object.prototype.hasOwnProperty.call(u, r), a.r = (u) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(u, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(u, "__esModule", { value: !0 });
      };
      var c = {};
      (() => {
        a.d(c, { default: () => d });
        var u = a("./node_modules/.pnpm/@babel+core@7.22.15/node_modules/@babel/core/lib/index.js"), r = a("url"), l = a("./node_modules/.pnpm/@babel+template@7.22.15/node_modules/@babel/template/lib/index.js");
        function i(s, o) {
          return { name: "transform-import-meta", visitor: { Program(m) {
            const h = [];
            if (m.traverse({ MemberExpression(y) {
              const { node: b } = y;
              b.object.type === "MetaProperty" && b.object.meta.name === "import" && b.object.property.name === "meta" && b.property.type === "Identifier" && b.property.name === "url" && h.push(y);
            } }), h.length !== 0)
              for (const y of h)
                y.replaceWith(l.smart.ast`${o.filename ? JSON.stringify((0, r.pathToFileURL)(o.filename)) : "require('url').pathToFileURL(__filename).toString()"}`);
          } } };
        }
        function f({ template: s, types: o }) {
          return { name: "@import-meta-env/babel", visitor: { Identifier(m) {
            if (!o.isIdentifier(m) || !o.isMemberExpression(m.parentPath) && !o.isOptionalMemberExpression(m.parentPath) || !o.isMemberExpression(m.parentPath.node))
              return;
            const h = m.parentPath.node;
            if (!o.isMetaProperty(h.object))
              return;
            const y = h.object;
            y.meta.name === "import" && y.property.name === "meta" && h.property.name === "env" && m.parentPath.replaceWith(s.expression.ast("process.env"));
          } } };
        }
        function d(s) {
          var o, m, h, y, b, E;
          const S = Object.assign(Object.assign({ babelrc: !1, configFile: !1, compact: !1, retainLines: typeof s.retainLines != "boolean" || s.retainLines, filename: "", cwd: "/" }, s.babel), { plugins: [[a("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js"), { allowTopLevelThis: !0 }], [a("./node_modules/.pnpm/babel-plugin-dynamic-import-node@2.3.3/node_modules/babel-plugin-dynamic-import-node/lib/index.js"), { noInterop: !0 }], [i, { filename: s.filename }], [a("./node_modules/.pnpm/@babel+plugin-syntax-class-properties@7.12.13_@babel+core@7.22.15/node_modules/@babel/plugin-syntax-class-properties/lib/index.js")], [a("./node_modules/.pnpm/@babel+plugin-transform-export-namespace-from@7.22.11_@babel+core@7.22.15/node_modules/@babel/plugin-transform-export-namespace-from/lib/index.js")], [f]] });
          s.ts && (S.plugins.push([a("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-transform-typescript/lib/index.js"), { allowDeclareFields: !0 }]), S.plugins.unshift([a("./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.22.15/node_modules/babel-plugin-transform-typescript-metadata/lib/plugin.js")], [a("./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-proposal-decorators/lib/index.js"), { legacy: !0 }]), S.plugins.push(a("./node_modules/.pnpm/babel-plugin-parameter-decorator@1.0.16/node_modules/babel-plugin-parameter-decorator/lib/index.js")), S.plugins.push(a("./node_modules/.pnpm/@babel+plugin-syntax-import-assertions@7.22.5_@babel+core@7.22.15/node_modules/@babel/plugin-syntax-import-assertions/lib/index.js"))), s.legacy && (S.plugins.push(a("./node_modules/.pnpm/@babel+plugin-transform-nullish-coalescing-operator@7.22.11_@babel+core@7.22.15/node_modules/@babel/plugin-transform-nullish-coalescing-operator/lib/index.js")), S.plugins.push(a("./node_modules/.pnpm/@babel+plugin-transform-optional-chaining@7.22.15_@babel+core@7.22.15/node_modules/@babel/plugin-transform-optional-chaining/lib/index.js"))), s.babel && Array.isArray(s.babel.plugins) && ((o = S.plugins) === null || o === void 0 || o.push(...s.babel.plugins));
          try {
            return { code: ((m = (0, u.transformSync)(s.source, S)) === null || m === void 0 ? void 0 : m.code) || "" };
          } catch (g) {
            return { error: g, code: "exports.__JITI_ERROR__ = " + JSON.stringify({ filename: s.filename, line: ((h = g.loc) === null || h === void 0 ? void 0 : h.line) || 0, column: ((y = g.loc) === null || y === void 0 ? void 0 : y.column) || 0, code: (b = g.code) === null || b === void 0 ? void 0 : b.replace("BABEL_", "").replace("PARSE_ERROR", "ParseError"), message: (E = g.message) === null || E === void 0 ? void 0 : E.replace("/: ", "").replace(/\(.+\)\s*$/, "") }) };
          }
        }
      })(), t.exports = c.default;
    })();
  }(Sm)), Sm.exports;
}
function VH(t) {
  throw t;
}
var WH = function(t, e) {
  const n = BH();
  return e = { onError: VH, ...e }, e.transform || (e.transform = UH()), n(t, e);
}, Fe;
(function(t) {
  t[t.NONE = 0] = "NONE";
  const n = 0 + 1;
  t[t._abstract = n] = "_abstract";
  const a = n + 1;
  t[t._accessor = a] = "_accessor";
  const c = a + 1;
  t[t._as = c] = "_as";
  const u = c + 1;
  t[t._assert = u] = "_assert";
  const r = u + 1;
  t[t._asserts = r] = "_asserts";
  const l = r + 1;
  t[t._async = l] = "_async";
  const i = l + 1;
  t[t._await = i] = "_await";
  const f = i + 1;
  t[t._checks = f] = "_checks";
  const d = f + 1;
  t[t._constructor = d] = "_constructor";
  const s = d + 1;
  t[t._declare = s] = "_declare";
  const o = s + 1;
  t[t._enum = o] = "_enum";
  const m = o + 1;
  t[t._exports = m] = "_exports";
  const h = m + 1;
  t[t._from = h] = "_from";
  const y = h + 1;
  t[t._get = y] = "_get";
  const b = y + 1;
  t[t._global = b] = "_global";
  const E = b + 1;
  t[t._implements = E] = "_implements";
  const S = E + 1;
  t[t._infer = S] = "_infer";
  const g = S + 1;
  t[t._interface = g] = "_interface";
  const P = g + 1;
  t[t._is = P] = "_is";
  const R = P + 1;
  t[t._keyof = R] = "_keyof";
  const N = R + 1;
  t[t._mixins = N] = "_mixins";
  const C = N + 1;
  t[t._module = C] = "_module";
  const I = C + 1;
  t[t._namespace = I] = "_namespace";
  const D = I + 1;
  t[t._of = D] = "_of";
  const j = D + 1;
  t[t._opaque = j] = "_opaque";
  const F = j + 1;
  t[t._out = F] = "_out";
  const _ = F + 1;
  t[t._override = _] = "_override";
  const T = _ + 1;
  t[t._private = T] = "_private";
  const v = T + 1;
  t[t._protected = v] = "_protected";
  const w = v + 1;
  t[t._proto = w] = "_proto";
  const O = w + 1;
  t[t._public = O] = "_public";
  const G = O + 1;
  t[t._readonly = G] = "_readonly";
  const W = G + 1;
  t[t._require = W] = "_require";
  const U = W + 1;
  t[t._satisfies = U] = "_satisfies";
  const M = U + 1;
  t[t._set = M] = "_set";
  const B = M + 1;
  t[t._static = B] = "_static";
  const k = B + 1;
  t[t._symbol = k] = "_symbol";
  const K = k + 1;
  t[t._type = K] = "_type";
  const te = K + 1;
  t[t._unique = te] = "_unique";
  const z = te + 1;
  t[t._using = z] = "_using";
})(Fe || (Fe = {}));
var L;
(function(t) {
  t[t.PRECEDENCE_MASK = 15] = "PRECEDENCE_MASK";
  const n = 16;
  t[t.IS_KEYWORD = n] = "IS_KEYWORD";
  const a = 32;
  t[t.IS_ASSIGN = a] = "IS_ASSIGN";
  const c = 64;
  t[t.IS_RIGHT_ASSOCIATIVE = c] = "IS_RIGHT_ASSOCIATIVE";
  const u = 128;
  t[t.IS_PREFIX = u] = "IS_PREFIX";
  const r = 256;
  t[t.IS_POSTFIX = r] = "IS_POSTFIX";
  const l = 512;
  t[t.IS_EXPRESSION_START = l] = "IS_EXPRESSION_START";
  const i = 512;
  t[t.num = i] = "num";
  const f = 1536;
  t[t.bigint = f] = "bigint";
  const d = 2560;
  t[t.decimal = d] = "decimal";
  const s = 3584;
  t[t.regexp = s] = "regexp";
  const o = 4608;
  t[t.string = o] = "string";
  const m = 5632;
  t[t.name = m] = "name";
  const h = 6144;
  t[t.eof = h] = "eof";
  const y = 7680;
  t[t.bracketL = y] = "bracketL";
  const b = 8192;
  t[t.bracketR = b] = "bracketR";
  const E = 9728;
  t[t.braceL = E] = "braceL";
  const S = 10752;
  t[t.braceBarL = S] = "braceBarL";
  const g = 11264;
  t[t.braceR = g] = "braceR";
  const P = 12288;
  t[t.braceBarR = P] = "braceBarR";
  const R = 13824;
  t[t.parenL = R] = "parenL";
  const N = 14336;
  t[t.parenR = N] = "parenR";
  const C = 15360;
  t[t.comma = C] = "comma";
  const I = 16384;
  t[t.semi = I] = "semi";
  const D = 17408;
  t[t.colon = D] = "colon";
  const j = 18432;
  t[t.doubleColon = j] = "doubleColon";
  const F = 19456;
  t[t.dot = F] = "dot";
  const _ = 20480;
  t[t.question = _] = "question";
  const T = 21504;
  t[t.questionDot = T] = "questionDot";
  const v = 22528;
  t[t.arrow = v] = "arrow";
  const w = 23552;
  t[t.template = w] = "template";
  const O = 24576;
  t[t.ellipsis = O] = "ellipsis";
  const G = 25600;
  t[t.backQuote = G] = "backQuote";
  const W = 27136;
  t[t.dollarBraceL = W] = "dollarBraceL";
  const U = 27648;
  t[t.at = U] = "at";
  const M = 29184;
  t[t.hash = M] = "hash";
  const B = 29728;
  t[t.eq = B] = "eq";
  const k = 30752;
  t[t.assign = k] = "assign";
  const K = 32640;
  t[t.preIncDec = K] = "preIncDec";
  const te = 33664;
  t[t.postIncDec = te] = "postIncDec";
  const z = 34432;
  t[t.bang = z] = "bang";
  const q = 35456;
  t[t.tilde = q] = "tilde";
  const $ = 35841;
  t[t.pipeline = $] = "pipeline";
  const Y = 36866;
  t[t.nullishCoalescing = Y] = "nullishCoalescing";
  const H = 37890;
  t[t.logicalOR = H] = "logicalOR";
  const Q = 38915;
  t[t.logicalAND = Q] = "logicalAND";
  const X = 39940;
  t[t.bitwiseOR = X] = "bitwiseOR";
  const ne = 40965;
  t[t.bitwiseXOR = ne] = "bitwiseXOR";
  const ye = 41990;
  t[t.bitwiseAND = ye] = "bitwiseAND";
  const ve = 43015;
  t[t.equality = ve] = "equality";
  const de = 44040;
  t[t.lessThan = de] = "lessThan";
  const oe = 45064;
  t[t.greaterThan = oe] = "greaterThan";
  const re = 46088;
  t[t.relationalOrEqual = re] = "relationalOrEqual";
  const ae = 47113;
  t[t.bitShiftL = ae] = "bitShiftL";
  const le = 48137;
  t[t.bitShiftR = le] = "bitShiftR";
  const ue = 49802;
  t[t.plus = ue] = "plus";
  const ie = 50826;
  t[t.minus = ie] = "minus";
  const we = 51723;
  t[t.modulo = we] = "modulo";
  const De = 52235;
  t[t.star = De] = "star";
  const Ee = 53259;
  t[t.slash = Ee] = "slash";
  const Ae = 54348;
  t[t.exponent = Ae] = "exponent";
  const Me = 55296;
  t[t.jsxName = Me] = "jsxName";
  const me = 56320;
  t[t.jsxText = me] = "jsxText";
  const se = 57344;
  t[t.jsxEmptyText = se] = "jsxEmptyText";
  const Z = 58880;
  t[t.jsxTagStart = Z] = "jsxTagStart";
  const pe = 59392;
  t[t.jsxTagEnd = pe] = "jsxTagEnd";
  const be = 60928;
  t[t.typeParameterStart = be] = "typeParameterStart";
  const _e = 61440;
  t[t.nonNullAssertion = _e] = "nonNullAssertion";
  const Ie = 62480;
  t[t._break = Ie] = "_break";
  const We = 63504;
  t[t._case = We] = "_case";
  const tt = 64528;
  t[t._catch = tt] = "_catch";
  const Ye = 65552;
  t[t._continue = Ye] = "_continue";
  const ht = 66576;
  t[t._debugger = ht] = "_debugger";
  const ct = 67600;
  t[t._default = ct] = "_default";
  const st = 68624;
  t[t._do = st] = "_do";
  const Xe = 69648;
  t[t._else = Xe] = "_else";
  const Ke = 70672;
  t[t._finally = Ke] = "_finally";
  const Ce = 71696;
  t[t._for = Ce] = "_for";
  const xe = 73232;
  t[t._function = xe] = "_function";
  const He = 73744;
  t[t._if = He] = "_if";
  const Be = 74768;
  t[t._return = Be] = "_return";
  const Ze = 75792;
  t[t._switch = Ze] = "_switch";
  const nt = 77456;
  t[t._throw = nt] = "_throw";
  const $e = 77840;
  t[t._try = $e] = "_try";
  const ut = 78864;
  t[t._var = ut] = "_var";
  const vt = 79888;
  t[t._let = vt] = "_let";
  const yt = 80912;
  t[t._const = yt] = "_const";
  const et = 81936;
  t[t._while = et] = "_while";
  const bt = 82960;
  t[t._with = bt] = "_with";
  const lt = 84496;
  t[t._new = lt] = "_new";
  const Et = 85520;
  t[t._this = Et] = "_this";
  const wt = 86544;
  t[t._super = wt] = "_super";
  const Ne = 87568;
  t[t._class = Ne] = "_class";
  const Je = 88080;
  t[t._extends = Je] = "_extends";
  const ft = 89104;
  t[t._export = ft] = "_export";
  const rt = 90640;
  t[t._import = rt] = "_import";
  const At = 91664;
  t[t._yield = At] = "_yield";
  const Nt = 92688;
  t[t._null = Nt] = "_null";
  const Tt = 93712;
  t[t._true = Tt] = "_true";
  const Ot = 94736;
  t[t._false = Ot] = "_false";
  const cr = 95256;
  t[t._in = cr] = "_in";
  const Wt = 96280;
  t[t._instanceof = Wt] = "_instanceof";
  const Jt = 97936;
  t[t._typeof = Jt] = "_typeof";
  const pr = 98960;
  t[t._void = pr] = "_void";
  const $r = 99984;
  t[t._delete = $r] = "_delete";
  const Ur = 100880;
  t[t._async = Ur] = "_async";
  const _r = 101904;
  t[t._get = _r] = "_get";
  const qn = 102928;
  t[t._set = qn] = "_set";
  const Mn = 103952;
  t[t._declare = Mn] = "_declare";
  const Ln = 104976;
  t[t._readonly = Ln] = "_readonly";
  const mn = 106e3;
  t[t._abstract = mn] = "_abstract";
  const jn = 107024;
  t[t._static = jn] = "_static";
  const yn = 107536;
  t[t._public = yn] = "_public";
  const bn = 108560;
  t[t._private = bn] = "_private";
  const En = 109584;
  t[t._protected = En] = "_protected";
  const Vr = 110608;
  t[t._override = Vr] = "_override";
  const zi = 112144;
  t[t._as = zi] = "_as";
  const As = 113168;
  t[t._enum = As] = "_enum";
  const ga = 114192;
  t[t._type = ga] = "_type";
  const Rt = 115216;
  t[t._implements = Rt] = "_implements";
})(L || (L = {}));
function $P(t) {
  switch (t) {
    case L.num:
      return "num";
    case L.bigint:
      return "bigint";
    case L.decimal:
      return "decimal";
    case L.regexp:
      return "regexp";
    case L.string:
      return "string";
    case L.name:
      return "name";
    case L.eof:
      return "eof";
    case L.bracketL:
      return "[";
    case L.bracketR:
      return "]";
    case L.braceL:
      return "{";
    case L.braceBarL:
      return "{|";
    case L.braceR:
      return "}";
    case L.braceBarR:
      return "|}";
    case L.parenL:
      return "(";
    case L.parenR:
      return ")";
    case L.comma:
      return ",";
    case L.semi:
      return ";";
    case L.colon:
      return ":";
    case L.doubleColon:
      return "::";
    case L.dot:
      return ".";
    case L.question:
      return "?";
    case L.questionDot:
      return "?.";
    case L.arrow:
      return "=>";
    case L.template:
      return "template";
    case L.ellipsis:
      return "...";
    case L.backQuote:
      return "`";
    case L.dollarBraceL:
      return "${";
    case L.at:
      return "@";
    case L.hash:
      return "#";
    case L.eq:
      return "=";
    case L.assign:
      return "_=";
    case L.preIncDec:
      return "++/--";
    case L.postIncDec:
      return "++/--";
    case L.bang:
      return "!";
    case L.tilde:
      return "~";
    case L.pipeline:
      return "|>";
    case L.nullishCoalescing:
      return "??";
    case L.logicalOR:
      return "||";
    case L.logicalAND:
      return "&&";
    case L.bitwiseOR:
      return "|";
    case L.bitwiseXOR:
      return "^";
    case L.bitwiseAND:
      return "&";
    case L.equality:
      return "==/!=";
    case L.lessThan:
      return "<";
    case L.greaterThan:
      return ">";
    case L.relationalOrEqual:
      return "<=/>=";
    case L.bitShiftL:
      return "<<";
    case L.bitShiftR:
      return ">>/>>>";
    case L.plus:
      return "+";
    case L.minus:
      return "-";
    case L.modulo:
      return "%";
    case L.star:
      return "*";
    case L.slash:
      return "/";
    case L.exponent:
      return "**";
    case L.jsxName:
      return "jsxName";
    case L.jsxText:
      return "jsxText";
    case L.jsxEmptyText:
      return "jsxEmptyText";
    case L.jsxTagStart:
      return "jsxTagStart";
    case L.jsxTagEnd:
      return "jsxTagEnd";
    case L.typeParameterStart:
      return "typeParameterStart";
    case L.nonNullAssertion:
      return "nonNullAssertion";
    case L._break:
      return "break";
    case L._case:
      return "case";
    case L._catch:
      return "catch";
    case L._continue:
      return "continue";
    case L._debugger:
      return "debugger";
    case L._default:
      return "default";
    case L._do:
      return "do";
    case L._else:
      return "else";
    case L._finally:
      return "finally";
    case L._for:
      return "for";
    case L._function:
      return "function";
    case L._if:
      return "if";
    case L._return:
      return "return";
    case L._switch:
      return "switch";
    case L._throw:
      return "throw";
    case L._try:
      return "try";
    case L._var:
      return "var";
    case L._let:
      return "let";
    case L._const:
      return "const";
    case L._while:
      return "while";
    case L._with:
      return "with";
    case L._new:
      return "new";
    case L._this:
      return "this";
    case L._super:
      return "super";
    case L._class:
      return "class";
    case L._extends:
      return "extends";
    case L._export:
      return "export";
    case L._import:
      return "import";
    case L._yield:
      return "yield";
    case L._null:
      return "null";
    case L._true:
      return "true";
    case L._false:
      return "false";
    case L._in:
      return "in";
    case L._instanceof:
      return "instanceof";
    case L._typeof:
      return "typeof";
    case L._void:
      return "void";
    case L._delete:
      return "delete";
    case L._async:
      return "async";
    case L._get:
      return "get";
    case L._set:
      return "set";
    case L._declare:
      return "declare";
    case L._readonly:
      return "readonly";
    case L._abstract:
      return "abstract";
    case L._static:
      return "static";
    case L._public:
      return "public";
    case L._private:
      return "private";
    case L._protected:
      return "protected";
    case L._override:
      return "override";
    case L._as:
      return "as";
    case L._enum:
      return "enum";
    case L._type:
      return "type";
    case L._implements:
      return "implements";
    default:
      return "";
  }
}
class gs {
  constructor(e, n, a) {
    this.startTokenIndex = e, this.endTokenIndex = n, this.isFunctionScope = a;
  }
}
class HH {
  constructor(e, n, a, c, u, r, l, i, f, d, s, o, m) {
    this.potentialArrowAt = e, this.noAnonFunctionType = n, this.inDisallowConditionalTypesContext = a, this.tokensLength = c, this.scopesLength = u, this.pos = r, this.type = l, this.contextualKeyword = i, this.start = f, this.end = d, this.isType = s, this.scopeDepth = o, this.error = m;
  }
}
class kn {
  constructor() {
    kn.prototype.__init.call(this), kn.prototype.__init2.call(this), kn.prototype.__init3.call(this), kn.prototype.__init4.call(this), kn.prototype.__init5.call(this), kn.prototype.__init6.call(this), kn.prototype.__init7.call(this), kn.prototype.__init8.call(this), kn.prototype.__init9.call(this), kn.prototype.__init10.call(this), kn.prototype.__init11.call(this), kn.prototype.__init12.call(this), kn.prototype.__init13.call(this);
  }
  // Used to signify the start of a potential arrow function
  __init() {
    this.potentialArrowAt = -1;
  }
  // Used by Flow to handle an edge case involving function type parsing.
  __init2() {
    this.noAnonFunctionType = !1;
  }
  // Used by TypeScript to handle ambiguities when parsing conditional types.
  __init3() {
    this.inDisallowConditionalTypesContext = !1;
  }
  // Token store.
  __init4() {
    this.tokens = [];
  }
  // Array of all observed scopes, ordered by their ending position.
  __init5() {
    this.scopes = [];
  }
  // The current position of the tokenizer in the input.
  __init6() {
    this.pos = 0;
  }
  // Information about the current token.
  __init7() {
    this.type = L.eof;
  }
  __init8() {
    this.contextualKeyword = Fe.NONE;
  }
  __init9() {
    this.start = 0;
  }
  __init10() {
    this.end = 0;
  }
  __init11() {
    this.isType = !1;
  }
  __init12() {
    this.scopeDepth = 0;
  }
  /**
   * If the parser is in an error state, then the token is always tt.eof and all functions can
   * keep executing but should be written so they don't get into an infinite loop in this situation.
   *
   * This approach, combined with the ability to snapshot and restore state, allows us to implement
   * backtracking without exceptions and without needing to explicitly propagate error states
   * everywhere.
   */
  __init13() {
    this.error = null;
  }
  snapshot() {
    return new HH(
      this.potentialArrowAt,
      this.noAnonFunctionType,
      this.inDisallowConditionalTypesContext,
      this.tokens.length,
      this.scopes.length,
      this.pos,
      this.type,
      this.contextualKeyword,
      this.start,
      this.end,
      this.isType,
      this.scopeDepth,
      this.error
    );
  }
  restoreFromSnapshot(e) {
    this.potentialArrowAt = e.potentialArrowAt, this.noAnonFunctionType = e.noAnonFunctionType, this.inDisallowConditionalTypesContext = e.inDisallowConditionalTypesContext, this.tokens.length = e.tokensLength, this.scopes.length = e.scopesLength, this.pos = e.pos, this.type = e.type, this.contextualKeyword = e.contextualKeyword, this.start = e.start, this.end = e.end, this.isType = e.isType, this.scopeDepth = e.scopeDepth, this.error = e.error;
  }
}
var Ge;
(function(t) {
  t[t.backSpace = 8] = "backSpace";
  const n = 10;
  t[t.lineFeed = n] = "lineFeed";
  const a = 9;
  t[t.tab = a] = "tab";
  const c = 13;
  t[t.carriageReturn = c] = "carriageReturn";
  const u = 14;
  t[t.shiftOut = u] = "shiftOut";
  const r = 32;
  t[t.space = r] = "space";
  const l = 33;
  t[t.exclamationMark = l] = "exclamationMark";
  const i = 34;
  t[t.quotationMark = i] = "quotationMark";
  const f = 35;
  t[t.numberSign = f] = "numberSign";
  const d = 36;
  t[t.dollarSign = d] = "dollarSign";
  const s = 37;
  t[t.percentSign = s] = "percentSign";
  const o = 38;
  t[t.ampersand = o] = "ampersand";
  const m = 39;
  t[t.apostrophe = m] = "apostrophe";
  const h = 40;
  t[t.leftParenthesis = h] = "leftParenthesis";
  const y = 41;
  t[t.rightParenthesis = y] = "rightParenthesis";
  const b = 42;
  t[t.asterisk = b] = "asterisk";
  const E = 43;
  t[t.plusSign = E] = "plusSign";
  const S = 44;
  t[t.comma = S] = "comma";
  const g = 45;
  t[t.dash = g] = "dash";
  const P = 46;
  t[t.dot = P] = "dot";
  const R = 47;
  t[t.slash = R] = "slash";
  const N = 48;
  t[t.digit0 = N] = "digit0";
  const C = 49;
  t[t.digit1 = C] = "digit1";
  const I = 50;
  t[t.digit2 = I] = "digit2";
  const D = 51;
  t[t.digit3 = D] = "digit3";
  const j = 52;
  t[t.digit4 = j] = "digit4";
  const F = 53;
  t[t.digit5 = F] = "digit5";
  const _ = 54;
  t[t.digit6 = _] = "digit6";
  const T = 55;
  t[t.digit7 = T] = "digit7";
  const v = 56;
  t[t.digit8 = v] = "digit8";
  const w = 57;
  t[t.digit9 = w] = "digit9";
  const O = 58;
  t[t.colon = O] = "colon";
  const G = 59;
  t[t.semicolon = G] = "semicolon";
  const W = 60;
  t[t.lessThan = W] = "lessThan";
  const U = 61;
  t[t.equalsTo = U] = "equalsTo";
  const M = 62;
  t[t.greaterThan = M] = "greaterThan";
  const B = 63;
  t[t.questionMark = B] = "questionMark";
  const k = 64;
  t[t.atSign = k] = "atSign";
  const K = 65;
  t[t.uppercaseA = K] = "uppercaseA";
  const te = 66;
  t[t.uppercaseB = te] = "uppercaseB";
  const z = 67;
  t[t.uppercaseC = z] = "uppercaseC";
  const q = 68;
  t[t.uppercaseD = q] = "uppercaseD";
  const $ = 69;
  t[t.uppercaseE = $] = "uppercaseE";
  const Y = 70;
  t[t.uppercaseF = Y] = "uppercaseF";
  const H = 71;
  t[t.uppercaseG = H] = "uppercaseG";
  const Q = 72;
  t[t.uppercaseH = Q] = "uppercaseH";
  const X = 73;
  t[t.uppercaseI = X] = "uppercaseI";
  const ne = 74;
  t[t.uppercaseJ = ne] = "uppercaseJ";
  const ye = 75;
  t[t.uppercaseK = ye] = "uppercaseK";
  const ve = 76;
  t[t.uppercaseL = ve] = "uppercaseL";
  const de = 77;
  t[t.uppercaseM = de] = "uppercaseM";
  const oe = 78;
  t[t.uppercaseN = oe] = "uppercaseN";
  const re = 79;
  t[t.uppercaseO = re] = "uppercaseO";
  const ae = 80;
  t[t.uppercaseP = ae] = "uppercaseP";
  const le = 81;
  t[t.uppercaseQ = le] = "uppercaseQ";
  const ue = 82;
  t[t.uppercaseR = ue] = "uppercaseR";
  const ie = 83;
  t[t.uppercaseS = ie] = "uppercaseS";
  const we = 84;
  t[t.uppercaseT = we] = "uppercaseT";
  const De = 85;
  t[t.uppercaseU = De] = "uppercaseU";
  const Ee = 86;
  t[t.uppercaseV = Ee] = "uppercaseV";
  const Ae = 87;
  t[t.uppercaseW = Ae] = "uppercaseW";
  const Me = 88;
  t[t.uppercaseX = Me] = "uppercaseX";
  const me = 89;
  t[t.uppercaseY = me] = "uppercaseY";
  const se = 90;
  t[t.uppercaseZ = se] = "uppercaseZ";
  const Z = 91;
  t[t.leftSquareBracket = Z] = "leftSquareBracket";
  const pe = 92;
  t[t.backslash = pe] = "backslash";
  const be = 93;
  t[t.rightSquareBracket = be] = "rightSquareBracket";
  const _e = 94;
  t[t.caret = _e] = "caret";
  const Ie = 95;
  t[t.underscore = Ie] = "underscore";
  const We = 96;
  t[t.graveAccent = We] = "graveAccent";
  const tt = 97;
  t[t.lowercaseA = tt] = "lowercaseA";
  const Ye = 98;
  t[t.lowercaseB = Ye] = "lowercaseB";
  const ht = 99;
  t[t.lowercaseC = ht] = "lowercaseC";
  const ct = 100;
  t[t.lowercaseD = ct] = "lowercaseD";
  const st = 101;
  t[t.lowercaseE = st] = "lowercaseE";
  const Xe = 102;
  t[t.lowercaseF = Xe] = "lowercaseF";
  const Ke = 103;
  t[t.lowercaseG = Ke] = "lowercaseG";
  const Ce = 104;
  t[t.lowercaseH = Ce] = "lowercaseH";
  const xe = 105;
  t[t.lowercaseI = xe] = "lowercaseI";
  const He = 106;
  t[t.lowercaseJ = He] = "lowercaseJ";
  const Be = 107;
  t[t.lowercaseK = Be] = "lowercaseK";
  const Ze = 108;
  t[t.lowercaseL = Ze] = "lowercaseL";
  const nt = 109;
  t[t.lowercaseM = nt] = "lowercaseM";
  const $e = 110;
  t[t.lowercaseN = $e] = "lowercaseN";
  const ut = 111;
  t[t.lowercaseO = ut] = "lowercaseO";
  const vt = 112;
  t[t.lowercaseP = vt] = "lowercaseP";
  const yt = 113;
  t[t.lowercaseQ = yt] = "lowercaseQ";
  const et = 114;
  t[t.lowercaseR = et] = "lowercaseR";
  const bt = 115;
  t[t.lowercaseS = bt] = "lowercaseS";
  const lt = 116;
  t[t.lowercaseT = lt] = "lowercaseT";
  const Et = 117;
  t[t.lowercaseU = Et] = "lowercaseU";
  const wt = 118;
  t[t.lowercaseV = wt] = "lowercaseV";
  const Ne = 119;
  t[t.lowercaseW = Ne] = "lowercaseW";
  const Je = 120;
  t[t.lowercaseX = Je] = "lowercaseX";
  const ft = 121;
  t[t.lowercaseY = ft] = "lowercaseY";
  const rt = 122;
  t[t.lowercaseZ = rt] = "lowercaseZ";
  const At = 123;
  t[t.leftCurlyBrace = At] = "leftCurlyBrace";
  const Nt = 124;
  t[t.verticalBar = Nt] = "verticalBar";
  const Tt = 125;
  t[t.rightCurlyBrace = Tt] = "rightCurlyBrace";
  const Ot = 126;
  t[t.tilde = Ot] = "tilde";
  const cr = 160;
  t[t.nonBreakingSpace = cr] = "nonBreakingSpace";
  const Wt = 5760;
  t[t.oghamSpaceMark = Wt] = "oghamSpaceMark";
  const Jt = 8232;
  t[t.lineSeparator = Jt] = "lineSeparator";
  const pr = 8233;
  t[t.paragraphSeparator = pr] = "paragraphSeparator";
})(Ge || (Ge = {}));
let Sp, rr, or, ce, _t, UP;
function pu() {
  return UP++;
}
function qH(t) {
  if ("pos" in t) {
    const e = zH(t.pos);
    t.message += ` (${e.line}:${e.column})`, t.loc = e;
  }
  return t;
}
class GH {
  constructor(e, n) {
    this.line = e, this.column = n;
  }
}
function zH(t) {
  let e = 1, n = 1;
  for (let a = 0; a < t; a++)
    _t.charCodeAt(a) === Ge.lineFeed ? (e++, n = 1) : n++;
  return new GH(e, n);
}
function KH(t, e, n, a) {
  _t = t, ce = new kn(), UP = 1, Sp = e, rr = n, or = a;
}
function Dt(t) {
  return ce.contextualKeyword === t;
}
function jb(t) {
  const e = ec();
  return e.type === L.name && e.contextualKeyword === t;
}
function Jr(t) {
  return ce.contextualKeyword === t && it(L.name);
}
function Br(t) {
  Jr(t) || Gt();
}
function Yn() {
  return ke(L.eof) || ke(L.braceR) || Rn();
}
function Rn() {
  const t = ce.tokens[ce.tokens.length - 1], e = t ? t.end : 0;
  for (let n = e; n < ce.start; n++) {
    const a = _t.charCodeAt(n);
    if (a === Ge.lineFeed || a === Ge.carriageReturn || a === 8232 || a === 8233)
      return !0;
  }
  return !1;
}
function VP() {
  const t = Fb();
  for (let e = ce.end; e < t; e++) {
    const n = _t.charCodeAt(e);
    if (n === Ge.lineFeed || n === Ge.carriageReturn || n === 8232 || n === 8233)
      return !0;
  }
  return !1;
}
function ss() {
  return it(L.semi) || Yn();
}
function Tr() {
  ss() || Gt('Unexpected token, expected ";"');
}
function dt(t) {
  it(t) || Gt(`Unexpected token, expected "${$P(t)}"`);
}
function Gt(t = "Unexpected token", e = ce.start) {
  if (ce.error)
    return;
  const n = new SyntaxError(t);
  n.pos = e, ce.error = n, ce.pos = _t.length, qt(L.eof);
}
const WP = [
  9,
  11,
  12,
  Ge.space,
  Ge.nonBreakingSpace,
  Ge.oghamSpaceMark,
  8192,
  // EN QUAD
  8193,
  // EM QUAD
  8194,
  // EN SPACE
  8195,
  // EM SPACE
  8196,
  // THREE-PER-EM SPACE
  8197,
  // FOUR-PER-EM SPACE
  8198,
  // SIX-PER-EM SPACE
  8199,
  // FIGURE SPACE
  8200,
  // PUNCTUATION SPACE
  8201,
  // THIN SPACE
  8202,
  // HAIR SPACE
  8239,
  // NARROW NO-BREAK SPACE
  8287,
  // MEDIUM MATHEMATICAL SPACE
  12288,
  // IDEOGRAPHIC SPACE
  65279
  // ZERO WIDTH NO-BREAK SPACE
], tS = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, HP = new Uint8Array(65536);
for (const t of WP)
  HP[t] = 1;
function YH(t) {
  if (t < 48)
    return t === 36;
  if (t < 58)
    return !0;
  if (t < 65)
    return !1;
  if (t < 91)
    return !0;
  if (t < 97)
    return t === 95;
  if (t < 123)
    return !0;
  if (t < 128)
    return !1;
  throw new Error("Should not be called with non-ASCII char code.");
}
const Fi = new Uint8Array(65536);
for (let t = 0; t < 128; t++)
  Fi[t] = YH(t) ? 1 : 0;
for (let t = 128; t < 65536; t++)
  Fi[t] = 1;
for (const t of WP)
  Fi[t] = 0;
Fi[8232] = 0;
Fi[8233] = 0;
const Zu = Fi.slice();
for (let t = Ge.digit0; t <= Ge.digit9; t++)
  Zu[t] = 0;
const rS = new Int32Array([
  // ""
  -1,
  27,
  783,
  918,
  1755,
  2376,
  2862,
  3483,
  -1,
  3699,
  -1,
  4617,
  4752,
  4833,
  5130,
  5508,
  5940,
  -1,
  6480,
  6939,
  7749,
  8181,
  8451,
  8613,
  -1,
  8829,
  -1,
  // "a"
  -1,
  -1,
  54,
  243,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  432,
  -1,
  -1,
  -1,
  675,
  -1,
  -1,
  -1,
  // "ab"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  81,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abs"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  108,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abst"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  135,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abstr"
  -1,
  162,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abstra"
  -1,
  -1,
  -1,
  189,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abstrac"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  216,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abstract"
  Fe._abstract << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ac"
  -1,
  -1,
  -1,
  270,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "acc"
  -1,
  -1,
  -1,
  -1,
  -1,
  297,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "acce"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  324,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "acces"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  351,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "access"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  378,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "accesso"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  405,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "accessor"
  Fe._accessor << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "as"
  Fe._as << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  459,
  -1,
  -1,
  -1,
  -1,
  -1,
  594,
  -1,
  // "ass"
  -1,
  -1,
  -1,
  -1,
  -1,
  486,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "asse"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  513,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "asser"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  540,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "assert"
  Fe._assert << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  567,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "asserts"
  Fe._asserts << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "asy"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  621,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "asyn"
  -1,
  -1,
  -1,
  648,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "async"
  Fe._async << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "aw"
  -1,
  702,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "awa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  729,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "awai"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  756,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "await"
  Fe._await << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "b"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  810,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "br"
  -1,
  -1,
  -1,
  -1,
  -1,
  837,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "bre"
  -1,
  864,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "brea"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  891,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "break"
  (L._break << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "c"
  -1,
  945,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1107,
  -1,
  -1,
  -1,
  1242,
  -1,
  -1,
  1350,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ca"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  972,
  1026,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cas"
  -1,
  -1,
  -1,
  -1,
  -1,
  999,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "case"
  (L._case << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cat"
  -1,
  -1,
  -1,
  1053,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "catc"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1080,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "catch"
  (L._catch << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ch"
  -1,
  -1,
  -1,
  -1,
  -1,
  1134,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "che"
  -1,
  -1,
  -1,
  1161,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "chec"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1188,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "check"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1215,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "checks"
  Fe._checks << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cl"
  -1,
  1269,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cla"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1296,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "clas"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1323,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "class"
  (L._class << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "co"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1377,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "con"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1404,
  1620,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cons"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1431,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "const"
  (L._const << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1458,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "constr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1485,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "constru"
  -1,
  -1,
  -1,
  1512,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "construc"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1539,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "construct"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1566,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "constructo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1593,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "constructor"
  Fe._constructor << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cont"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1647,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "conti"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1674,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "contin"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1701,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "continu"
  -1,
  -1,
  -1,
  -1,
  -1,
  1728,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "continue"
  (L._continue << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "d"
  -1,
  -1,
  -1,
  -1,
  -1,
  1782,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2349,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "de"
  -1,
  -1,
  1809,
  1971,
  -1,
  -1,
  2106,
  -1,
  -1,
  -1,
  -1,
  -1,
  2241,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "deb"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1836,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "debu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1863,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "debug"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1890,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "debugg"
  -1,
  -1,
  -1,
  -1,
  -1,
  1917,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "debugge"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1944,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "debugger"
  (L._debugger << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "dec"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1998,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "decl"
  -1,
  2025,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "decla"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2052,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "declar"
  -1,
  -1,
  -1,
  -1,
  -1,
  2079,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "declare"
  Fe._declare << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "def"
  -1,
  2133,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "defa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2160,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "defau"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2187,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "defaul"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2214,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "default"
  (L._default << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "del"
  -1,
  -1,
  -1,
  -1,
  -1,
  2268,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "dele"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2295,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "delet"
  -1,
  -1,
  -1,
  -1,
  -1,
  2322,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "delete"
  (L._delete << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "do"
  (L._do << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "e"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2403,
  -1,
  2484,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2565,
  -1,
  -1,
  // "el"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2430,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "els"
  -1,
  -1,
  -1,
  -1,
  -1,
  2457,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "else"
  (L._else << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "en"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2511,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "enu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2538,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "enum"
  Fe._enum << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ex"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2592,
  -1,
  -1,
  -1,
  2727,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "exp"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2619,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "expo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2646,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "expor"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2673,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "export"
  (L._export << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2700,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "exports"
  Fe._exports << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ext"
  -1,
  -1,
  -1,
  -1,
  -1,
  2754,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "exte"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2781,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "exten"
  -1,
  -1,
  -1,
  -1,
  2808,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "extend"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2835,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "extends"
  (L._extends << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "f"
  -1,
  2889,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2997,
  -1,
  -1,
  -1,
  -1,
  -1,
  3159,
  -1,
  -1,
  3213,
  -1,
  -1,
  3294,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2916,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fal"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2943,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fals"
  -1,
  -1,
  -1,
  -1,
  -1,
  2970,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "false"
  (L._false << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3024,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fin"
  -1,
  3051,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fina"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3078,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "final"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3105,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "finall"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3132,
  -1,
  // "finally"
  (L._finally << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3186,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "for"
  (L._for << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3240,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fro"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3267,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "from"
  Fe._from << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3321,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fun"
  -1,
  -1,
  -1,
  3348,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "func"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3375,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "funct"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3402,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "functi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3429,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "functio"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3456,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "function"
  (L._function << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "g"
  -1,
  -1,
  -1,
  -1,
  -1,
  3510,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3564,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ge"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3537,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "get"
  Fe._get << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "gl"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3591,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "glo"
  -1,
  -1,
  3618,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "glob"
  -1,
  3645,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "globa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3672,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "global"
  Fe._global << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "i"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3726,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3753,
  4077,
  -1,
  -1,
  -1,
  -1,
  4590,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "if"
  (L._if << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "im"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3780,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "imp"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3807,
  -1,
  -1,
  3996,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "impl"
  -1,
  -1,
  -1,
  -1,
  -1,
  3834,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "imple"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3861,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "implem"
  -1,
  -1,
  -1,
  -1,
  -1,
  3888,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "impleme"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3915,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "implemen"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3942,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "implement"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3969,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "implements"
  Fe._implements << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "impo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4023,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "impor"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4050,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "import"
  (L._import << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "in"
  (L._in << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4104,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4185,
  4401,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "inf"
  -1,
  -1,
  -1,
  -1,
  -1,
  4131,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "infe"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4158,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "infer"
  Fe._infer << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ins"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4212,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "inst"
  -1,
  4239,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "insta"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4266,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "instan"
  -1,
  -1,
  -1,
  4293,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "instanc"
  -1,
  -1,
  -1,
  -1,
  -1,
  4320,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "instance"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4347,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "instanceo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4374,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "instanceof"
  (L._instanceof << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "int"
  -1,
  -1,
  -1,
  -1,
  -1,
  4428,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "inte"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4455,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "inter"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4482,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "interf"
  -1,
  4509,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "interfa"
  -1,
  -1,
  -1,
  4536,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "interfac"
  -1,
  -1,
  -1,
  -1,
  -1,
  4563,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "interface"
  Fe._interface << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "is"
  Fe._is << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "k"
  -1,
  -1,
  -1,
  -1,
  -1,
  4644,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ke"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4671,
  -1,
  // "key"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4698,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "keyo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4725,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "keyof"
  Fe._keyof << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "l"
  -1,
  -1,
  -1,
  -1,
  -1,
  4779,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "le"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4806,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "let"
  (L._let << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "m"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4860,
  -1,
  -1,
  -1,
  -1,
  -1,
  4995,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4887,
  -1,
  -1,
  // "mix"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4914,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mixi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4941,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mixin"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4968,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mixins"
  Fe._mixins << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mo"
  -1,
  -1,
  -1,
  -1,
  5022,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mod"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5049,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "modu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5076,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "modul"
  -1,
  -1,
  -1,
  -1,
  -1,
  5103,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "module"
  Fe._module << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "n"
  -1,
  5157,
  -1,
  -1,
  -1,
  5373,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5427,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "na"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5184,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "nam"
  -1,
  -1,
  -1,
  -1,
  -1,
  5211,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "name"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5238,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "names"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5265,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "namesp"
  -1,
  5292,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "namespa"
  -1,
  -1,
  -1,
  5319,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "namespac"
  -1,
  -1,
  -1,
  -1,
  -1,
  5346,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "namespace"
  Fe._namespace << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ne"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5400,
  -1,
  -1,
  -1,
  // "new"
  (L._new << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "nu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5454,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "nul"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5481,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "null"
  (L._null << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "o"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5535,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5562,
  -1,
  -1,
  -1,
  -1,
  5697,
  5751,
  -1,
  -1,
  -1,
  -1,
  // "of"
  Fe._of << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "op"
  -1,
  5589,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "opa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5616,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "opaq"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5643,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "opaqu"
  -1,
  -1,
  -1,
  -1,
  -1,
  5670,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "opaque"
  Fe._opaque << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ou"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5724,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "out"
  Fe._out << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ov"
  -1,
  -1,
  -1,
  -1,
  -1,
  5778,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ove"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5805,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "over"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5832,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "overr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5859,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "overri"
  -1,
  -1,
  -1,
  -1,
  5886,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "overrid"
  -1,
  -1,
  -1,
  -1,
  -1,
  5913,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "override"
  Fe._override << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "p"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5967,
  -1,
  -1,
  6345,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "pr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5994,
  -1,
  -1,
  -1,
  -1,
  -1,
  6129,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "pri"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6021,
  -1,
  -1,
  -1,
  -1,
  // "priv"
  -1,
  6048,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "priva"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6075,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "privat"
  -1,
  -1,
  -1,
  -1,
  -1,
  6102,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "private"
  Fe._private << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "pro"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6156,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "prot"
  -1,
  -1,
  -1,
  -1,
  -1,
  6183,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6318,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "prote"
  -1,
  -1,
  -1,
  6210,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "protec"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6237,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "protect"
  -1,
  -1,
  -1,
  -1,
  -1,
  6264,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "protecte"
  -1,
  -1,
  -1,
  -1,
  6291,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "protected"
  Fe._protected << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "proto"
  Fe._proto << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "pu"
  -1,
  -1,
  6372,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "pub"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6399,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "publ"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6426,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "publi"
  -1,
  -1,
  -1,
  6453,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "public"
  Fe._public << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "r"
  -1,
  -1,
  -1,
  -1,
  -1,
  6507,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "re"
  -1,
  6534,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6696,
  -1,
  -1,
  6831,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "rea"
  -1,
  -1,
  -1,
  -1,
  6561,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "read"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6588,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "reado"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6615,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "readon"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6642,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "readonl"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6669,
  -1,
  // "readonly"
  Fe._readonly << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "req"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6723,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "requ"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6750,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "requi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6777,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "requir"
  -1,
  -1,
  -1,
  -1,
  -1,
  6804,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "require"
  Fe._require << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ret"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6858,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "retu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6885,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "retur"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6912,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "return"
  (L._return << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "s"
  -1,
  6966,
  -1,
  -1,
  -1,
  7182,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7236,
  7371,
  -1,
  7479,
  -1,
  7614,
  -1,
  // "sa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6993,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sat"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7020,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sati"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7047,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "satis"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7074,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "satisf"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7101,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "satisfi"
  -1,
  -1,
  -1,
  -1,
  -1,
  7128,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "satisfie"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7155,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "satisfies"
  Fe._satisfies << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "se"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7209,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "set"
  Fe._set << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "st"
  -1,
  7263,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sta"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7290,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "stat"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7317,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "stati"
  -1,
  -1,
  -1,
  7344,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "static"
  Fe._static << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "su"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7398,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sup"
  -1,
  -1,
  -1,
  -1,
  -1,
  7425,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "supe"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7452,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "super"
  (L._super << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sw"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7506,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "swi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7533,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "swit"
  -1,
  -1,
  -1,
  7560,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "switc"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7587,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "switch"
  (L._switch << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sy"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7641,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sym"
  -1,
  -1,
  7668,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "symb"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7695,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "symbo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7722,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "symbol"
  Fe._symbol << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "t"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7776,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7938,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8046,
  -1,
  // "th"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7803,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7857,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "thi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7830,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "this"
  (L._this << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "thr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7884,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "thro"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7911,
  -1,
  -1,
  -1,
  // "throw"
  (L._throw << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "tr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7965,
  -1,
  -1,
  -1,
  8019,
  -1,
  // "tru"
  -1,
  -1,
  -1,
  -1,
  -1,
  7992,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "true"
  (L._true << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "try"
  (L._try << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ty"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8073,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "typ"
  -1,
  -1,
  -1,
  -1,
  -1,
  8100,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "type"
  Fe._type << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8127,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "typeo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8154,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "typeof"
  (L._typeof << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "u"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8208,
  -1,
  -1,
  -1,
  -1,
  8343,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "un"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8235,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "uni"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8262,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "uniq"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8289,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "uniqu"
  -1,
  -1,
  -1,
  -1,
  -1,
  8316,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "unique"
  Fe._unique << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "us"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8370,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "usi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8397,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "usin"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8424,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "using"
  Fe._using << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "v"
  -1,
  8478,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8532,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "va"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8505,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "var"
  (L._var << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "vo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8559,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "voi"
  -1,
  -1,
  -1,
  -1,
  8586,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "void"
  (L._void << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "w"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8640,
  8748,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "wh"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8667,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "whi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8694,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "whil"
  -1,
  -1,
  -1,
  -1,
  -1,
  8721,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "while"
  (L._while << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "wi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8775,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "wit"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8802,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "with"
  (L._with << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "y"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8856,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "yi"
  -1,
  -1,
  -1,
  -1,
  -1,
  8883,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "yie"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8910,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "yiel"
  -1,
  -1,
  -1,
  -1,
  8937,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "yield"
  (L._yield << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
]);
function XH() {
  let t = 0, e = 0, n = ce.pos;
  for (; n < _t.length && (e = _t.charCodeAt(n), !(e < Ge.lowercaseA || e > Ge.lowercaseZ)); ) {
    const c = rS[t + (e - Ge.lowercaseA) + 1];
    if (c === -1)
      break;
    t = c, n++;
  }
  const a = rS[t];
  if (a > -1 && !Fi[e]) {
    ce.pos = n, a & 1 ? qt(a >>> 1) : qt(L.name, a >>> 1);
    return;
  }
  for (; n < _t.length; ) {
    const c = _t.charCodeAt(n);
    if (Fi[c])
      n++;
    else if (c === Ge.backslash) {
      if (n += 2, _t.charCodeAt(n) === Ge.leftCurlyBrace) {
        for (; n < _t.length && _t.charCodeAt(n) !== Ge.rightCurlyBrace; )
          n++;
        n++;
      }
    } else if (c === Ge.atSign && _t.charCodeAt(n + 1) === Ge.atSign)
      n += 2;
    else
      break;
  }
  ce.pos = n, qt(L.name);
}
var jt;
(function(t) {
  t[t.Access = 0] = "Access";
  const n = 0 + 1;
  t[t.ExportAccess = n] = "ExportAccess";
  const a = n + 1;
  t[t.TopLevelDeclaration = a] = "TopLevelDeclaration";
  const c = a + 1;
  t[t.FunctionScopedDeclaration = c] = "FunctionScopedDeclaration";
  const u = c + 1;
  t[t.BlockScopedDeclaration = u] = "BlockScopedDeclaration";
  const r = u + 1;
  t[t.ObjectShorthandTopLevelDeclaration = r] = "ObjectShorthandTopLevelDeclaration";
  const l = r + 1;
  t[t.ObjectShorthandFunctionScopedDeclaration = l] = "ObjectShorthandFunctionScopedDeclaration";
  const i = l + 1;
  t[t.ObjectShorthandBlockScopedDeclaration = i] = "ObjectShorthandBlockScopedDeclaration";
  const f = i + 1;
  t[t.ObjectShorthand = f] = "ObjectShorthand";
  const d = f + 1;
  t[t.ImportDeclaration = d] = "ImportDeclaration";
  const s = d + 1;
  t[t.ObjectKey = s] = "ObjectKey";
  const o = s + 1;
  t[t.ImportAccess = o] = "ImportAccess";
})(jt || (jt = {}));
var Ri;
(function(t) {
  t[t.NoChildren = 0] = "NoChildren";
  const n = 0 + 1;
  t[t.OneChild = n] = "OneChild";
  const a = n + 1;
  t[t.StaticChildren = a] = "StaticChildren";
  const c = a + 1;
  t[t.KeyAfterPropSpread = c] = "KeyAfterPropSpread";
})(Ri || (Ri = {}));
function qP(t) {
  const e = t.identifierRole;
  return e === jt.TopLevelDeclaration || e === jt.FunctionScopedDeclaration || e === jt.BlockScopedDeclaration || e === jt.ObjectShorthandTopLevelDeclaration || e === jt.ObjectShorthandFunctionScopedDeclaration || e === jt.ObjectShorthandBlockScopedDeclaration;
}
function JH(t) {
  const e = t.identifierRole;
  return e === jt.FunctionScopedDeclaration || e === jt.BlockScopedDeclaration || e === jt.ObjectShorthandFunctionScopedDeclaration || e === jt.ObjectShorthandBlockScopedDeclaration;
}
function GP(t) {
  const e = t.identifierRole;
  return e === jt.TopLevelDeclaration || e === jt.ObjectShorthandTopLevelDeclaration || e === jt.ImportDeclaration;
}
function QH(t) {
  const e = t.identifierRole;
  return e === jt.TopLevelDeclaration || e === jt.BlockScopedDeclaration || e === jt.ObjectShorthandTopLevelDeclaration || e === jt.ObjectShorthandBlockScopedDeclaration;
}
function ZH(t) {
  const e = t.identifierRole;
  return e === jt.FunctionScopedDeclaration || e === jt.ObjectShorthandFunctionScopedDeclaration;
}
function eq(t) {
  return t.identifierRole === jt.ObjectShorthandTopLevelDeclaration || t.identifierRole === jt.ObjectShorthandBlockScopedDeclaration || t.identifierRole === jt.ObjectShorthandFunctionScopedDeclaration;
}
class wp {
  constructor() {
    this.type = ce.type, this.contextualKeyword = ce.contextualKeyword, this.start = ce.start, this.end = ce.end, this.scopeDepth = ce.scopeDepth, this.isType = ce.isType, this.identifierRole = null, this.jsxRole = null, this.shadowsGlobal = !1, this.isAsyncOperation = !1, this.contextId = null, this.rhsEndIndex = null, this.isExpression = !1, this.numNullishCoalesceStarts = 0, this.numNullishCoalesceEnds = 0, this.isOptionalChainStart = !1, this.isOptionalChainEnd = !1, this.subscriptStartIndex = null, this.nullishStartIndex = null;
  }
  // Initially false for all tokens, then may be computed in a follow-up step that does scope
  // analysis.
  // Initially false for all tokens, but may be set during transform to mark it as containing an
  // await operation.
  // For assignments, the index of the RHS. For export tokens, the end of the export.
  // For class tokens, records if the class is a class expression or a class statement.
  // Number of times to insert a `nullishCoalesce(` snippet before this token.
  // Number of times to insert a `)` snippet after this token.
  // If true, insert an `optionalChain([` snippet before this token.
  // If true, insert a `])` snippet after this token.
  // Tag for `.`, `?.`, `[`, `?.[`, `(`, and `?.(` to denote the "root" token for this
  // subscript chain. This can be used to determine if this chain is an optional chain.
  // Tag for `??` operators to denote the root token for this nullish coalescing call.
}
function pt() {
  ce.tokens.push(new wp()), XP();
}
function ea() {
  ce.tokens.push(new wp()), ce.start = ce.pos, bq();
}
function tq() {
  ce.type === L.assign && --ce.pos, hq();
}
function Kt(t) {
  for (let n = ce.tokens.length - t; n < ce.tokens.length; n++)
    ce.tokens[n].isType = !0;
  const e = ce.isType;
  return ce.isType = !0, e;
}
function zt(t) {
  ce.isType = t;
}
function it(t) {
  return ke(t) ? (pt(), !0) : !1;
}
function zP(t) {
  const e = ce.isType;
  ce.isType = !0, it(t), ce.isType = e;
}
function ke(t) {
  return ce.type === t;
}
function kr() {
  const t = ce.snapshot();
  pt();
  const e = ce.type;
  return ce.restoreFromSnapshot(t), e;
}
class rq {
  constructor(e, n) {
    this.type = e, this.contextualKeyword = n;
  }
}
function ec() {
  const t = ce.snapshot();
  pt();
  const e = ce.type, n = ce.contextualKeyword;
  return ce.restoreFromSnapshot(t), new rq(e, n);
}
function Fb() {
  return KP(ce.pos);
}
function KP(t) {
  tS.lastIndex = t;
  const e = tS.exec(_t);
  return t + e[0].length;
}
function YP() {
  return _t.charCodeAt(Fb());
}
function XP() {
  if (QP(), ce.start = ce.pos, ce.pos >= _t.length) {
    const t = ce.tokens;
    t.length >= 2 && t[t.length - 1].start >= _t.length && t[t.length - 2].start >= _t.length && Gt("Unexpectedly reached the end of input."), qt(L.eof);
    return;
  }
  nq(_t.charCodeAt(ce.pos));
}
function nq(t) {
  Zu[t] || t === Ge.backslash || t === Ge.atSign && _t.charCodeAt(ce.pos + 1) === Ge.atSign ? XH() : tC(t);
}
function iq() {
  for (; _t.charCodeAt(ce.pos) !== Ge.asterisk || _t.charCodeAt(ce.pos + 1) !== Ge.slash; )
    if (ce.pos++, ce.pos > _t.length) {
      Gt("Unterminated comment", ce.pos - 2);
      return;
    }
  ce.pos += 2;
}
function JP(t) {
  let e = _t.charCodeAt(ce.pos += t);
  if (ce.pos < _t.length)
    for (; e !== Ge.lineFeed && e !== Ge.carriageReturn && e !== Ge.lineSeparator && e !== Ge.paragraphSeparator && ++ce.pos < _t.length; )
      e = _t.charCodeAt(ce.pos);
}
function QP() {
  for (; ce.pos < _t.length; ) {
    const t = _t.charCodeAt(ce.pos);
    switch (t) {
      case Ge.carriageReturn:
        _t.charCodeAt(ce.pos + 1) === Ge.lineFeed && ++ce.pos;
      case Ge.lineFeed:
      case Ge.lineSeparator:
      case Ge.paragraphSeparator:
        ++ce.pos;
        break;
      case Ge.slash:
        switch (_t.charCodeAt(ce.pos + 1)) {
          case Ge.asterisk:
            ce.pos += 2, iq();
            break;
          case Ge.slash:
            JP(2);
            break;
          default:
            return;
        }
        break;
      default:
        if (HP[t])
          ++ce.pos;
        else
          return;
    }
  }
}
function qt(t, e = Fe.NONE) {
  ce.end = ce.pos, ce.type = t, ce.contextualKeyword = e;
}
function sq() {
  const t = _t.charCodeAt(ce.pos + 1);
  if (t >= Ge.digit0 && t <= Ge.digit9) {
    rC(!0);
    return;
  }
  t === Ge.dot && _t.charCodeAt(ce.pos + 2) === Ge.dot ? (ce.pos += 3, qt(L.ellipsis)) : (++ce.pos, qt(L.dot));
}
function aq() {
  _t.charCodeAt(ce.pos + 1) === Ge.equalsTo ? ur(L.assign, 2) : ur(L.slash, 1);
}
function oq(t) {
  let e = t === Ge.asterisk ? L.star : L.modulo, n = 1, a = _t.charCodeAt(ce.pos + 1);
  t === Ge.asterisk && a === Ge.asterisk && (n++, a = _t.charCodeAt(ce.pos + 2), e = L.exponent), a === Ge.equalsTo && _t.charCodeAt(ce.pos + 2) !== Ge.greaterThan && (n++, e = L.assign), ur(e, n);
}
function lq(t) {
  const e = _t.charCodeAt(ce.pos + 1);
  if (e === t) {
    _t.charCodeAt(ce.pos + 2) === Ge.equalsTo ? ur(L.assign, 3) : ur(t === Ge.verticalBar ? L.logicalOR : L.logicalAND, 2);
    return;
  }
  if (t === Ge.verticalBar) {
    if (e === Ge.greaterThan) {
      ur(L.pipeline, 2);
      return;
    } else if (e === Ge.rightCurlyBrace && or) {
      ur(L.braceBarR, 2);
      return;
    }
  }
  if (e === Ge.equalsTo) {
    ur(L.assign, 2);
    return;
  }
  ur(t === Ge.verticalBar ? L.bitwiseOR : L.bitwiseAND, 1);
}
function uq() {
  _t.charCodeAt(ce.pos + 1) === Ge.equalsTo ? ur(L.assign, 2) : ur(L.bitwiseXOR, 1);
}
function cq(t) {
  const e = _t.charCodeAt(ce.pos + 1);
  if (e === t) {
    ur(L.preIncDec, 2);
    return;
  }
  e === Ge.equalsTo ? ur(L.assign, 2) : t === Ge.plusSign ? ur(L.plus, 1) : ur(L.minus, 1);
}
function fq() {
  const t = _t.charCodeAt(ce.pos + 1);
  if (t === Ge.lessThan) {
    if (_t.charCodeAt(ce.pos + 2) === Ge.equalsTo) {
      ur(L.assign, 3);
      return;
    }
    ce.isType ? ur(L.lessThan, 1) : ur(L.bitShiftL, 2);
    return;
  }
  t === Ge.equalsTo ? ur(L.relationalOrEqual, 2) : ur(L.lessThan, 1);
}
function ZP() {
  if (ce.isType) {
    ur(L.greaterThan, 1);
    return;
  }
  const t = _t.charCodeAt(ce.pos + 1);
  if (t === Ge.greaterThan) {
    const e = _t.charCodeAt(ce.pos + 2) === Ge.greaterThan ? 3 : 2;
    if (_t.charCodeAt(ce.pos + e) === Ge.equalsTo) {
      ur(L.assign, e + 1);
      return;
    }
    ur(L.bitShiftR, e);
    return;
  }
  t === Ge.equalsTo ? ur(L.relationalOrEqual, 2) : ur(L.greaterThan, 1);
}
function eC() {
  ce.type === L.greaterThan && (ce.pos -= 1, ZP());
}
function dq(t) {
  const e = _t.charCodeAt(ce.pos + 1);
  if (e === Ge.equalsTo) {
    ur(L.equality, _t.charCodeAt(ce.pos + 2) === Ge.equalsTo ? 3 : 2);
    return;
  }
  if (t === Ge.equalsTo && e === Ge.greaterThan) {
    ce.pos += 2, qt(L.arrow);
    return;
  }
  ur(t === Ge.equalsTo ? L.eq : L.bang, 1);
}
function pq() {
  const t = _t.charCodeAt(ce.pos + 1), e = _t.charCodeAt(ce.pos + 2);
  t === Ge.questionMark && // In Flow (but not TypeScript), ??string is a valid type that should be
  // tokenized as two individual ? tokens.
  !(or && ce.isType) ? e === Ge.equalsTo ? ur(L.assign, 3) : ur(L.nullishCoalescing, 2) : t === Ge.dot && !(e >= Ge.digit0 && e <= Ge.digit9) ? (ce.pos += 2, qt(L.questionDot)) : (++ce.pos, qt(L.question));
}
function tC(t) {
  switch (t) {
    case Ge.numberSign:
      ++ce.pos, qt(L.hash);
      return;
    case Ge.dot:
      sq();
      return;
    case Ge.leftParenthesis:
      ++ce.pos, qt(L.parenL);
      return;
    case Ge.rightParenthesis:
      ++ce.pos, qt(L.parenR);
      return;
    case Ge.semicolon:
      ++ce.pos, qt(L.semi);
      return;
    case Ge.comma:
      ++ce.pos, qt(L.comma);
      return;
    case Ge.leftSquareBracket:
      ++ce.pos, qt(L.bracketL);
      return;
    case Ge.rightSquareBracket:
      ++ce.pos, qt(L.bracketR);
      return;
    case Ge.leftCurlyBrace:
      or && _t.charCodeAt(ce.pos + 1) === Ge.verticalBar ? ur(L.braceBarL, 2) : (++ce.pos, qt(L.braceL));
      return;
    case Ge.rightCurlyBrace:
      ++ce.pos, qt(L.braceR);
      return;
    case Ge.colon:
      _t.charCodeAt(ce.pos + 1) === Ge.colon ? ur(L.doubleColon, 2) : (++ce.pos, qt(L.colon));
      return;
    case Ge.questionMark:
      pq();
      return;
    case Ge.atSign:
      ++ce.pos, qt(L.at);
      return;
    case Ge.graveAccent:
      ++ce.pos, qt(L.backQuote);
      return;
    case Ge.digit0: {
      const e = _t.charCodeAt(ce.pos + 1);
      if (e === Ge.lowercaseX || e === Ge.uppercaseX || e === Ge.lowercaseO || e === Ge.uppercaseO || e === Ge.lowercaseB || e === Ge.uppercaseB) {
        mq();
        return;
      }
    }
    case Ge.digit1:
    case Ge.digit2:
    case Ge.digit3:
    case Ge.digit4:
    case Ge.digit5:
    case Ge.digit6:
    case Ge.digit7:
    case Ge.digit8:
    case Ge.digit9:
      rC(!1);
      return;
    case Ge.quotationMark:
    case Ge.apostrophe:
      yq(t);
      return;
    case Ge.slash:
      aq();
      return;
    case Ge.percentSign:
    case Ge.asterisk:
      oq(t);
      return;
    case Ge.verticalBar:
    case Ge.ampersand:
      lq(t);
      return;
    case Ge.caret:
      uq();
      return;
    case Ge.plusSign:
    case Ge.dash:
      cq(t);
      return;
    case Ge.lessThan:
      fq();
      return;
    case Ge.greaterThan:
      ZP();
      return;
    case Ge.equalsTo:
    case Ge.exclamationMark:
      dq(t);
      return;
    case Ge.tilde:
      ur(L.tilde, 1);
      return;
  }
  Gt(`Unexpected character '${String.fromCharCode(t)}'`, ce.pos);
}
function ur(t, e) {
  ce.pos += e, qt(t);
}
function hq() {
  const t = ce.pos;
  let e = !1, n = !1;
  for (; ; ) {
    if (ce.pos >= _t.length) {
      Gt("Unterminated regular expression", t);
      return;
    }
    const a = _t.charCodeAt(ce.pos);
    if (e)
      e = !1;
    else {
      if (a === Ge.leftSquareBracket)
        n = !0;
      else if (a === Ge.rightSquareBracket && n)
        n = !1;
      else if (a === Ge.slash && !n)
        break;
      e = a === Ge.backslash;
    }
    ++ce.pos;
  }
  ++ce.pos, gq(), qt(L.regexp);
}
function wm() {
  for (; ; ) {
    const t = _t.charCodeAt(ce.pos);
    if (t >= Ge.digit0 && t <= Ge.digit9 || t === Ge.underscore)
      ce.pos++;
    else
      break;
  }
}
function mq() {
  for (ce.pos += 2; ; ) {
    const e = _t.charCodeAt(ce.pos);
    if (e >= Ge.digit0 && e <= Ge.digit9 || e >= Ge.lowercaseA && e <= Ge.lowercaseF || e >= Ge.uppercaseA && e <= Ge.uppercaseF || e === Ge.underscore)
      ce.pos++;
    else
      break;
  }
  _t.charCodeAt(ce.pos) === Ge.lowercaseN ? (++ce.pos, qt(L.bigint)) : qt(L.num);
}
function rC(t) {
  let e = !1, n = !1;
  t || wm();
  let a = _t.charCodeAt(ce.pos);
  if (a === Ge.dot && (++ce.pos, wm(), a = _t.charCodeAt(ce.pos)), (a === Ge.uppercaseE || a === Ge.lowercaseE) && (a = _t.charCodeAt(++ce.pos), (a === Ge.plusSign || a === Ge.dash) && ++ce.pos, wm(), a = _t.charCodeAt(ce.pos)), a === Ge.lowercaseN ? (++ce.pos, e = !0) : a === Ge.lowercaseM && (++ce.pos, n = !0), e) {
    qt(L.bigint);
    return;
  }
  if (n) {
    qt(L.decimal);
    return;
  }
  qt(L.num);
}
function yq(t) {
  for (ce.pos++; ; ) {
    if (ce.pos >= _t.length) {
      Gt("Unterminated string constant");
      return;
    }
    const e = _t.charCodeAt(ce.pos);
    if (e === Ge.backslash)
      ce.pos++;
    else if (e === t)
      break;
    ce.pos++;
  }
  ce.pos++, qt(L.string);
}
function bq() {
  for (; ; ) {
    if (ce.pos >= _t.length) {
      Gt("Unterminated template");
      return;
    }
    const t = _t.charCodeAt(ce.pos);
    if (t === Ge.graveAccent || t === Ge.dollarSign && _t.charCodeAt(ce.pos + 1) === Ge.leftCurlyBrace) {
      if (ce.pos === ce.start && ke(L.template))
        if (t === Ge.dollarSign) {
          ce.pos += 2, qt(L.dollarBraceL);
          return;
        } else {
          ++ce.pos, qt(L.backQuote);
          return;
        }
      qt(L.template);
      return;
    }
    t === Ge.backslash && ce.pos++, ce.pos++;
  }
}
function gq() {
  for (; ce.pos < _t.length; ) {
    const t = _t.charCodeAt(ce.pos);
    if (Fi[t])
      ce.pos++;
    else if (t === Ge.backslash) {
      if (ce.pos += 2, _t.charCodeAt(ce.pos) === Ge.leftCurlyBrace) {
        for (; ce.pos < _t.length && _t.charCodeAt(ce.pos) !== Ge.rightCurlyBrace; )
          ce.pos++;
        ce.pos++;
      }
    } else
      break;
  }
}
function hu(t, e = t.currentIndex()) {
  let n = e + 1;
  if (Wc(t, n)) {
    const a = t.identifierNameAtIndex(e);
    return {
      isType: !1,
      leftName: a,
      rightName: a,
      endIndex: n
    };
  }
  if (n++, Wc(t, n))
    return {
      isType: !0,
      leftName: null,
      rightName: null,
      endIndex: n
    };
  if (n++, Wc(t, n))
    return {
      isType: !1,
      leftName: t.identifierNameAtIndex(e),
      rightName: t.identifierNameAtIndex(e + 2),
      endIndex: n
    };
  if (n++, Wc(t, n))
    return {
      isType: !0,
      leftName: null,
      rightName: null,
      endIndex: n
    };
  throw new Error(`Unexpected import/export specifier at ${e}`);
}
function Wc(t, e) {
  const n = t.tokens[e];
  return n.type === L.braceR || n.type === L.comma;
}
const vq = /* @__PURE__ */ new Map([
  ["quot", '"'],
  ["amp", "&"],
  ["apos", "'"],
  ["lt", "<"],
  ["gt", ">"],
  ["nbsp", ""],
  ["iexcl", ""],
  ["cent", ""],
  ["pound", ""],
  ["curren", ""],
  ["yen", ""],
  ["brvbar", ""],
  ["sect", ""],
  ["uml", ""],
  ["copy", ""],
  ["ordf", ""],
  ["laquo", ""],
  ["not", ""],
  ["shy", ""],
  ["reg", ""],
  ["macr", ""],
  ["deg", ""],
  ["plusmn", ""],
  ["sup2", ""],
  ["sup3", ""],
  ["acute", ""],
  ["micro", ""],
  ["para", ""],
  ["middot", ""],
  ["cedil", ""],
  ["sup1", ""],
  ["ordm", ""],
  ["raquo", ""],
  ["frac14", ""],
  ["frac12", ""],
  ["frac34", ""],
  ["iquest", ""],
  ["Agrave", ""],
  ["Aacute", ""],
  ["Acirc", ""],
  ["Atilde", ""],
  ["Auml", ""],
  ["Aring", ""],
  ["AElig", ""],
  ["Ccedil", ""],
  ["Egrave", ""],
  ["Eacute", ""],
  ["Ecirc", ""],
  ["Euml", ""],
  ["Igrave", ""],
  ["Iacute", ""],
  ["Icirc", ""],
  ["Iuml", ""],
  ["ETH", ""],
  ["Ntilde", ""],
  ["Ograve", ""],
  ["Oacute", ""],
  ["Ocirc", ""],
  ["Otilde", ""],
  ["Ouml", ""],
  ["times", ""],
  ["Oslash", ""],
  ["Ugrave", ""],
  ["Uacute", ""],
  ["Ucirc", ""],
  ["Uuml", ""],
  ["Yacute", ""],
  ["THORN", ""],
  ["szlig", ""],
  ["agrave", ""],
  ["aacute", ""],
  ["acirc", ""],
  ["atilde", ""],
  ["auml", ""],
  ["aring", ""],
  ["aelig", ""],
  ["ccedil", ""],
  ["egrave", ""],
  ["eacute", ""],
  ["ecirc", ""],
  ["euml", ""],
  ["igrave", ""],
  ["iacute", ""],
  ["icirc", ""],
  ["iuml", ""],
  ["eth", ""],
  ["ntilde", ""],
  ["ograve", ""],
  ["oacute", ""],
  ["ocirc", ""],
  ["otilde", ""],
  ["ouml", ""],
  ["divide", ""],
  ["oslash", ""],
  ["ugrave", ""],
  ["uacute", ""],
  ["ucirc", ""],
  ["uuml", ""],
  ["yacute", ""],
  ["thorn", ""],
  ["yuml", ""],
  ["OElig", ""],
  ["oelig", ""],
  ["Scaron", ""],
  ["scaron", ""],
  ["Yuml", ""],
  ["fnof", ""],
  ["circ", ""],
  ["tilde", ""],
  ["Alpha", ""],
  ["Beta", ""],
  ["Gamma", ""],
  ["Delta", ""],
  ["Epsilon", ""],
  ["Zeta", ""],
  ["Eta", ""],
  ["Theta", ""],
  ["Iota", ""],
  ["Kappa", ""],
  ["Lambda", ""],
  ["Mu", ""],
  ["Nu", ""],
  ["Xi", ""],
  ["Omicron", ""],
  ["Pi", ""],
  ["Rho", ""],
  ["Sigma", ""],
  ["Tau", ""],
  ["Upsilon", ""],
  ["Phi", ""],
  ["Chi", ""],
  ["Psi", ""],
  ["Omega", ""],
  ["alpha", ""],
  ["beta", ""],
  ["gamma", ""],
  ["delta", ""],
  ["epsilon", ""],
  ["zeta", ""],
  ["eta", ""],
  ["theta", ""],
  ["iota", ""],
  ["kappa", ""],
  ["lambda", ""],
  ["mu", ""],
  ["nu", ""],
  ["xi", ""],
  ["omicron", ""],
  ["pi", ""],
  ["rho", ""],
  ["sigmaf", ""],
  ["sigma", ""],
  ["tau", ""],
  ["upsilon", ""],
  ["phi", ""],
  ["chi", ""],
  ["psi", ""],
  ["omega", ""],
  ["thetasym", ""],
  ["upsih", ""],
  ["piv", ""],
  ["ensp", ""],
  ["emsp", ""],
  ["thinsp", ""],
  ["zwnj", ""],
  ["zwj", ""],
  ["lrm", ""],
  ["rlm", ""],
  ["ndash", ""],
  ["mdash", ""],
  ["lsquo", ""],
  ["rsquo", ""],
  ["sbquo", ""],
  ["ldquo", ""],
  ["rdquo", ""],
  ["bdquo", ""],
  ["dagger", ""],
  ["Dagger", ""],
  ["bull", ""],
  ["hellip", ""],
  ["permil", ""],
  ["prime", ""],
  ["Prime", ""],
  ["lsaquo", ""],
  ["rsaquo", ""],
  ["oline", ""],
  ["frasl", ""],
  ["euro", ""],
  ["image", ""],
  ["weierp", ""],
  ["real", ""],
  ["trade", ""],
  ["alefsym", ""],
  ["larr", ""],
  ["uarr", ""],
  ["rarr", ""],
  ["darr", ""],
  ["harr", ""],
  ["crarr", ""],
  ["lArr", ""],
  ["uArr", ""],
  ["rArr", ""],
  ["dArr", ""],
  ["hArr", ""],
  ["forall", ""],
  ["part", ""],
  ["exist", ""],
  ["empty", ""],
  ["nabla", ""],
  ["isin", ""],
  ["notin", ""],
  ["ni", ""],
  ["prod", ""],
  ["sum", ""],
  ["minus", ""],
  ["lowast", ""],
  ["radic", ""],
  ["prop", ""],
  ["infin", ""],
  ["ang", ""],
  ["and", ""],
  ["or", ""],
  ["cap", ""],
  ["cup", ""],
  ["int", ""],
  ["there4", ""],
  ["sim", ""],
  ["cong", ""],
  ["asymp", ""],
  ["ne", ""],
  ["equiv", ""],
  ["le", ""],
  ["ge", ""],
  ["sub", ""],
  ["sup", ""],
  ["nsub", ""],
  ["sube", ""],
  ["supe", ""],
  ["oplus", ""],
  ["otimes", ""],
  ["perp", ""],
  ["sdot", ""],
  ["lceil", ""],
  ["rceil", ""],
  ["lfloor", ""],
  ["rfloor", ""],
  ["lang", ""],
  ["rang", ""],
  ["loz", ""],
  ["spades", ""],
  ["clubs", ""],
  ["hearts", ""],
  ["diams", ""]
]);
function nC(t) {
  const [e, n] = nS(t.jsxPragma || "React.createElement"), [a, c] = nS(t.jsxFragmentPragma || "React.Fragment");
  return { base: e, suffix: n, fragmentBase: a, fragmentSuffix: c };
}
function nS(t) {
  let e = t.indexOf(".");
  return e === -1 && (e = t.length), [t.slice(0, e), t.slice(e)];
}
class qi {
  // Return true if anything was processed, false otherwise.
  getPrefixCode() {
    return "";
  }
  getHoistedCode() {
    return "";
  }
  getSuffixCode() {
    return "";
  }
}
class ka extends qi {
  // State for calculating the line number of each JSX tag in development.
  __init() {
    this.lastLineNumber = 1;
  }
  __init2() {
    this.lastIndex = 0;
  }
  // In development, variable name holding the name of the current file.
  __init3() {
    this.filenameVarName = null;
  }
  // Mapping of claimed names for imports in the automatic transform, e,g.
  // {jsx: "_jsx"}. This determines which imports to generate in the prefix.
  __init4() {
    this.esmAutomaticImportNameResolutions = {};
  }
  // When automatically adding imports in CJS mode, we store the variable name
  // holding the imported CJS module so we can require it in the prefix.
  __init5() {
    this.cjsAutomaticModuleNameResolutions = {};
  }
  constructor(e, n, a, c, u) {
    super(), this.rootTransformer = e, this.tokens = n, this.importProcessor = a, this.nameManager = c, this.options = u, ka.prototype.__init.call(this), ka.prototype.__init2.call(this), ka.prototype.__init3.call(this), ka.prototype.__init4.call(this), ka.prototype.__init5.call(this), this.jsxPragmaInfo = nC(u), this.isAutomaticRuntime = u.jsxRuntime === "automatic", this.jsxImportSource = u.jsxImportSource || "react";
  }
  process() {
    return this.tokens.matches1(L.jsxTagStart) ? (this.processJSXTag(), !0) : !1;
  }
  getPrefixCode() {
    let e = "";
    if (this.filenameVarName && (e += `const ${this.filenameVarName} = ${JSON.stringify(this.options.filePath || "")};`), this.isAutomaticRuntime)
      if (this.importProcessor)
        for (const [n, a] of Object.entries(this.cjsAutomaticModuleNameResolutions))
          e += `var ${a} = require("${n}");`;
      else {
        const { createElement: n, ...a } = this.esmAutomaticImportNameResolutions;
        n && (e += `import {createElement as ${n}} from "${this.jsxImportSource}";`);
        const c = Object.entries(a).map(([u, r]) => `${u} as ${r}`).join(", ");
        if (c) {
          const u = this.jsxImportSource + (this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime");
          e += `import {${c}} from "${u}";`;
        }
      }
    return e;
  }
  processJSXTag() {
    const { jsxRole: e, start: n } = this.tokens.currentToken(), a = this.options.production ? null : this.getElementLocationCode(n);
    this.isAutomaticRuntime && e !== Ri.KeyAfterPropSpread ? this.transformTagToJSXFunc(a, e) : this.transformTagToCreateElement(a);
  }
  getElementLocationCode(e) {
    return `lineNumber: ${this.getLineNumberForIndex(e)}`;
  }
  /**
   * Get the line number for this source position. This is calculated lazily and
   * must be called in increasing order by index.
   */
  getLineNumberForIndex(e) {
    const n = this.tokens.code;
    for (; this.lastIndex < e && this.lastIndex < n.length; )
      n[this.lastIndex] === `
` && this.lastLineNumber++, this.lastIndex++;
    return this.lastLineNumber;
  }
  /**
   * Convert the current JSX element to a call to jsx, jsxs, or jsxDEV. This is
   * the primary transformation for the automatic transform.
   *
   * Example:
   * <div a={1} key={2}>Hello{x}</div>
   * becomes
   * jsxs('div', {a: 1, children: ["Hello", x]}, 2)
   */
  transformTagToJSXFunc(e, n) {
    const a = n === Ri.StaticChildren;
    this.tokens.replaceToken(this.getJSXFuncInvocationCode(a));
    let c = null;
    if (this.tokens.matches1(L.jsxTagEnd))
      this.tokens.replaceToken(`${this.getFragmentCode()}, {`), this.processAutomaticChildrenAndEndProps(n);
    else {
      if (this.processTagIntro(), this.tokens.appendCode(", {"), c = this.processProps(!0), this.tokens.matches2(L.slash, L.jsxTagEnd))
        this.tokens.appendCode("}");
      else if (this.tokens.matches1(L.jsxTagEnd))
        this.tokens.removeToken(), this.processAutomaticChildrenAndEndProps(n);
      else
        throw new Error("Expected either /> or > at the end of the tag.");
      c && this.tokens.appendCode(`, ${c}`);
    }
    for (this.options.production || (c === null && this.tokens.appendCode(", void 0"), this.tokens.appendCode(`, ${a}, ${this.getDevSource(e)}, this`)), this.tokens.removeInitialToken(); !this.tokens.matches1(L.jsxTagEnd); )
      this.tokens.removeToken();
    this.tokens.replaceToken(")");
  }
  /**
   * Convert the current JSX element to a createElement call. In the classic
   * runtime, this is the only case. In the automatic runtime, this is called
   * as a fallback in some situations.
   *
   * Example:
   * <div a={1} key={2}>Hello{x}</div>
   * becomes
   * React.createElement('div', {a: 1, key: 2}, "Hello", x)
   */
  transformTagToCreateElement(e) {
    if (this.tokens.replaceToken(this.getCreateElementInvocationCode()), this.tokens.matches1(L.jsxTagEnd))
      this.tokens.replaceToken(`${this.getFragmentCode()}, null`), this.processChildren(!0);
    else if (this.processTagIntro(), this.processPropsObjectWithDevInfo(e), !this.tokens.matches2(L.slash, L.jsxTagEnd))
      if (this.tokens.matches1(L.jsxTagEnd))
        this.tokens.removeToken(), this.processChildren(!0);
      else
        throw new Error("Expected either /> or > at the end of the tag.");
    for (this.tokens.removeInitialToken(); !this.tokens.matches1(L.jsxTagEnd); )
      this.tokens.removeToken();
    this.tokens.replaceToken(")");
  }
  /**
   * Get the code for the relevant function for this context: jsx, jsxs,
   * or jsxDEV. The following open-paren is included as well.
   *
   * These functions are only used for the automatic runtime, so they are always
   * auto-imported, but the auto-import will be either CJS or ESM based on the
   * target module format.
   */
  getJSXFuncInvocationCode(e) {
    return this.options.production ? e ? this.claimAutoImportedFuncInvocation("jsxs", "/jsx-runtime") : this.claimAutoImportedFuncInvocation("jsx", "/jsx-runtime") : this.claimAutoImportedFuncInvocation("jsxDEV", "/jsx-dev-runtime");
  }
  /**
   * Return the code to use for the createElement function, e.g.
   * `React.createElement`, including the following open-paren.
   *
   * This is the main function to use for the classic runtime. For the
   * automatic runtime, this function is used as a fallback function to
   * preserve behavior when there is a prop spread followed by an explicit
   * key. In that automatic runtime case, the function should be automatically
   * imported.
   */
  getCreateElementInvocationCode() {
    if (this.isAutomaticRuntime)
      return this.claimAutoImportedFuncInvocation("createElement", "");
    {
      const { jsxPragmaInfo: e } = this;
      return `${this.importProcessor && this.importProcessor.getIdentifierReplacement(e.base) || e.base}${e.suffix}(`;
    }
  }
  /**
   * Return the code to use as the component when compiling a shorthand
   * fragment, e.g. `React.Fragment`.
   *
   * This may be called from either the classic or automatic runtime, and
   * the value should be auto-imported for the automatic runtime.
   */
  getFragmentCode() {
    if (this.isAutomaticRuntime)
      return this.claimAutoImportedName(
        "Fragment",
        this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime"
      );
    {
      const { jsxPragmaInfo: e } = this;
      return (this.importProcessor && this.importProcessor.getIdentifierReplacement(e.fragmentBase) || e.fragmentBase) + e.fragmentSuffix;
    }
  }
  /**
   * Return code that invokes the given function.
   *
   * When the imports transform is enabled, use the CJSImportTransformer
   * strategy of using `.call(void 0, ...` to avoid passing a `this` value in a
   * situation that would otherwise look like a method call.
   */
  claimAutoImportedFuncInvocation(e, n) {
    const a = this.claimAutoImportedName(e, n);
    return this.importProcessor ? `${a}.call(void 0, ` : `${a}(`;
  }
  claimAutoImportedName(e, n) {
    if (this.importProcessor) {
      const a = this.jsxImportSource + n;
      return this.cjsAutomaticModuleNameResolutions[a] || (this.cjsAutomaticModuleNameResolutions[a] = this.importProcessor.getFreeIdentifierForPath(a)), `${this.cjsAutomaticModuleNameResolutions[a]}.${e}`;
    } else
      return this.esmAutomaticImportNameResolutions[e] || (this.esmAutomaticImportNameResolutions[e] = this.nameManager.claimFreeName(
        `_${e}`
      )), this.esmAutomaticImportNameResolutions[e];
  }
  /**
   * Process the first part of a tag, before any props.
   */
  processTagIntro() {
    let e = this.tokens.currentIndex() + 1;
    for (; this.tokens.tokens[e].isType || !this.tokens.matches2AtIndex(e - 1, L.jsxName, L.jsxName) && !this.tokens.matches2AtIndex(e - 1, L.greaterThan, L.jsxName) && !this.tokens.matches1AtIndex(e, L.braceL) && !this.tokens.matches1AtIndex(e, L.jsxTagEnd) && !this.tokens.matches2AtIndex(e, L.slash, L.jsxTagEnd); )
      e++;
    if (e === this.tokens.currentIndex() + 1) {
      const n = this.tokens.identifierName();
      iC(n) && this.tokens.replaceToken(`'${n}'`);
    }
    for (; this.tokens.currentIndex() < e; )
      this.rootTransformer.processToken();
  }
  /**
   * Starting at the beginning of the props, add the props argument to
   * React.createElement, including the comma before it.
   */
  processPropsObjectWithDevInfo(e) {
    const n = this.options.production ? "" : `__self: this, __source: ${this.getDevSource(e)}`;
    if (!this.tokens.matches1(L.jsxName) && !this.tokens.matches1(L.braceL)) {
      n ? this.tokens.appendCode(`, {${n}}`) : this.tokens.appendCode(", null");
      return;
    }
    this.tokens.appendCode(", {"), this.processProps(!1), n ? this.tokens.appendCode(` ${n}}`) : this.tokens.appendCode("}");
  }
  /**
   * Transform the core part of the props, assuming that a { has already been
   * inserted before us and that a } will be inserted after us.
   *
   * If extractKeyCode is true (i.e. when using any jsx... function), any prop
   * named "key" has its code captured and returned rather than being emitted to
   * the output code. This shifts line numbers, and emitting the code later will
   * correct line numbers again. If no key is found or if extractKeyCode is
   * false, this function returns null.
   */
  processProps(e) {
    let n = null;
    for (; ; ) {
      if (this.tokens.matches2(L.jsxName, L.eq)) {
        const a = this.tokens.identifierName();
        if (e && a === "key") {
          n !== null && this.tokens.appendCode(n.replace(/[^\n]/g, "")), this.tokens.removeToken(), this.tokens.removeToken();
          const c = this.tokens.snapshot();
          this.processPropValue(), n = this.tokens.dangerouslyGetAndRemoveCodeSinceSnapshot(c);
          continue;
        } else
          this.processPropName(a), this.tokens.replaceToken(": "), this.processPropValue();
      } else if (this.tokens.matches1(L.jsxName)) {
        const a = this.tokens.identifierName();
        this.processPropName(a), this.tokens.appendCode(": true");
      } else if (this.tokens.matches1(L.braceL))
        this.tokens.replaceToken(""), this.rootTransformer.processBalancedCode(), this.tokens.replaceToken("");
      else
        break;
      this.tokens.appendCode(",");
    }
    return n;
  }
  processPropName(e) {
    e.includes("-") ? this.tokens.replaceToken(`'${e}'`) : this.tokens.copyToken();
  }
  processPropValue() {
    this.tokens.matches1(L.braceL) ? (this.tokens.replaceToken(""), this.rootTransformer.processBalancedCode(), this.tokens.replaceToken("")) : this.tokens.matches1(L.jsxTagStart) ? this.processJSXTag() : this.processStringPropValue();
  }
  processStringPropValue() {
    const e = this.tokens.currentToken(), n = this.tokens.code.slice(e.start + 1, e.end - 1), a = iS(n), c = _q(n);
    this.tokens.replaceToken(c + a);
  }
  /**
   * Starting in the middle of the props object literal, produce an additional
   * prop for the children and close the object literal.
   */
  processAutomaticChildrenAndEndProps(e) {
    e === Ri.StaticChildren ? (this.tokens.appendCode(" children: ["), this.processChildren(!1), this.tokens.appendCode("]}")) : (e === Ri.OneChild && this.tokens.appendCode(" children: "), this.processChildren(!1), this.tokens.appendCode("}"));
  }
  /**
   * Transform children into a comma-separated list, which will be either
   * arguments to createElement or array elements of a children prop.
   */
  processChildren(e) {
    let n = e;
    for (; ; ) {
      if (this.tokens.matches2(L.jsxTagStart, L.slash))
        return;
      let a = !1;
      if (this.tokens.matches1(L.braceL))
        this.tokens.matches2(L.braceL, L.braceR) ? (this.tokens.replaceToken(""), this.tokens.replaceToken("")) : (this.tokens.replaceToken(n ? ", " : ""), this.rootTransformer.processBalancedCode(), this.tokens.replaceToken(""), a = !0);
      else if (this.tokens.matches1(L.jsxTagStart))
        this.tokens.appendCode(n ? ", " : ""), this.processJSXTag(), a = !0;
      else if (this.tokens.matches1(L.jsxText) || this.tokens.matches1(L.jsxEmptyText))
        a = this.processChildTextElement(n);
      else
        throw new Error("Unexpected token when processing JSX children.");
      a && (n = !0);
    }
  }
  /**
   * Turn a JSX text element into a string literal, or nothing at all if the JSX
   * text resolves to the empty string.
   *
   * Returns true if a string literal is emitted, false otherwise.
   */
  processChildTextElement(e) {
    const n = this.tokens.currentToken(), a = this.tokens.code.slice(n.start, n.end), c = iS(a), u = Eq(a);
    return u === '""' ? (this.tokens.replaceToken(c), !1) : (this.tokens.replaceToken(`${e ? ", " : ""}${u}${c}`), !0);
  }
  getDevSource(e) {
    return `{fileName: ${this.getFilenameVarName()}, ${e}}`;
  }
  getFilenameVarName() {
    return this.filenameVarName || (this.filenameVarName = this.nameManager.claimFreeName("_jsxFileName")), this.filenameVarName;
  }
}
function iC(t) {
  const e = t.charCodeAt(0);
  return e >= Ge.lowercaseA && e <= Ge.lowercaseZ;
}
function Eq(t) {
  let e = "", n = "", a = !1, c = !1;
  for (let u = 0; u < t.length; u++) {
    const r = t[u];
    if (r === " " || r === "	" || r === "\r")
      a || (n += r);
    else if (r === `
`)
      n = "", a = !0;
    else {
      if (c && a && (e += " "), e += n, n = "", r === "&") {
        const { entity: l, newI: i } = sC(t, u + 1);
        u = i - 1, e += l;
      } else
        e += r;
      c = !0, a = !1;
    }
  }
  return a || (e += n), JSON.stringify(e);
}
function iS(t) {
  let e = 0, n = 0;
  for (const a of t)
    a === `
` ? (e++, n = 0) : a === " " && n++;
  return `
`.repeat(e) + " ".repeat(n);
}
function _q(t) {
  let e = "";
  for (let n = 0; n < t.length; n++) {
    const a = t[n];
    if (a === `
`)
      if (/\s/.test(t[n + 1]))
        for (e += " "; n < t.length && /\s/.test(t[n + 1]); )
          n++;
      else
        e += `
`;
    else if (a === "&") {
      const { entity: c, newI: u } = sC(t, n + 1);
      e += c, n = u - 1;
    } else
      e += a;
  }
  return JSON.stringify(e);
}
function sC(t, e) {
  let n = "", a = 0, c, u = e;
  if (t[u] === "#") {
    let r = 10;
    u++;
    let l;
    if (t[u] === "x")
      for (r = 16, u++, l = u; u < t.length && wq(t.charCodeAt(u)); )
        u++;
    else
      for (l = u; u < t.length && Sq(t.charCodeAt(u)); )
        u++;
    if (t[u] === ";") {
      const i = t.slice(l, u);
      i && (u++, c = String.fromCodePoint(parseInt(i, r)));
    }
  } else
    for (; u < t.length && a++ < 10; ) {
      const r = t[u];
      if (u++, r === ";") {
        c = vq.get(n);
        break;
      }
      n += r;
    }
  return c ? { entity: c, newI: u } : { entity: "&", newI: e };
}
function Sq(t) {
  return t >= Ge.digit0 && t <= Ge.digit9;
}
function wq(t) {
  return t >= Ge.digit0 && t <= Ge.digit9 || t >= Ge.lowercaseA && t <= Ge.lowercaseF || t >= Ge.uppercaseA && t <= Ge.uppercaseF;
}
function aC(t, e) {
  const n = nC(e), a = /* @__PURE__ */ new Set();
  for (let c = 0; c < t.tokens.length; c++) {
    const u = t.tokens[c];
    if (u.type === L.name && !u.isType && (u.identifierRole === jt.Access || u.identifierRole === jt.ObjectShorthand || u.identifierRole === jt.ExportAccess) && !u.shadowsGlobal && a.add(t.identifierNameForToken(u)), u.type === L.jsxTagStart && a.add(n.base), u.type === L.jsxTagStart && c + 1 < t.tokens.length && t.tokens[c + 1].type === L.jsxTagEnd && (a.add(n.base), a.add(n.fragmentBase)), u.type === L.jsxName && u.identifierRole === jt.Access) {
      const r = t.identifierNameForToken(u);
      (!iC(r) || t.tokens[c + 1].type === L.dot) && a.add(t.identifierNameForToken(u));
    }
  }
  return a;
}
class Da {
  __init() {
    this.nonTypeIdentifiers = /* @__PURE__ */ new Set();
  }
  __init2() {
    this.importInfoByPath = /* @__PURE__ */ new Map();
  }
  __init3() {
    this.importsToReplace = /* @__PURE__ */ new Map();
  }
  __init4() {
    this.identifierReplacements = /* @__PURE__ */ new Map();
  }
  __init5() {
    this.exportBindingsByLocalName = /* @__PURE__ */ new Map();
  }
  constructor(e, n, a, c, u, r, l) {
    this.nameManager = e, this.tokens = n, this.enableLegacyTypeScriptModuleInterop = a, this.options = c, this.isTypeScriptTransformEnabled = u, this.keepUnusedImports = r, this.helperManager = l, Da.prototype.__init.call(this), Da.prototype.__init2.call(this), Da.prototype.__init3.call(this), Da.prototype.__init4.call(this), Da.prototype.__init5.call(this);
  }
  preprocessTokens() {
    for (let e = 0; e < this.tokens.tokens.length; e++)
      this.tokens.matches1AtIndex(e, L._import) && !this.tokens.matches3AtIndex(e, L._import, L.name, L.eq) && this.preprocessImportAtIndex(e), this.tokens.matches1AtIndex(e, L._export) && !this.tokens.matches2AtIndex(e, L._export, L.eq) && this.preprocessExportAtIndex(e);
    this.generateImportReplacements();
  }
  /**
   * In TypeScript, import statements that only import types should be removed.
   * This includes `import {} from 'foo';`, but not `import 'foo';`.
   */
  pruneTypeOnlyImports() {
    this.nonTypeIdentifiers = aC(this.tokens, this.options);
    for (const [e, n] of this.importInfoByPath.entries()) {
      if (n.hasBareImport || n.hasStarExport || n.exportStarNames.length > 0 || n.namedExports.length > 0)
        continue;
      [
        ...n.defaultNames,
        ...n.wildcardNames,
        ...n.namedImports.map(({ localName: c }) => c)
      ].every((c) => this.shouldAutomaticallyElideImportedName(c)) && this.importsToReplace.set(e, "");
    }
  }
  shouldAutomaticallyElideImportedName(e) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.nonTypeIdentifiers.has(e);
  }
  generateImportReplacements() {
    for (const [e, n] of this.importInfoByPath.entries()) {
      const {
        defaultNames: a,
        wildcardNames: c,
        namedImports: u,
        namedExports: r,
        exportStarNames: l,
        hasStarExport: i
      } = n;
      if (a.length === 0 && c.length === 0 && u.length === 0 && r.length === 0 && l.length === 0 && !i) {
        this.importsToReplace.set(e, `require('${e}');`);
        continue;
      }
      const f = this.getFreeIdentifierForPath(e);
      let d;
      this.enableLegacyTypeScriptModuleInterop ? d = f : d = c.length > 0 ? c[0] : this.getFreeIdentifierForPath(e);
      let s = `var ${f} = require('${e}');`;
      if (c.length > 0)
        for (const o of c) {
          const m = this.enableLegacyTypeScriptModuleInterop ? f : `${this.helperManager.getHelperName("interopRequireWildcard")}(${f})`;
          s += ` var ${o} = ${m};`;
        }
      else
        l.length > 0 && d !== f ? s += ` var ${d} = ${this.helperManager.getHelperName(
          "interopRequireWildcard"
        )}(${f});` : a.length > 0 && d !== f && (s += ` var ${d} = ${this.helperManager.getHelperName(
          "interopRequireDefault"
        )}(${f});`);
      for (const { importedName: o, localName: m } of r)
        s += ` ${this.helperManager.getHelperName(
          "createNamedExportFrom"
        )}(${f}, '${m}', '${o}');`;
      for (const o of l)
        s += ` exports.${o} = ${d};`;
      i && (s += ` ${this.helperManager.getHelperName(
        "createStarExport"
      )}(${f});`), this.importsToReplace.set(e, s);
      for (const o of a)
        this.identifierReplacements.set(o, `${d}.default`);
      for (const { importedName: o, localName: m } of u)
        this.identifierReplacements.set(m, `${f}.${o}`);
    }
  }
  getFreeIdentifierForPath(e) {
    const n = e.split("/"), c = n[n.length - 1].replace(/\W/g, "");
    return this.nameManager.claimFreeName(`_${c}`);
  }
  preprocessImportAtIndex(e) {
    const n = [], a = [], c = [];
    if (e++, (this.tokens.matchesContextualAtIndex(e, Fe._type) || this.tokens.matches1AtIndex(e, L._typeof)) && !this.tokens.matches1AtIndex(e + 1, L.comma) && !this.tokens.matchesContextualAtIndex(e + 1, Fe._from) || this.tokens.matches1AtIndex(e, L.parenL))
      return;
    if (this.tokens.matches1AtIndex(e, L.name) && (n.push(this.tokens.identifierNameAtIndex(e)), e++, this.tokens.matches1AtIndex(e, L.comma) && e++), this.tokens.matches1AtIndex(e, L.star) && (e += 2, a.push(this.tokens.identifierNameAtIndex(e)), e++), this.tokens.matches1AtIndex(e, L.braceL)) {
      const l = this.getNamedImports(e + 1);
      e = l.newIndex;
      for (const i of l.namedImports)
        i.importedName === "default" ? n.push(i.localName) : c.push(i);
    }
    if (this.tokens.matchesContextualAtIndex(e, Fe._from) && e++, !this.tokens.matches1AtIndex(e, L.string))
      throw new Error("Expected string token at the end of import statement.");
    const u = this.tokens.stringValueAtIndex(e), r = this.getImportInfo(u);
    r.defaultNames.push(...n), r.wildcardNames.push(...a), r.namedImports.push(...c), n.length === 0 && a.length === 0 && c.length === 0 && (r.hasBareImport = !0);
  }
  preprocessExportAtIndex(e) {
    if (this.tokens.matches2AtIndex(e, L._export, L._var) || this.tokens.matches2AtIndex(e, L._export, L._let) || this.tokens.matches2AtIndex(e, L._export, L._const))
      this.preprocessVarExportAtIndex(e);
    else if (this.tokens.matches2AtIndex(e, L._export, L._function) || this.tokens.matches2AtIndex(e, L._export, L._class)) {
      const n = this.tokens.identifierNameAtIndex(e + 2);
      this.addExportBinding(n, n);
    } else if (this.tokens.matches3AtIndex(e, L._export, L.name, L._function)) {
      const n = this.tokens.identifierNameAtIndex(e + 3);
      this.addExportBinding(n, n);
    } else
      this.tokens.matches2AtIndex(e, L._export, L.braceL) ? this.preprocessNamedExportAtIndex(e) : this.tokens.matches2AtIndex(e, L._export, L.star) && this.preprocessExportStarAtIndex(e);
  }
  preprocessVarExportAtIndex(e) {
    let n = 0;
    for (let a = e + 2; ; a++)
      if (this.tokens.matches1AtIndex(a, L.braceL) || this.tokens.matches1AtIndex(a, L.dollarBraceL) || this.tokens.matches1AtIndex(a, L.bracketL))
        n++;
      else if (this.tokens.matches1AtIndex(a, L.braceR) || this.tokens.matches1AtIndex(a, L.bracketR))
        n--;
      else {
        if (n === 0 && !this.tokens.matches1AtIndex(a, L.name))
          break;
        if (this.tokens.matches1AtIndex(1, L.eq)) {
          const c = this.tokens.currentToken().rhsEndIndex;
          if (c == null)
            throw new Error("Expected = token with an end index.");
          a = c - 1;
        } else {
          const c = this.tokens.tokens[a];
          if (qP(c)) {
            const u = this.tokens.identifierNameAtIndex(a);
            this.identifierReplacements.set(u, `exports.${u}`);
          }
        }
      }
  }
  /**
   * Walk this export statement just in case it's an export...from statement.
   * If it is, combine it into the import info for that path. Otherwise, just
   * bail out; it'll be handled later.
   */
  preprocessNamedExportAtIndex(e) {
    e += 2;
    const { newIndex: n, namedImports: a } = this.getNamedImports(e);
    if (e = n, this.tokens.matchesContextualAtIndex(e, Fe._from))
      e++;
    else {
      for (const { importedName: r, localName: l } of a)
        this.addExportBinding(r, l);
      return;
    }
    if (!this.tokens.matches1AtIndex(e, L.string))
      throw new Error("Expected string token at the end of import statement.");
    const c = this.tokens.stringValueAtIndex(e);
    this.getImportInfo(c).namedExports.push(...a);
  }
  preprocessExportStarAtIndex(e) {
    let n = null;
    if (this.tokens.matches3AtIndex(e, L._export, L.star, L._as) ? (e += 3, n = this.tokens.identifierNameAtIndex(e), e += 2) : e += 3, !this.tokens.matches1AtIndex(e, L.string))
      throw new Error("Expected string token at the end of star export statement.");
    const a = this.tokens.stringValueAtIndex(e), c = this.getImportInfo(a);
    n !== null ? c.exportStarNames.push(n) : c.hasStarExport = !0;
  }
  getNamedImports(e) {
    const n = [];
    for (; ; ) {
      if (this.tokens.matches1AtIndex(e, L.braceR)) {
        e++;
        break;
      }
      const a = hu(this.tokens, e);
      if (e = a.endIndex, a.isType || n.push({
        importedName: a.leftName,
        localName: a.rightName
      }), this.tokens.matches2AtIndex(e, L.comma, L.braceR)) {
        e += 2;
        break;
      } else if (this.tokens.matches1AtIndex(e, L.braceR)) {
        e++;
        break;
      } else if (this.tokens.matches1AtIndex(e, L.comma))
        e++;
      else
        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.tokens[e])}`);
    }
    return { newIndex: e, namedImports: n };
  }
  /**
   * Get a mutable import info object for this path, creating one if it doesn't
   * exist yet.
   */
  getImportInfo(e) {
    const n = this.importInfoByPath.get(e);
    if (n)
      return n;
    const a = {
      defaultNames: [],
      wildcardNames: [],
      namedImports: [],
      namedExports: [],
      hasBareImport: !1,
      exportStarNames: [],
      hasStarExport: !1
    };
    return this.importInfoByPath.set(e, a), a;
  }
  addExportBinding(e, n) {
    this.exportBindingsByLocalName.has(e) || this.exportBindingsByLocalName.set(e, []), this.exportBindingsByLocalName.get(e).push(n);
  }
  /**
   * Return the code to use for the import for this path, or the empty string if
   * the code has already been "claimed" by a previous import.
   */
  claimImportCode(e) {
    const n = this.importsToReplace.get(e);
    return this.importsToReplace.set(e, ""), n || "";
  }
  getIdentifierReplacement(e) {
    return this.identifierReplacements.get(e) || null;
  }
  /**
   * Return a string like `exports.foo = exports.bar`.
   */
  resolveExportBinding(e) {
    const n = this.exportBindingsByLocalName.get(e);
    return !n || n.length === 0 ? null : n.map((a) => `exports.${a}`).join(" = ");
  }
  /**
   * Return all imported/exported names where we might be interested in whether usages of those
   * names are shadowed.
   */
  getGlobalNames() {
    return /* @__PURE__ */ new Set([
      ...this.identifierReplacements.keys(),
      ...this.exportBindingsByLocalName.keys()
    ]);
  }
}
var m0 = { exports: {} }, Hc = { exports: {} }, sS;
function Tq() {
  return sS || (sS = 1, function(t, e) {
    (function(n, a) {
      a(e);
    })(Bt, function(n) {
      n.get = void 0, n.put = void 0, n.pop = void 0;
      class a {
        constructor() {
          this._indexes = { __proto__: null }, this.array = [];
        }
      }
      n.get = (c, u) => c._indexes[u], n.put = (c, u) => {
        const r = n.get(c, u);
        if (r !== void 0)
          return r;
        const { array: l, _indexes: i } = c;
        return i[u] = l.push(u) - 1;
      }, n.pop = (c) => {
        const { array: u, _indexes: r } = c;
        if (u.length === 0)
          return;
        const l = u.pop();
        r[l] = void 0;
      }, n.SetArray = a, Object.defineProperty(n, "__esModule", { value: !0 });
    });
  }(Hc, Hc.exports)), Hc.exports;
}
var qc = { exports: {} }, aS;
function oC() {
  return aS || (aS = 1, function(t, e) {
    (function(n, a) {
      a(e);
    })(Bt, function(n) {
      const a = ",".charCodeAt(0), c = ";".charCodeAt(0), u = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r = new Uint8Array(64), l = new Uint8Array(128);
      for (let E = 0; E < u.length; E++) {
        const S = u.charCodeAt(E);
        r[E] = S, l[S] = E;
      }
      const i = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Ve.Buffer < "u" ? {
        decode(E) {
          return Ve.Buffer.from(E.buffer, E.byteOffset, E.byteLength).toString();
        }
      } : {
        decode(E) {
          let S = "";
          for (let g = 0; g < E.length; g++)
            S += String.fromCharCode(E[g]);
          return S;
        }
      };
      function f(E) {
        const S = new Int32Array(5), g = [];
        let P = 0;
        do {
          const R = d(E, P), N = [];
          let C = !0, I = 0;
          S[0] = 0;
          for (let D = P; D < R; D++) {
            let j;
            D = s(E, D, S, 0);
            const F = S[0];
            F < I && (C = !1), I = F, o(E, D, R) ? (D = s(E, D, S, 1), D = s(E, D, S, 2), D = s(E, D, S, 3), o(E, D, R) ? (D = s(E, D, S, 4), j = [F, S[1], S[2], S[3], S[4]]) : j = [F, S[1], S[2], S[3]]) : j = [F], N.push(j);
          }
          C || m(N), g.push(N), P = R + 1;
        } while (P <= E.length);
        return g;
      }
      function d(E, S) {
        const g = E.indexOf(";", S);
        return g === -1 ? E.length : g;
      }
      function s(E, S, g, P) {
        let R = 0, N = 0, C = 0;
        do {
          const D = E.charCodeAt(S++);
          C = l[D], R |= (C & 31) << N, N += 5;
        } while (C & 32);
        const I = R & 1;
        return R >>>= 1, I && (R = -2147483648 | -R), g[P] += R, S;
      }
      function o(E, S, g) {
        return S >= g ? !1 : E.charCodeAt(S) !== a;
      }
      function m(E) {
        E.sort(h);
      }
      function h(E, S) {
        return E[0] - S[0];
      }
      function y(E) {
        const S = new Int32Array(5), g = 1024 * 16, P = g - 36, R = new Uint8Array(g), N = R.subarray(0, P);
        let C = 0, I = "";
        for (let D = 0; D < E.length; D++) {
          const j = E[D];
          if (D > 0 && (C === g && (I += i.decode(R), C = 0), R[C++] = c), j.length !== 0) {
            S[0] = 0;
            for (let F = 0; F < j.length; F++) {
              const _ = j[F];
              C > P && (I += i.decode(N), R.copyWithin(0, P, C), C -= P), F > 0 && (R[C++] = a), C = b(R, C, S, _, 0), _.length !== 1 && (C = b(R, C, S, _, 1), C = b(R, C, S, _, 2), C = b(R, C, S, _, 3), _.length !== 4 && (C = b(R, C, S, _, 4)));
            }
          }
        }
        return I + i.decode(R.subarray(0, C));
      }
      function b(E, S, g, P, R) {
        const N = P[R];
        let C = N - g[R];
        g[R] = N, C = C < 0 ? -C << 1 | 1 : C << 1;
        do {
          let I = C & 31;
          C >>>= 5, C > 0 && (I |= 32), E[S++] = r[I];
        } while (C > 0);
        return S;
      }
      n.decode = f, n.encode = y, Object.defineProperty(n, "__esModule", { value: !0 });
    });
  }(qc, qc.exports)), qc.exports;
}
var Gc = { exports: {} }, Tm = { exports: {} }, oS;
function Aq() {
  return oS || (oS = 1, function(t, e) {
    (function(n, a) {
      t.exports = a();
    })(Bt, function() {
      const n = /^[\w+.-]+:\/\//, a = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, c = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      var u;
      (function(g) {
        g[g.Empty = 1] = "Empty", g[g.Hash = 2] = "Hash", g[g.Query = 3] = "Query", g[g.RelativePath = 4] = "RelativePath", g[g.AbsolutePath = 5] = "AbsolutePath", g[g.SchemeRelative = 6] = "SchemeRelative", g[g.Absolute = 7] = "Absolute";
      })(u || (u = {}));
      function r(g) {
        return n.test(g);
      }
      function l(g) {
        return g.startsWith("//");
      }
      function i(g) {
        return g.startsWith("/");
      }
      function f(g) {
        return g.startsWith("file:");
      }
      function d(g) {
        return /^[.?#]/.test(g);
      }
      function s(g) {
        const P = a.exec(g);
        return m(P[1], P[2] || "", P[3], P[4] || "", P[5] || "/", P[6] || "", P[7] || "");
      }
      function o(g) {
        const P = c.exec(g), R = P[2];
        return m("file:", "", P[1] || "", "", i(R) ? R : "/" + R, P[3] || "", P[4] || "");
      }
      function m(g, P, R, N, C, I, D) {
        return {
          scheme: g,
          user: P,
          host: R,
          port: N,
          path: C,
          query: I,
          hash: D,
          type: u.Absolute
        };
      }
      function h(g) {
        if (l(g)) {
          const R = s("http:" + g);
          return R.scheme = "", R.type = u.SchemeRelative, R;
        }
        if (i(g)) {
          const R = s("http://foo.com" + g);
          return R.scheme = "", R.host = "", R.type = u.AbsolutePath, R;
        }
        if (f(g))
          return o(g);
        if (r(g))
          return s(g);
        const P = s("http://foo.com/" + g);
        return P.scheme = "", P.host = "", P.type = g ? g.startsWith("?") ? u.Query : g.startsWith("#") ? u.Hash : u.RelativePath : u.Empty, P;
      }
      function y(g) {
        if (g.endsWith("/.."))
          return g;
        const P = g.lastIndexOf("/");
        return g.slice(0, P + 1);
      }
      function b(g, P) {
        E(P, P.type), g.path === "/" ? g.path = P.path : g.path = y(P.path) + g.path;
      }
      function E(g, P) {
        const R = P <= u.RelativePath, N = g.path.split("/");
        let C = 1, I = 0, D = !1;
        for (let F = 1; F < N.length; F++) {
          const _ = N[F];
          if (!_) {
            D = !0;
            continue;
          }
          if (D = !1, _ !== ".") {
            if (_ === "..") {
              I ? (D = !0, I--, C--) : R && (N[C++] = _);
              continue;
            }
            N[C++] = _, I++;
          }
        }
        let j = "";
        for (let F = 1; F < C; F++)
          j += "/" + N[F];
        (!j || D && !j.endsWith("/..")) && (j += "/"), g.path = j;
      }
      function S(g, P) {
        if (!g && !P)
          return "";
        const R = h(g);
        let N = R.type;
        if (P && N !== u.Absolute) {
          const I = h(P), D = I.type;
          switch (N) {
            case u.Empty:
              R.hash = I.hash;
            case u.Hash:
              R.query = I.query;
            case u.Query:
            case u.RelativePath:
              b(R, I);
            case u.AbsolutePath:
              R.user = I.user, R.host = I.host, R.port = I.port;
            case u.SchemeRelative:
              R.scheme = I.scheme;
          }
          D > N && (N = D);
        }
        E(R, N);
        const C = R.query + R.hash;
        switch (N) {
          case u.Hash:
          case u.Query:
            return C;
          case u.RelativePath: {
            const I = R.path.slice(1);
            return I ? d(P || g) && !d(I) ? "./" + I + C : I + C : C || ".";
          }
          case u.AbsolutePath:
            return R.path + C;
          default:
            return R.scheme + "//" + R.user + R.host + R.port + R.path + C;
        }
      }
      return S;
    });
  }(Tm)), Tm.exports;
}
var lS;
function xq() {
  return lS || (lS = 1, function(t, e) {
    (function(n, a) {
      a(e, oC(), Aq());
    })(Bt, function(n, a, c) {
      function u(H) {
        return H && typeof H == "object" && "default" in H ? H : { default: H };
      }
      var r = /* @__PURE__ */ u(c);
      function l(H, Q) {
        return Q && !Q.endsWith("/") && (Q += "/"), r.default(H, Q);
      }
      function i(H) {
        if (!H)
          return "";
        const Q = H.lastIndexOf("/");
        return H.slice(0, Q + 1);
      }
      const f = 0, d = 1, s = 2, o = 3, m = 4, h = 1, y = 2;
      function b(H, Q) {
        const X = E(H, 0);
        if (X === H.length)
          return H;
        Q || (H = H.slice());
        for (let ne = X; ne < H.length; ne = E(H, ne + 1))
          H[ne] = g(H[ne], Q);
        return H;
      }
      function E(H, Q) {
        for (let X = Q; X < H.length; X++)
          if (!S(H[X]))
            return X;
        return H.length;
      }
      function S(H) {
        for (let Q = 1; Q < H.length; Q++)
          if (H[Q][f] < H[Q - 1][f])
            return !1;
        return !0;
      }
      function g(H, Q) {
        return Q || (H = H.slice()), H.sort(P);
      }
      function P(H, Q) {
        return H[f] - Q[f];
      }
      let R = !1;
      function N(H, Q, X, ne) {
        for (; X <= ne; ) {
          const ye = X + (ne - X >> 1), ve = H[ye][f] - Q;
          if (ve === 0)
            return R = !0, ye;
          ve < 0 ? X = ye + 1 : ne = ye - 1;
        }
        return R = !1, X - 1;
      }
      function C(H, Q, X) {
        for (let ne = X + 1; ne < H.length && H[ne][f] === Q; X = ne++)
          ;
        return X;
      }
      function I(H, Q, X) {
        for (let ne = X - 1; ne >= 0 && H[ne][f] === Q; X = ne--)
          ;
        return X;
      }
      function D() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function j(H, Q, X, ne) {
        const { lastKey: ye, lastNeedle: ve, lastIndex: de } = X;
        let oe = 0, re = H.length - 1;
        if (ne === ye) {
          if (Q === ve)
            return R = de !== -1 && H[de][f] === Q, de;
          Q >= ve ? oe = de === -1 ? 0 : de : re = de;
        }
        return X.lastKey = ne, X.lastNeedle = Q, X.lastIndex = N(H, Q, oe, re);
      }
      function F(H, Q) {
        const X = Q.map(T);
        for (let ne = 0; ne < H.length; ne++) {
          const ye = H[ne];
          for (let ve = 0; ve < ye.length; ve++) {
            const de = ye[ve];
            if (de.length === 1)
              continue;
            const oe = de[d], re = de[s], ae = de[o], le = X[oe], ue = le[re] || (le[re] = []), ie = Q[oe], we = C(ue, ae, j(ue, ae, ie, re));
            _(ue, ie.lastIndex = we + 1, [ae, ne, de[f]]);
          }
        }
        return X;
      }
      function _(H, Q, X) {
        for (let ne = H.length; ne > Q; ne--)
          H[ne] = H[ne - 1];
        H[Q] = X;
      }
      function T() {
        return { __proto__: null };
      }
      const v = function(H, Q) {
        const X = typeof H == "string" ? JSON.parse(H) : H;
        if (!("sections" in X))
          return new K(X, Q);
        const ne = [], ye = [], ve = [], de = [];
        w(X, Q, ne, ye, ve, de, 0, 0, 1 / 0, 1 / 0);
        const oe = {
          version: 3,
          file: X.file,
          names: de,
          sources: ye,
          sourcesContent: ve,
          mappings: ne
        };
        return n.presortedDecodedMap(oe);
      };
      function w(H, Q, X, ne, ye, ve, de, oe, re, ae) {
        const { sections: le } = H;
        for (let ue = 0; ue < le.length; ue++) {
          const { map: ie, offset: we } = le[ue];
          let De = re, Ee = ae;
          if (ue + 1 < le.length) {
            const Ae = le[ue + 1].offset;
            De = Math.min(re, de + Ae.line), De === re ? Ee = Math.min(ae, oe + Ae.column) : De < re && (Ee = oe + Ae.column);
          }
          O(ie, Q, X, ne, ye, ve, de + we.line, oe + we.column, De, Ee);
        }
      }
      function O(H, Q, X, ne, ye, ve, de, oe, re, ae) {
        if ("sections" in H)
          return w(...arguments);
        const le = new K(H, Q), ue = ne.length, ie = ve.length, we = n.decodedMappings(le), { resolvedSources: De, sourcesContent: Ee } = le;
        if (G(ne, De), G(ve, le.names), Ee)
          G(ye, Ee);
        else
          for (let Ae = 0; Ae < De.length; Ae++)
            ye.push(null);
        for (let Ae = 0; Ae < we.length; Ae++) {
          const Me = de + Ae;
          if (Me > re)
            return;
          const me = W(X, Me), se = Ae === 0 ? oe : 0, Z = we[Ae];
          for (let pe = 0; pe < Z.length; pe++) {
            const be = Z[pe], _e = se + be[f];
            if (Me === re && _e >= ae)
              return;
            if (be.length === 1) {
              me.push([_e]);
              continue;
            }
            const Ie = ue + be[d], We = be[s], tt = be[o];
            me.push(be.length === 4 ? [_e, Ie, We, tt] : [_e, Ie, We, tt, ie + be[m]]);
          }
        }
      }
      function G(H, Q) {
        for (let X = 0; X < Q.length; X++)
          H.push(Q[X]);
      }
      function W(H, Q) {
        for (let X = H.length; X <= Q; X++)
          H[X] = [];
        return H[Q];
      }
      const U = "`line` must be greater than 0 (lines start at line 1)", M = "`column` must be greater than or equal to 0 (columns start at column 0)", B = -1, k = 1;
      n.encodedMappings = void 0, n.decodedMappings = void 0, n.traceSegment = void 0, n.originalPositionFor = void 0, n.generatedPositionFor = void 0, n.allGeneratedPositionsFor = void 0, n.eachMapping = void 0, n.sourceContentFor = void 0, n.presortedDecodedMap = void 0, n.decodedMap = void 0, n.encodedMap = void 0;
      class K {
        constructor(Q, X) {
          const ne = typeof Q == "string";
          if (!ne && Q._decodedMemo)
            return Q;
          const ye = ne ? JSON.parse(Q) : Q, { version: ve, file: de, names: oe, sourceRoot: re, sources: ae, sourcesContent: le } = ye;
          this.version = ve, this.file = de, this.names = oe, this.sourceRoot = re, this.sources = ae, this.sourcesContent = le;
          const ue = l(re || "", i(X));
          this.resolvedSources = ae.map((we) => l(we || "", ue));
          const { mappings: ie } = ye;
          typeof ie == "string" ? (this._encoded = ie, this._decoded = void 0) : (this._encoded = void 0, this._decoded = b(ie, ne)), this._decodedMemo = D(), this._bySources = void 0, this._bySourceMemos = void 0;
        }
      }
      (() => {
        n.encodedMappings = (Q) => {
          var X;
          return (X = Q._encoded) !== null && X !== void 0 ? X : Q._encoded = a.encode(Q._decoded);
        }, n.decodedMappings = (Q) => Q._decoded || (Q._decoded = a.decode(Q._encoded)), n.traceSegment = (Q, X, ne) => {
          const ye = n.decodedMappings(Q);
          if (X >= ye.length)
            return null;
          const ve = ye[X], de = $(ve, Q._decodedMemo, X, ne, k);
          return de === -1 ? null : ve[de];
        }, n.originalPositionFor = (Q, { line: X, column: ne, bias: ye }) => {
          if (X--, X < 0)
            throw new Error(U);
          if (ne < 0)
            throw new Error(M);
          const ve = n.decodedMappings(Q);
          if (X >= ve.length)
            return z(null, null, null, null);
          const de = ve[X], oe = $(de, Q._decodedMemo, X, ne, ye || k);
          if (oe === -1)
            return z(null, null, null, null);
          const re = de[oe];
          if (re.length === 1)
            return z(null, null, null, null);
          const { names: ae, resolvedSources: le } = Q;
          return z(le[re[d]], re[s] + 1, re[o], re.length === 5 ? ae[re[m]] : null);
        }, n.allGeneratedPositionsFor = (Q, { source: X, line: ne, column: ye, bias: ve }) => H(Q, X, ne, ye, ve || B, !0), n.generatedPositionFor = (Q, { source: X, line: ne, column: ye, bias: ve }) => H(Q, X, ne, ye, ve || k, !1), n.eachMapping = (Q, X) => {
          const ne = n.decodedMappings(Q), { names: ye, resolvedSources: ve } = Q;
          for (let de = 0; de < ne.length; de++) {
            const oe = ne[de];
            for (let re = 0; re < oe.length; re++) {
              const ae = oe[re], le = de + 1, ue = ae[0];
              let ie = null, we = null, De = null, Ee = null;
              ae.length !== 1 && (ie = ve[ae[1]], we = ae[2] + 1, De = ae[3]), ae.length === 5 && (Ee = ye[ae[4]]), X({
                generatedLine: le,
                generatedColumn: ue,
                source: ie,
                originalLine: we,
                originalColumn: De,
                name: Ee
              });
            }
          }
        }, n.sourceContentFor = (Q, X) => {
          const { sources: ne, resolvedSources: ye, sourcesContent: ve } = Q;
          if (ve == null)
            return null;
          let de = ne.indexOf(X);
          return de === -1 && (de = ye.indexOf(X)), de === -1 ? null : ve[de];
        }, n.presortedDecodedMap = (Q, X) => {
          const ne = new K(te(Q, []), X);
          return ne._decoded = Q.mappings, ne;
        }, n.decodedMap = (Q) => te(Q, n.decodedMappings(Q)), n.encodedMap = (Q) => te(Q, n.encodedMappings(Q));
        function H(Q, X, ne, ye, ve, de) {
          if (ne--, ne < 0)
            throw new Error(U);
          if (ye < 0)
            throw new Error(M);
          const { sources: oe, resolvedSources: re } = Q;
          let ae = oe.indexOf(X);
          if (ae === -1 && (ae = re.indexOf(X)), ae === -1)
            return de ? [] : q(null, null);
          const ue = (Q._bySources || (Q._bySources = F(n.decodedMappings(Q), Q._bySourceMemos = oe.map(D))))[ae][ne];
          if (ue == null)
            return de ? [] : q(null, null);
          const ie = Q._bySourceMemos[ae];
          if (de)
            return Y(ue, ie, ne, ye, ve);
          const we = $(ue, ie, ne, ye, ve);
          if (we === -1)
            return q(null, null);
          const De = ue[we];
          return q(De[h] + 1, De[y]);
        }
      })();
      function te(H, Q) {
        return {
          version: H.version,
          file: H.file,
          names: H.names,
          sourceRoot: H.sourceRoot,
          sources: H.sources,
          sourcesContent: H.sourcesContent,
          mappings: Q
        };
      }
      function z(H, Q, X, ne) {
        return { source: H, line: Q, column: X, name: ne };
      }
      function q(H, Q) {
        return { line: H, column: Q };
      }
      function $(H, Q, X, ne, ye) {
        let ve = j(H, ne, Q, X);
        return R ? ve = (ye === B ? C : I)(H, ne, ve) : ye === B && ve++, ve === -1 || ve === H.length ? -1 : ve;
      }
      function Y(H, Q, X, ne, ye) {
        let ve = $(H, Q, X, ne, k);
        if (!R && ye === B && ve++, ve === -1 || ve === H.length)
          return [];
        const de = R ? ne : H[ve][f];
        R || (ve = I(H, de, ve));
        const oe = C(H, de, ve), re = [];
        for (; ve <= oe; ve++) {
          const ae = H[ve];
          re.push(q(ae[h] + 1, ae[y]));
        }
        return re;
      }
      n.AnyMap = v, n.GREATEST_LOWER_BOUND = k, n.LEAST_UPPER_BOUND = B, n.TraceMap = K, Object.defineProperty(n, "__esModule", { value: !0 });
    });
  }(Gc, Gc.exports)), Gc.exports;
}
(function(t, e) {
  (function(n, a) {
    a(e, Tq(), oC(), xq());
  })(Bt, function(n, a, c, u) {
    n.addSegment = void 0, n.addMapping = void 0, n.maybeAddSegment = void 0, n.maybeAddMapping = void 0, n.setSourceContent = void 0, n.toDecodedMap = void 0, n.toEncodedMap = void 0, n.fromMap = void 0, n.allMappings = void 0;
    let o;
    class m {
      constructor({ file: C, sourceRoot: I } = {}) {
        this._names = new a.SetArray(), this._sources = new a.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = C, this.sourceRoot = I;
      }
    }
    n.addSegment = (N, C, I, D, j, F, _, T) => o(!1, N, C, I, D, j, F, _, T), n.maybeAddSegment = (N, C, I, D, j, F, _, T) => o(!0, N, C, I, D, j, F, _, T), n.addMapping = (N, C) => R(!1, N, C), n.maybeAddMapping = (N, C) => R(!0, N, C), n.setSourceContent = (N, C, I) => {
      const { _sources: D, _sourcesContent: j } = N;
      j[a.put(D, C)] = I;
    }, n.toDecodedMap = (N) => {
      const { file: C, sourceRoot: I, _mappings: D, _sources: j, _sourcesContent: F, _names: _ } = N;
      return E(D), {
        version: 3,
        file: C || void 0,
        names: _.array,
        sourceRoot: I || void 0,
        sources: j.array,
        sourcesContent: F,
        mappings: D
      };
    }, n.toEncodedMap = (N) => {
      const C = n.toDecodedMap(N);
      return Object.assign(Object.assign({}, C), { mappings: c.encode(C.mappings) });
    }, n.allMappings = (N) => {
      const C = [], { _mappings: I, _sources: D, _names: j } = N;
      for (let F = 0; F < I.length; F++) {
        const _ = I[F];
        for (let T = 0; T < _.length; T++) {
          const v = _[T], w = { line: F + 1, column: v[0] };
          let O, G, W;
          v.length !== 1 && (O = D.array[v[1]], G = { line: v[2] + 1, column: v[3] }, v.length === 5 && (W = j.array[v[4]])), C.push({ generated: w, source: O, original: G, name: W });
        }
      }
      return C;
    }, n.fromMap = (N) => {
      const C = new u.TraceMap(N), I = new m({ file: C.file, sourceRoot: C.sourceRoot });
      return S(I._names, C.names), S(I._sources, C.sources), I._sourcesContent = C.sourcesContent || C.sources.map(() => null), I._mappings = u.decodedMappings(C), I;
    }, o = (N, C, I, D, j, F, _, T, v) => {
      const { _mappings: w, _sources: O, _sourcesContent: G, _names: W } = C, U = h(w, I), M = y(U, D);
      if (!j)
        return N && g(U, M) ? void 0 : b(U, M, [D]);
      const B = a.put(O, j), k = T ? a.put(W, T) : -1;
      if (B === G.length && (G[B] = v ?? null), !(N && P(U, M, B, F, _, k)))
        return b(U, M, T ? [D, B, F, _, k] : [D, B, F, _]);
    };
    function h(N, C) {
      for (let I = N.length; I <= C; I++)
        N[I] = [];
      return N[C];
    }
    function y(N, C) {
      let I = N.length;
      for (let D = I - 1; D >= 0; I = D--) {
        const j = N[D];
        if (C >= j[0])
          break;
      }
      return I;
    }
    function b(N, C, I) {
      for (let D = N.length; D > C; D--)
        N[D] = N[D - 1];
      N[C] = I;
    }
    function E(N) {
      const { length: C } = N;
      let I = C;
      for (let D = I - 1; D >= 0 && !(N[D].length > 0); I = D, D--)
        ;
      I < C && (N.length = I);
    }
    function S(N, C) {
      for (let I = 0; I < C.length; I++)
        a.put(N, C[I]);
    }
    function g(N, C) {
      return C === 0 ? !0 : N[C - 1].length === 1;
    }
    function P(N, C, I, D, j, F) {
      if (C === 0)
        return !1;
      const _ = N[C - 1];
      return _.length === 1 ? !1 : I === _[1] && D === _[2] && j === _[3] && F === (_.length === 5 ? _[4] : -1);
    }
    function R(N, C, I) {
      const { generated: D, source: j, original: F, name: _, content: T } = I;
      if (!j)
        return o(N, C, D.line - 1, D.column, null, null, null, null, null);
      const v = j;
      return o(N, C, D.line - 1, D.column, v, F.line - 1, F.column, _, T);
    }
    n.GenMapping = m, Object.defineProperty(n, "__esModule", { value: !0 });
  });
})(m0, m0.exports);
var Fl = m0.exports;
function Pq({ code: t, mappings: e }, n, a, c, u) {
  const r = Cq(c, u), l = new Fl.GenMapping({ file: a.compiledFilename });
  let i = 0, f = e[0];
  for (; f === void 0 && i < e.length - 1; )
    i++, f = e[i];
  let d = 0, s = 0;
  f !== s && Fl.maybeAddSegment(l, d, 0, n, d, 0);
  for (let y = 0; y < t.length; y++) {
    if (y === f) {
      const b = f - s, E = r[i];
      for (Fl.maybeAddSegment(l, d, b, n, d, E); (f === y || f === void 0) && i < e.length - 1; )
        i++, f = e[i];
    }
    t.charCodeAt(y) === Ge.lineFeed && (d++, s = y + 1, f !== s && Fl.maybeAddSegment(l, d, 0, n, d, 0));
  }
  const { sourceRoot: o, sourcesContent: m, ...h } = Fl.toEncodedMap(l);
  return h;
}
function Cq(t, e) {
  const n = new Array(e.length);
  let a = 0, c = e[a].start, u = 0;
  for (let r = 0; r < t.length; r++)
    r === c && (n[a] = c - u, a++, c = e[a].start), t.charCodeAt(r) === Ge.lineFeed && (u = r + 1);
  return n;
}
const Iq = {
  require: `
    import {createRequire as CREATE_REQUIRE_NAME} from "module";
    const require = CREATE_REQUIRE_NAME(import.meta.url);
  `,
  interopRequireWildcard: `
    function interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
  `,
  interopRequireDefault: `
    function interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  `,
  createNamedExportFrom: `
    function createNamedExportFrom(obj, localName, importedName) {
      Object.defineProperty(exports, localName, {enumerable: true, configurable: true, get: () => obj[importedName]});
    }
  `,
  // Note that TypeScript and Babel do this differently; TypeScript does a simple existence
  // check in the exports object and does a plain assignment, whereas Babel uses
  // defineProperty and builds an object of explicitly-exported names so that star exports can
  // always take lower precedence. For now, we do the easier TypeScript thing.
  createStarExport: `
    function createStarExport(obj) {
      Object.keys(obj)
        .filter((key) => key !== "default" && key !== "__esModule")
        .forEach((key) => {
          if (exports.hasOwnProperty(key)) {
            return;
          }
          Object.defineProperty(exports, key, {enumerable: true, configurable: true, get: () => obj[key]});
        });
    }
  `,
  nullishCoalesce: `
    function nullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return rhsFn();
      }
    }
  `,
  asyncNullishCoalesce: `
    async function asyncNullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return await rhsFn();
      }
    }
  `,
  optionalChain: `
    function optionalChain(ops) {
      let lastAccessLHS = undefined;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
          return undefined;
        }
        if (op === 'access' || op === 'optionalAccess') {
          lastAccessLHS = value;
          value = fn(value);
        } else if (op === 'call' || op === 'optionalCall') {
          value = fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = undefined;
        }
      }
      return value;
    }
  `,
  asyncOptionalChain: `
    async function asyncOptionalChain(ops) {
      let lastAccessLHS = undefined;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
          return undefined;
        }
        if (op === 'access' || op === 'optionalAccess') {
          lastAccessLHS = value;
          value = await fn(value);
        } else if (op === 'call' || op === 'optionalCall') {
          value = await fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = undefined;
        }
      }
      return value;
    }
  `,
  optionalChainDelete: `
    function optionalChainDelete(ops) {
      const result = OPTIONAL_CHAIN_NAME(ops);
      return result == null ? true : result;
    }
  `,
  asyncOptionalChainDelete: `
    async function asyncOptionalChainDelete(ops) {
      const result = await ASYNC_OPTIONAL_CHAIN_NAME(ops);
      return result == null ? true : result;
    }
  `
};
class Gf {
  __init() {
    this.helperNames = {};
  }
  __init2() {
    this.createRequireName = null;
  }
  constructor(e) {
    this.nameManager = e, Gf.prototype.__init.call(this), Gf.prototype.__init2.call(this);
  }
  getHelperName(e) {
    let n = this.helperNames[e];
    return n || (n = this.nameManager.claimFreeName(`_${e}`), this.helperNames[e] = n, n);
  }
  emitHelpers() {
    let e = "";
    this.helperNames.optionalChainDelete && this.getHelperName("optionalChain"), this.helperNames.asyncOptionalChainDelete && this.getHelperName("asyncOptionalChain");
    for (const [n, a] of Object.entries(Iq)) {
      const c = this.helperNames[n];
      let u = a;
      n === "optionalChainDelete" ? u = u.replace("OPTIONAL_CHAIN_NAME", this.helperNames.optionalChain) : n === "asyncOptionalChainDelete" ? u = u.replace(
        "ASYNC_OPTIONAL_CHAIN_NAME",
        this.helperNames.asyncOptionalChain
      ) : n === "require" && (this.createRequireName === null && (this.createRequireName = this.nameManager.claimFreeName("_createRequire")), u = u.replace(/CREATE_REQUIRE_NAME/g, this.createRequireName)), c && (e += " ", e += u.replace(n, c).replace(/\s+/g, " ").trim());
    }
    return e;
  }
}
function uS(t, e, n) {
  Oq(t, n) && kq(t, e, n);
}
function Oq(t, e) {
  for (const n of t.tokens)
    if (n.type === L.name && !n.isType && JH(n) && e.has(t.identifierNameForToken(n)))
      return !0;
  return !1;
}
function kq(t, e, n) {
  const a = [];
  let c = e.length - 1;
  for (let u = t.tokens.length - 1; ; u--) {
    for (; a.length > 0 && a[a.length - 1].startTokenIndex === u + 1; )
      a.pop();
    for (; c >= 0 && e[c].endTokenIndex === u + 1; )
      a.push(e[c]), c--;
    if (u < 0)
      break;
    const r = t.tokens[u], l = t.identifierNameForToken(r);
    if (a.length > 1 && !r.isType && r.type === L.name && n.has(l)) {
      if (QH(r))
        cS(a[a.length - 1], t, l);
      else if (ZH(r)) {
        let i = a.length - 1;
        for (; i > 0 && !a[i].isFunctionScope; )
          i--;
        if (i < 0)
          throw new Error("Did not find parent function scope.");
        cS(a[i], t, l);
      }
    }
  }
  if (a.length > 0)
    throw new Error("Expected empty scope stack after processing file.");
}
function cS(t, e, n) {
  for (let a = t.startTokenIndex; a < t.endTokenIndex; a++) {
    const c = e.tokens[a];
    (c.type === L.name || c.type === L.jsxName) && e.identifierNameForToken(c) === n && (c.shadowsGlobal = !0);
  }
}
function Dq(t, e) {
  const n = [];
  for (const a of e)
    a.type === L.name && n.push(t.slice(a.start, a.end));
  return n;
}
class Bb {
  __init() {
    this.usedNames = /* @__PURE__ */ new Set();
  }
  constructor(e, n) {
    Bb.prototype.__init.call(this), this.usedNames = new Set(Dq(e, n));
  }
  claimFreeName(e) {
    const n = this.findFreeName(e);
    return this.usedNames.add(n), n;
  }
  findFreeName(e) {
    if (!this.usedNames.has(e))
      return e;
    let n = 2;
    for (; this.usedNames.has(e + String(n)); )
      n++;
    return e + String(n);
  }
}
var yr = {}, y0 = {}, cs = {}, Nq = Bt && Bt.__extends || function() {
  var t = function(e, n) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a, c) {
      a.__proto__ = c;
    } || function(a, c) {
      for (var u in c)
        c.hasOwnProperty(u) && (a[u] = c[u]);
    }, t(e, n);
  };
  return function(e, n) {
    t(e, n);
    function a() {
      this.constructor = e;
    }
    e.prototype = n === null ? Object.create(n) : (a.prototype = n.prototype, new a());
  };
}();
Object.defineProperty(cs, "__esModule", { value: !0 });
cs.DetailContext = cs.NoopContext = cs.VError = void 0;
var lC = (
  /** @class */
  function(t) {
    Nq(e, t);
    function e(n, a) {
      var c = t.call(this, a) || this;
      return c.path = n, Object.setPrototypeOf(c, e.prototype), c;
    }
    return e;
  }(Error)
);
cs.VError = lC;
var Rq = (
  /** @class */
  function() {
    function t() {
    }
    return t.prototype.fail = function(e, n, a) {
      return !1;
    }, t.prototype.unionResolver = function() {
      return this;
    }, t.prototype.createContext = function() {
      return this;
    }, t.prototype.resolveUnion = function(e) {
    }, t;
  }()
);
cs.NoopContext = Rq;
var uC = (
  /** @class */
  function() {
    function t() {
      this._propNames = [""], this._messages = [null], this._score = 0;
    }
    return t.prototype.fail = function(e, n, a) {
      return this._propNames.push(e), this._messages.push(n), this._score += a, !1;
    }, t.prototype.unionResolver = function() {
      return new Mq();
    }, t.prototype.resolveUnion = function(e) {
      for (var n, a, c = e, u = null, r = 0, l = c.contexts; r < l.length; r++) {
        var i = l[r];
        (!u || i._score >= u._score) && (u = i);
      }
      u && u._score > 0 && ((n = this._propNames).push.apply(n, u._propNames), (a = this._messages).push.apply(a, u._messages));
    }, t.prototype.getError = function(e) {
      for (var n = [], a = this._propNames.length - 1; a >= 0; a--) {
        var c = this._propNames[a];
        e += typeof c == "number" ? "[" + c + "]" : c ? "." + c : "";
        var u = this._messages[a];
        u && n.push(e + " " + u);
      }
      return new lC(e, n.join("; "));
    }, t.prototype.getErrorDetail = function(e) {
      for (var n = [], a = this._propNames.length - 1; a >= 0; a--) {
        var c = this._propNames[a];
        e += typeof c == "number" ? "[" + c + "]" : c ? "." + c : "";
        var u = this._messages[a];
        u && n.push({ path: e, message: u });
      }
      for (var r = null, a = n.length - 1; a >= 0; a--)
        r && (n[a].nested = [r]), r = n[a];
      return r;
    }, t;
  }()
);
cs.DetailContext = uC;
var Mq = (
  /** @class */
  function() {
    function t() {
      this.contexts = [];
    }
    return t.prototype.createContext = function() {
      var e = new uC();
      return this.contexts.push(e), e;
    }, t;
  }()
);
(function(t) {
  var e = Bt && Bt.__extends || function() {
    var z = function(q, $) {
      return z = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Y, H) {
        Y.__proto__ = H;
      } || function(Y, H) {
        for (var Q in H)
          H.hasOwnProperty(Q) && (Y[Q] = H[Q]);
      }, z(q, $);
    };
    return function(q, $) {
      z(q, $);
      function Y() {
        this.constructor = q;
      }
      q.prototype = $ === null ? Object.create($) : (Y.prototype = $.prototype, new Y());
    };
  }();
  Object.defineProperty(t, "__esModule", { value: !0 }), t.basicTypes = t.BasicType = t.TParamList = t.TParam = t.param = t.TFunc = t.func = t.TProp = t.TOptional = t.opt = t.TIface = t.iface = t.TEnumLiteral = t.enumlit = t.TEnumType = t.enumtype = t.TIntersection = t.intersection = t.TUnion = t.union = t.TTuple = t.tuple = t.TArray = t.array = t.TLiteral = t.lit = t.TName = t.name = t.TType = void 0;
  var n = cs, a = (
    /** @class */
    function() {
      function z() {
      }
      return z;
    }()
  );
  t.TType = a;
  function c(z) {
    return typeof z == "string" ? r(z) : z;
  }
  function u(z, q) {
    var $ = z[q];
    if (!$)
      throw new Error("Unknown type " + q);
    return $;
  }
  function r(z) {
    return new l(z);
  }
  t.name = r;
  var l = (
    /** @class */
    function(z) {
      e(q, z);
      function q($) {
        var Y = z.call(this) || this;
        return Y.name = $, Y._failMsg = "is not a " + $, Y;
      }
      return q.prototype.getChecker = function($, Y, H) {
        var Q = this, X = u($, this.name), ne = X.getChecker($, Y, H);
        return X instanceof W || X instanceof q ? ne : function(ye, ve) {
          return ne(ye, ve) ? !0 : ve.fail(null, Q._failMsg, 0);
        };
      }, q;
    }(a)
  );
  t.TName = l;
  function i(z) {
    return new f(z);
  }
  t.lit = i;
  var f = (
    /** @class */
    function(z) {
      e(q, z);
      function q($) {
        var Y = z.call(this) || this;
        return Y.value = $, Y.name = JSON.stringify($), Y._failMsg = "is not " + Y.name, Y;
      }
      return q.prototype.getChecker = function($, Y) {
        var H = this;
        return function(Q, X) {
          return Q === H.value ? !0 : X.fail(null, H._failMsg, -1);
        };
      }, q;
    }(a)
  );
  t.TLiteral = f;
  function d(z) {
    return new s(c(z));
  }
  t.array = d;
  var s = (
    /** @class */
    function(z) {
      e(q, z);
      function q($) {
        var Y = z.call(this) || this;
        return Y.ttype = $, Y;
      }
      return q.prototype.getChecker = function($, Y) {
        var H = this.ttype.getChecker($, Y);
        return function(Q, X) {
          if (!Array.isArray(Q))
            return X.fail(null, "is not an array", 0);
          for (var ne = 0; ne < Q.length; ne++) {
            var ye = H(Q[ne], X);
            if (!ye)
              return X.fail(ne, null, 1);
          }
          return !0;
        };
      }, q;
    }(a)
  );
  t.TArray = s;
  function o() {
    for (var z = [], q = 0; q < arguments.length; q++)
      z[q] = arguments[q];
    return new m(z.map(function($) {
      return c($);
    }));
  }
  t.tuple = o;
  var m = (
    /** @class */
    function(z) {
      e(q, z);
      function q($) {
        var Y = z.call(this) || this;
        return Y.ttypes = $, Y;
      }
      return q.prototype.getChecker = function($, Y) {
        var H = this.ttypes.map(function(X) {
          return X.getChecker($, Y);
        }), Q = function(X, ne) {
          if (!Array.isArray(X))
            return ne.fail(null, "is not an array", 0);
          for (var ye = 0; ye < H.length; ye++) {
            var ve = H[ye](X[ye], ne);
            if (!ve)
              return ne.fail(ye, null, 1);
          }
          return !0;
        };
        return Y ? function(X, ne) {
          return Q(X, ne) ? X.length <= H.length ? !0 : ne.fail(H.length, "is extraneous", 2) : !1;
        } : Q;
      }, q;
    }(a)
  );
  t.TTuple = m;
  function h() {
    for (var z = [], q = 0; q < arguments.length; q++)
      z[q] = arguments[q];
    return new y(z.map(function($) {
      return c($);
    }));
  }
  t.union = h;
  var y = (
    /** @class */
    function(z) {
      e(q, z);
      function q($) {
        var Y = z.call(this) || this;
        Y.ttypes = $;
        var H = $.map(function(X) {
          return X instanceof l || X instanceof f ? X.name : null;
        }).filter(function(X) {
          return X;
        }), Q = $.length - H.length;
        return H.length ? (Q > 0 && H.push(Q + " more"), Y._failMsg = "is none of " + H.join(", ")) : Y._failMsg = "is none of " + Q + " types", Y;
      }
      return q.prototype.getChecker = function($, Y) {
        var H = this, Q = this.ttypes.map(function(X) {
          return X.getChecker($, Y);
        });
        return function(X, ne) {
          for (var ye = ne.unionResolver(), ve = 0; ve < Q.length; ve++) {
            var de = Q[ve](X, ye.createContext());
            if (de)
              return !0;
          }
          return ne.resolveUnion(ye), ne.fail(null, H._failMsg, 0);
        };
      }, q;
    }(a)
  );
  t.TUnion = y;
  function b() {
    for (var z = [], q = 0; q < arguments.length; q++)
      z[q] = arguments[q];
    return new E(z.map(function($) {
      return c($);
    }));
  }
  t.intersection = b;
  var E = (
    /** @class */
    function(z) {
      e(q, z);
      function q($) {
        var Y = z.call(this) || this;
        return Y.ttypes = $, Y;
      }
      return q.prototype.getChecker = function($, Y) {
        var H = /* @__PURE__ */ new Set(), Q = this.ttypes.map(function(X) {
          return X.getChecker($, Y, H);
        });
        return function(X, ne) {
          var ye = Q.every(function(ve) {
            return ve(X, ne);
          });
          return ye ? !0 : ne.fail(null, null, 0);
        };
      }, q;
    }(a)
  );
  t.TIntersection = E;
  function S(z) {
    return new g(z);
  }
  t.enumtype = S;
  var g = (
    /** @class */
    function(z) {
      e(q, z);
      function q($) {
        var Y = z.call(this) || this;
        return Y.members = $, Y.validValues = /* @__PURE__ */ new Set(), Y._failMsg = "is not a valid enum value", Y.validValues = new Set(Object.keys($).map(function(H) {
          return $[H];
        })), Y;
      }
      return q.prototype.getChecker = function($, Y) {
        var H = this;
        return function(Q, X) {
          return H.validValues.has(Q) ? !0 : X.fail(null, H._failMsg, 0);
        };
      }, q;
    }(a)
  );
  t.TEnumType = g;
  function P(z, q) {
    return new R(z, q);
  }
  t.enumlit = P;
  var R = (
    /** @class */
    function(z) {
      e(q, z);
      function q($, Y) {
        var H = z.call(this) || this;
        return H.enumName = $, H.prop = Y, H._failMsg = "is not " + $ + "." + Y, H;
      }
      return q.prototype.getChecker = function($, Y) {
        var H = this, Q = u($, this.enumName);
        if (!(Q instanceof g))
          throw new Error("Type " + this.enumName + " used in enumlit is not an enum type");
        var X = Q.members[this.prop];
        if (!Q.members.hasOwnProperty(this.prop))
          throw new Error("Unknown value " + this.enumName + "." + this.prop + " used in enumlit");
        return function(ne, ye) {
          return ne === X ? !0 : ye.fail(null, H._failMsg, -1);
        };
      }, q;
    }(a)
  );
  t.TEnumLiteral = R;
  function N(z) {
    return Object.keys(z).map(function(q) {
      return C(q, z[q]);
    });
  }
  function C(z, q) {
    return q instanceof F ? new _(z, q.ttype, !0) : new _(z, c(q), !1);
  }
  function I(z, q) {
    return new D(z, N(q));
  }
  t.iface = I;
  var D = (
    /** @class */
    function(z) {
      e(q, z);
      function q($, Y) {
        var H = z.call(this) || this;
        return H.bases = $, H.props = Y, H.propSet = new Set(Y.map(function(Q) {
          return Q.name;
        })), H;
      }
      return q.prototype.getChecker = function($, Y, H) {
        var Q = this, X = this.bases.map(function(re) {
          return u($, re).getChecker($, Y);
        }), ne = this.props.map(function(re) {
          return re.ttype.getChecker($, Y);
        }), ye = new n.NoopContext(), ve = this.props.map(function(re, ae) {
          return !re.isOpt && !ne[ae](void 0, ye);
        }), de = function(re, ae) {
          if (typeof re != "object" || re === null)
            return ae.fail(null, "is not an object", 0);
          for (var le = 0; le < X.length; le++)
            if (!X[le](re, ae))
              return !1;
          for (var le = 0; le < ne.length; le++) {
            var ue = Q.props[le].name, ie = re[ue];
            if (ie === void 0) {
              if (ve[le])
                return ae.fail(ue, "is missing", 1);
            } else {
              var we = ne[le](ie, ae);
              if (!we)
                return ae.fail(ue, null, 1);
            }
          }
          return !0;
        };
        if (!Y)
          return de;
        var oe = this.propSet;
        return H && (this.propSet.forEach(function(re) {
          return H.add(re);
        }), oe = H), function(re, ae) {
          if (!de(re, ae))
            return !1;
          for (var le in re)
            if (!oe.has(le))
              return ae.fail(le, "is extraneous", 2);
          return !0;
        };
      }, q;
    }(a)
  );
  t.TIface = D;
  function j(z) {
    return new F(c(z));
  }
  t.opt = j;
  var F = (
    /** @class */
    function(z) {
      e(q, z);
      function q($) {
        var Y = z.call(this) || this;
        return Y.ttype = $, Y;
      }
      return q.prototype.getChecker = function($, Y) {
        var H = this.ttype.getChecker($, Y);
        return function(Q, X) {
          return Q === void 0 || H(Q, X);
        };
      }, q;
    }(a)
  );
  t.TOptional = F;
  var _ = (
    /** @class */
    function() {
      function z(q, $, Y) {
        this.name = q, this.ttype = $, this.isOpt = Y;
      }
      return z;
    }()
  );
  t.TProp = _;
  function T(z) {
    for (var q = [], $ = 1; $ < arguments.length; $++)
      q[$ - 1] = arguments[$];
    return new v(new G(q), c(z));
  }
  t.func = T;
  var v = (
    /** @class */
    function(z) {
      e(q, z);
      function q($, Y) {
        var H = z.call(this) || this;
        return H.paramList = $, H.result = Y, H;
      }
      return q.prototype.getChecker = function($, Y) {
        return function(H, Q) {
          return typeof H == "function" ? !0 : Q.fail(null, "is not a function", 0);
        };
      }, q;
    }(a)
  );
  t.TFunc = v;
  function w(z, q, $) {
    return new O(z, c(q), !!$);
  }
  t.param = w;
  var O = (
    /** @class */
    function() {
      function z(q, $, Y) {
        this.name = q, this.ttype = $, this.isOpt = Y;
      }
      return z;
    }()
  );
  t.TParam = O;
  var G = (
    /** @class */
    function(z) {
      e(q, z);
      function q($) {
        var Y = z.call(this) || this;
        return Y.params = $, Y;
      }
      return q.prototype.getChecker = function($, Y) {
        var H = this, Q = this.params.map(function(ve) {
          return ve.ttype.getChecker($, Y);
        }), X = new n.NoopContext(), ne = this.params.map(function(ve, de) {
          return !ve.isOpt && !Q[de](void 0, X);
        }), ye = function(ve, de) {
          if (!Array.isArray(ve))
            return de.fail(null, "is not an array", 0);
          for (var oe = 0; oe < Q.length; oe++) {
            var re = H.params[oe];
            if (ve[oe] === void 0) {
              if (ne[oe])
                return de.fail(re.name, "is missing", 1);
            } else {
              var ae = Q[oe](ve[oe], de);
              if (!ae)
                return de.fail(re.name, null, 1);
            }
          }
          return !0;
        };
        return Y ? function(ve, de) {
          return ye(ve, de) ? ve.length <= Q.length ? !0 : de.fail(Q.length, "is extraneous", 2) : !1;
        } : ye;
      }, q;
    }(a)
  );
  t.TParamList = G;
  var W = (
    /** @class */
    function(z) {
      e(q, z);
      function q($, Y) {
        var H = z.call(this) || this;
        return H.validator = $, H.message = Y, H;
      }
      return q.prototype.getChecker = function($, Y) {
        var H = this;
        return function(Q, X) {
          return H.validator(Q) ? !0 : X.fail(null, H.message, 0);
        };
      }, q;
    }(a)
  );
  t.BasicType = W, t.basicTypes = {
    any: new W(function(z) {
      return !0;
    }, "is invalid"),
    number: new W(function(z) {
      return typeof z == "number";
    }, "is not a number"),
    object: new W(function(z) {
      return typeof z == "object" && z;
    }, "is not an object"),
    boolean: new W(function(z) {
      return typeof z == "boolean";
    }, "is not a boolean"),
    string: new W(function(z) {
      return typeof z == "string";
    }, "is not a string"),
    symbol: new W(function(z) {
      return typeof z == "symbol";
    }, "is not a symbol"),
    void: new W(function(z) {
      return z == null;
    }, "is not void"),
    undefined: new W(function(z) {
      return z === void 0;
    }, "is not undefined"),
    null: new W(function(z) {
      return z === null;
    }, "is not null"),
    never: new W(function(z) {
      return !1;
    }, "is unexpected"),
    Date: new W(M("[object Date]"), "is not a Date"),
    RegExp: new W(M("[object RegExp]"), "is not a RegExp")
  };
  var U = Object.prototype.toString;
  function M(z) {
    return function(q) {
      return typeof q == "object" && q && U.call(q) === z;
    };
  }
  typeof Ve.Buffer < "u" && (t.basicTypes.Buffer = new W(function(z) {
    return Ve.Buffer.isBuffer(z);
  }, "is not a Buffer"));
  for (var B = function(z) {
    t.basicTypes[z.name] = new W(function(q) {
      return q instanceof z;
    }, "is not a " + z.name);
  }, k = 0, K = [
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array,
    ArrayBuffer
  ]; k < K.length; k++) {
    var te = K[k];
    B(te);
  }
})(y0);
(function(t) {
  var e = Bt && Bt.__spreadArrays || function() {
    for (var i = 0, f = 0, d = arguments.length; f < d; f++)
      i += arguments[f].length;
    for (var s = Array(i), o = 0, f = 0; f < d; f++)
      for (var m = arguments[f], h = 0, y = m.length; h < y; h++, o++)
        s[o] = m[h];
    return s;
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.Checker = t.createCheckers = void 0;
  var n = y0, a = cs, c = y0;
  Object.defineProperty(t, "TArray", { enumerable: !0, get: function() {
    return c.TArray;
  } }), Object.defineProperty(t, "TEnumType", { enumerable: !0, get: function() {
    return c.TEnumType;
  } }), Object.defineProperty(t, "TEnumLiteral", { enumerable: !0, get: function() {
    return c.TEnumLiteral;
  } }), Object.defineProperty(t, "TFunc", { enumerable: !0, get: function() {
    return c.TFunc;
  } }), Object.defineProperty(t, "TIface", { enumerable: !0, get: function() {
    return c.TIface;
  } }), Object.defineProperty(t, "TLiteral", { enumerable: !0, get: function() {
    return c.TLiteral;
  } }), Object.defineProperty(t, "TName", { enumerable: !0, get: function() {
    return c.TName;
  } }), Object.defineProperty(t, "TOptional", { enumerable: !0, get: function() {
    return c.TOptional;
  } }), Object.defineProperty(t, "TParam", { enumerable: !0, get: function() {
    return c.TParam;
  } }), Object.defineProperty(t, "TParamList", { enumerable: !0, get: function() {
    return c.TParamList;
  } }), Object.defineProperty(t, "TProp", { enumerable: !0, get: function() {
    return c.TProp;
  } }), Object.defineProperty(t, "TTuple", { enumerable: !0, get: function() {
    return c.TTuple;
  } }), Object.defineProperty(t, "TType", { enumerable: !0, get: function() {
    return c.TType;
  } }), Object.defineProperty(t, "TUnion", { enumerable: !0, get: function() {
    return c.TUnion;
  } }), Object.defineProperty(t, "TIntersection", { enumerable: !0, get: function() {
    return c.TIntersection;
  } }), Object.defineProperty(t, "array", { enumerable: !0, get: function() {
    return c.array;
  } }), Object.defineProperty(t, "enumlit", { enumerable: !0, get: function() {
    return c.enumlit;
  } }), Object.defineProperty(t, "enumtype", { enumerable: !0, get: function() {
    return c.enumtype;
  } }), Object.defineProperty(t, "func", { enumerable: !0, get: function() {
    return c.func;
  } }), Object.defineProperty(t, "iface", { enumerable: !0, get: function() {
    return c.iface;
  } }), Object.defineProperty(t, "lit", { enumerable: !0, get: function() {
    return c.lit;
  } }), Object.defineProperty(t, "name", { enumerable: !0, get: function() {
    return c.name;
  } }), Object.defineProperty(t, "opt", { enumerable: !0, get: function() {
    return c.opt;
  } }), Object.defineProperty(t, "param", { enumerable: !0, get: function() {
    return c.param;
  } }), Object.defineProperty(t, "tuple", { enumerable: !0, get: function() {
    return c.tuple;
  } }), Object.defineProperty(t, "union", { enumerable: !0, get: function() {
    return c.union;
  } }), Object.defineProperty(t, "intersection", { enumerable: !0, get: function() {
    return c.intersection;
  } }), Object.defineProperty(t, "BasicType", { enumerable: !0, get: function() {
    return c.BasicType;
  } });
  var u = cs;
  Object.defineProperty(t, "VError", { enumerable: !0, get: function() {
    return u.VError;
  } });
  function r() {
    for (var i = [], f = 0; f < arguments.length; f++)
      i[f] = arguments[f];
    for (var d = Object.assign.apply(Object, e([{}, n.basicTypes], i)), s = {}, o = 0, m = i; o < m.length; o++)
      for (var h = m[o], y = 0, b = Object.keys(h); y < b.length; y++) {
        var E = b[y];
        s[E] = new l(d, h[E]);
      }
    return s;
  }
  t.createCheckers = r;
  var l = (
    /** @class */
    function() {
      function i(f, d, s) {
        if (s === void 0 && (s = "value"), this.suite = f, this.ttype = d, this._path = s, this.props = /* @__PURE__ */ new Map(), d instanceof n.TIface)
          for (var o = 0, m = d.props; o < m.length; o++) {
            var h = m[o];
            this.props.set(h.name, h.ttype);
          }
        this.checkerPlain = this.ttype.getChecker(f, !1), this.checkerStrict = this.ttype.getChecker(f, !0);
      }
      return i.prototype.setReportedPath = function(f) {
        this._path = f;
      }, i.prototype.check = function(f) {
        return this._doCheck(this.checkerPlain, f);
      }, i.prototype.test = function(f) {
        return this.checkerPlain(f, new a.NoopContext());
      }, i.prototype.validate = function(f) {
        return this._doValidate(this.checkerPlain, f);
      }, i.prototype.strictCheck = function(f) {
        return this._doCheck(this.checkerStrict, f);
      }, i.prototype.strictTest = function(f) {
        return this.checkerStrict(f, new a.NoopContext());
      }, i.prototype.strictValidate = function(f) {
        return this._doValidate(this.checkerStrict, f);
      }, i.prototype.getProp = function(f) {
        var d = this.props.get(f);
        if (!d)
          throw new Error("Type has no property " + f);
        return new i(this.suite, d, this._path + "." + f);
      }, i.prototype.methodArgs = function(f) {
        var d = this._getMethod(f);
        return new i(this.suite, d.paramList);
      }, i.prototype.methodResult = function(f) {
        var d = this._getMethod(f);
        return new i(this.suite, d.result);
      }, i.prototype.getArgs = function() {
        if (!(this.ttype instanceof n.TFunc))
          throw new Error("getArgs() applied to non-function");
        return new i(this.suite, this.ttype.paramList);
      }, i.prototype.getResult = function() {
        if (!(this.ttype instanceof n.TFunc))
          throw new Error("getResult() applied to non-function");
        return new i(this.suite, this.ttype.result);
      }, i.prototype.getType = function() {
        return this.ttype;
      }, i.prototype._doCheck = function(f, d) {
        var s = new a.NoopContext();
        if (!f(d, s)) {
          var o = new a.DetailContext();
          throw f(d, o), o.getError(this._path);
        }
      }, i.prototype._doValidate = function(f, d) {
        var s = new a.NoopContext();
        if (f(d, s))
          return null;
        var o = new a.DetailContext();
        return f(d, o), o.getErrorDetail(this._path);
      }, i.prototype._getMethod = function(f) {
        var d = this.props.get(f);
        if (!d)
          throw new Error("Type has no property " + f);
        if (!(d instanceof n.TFunc))
          throw new Error("Property " + f + " is not a method");
        return d;
      }, i;
    }()
  );
  t.Checker = l;
})(yr);
const Lq = yr.union(
  yr.lit("jsx"),
  yr.lit("typescript"),
  yr.lit("flow"),
  yr.lit("imports"),
  yr.lit("react-hot-loader"),
  yr.lit("jest")
), jq = yr.iface([], {
  compiledFilename: "string"
}), Fq = yr.iface([], {
  transforms: yr.array("Transform"),
  disableESTransforms: yr.opt("boolean"),
  jsxRuntime: yr.opt(yr.union(yr.lit("classic"), yr.lit("automatic"), yr.lit("preserve"))),
  production: yr.opt("boolean"),
  jsxImportSource: yr.opt("string"),
  jsxPragma: yr.opt("string"),
  jsxFragmentPragma: yr.opt("string"),
  keepUnusedImports: yr.opt("boolean"),
  preserveDynamicImport: yr.opt("boolean"),
  injectCreateRequireForImportRequire: yr.opt("boolean"),
  enableLegacyTypeScriptModuleInterop: yr.opt("boolean"),
  enableLegacyBabel5ModuleInterop: yr.opt("boolean"),
  sourceMapOptions: yr.opt("SourceMapOptions"),
  filePath: yr.opt("string")
}), Bq = {
  Transform: Lq,
  SourceMapOptions: jq,
  Options: Fq
}, { Options: $q } = yr.createCheckers(Bq);
function Uq(t) {
  $q.strictCheck(t);
}
function cC() {
  pt(), dn(!1);
}
function fC(t) {
  pt(), Tp(t);
}
function ba(t) {
  $t(), $b(t);
}
function zf() {
  $t(), ce.tokens[ce.tokens.length - 1].identifierRole = jt.ImportDeclaration;
}
function $b(t) {
  let e;
  ce.scopeDepth === 0 ? e = jt.TopLevelDeclaration : t ? e = jt.BlockScopedDeclaration : e = jt.FunctionScopedDeclaration, ce.tokens[ce.tokens.length - 1].identifierRole = e;
}
function Tp(t) {
  switch (ce.type) {
    case L._this: {
      const e = Kt(0);
      pt(), zt(e);
      return;
    }
    case L._yield:
    case L.name: {
      ce.type = L.name, ba(t);
      return;
    }
    case L.bracketL: {
      pt(), Ub(
        L.bracketR,
        t,
        !0
        /* allowEmpty */
      );
      return;
    }
    case L.braceL:
      Qb(!0, t);
      return;
    default:
      Gt();
  }
}
function Ub(t, e, n = !1, a = !1, c = 0) {
  let u = !0, r = !1;
  const l = ce.tokens.length;
  for (; !it(t) && !ce.error; )
    if (u ? u = !1 : (dt(L.comma), ce.tokens[ce.tokens.length - 1].contextId = c, !r && ce.tokens[l].isType && (ce.tokens[ce.tokens.length - 1].isType = !0, r = !0)), !(n && ke(L.comma))) {
      if (it(t))
        break;
      if (ke(L.ellipsis)) {
        fC(e), dC(), it(L.comma), dt(t);
        break;
      } else
        Vq(a, e);
    }
}
function Vq(t, e) {
  t && Vb([
    Fe._public,
    Fe._protected,
    Fe._private,
    Fe._readonly,
    Fe._override
  ]), Kf(e), dC(), Kf(
    e,
    !0
    /* leftAlreadyParsed */
  );
}
function dC() {
  or ? aK() : rr && XG();
}
function Kf(t, e = !1) {
  if (e || Tp(t), !it(L.eq))
    return;
  const n = ce.tokens.length - 1;
  dn(), ce.tokens[n].rhsEndIndex = ce.tokens.length;
}
function b0() {
  return ke(L.name);
}
function Wq() {
  return ke(L.name) || !!(ce.type & L.IS_KEYWORD) || ke(L.string) || ke(L.num) || ke(L.bigint) || ke(L.decimal);
}
function pC() {
  const t = ce.snapshot();
  return pt(), (ke(L.bracketL) || ke(L.braceL) || ke(L.star) || ke(L.ellipsis) || ke(L.hash) || Wq()) && !Rn() ? !0 : (ce.restoreFromSnapshot(t), !1);
}
function Vb(t) {
  for (; hC(t) !== null; )
    ;
}
function hC(t) {
  if (!ke(L.name))
    return null;
  const e = ce.contextualKeyword;
  if (t.indexOf(e) !== -1 && pC()) {
    switch (e) {
      case Fe._readonly:
        ce.tokens[ce.tokens.length - 1].type = L._readonly;
        break;
      case Fe._abstract:
        ce.tokens[ce.tokens.length - 1].type = L._abstract;
        break;
      case Fe._static:
        ce.tokens[ce.tokens.length - 1].type = L._static;
        break;
      case Fe._public:
        ce.tokens[ce.tokens.length - 1].type = L._public;
        break;
      case Fe._private:
        ce.tokens[ce.tokens.length - 1].type = L._private;
        break;
      case Fe._protected:
        ce.tokens[ce.tokens.length - 1].type = L._protected;
        break;
      case Fe._override:
        ce.tokens[ce.tokens.length - 1].type = L._override;
        break;
      case Fe._declare:
        ce.tokens[ce.tokens.length - 1].type = L._declare;
        break;
    }
    return e;
  }
  return null;
}
function tc() {
  for ($t(); it(L.dot); )
    $t();
}
function Hq() {
  tc(), !Rn() && ke(L.lessThan) && pl();
}
function qq() {
  pt(), rc();
}
function Gq() {
  pt();
}
function zq() {
  dt(L._typeof), ke(L._import) ? mC() : tc(), !Rn() && ke(L.lessThan) && pl();
}
function mC() {
  dt(L._import), dt(L.parenL), dt(L.string), dt(L.parenR), it(L.dot) && tc(), ke(L.lessThan) && pl();
}
function Kq() {
  it(L._const);
  const t = it(L._in), e = Jr(Fe._out);
  it(L._const), (t || e) && !ke(L.name) ? ce.tokens[ce.tokens.length - 1].type = L.name : $t(), it(L._extends) && Dr(), it(L.eq) && Dr();
}
function to() {
  ke(L.lessThan) && Ap();
}
function Ap() {
  const t = Kt(0);
  for (ke(L.lessThan) || ke(L.typeParameterStart) ? pt() : Gt(); !it(L.greaterThan) && !ce.error; )
    Kq(), it(L.comma);
  zt(t);
}
function Wb(t) {
  const e = t === L.arrow;
  to(), dt(L.parenL), ce.scopeDepth++, Yq(
    !1
    /* isBlockScope */
  ), ce.scopeDepth--, (e || ke(t)) && mu(t);
}
function Yq(t) {
  Ub(L.parenR, t);
}
function Yf() {
  it(L.comma) || Tr();
}
function fS() {
  Wb(L.colon), Yf();
}
function Xq() {
  const t = ce.snapshot();
  pt();
  const e = it(L.name) && ke(L.colon);
  return ce.restoreFromSnapshot(t), e;
}
function yC() {
  if (!(ke(L.bracketL) && Xq()))
    return !1;
  const t = Kt(0);
  return dt(L.bracketL), $t(), rc(), dt(L.bracketR), dl(), Yf(), zt(t), !0;
}
function dS(t) {
  it(L.question), !t && (ke(L.parenL) || ke(L.lessThan)) ? (Wb(L.colon), Yf()) : (dl(), Yf());
}
function Jq() {
  if (ke(L.parenL) || ke(L.lessThan)) {
    fS();
    return;
  }
  if (ke(L._new)) {
    pt(), ke(L.parenL) || ke(L.lessThan) ? fS() : dS(!1);
    return;
  }
  const t = !!hC([Fe._readonly]);
  yC() || ((Dt(Fe._get) || Dt(Fe._set)) && pC(), yu(
    -1
    /* Types don't need context IDs. */
  ), dS(t));
}
function Qq() {
  bC();
}
function bC() {
  for (dt(L.braceL); !it(L.braceR) && !ce.error; )
    Jq();
}
function Zq() {
  const t = ce.snapshot(), e = eG();
  return ce.restoreFromSnapshot(t), e;
}
function eG() {
  return pt(), it(L.plus) || it(L.minus) ? Dt(Fe._readonly) : (Dt(Fe._readonly) && pt(), !ke(L.bracketL) || (pt(), !b0()) ? !1 : (pt(), ke(L._in)));
}
function tG() {
  $t(), dt(L._in), Dr();
}
function rG() {
  dt(L.braceL), ke(L.plus) || ke(L.minus) ? (pt(), Br(Fe._readonly)) : Jr(Fe._readonly), dt(L.bracketL), tG(), Jr(Fe._as) && Dr(), dt(L.bracketR), ke(L.plus) || ke(L.minus) ? (pt(), dt(L.question)) : it(L.question), yG(), Tr(), dt(L.braceR);
}
function nG() {
  for (dt(L.bracketL); !it(L.bracketR) && !ce.error; )
    iG(), it(L.comma);
}
function iG() {
  it(L.ellipsis) ? Dr() : (Dr(), it(L.question)), it(L.colon) && Dr();
}
function sG() {
  dt(L.parenL), Dr(), dt(L.parenR);
}
function aG() {
  for (ea(), ea(); !ke(L.backQuote) && !ce.error; )
    dt(L.dollarBraceL), Dr(), ea(), ea();
  pt();
}
var ia;
(function(t) {
  t[t.TSFunctionType = 0] = "TSFunctionType";
  const n = 0 + 1;
  t[t.TSConstructorType = n] = "TSConstructorType";
  const a = n + 1;
  t[t.TSAbstractConstructorType = a] = "TSAbstractConstructorType";
})(ia || (ia = {}));
function Am(t) {
  t === ia.TSAbstractConstructorType && Br(Fe._abstract), (t === ia.TSConstructorType || t === ia.TSAbstractConstructorType) && dt(L._new);
  const e = ce.inDisallowConditionalTypesContext;
  ce.inDisallowConditionalTypesContext = !1, Wb(L.arrow), ce.inDisallowConditionalTypesContext = e;
}
function oG() {
  switch (ce.type) {
    case L.name:
      Hq();
      return;
    case L._void:
    case L._null:
      pt();
      return;
    case L.string:
    case L.num:
    case L.bigint:
    case L.decimal:
    case L._true:
    case L._false:
      Xo();
      return;
    case L.minus:
      pt(), Xo();
      return;
    case L._this: {
      Gq(), Dt(Fe._is) && !Rn() && qq();
      return;
    }
    case L._typeof:
      zq();
      return;
    case L._import:
      mC();
      return;
    case L.braceL:
      Zq() ? rG() : Qq();
      return;
    case L.bracketL:
      nG();
      return;
    case L.parenL:
      sG();
      return;
    case L.backQuote:
      aG();
      return;
    default:
      if (ce.type & L.IS_KEYWORD) {
        pt(), ce.tokens[ce.tokens.length - 1].type = L.name;
        return;
      }
      break;
  }
  Gt();
}
function lG() {
  for (oG(); !Rn() && it(L.bracketL); )
    it(L.bracketR) || (Dr(), dt(L.bracketR));
}
function uG() {
  if (Br(Fe._infer), $t(), ke(L._extends)) {
    const t = ce.snapshot();
    dt(L._extends);
    const e = ce.inDisallowConditionalTypesContext;
    ce.inDisallowConditionalTypesContext = !0, Dr(), ce.inDisallowConditionalTypesContext = e, (ce.error || !ce.inDisallowConditionalTypesContext && ke(L.question)) && ce.restoreFromSnapshot(t);
  }
}
function g0() {
  if (Dt(Fe._keyof) || Dt(Fe._unique) || Dt(Fe._readonly))
    pt(), g0();
  else if (Dt(Fe._infer))
    uG();
  else {
    const t = ce.inDisallowConditionalTypesContext;
    ce.inDisallowConditionalTypesContext = !1, lG(), ce.inDisallowConditionalTypesContext = t;
  }
}
function pS() {
  if (it(L.bitwiseAND), g0(), ke(L.bitwiseAND))
    for (; it(L.bitwiseAND); )
      g0();
}
function cG() {
  if (it(L.bitwiseOR), pS(), ke(L.bitwiseOR))
    for (; it(L.bitwiseOR); )
      pS();
}
function fG() {
  return ke(L.lessThan) ? !0 : ke(L.parenL) && pG();
}
function dG() {
  if (ke(L.name) || ke(L._this))
    return pt(), !0;
  if (ke(L.braceL) || ke(L.bracketL)) {
    let t = 1;
    for (pt(); t > 0 && !ce.error; )
      ke(L.braceL) || ke(L.bracketL) ? t++ : (ke(L.braceR) || ke(L.bracketR)) && t--, pt();
    return !0;
  }
  return !1;
}
function pG() {
  const t = ce.snapshot(), e = hG();
  return ce.restoreFromSnapshot(t), e;
}
function hG() {
  return pt(), !!(ke(L.parenR) || ke(L.ellipsis) || dG() && (ke(L.colon) || ke(L.comma) || ke(L.question) || ke(L.eq) || ke(L.parenR) && (pt(), ke(L.arrow))));
}
function mu(t) {
  const e = Kt(0);
  dt(t), bG() || Dr(), zt(e);
}
function mG() {
  ke(L.colon) && mu(L.colon);
}
function dl() {
  ke(L.colon) && rc();
}
function yG() {
  it(L.colon) && Dr();
}
function bG() {
  const t = ce.snapshot();
  return Dt(Fe._asserts) ? (pt(), Jr(Fe._is) ? (Dr(), !0) : b0() || ke(L._this) ? (pt(), Jr(Fe._is) && Dr(), !0) : (ce.restoreFromSnapshot(t), !1)) : b0() || ke(L._this) ? (pt(), Dt(Fe._is) && !Rn() ? (pt(), Dr(), !0) : (ce.restoreFromSnapshot(t), !1)) : !1;
}
function rc() {
  const t = Kt(0);
  dt(L.colon), Dr(), zt(t);
}
function Dr() {
  if (hS(), ce.inDisallowConditionalTypesContext || Rn() || !it(L._extends))
    return;
  const t = ce.inDisallowConditionalTypesContext;
  ce.inDisallowConditionalTypesContext = !0, hS(), ce.inDisallowConditionalTypesContext = t, dt(L.question), Dr(), dt(L.colon), Dr();
}
function gG() {
  return Dt(Fe._abstract) && kr() === L._new;
}
function hS() {
  if (fG()) {
    Am(ia.TSFunctionType);
    return;
  }
  if (ke(L._new)) {
    Am(ia.TSConstructorType);
    return;
  } else if (gG()) {
    Am(ia.TSAbstractConstructorType);
    return;
  }
  cG();
}
function vG() {
  const t = Kt(1);
  Dr(), dt(L.greaterThan), zt(t), nc();
}
function EG() {
  if (it(L.jsxTagStart)) {
    ce.tokens[ce.tokens.length - 1].type = L.typeParameterStart;
    const t = Kt(1);
    for (; !ke(L.greaterThan) && !ce.error; )
      Dr(), it(L.comma);
    hi(), zt(t);
  }
}
function gC() {
  for (; !ke(L.braceL) && !ce.error; )
    _G(), it(L.comma);
}
function _G() {
  tc(), ke(L.lessThan) && pl();
}
function SG() {
  ba(!1), to(), it(L._extends) && gC(), bC();
}
function wG() {
  ba(!1), to(), dt(L.eq), Dr(), Tr();
}
function TG() {
  if (ke(L.string) ? Xo() : $t(), it(L.eq)) {
    const t = ce.tokens.length - 1;
    dn(), ce.tokens[t].rhsEndIndex = ce.tokens.length;
  }
}
function Hb() {
  for (ba(!1), dt(L.braceL); !it(L.braceR) && !ce.error; )
    TG(), it(L.comma);
}
function qb() {
  dt(L.braceL), Ip(
    /* end */
    L.braceR
  );
}
function v0() {
  ba(!1), it(L.dot) ? v0() : qb();
}
function vC() {
  Dt(Fe._global) ? $t() : ke(L.string) ? Us() : Gt(), ke(L.braceL) ? qb() : Tr();
}
function E0() {
  zf(), dt(L.eq), xG(), Tr();
}
function AG() {
  return Dt(Fe._require) && kr() === L.parenL;
}
function xG() {
  AG() ? PG() : tc();
}
function PG() {
  Br(Fe._require), dt(L.parenL), ke(L.string) || Gt(), Xo(), dt(L.parenR);
}
function CG() {
  if (ss())
    return !1;
  switch (ce.type) {
    case L._function: {
      const t = Kt(1);
      pt();
      const e = ce.start;
      return Ga(
        e,
        /* isStatement */
        !0
      ), zt(t), !0;
    }
    case L._class: {
      const t = Kt(1);
      return za(
        /* isStatement */
        !0,
        /* optionalId */
        !1
      ), zt(t), !0;
    }
    case L._const:
      if (ke(L._const) && jb(Fe._enum)) {
        const t = Kt(1);
        return dt(L._const), Br(Fe._enum), ce.tokens[ce.tokens.length - 1].type = L._enum, Hb(), zt(t), !0;
      }
    case L._var:
    case L._let: {
      const t = Kt(1);
      return gf(ce.type !== L._var), zt(t), !0;
    }
    case L.name: {
      const t = Kt(1), e = ce.contextualKeyword;
      let n = !1;
      return e === Fe._global ? (vC(), n = !0) : n = xp(
        e,
        /* isBeforeToken */
        !0
      ), zt(t), n;
    }
    default:
      return !1;
  }
}
function mS() {
  return xp(
    ce.contextualKeyword,
    /* isBeforeToken */
    !0
  );
}
function IG(t) {
  switch (t) {
    case Fe._declare: {
      const e = ce.tokens.length - 1;
      if (CG())
        return ce.tokens[e].type = L._declare, !0;
      break;
    }
    case Fe._global:
      if (ke(L.braceL))
        return qb(), !0;
      break;
    default:
      return xp(
        t,
        /* isBeforeToken */
        !1
      );
  }
  return !1;
}
function xp(t, e) {
  switch (t) {
    case Fe._abstract:
      if (yo(e) && ke(L._class))
        return ce.tokens[ce.tokens.length - 1].type = L._abstract, za(
          /* isStatement */
          !0,
          /* optionalId */
          !1
        ), !0;
      break;
    case Fe._enum:
      if (yo(e) && ke(L.name))
        return ce.tokens[ce.tokens.length - 1].type = L._enum, Hb(), !0;
      break;
    case Fe._interface:
      if (yo(e) && ke(L.name)) {
        const n = Kt(e ? 2 : 1);
        return SG(), zt(n), !0;
      }
      break;
    case Fe._module:
      if (yo(e)) {
        if (ke(L.string)) {
          const n = Kt(e ? 2 : 1);
          return vC(), zt(n), !0;
        } else if (ke(L.name)) {
          const n = Kt(e ? 2 : 1);
          return v0(), zt(n), !0;
        }
      }
      break;
    case Fe._namespace:
      if (yo(e) && ke(L.name)) {
        const n = Kt(e ? 2 : 1);
        return v0(), zt(n), !0;
      }
      break;
    case Fe._type:
      if (yo(e) && ke(L.name)) {
        const n = Kt(e ? 2 : 1);
        return wG(), zt(n), !0;
      }
      break;
  }
  return !1;
}
function yo(t) {
  return t ? (pt(), !0) : !ss();
}
function OG() {
  const t = ce.snapshot();
  return Ap(), hl(), mG(), dt(L.arrow), ce.error ? (ce.restoreFromSnapshot(t), !1) : (ic(!0), !0);
}
function Gb() {
  ce.type === L.bitShiftL && (ce.pos -= 1, qt(L.lessThan)), pl();
}
function pl() {
  const t = Kt(0);
  for (dt(L.lessThan); !ke(L.greaterThan) && !ce.error; )
    Dr(), it(L.comma);
  t ? (dt(L.greaterThan), zt(t)) : (zt(t), eC(), dt(L.greaterThan), ce.tokens[ce.tokens.length - 1].isType = !0);
}
function EC() {
  if (ke(L.name))
    switch (ce.contextualKeyword) {
      case Fe._abstract:
      case Fe._declare:
      case Fe._enum:
      case Fe._interface:
      case Fe._module:
      case Fe._namespace:
      case Fe._type:
        return !0;
    }
  return !1;
}
function kG(t, e) {
  if (ke(L.colon) && mu(L.colon), !ke(L.braceL) && ss()) {
    let n = ce.tokens.length - 1;
    for (; n >= 0 && (ce.tokens[n].start >= t || ce.tokens[n].type === L._default || ce.tokens[n].type === L._export); )
      ce.tokens[n].isType = !0, n--;
    return;
  }
  ic(!1, e);
}
function DG(t, e, n) {
  if (!Rn() && it(L.bang)) {
    ce.tokens[ce.tokens.length - 1].type = L.nonNullAssertion;
    return;
  }
  if (ke(L.lessThan) || ke(L.bitShiftL)) {
    const a = ce.snapshot();
    if (!e && CC() && OG())
      return;
    if (Gb(), !e && it(L.parenL) ? (ce.tokens[ce.tokens.length - 1].subscriptStartIndex = t, sa()) : ke(L.backQuote) ? Jb() : (
      // The remaining possible case is an instantiation expression, e.g.
      // Array<number> . Check for a few cases that would disqualify it and
      // cause us to bail out.
      // a<b>>c is not (a<b>)>c, but a<(b>>c)
      (ce.type === L.greaterThan || // a<b>c is (a<b)>c
      ce.type !== L.parenL && ce.type & L.IS_EXPRESSION_START && !Rn()) && Gt()
    ), ce.error)
      ce.restoreFromSnapshot(a);
    else
      return;
  } else
    !e && ke(L.questionDot) && kr() === L.lessThan && (pt(), ce.tokens[t].isOptionalChainStart = !0, ce.tokens[ce.tokens.length - 1].subscriptStartIndex = t, pl(), dt(L.parenL), sa());
  Kb(t, e, n);
}
function NG() {
  if (it(L._import))
    return Dt(Fe._type) && kr() !== L.eq && Br(Fe._type), E0(), !0;
  if (it(L.eq))
    return fn(), Tr(), !0;
  if (Jr(Fe._as))
    return Br(Fe._namespace), $t(), Tr(), !0;
  if (Dt(Fe._type)) {
    const t = kr();
    (t === L.braceL || t === L.star) && pt();
  }
  return !1;
}
function RG() {
  if ($t(), ke(L.comma) || ke(L.braceR)) {
    ce.tokens[ce.tokens.length - 1].identifierRole = jt.ImportDeclaration;
    return;
  }
  if ($t(), ke(L.comma) || ke(L.braceR)) {
    ce.tokens[ce.tokens.length - 1].identifierRole = jt.ImportDeclaration, ce.tokens[ce.tokens.length - 2].isType = !0, ce.tokens[ce.tokens.length - 1].isType = !0;
    return;
  }
  if ($t(), ke(L.comma) || ke(L.braceR)) {
    ce.tokens[ce.tokens.length - 3].identifierRole = jt.ImportAccess, ce.tokens[ce.tokens.length - 1].identifierRole = jt.ImportDeclaration;
    return;
  }
  $t(), ce.tokens[ce.tokens.length - 3].identifierRole = jt.ImportAccess, ce.tokens[ce.tokens.length - 1].identifierRole = jt.ImportDeclaration, ce.tokens[ce.tokens.length - 4].isType = !0, ce.tokens[ce.tokens.length - 3].isType = !0, ce.tokens[ce.tokens.length - 2].isType = !0, ce.tokens[ce.tokens.length - 1].isType = !0;
}
function MG() {
  if ($t(), ke(L.comma) || ke(L.braceR)) {
    ce.tokens[ce.tokens.length - 1].identifierRole = jt.ExportAccess;
    return;
  }
  if ($t(), ke(L.comma) || ke(L.braceR)) {
    ce.tokens[ce.tokens.length - 1].identifierRole = jt.ExportAccess, ce.tokens[ce.tokens.length - 2].isType = !0, ce.tokens[ce.tokens.length - 1].isType = !0;
    return;
  }
  if ($t(), ke(L.comma) || ke(L.braceR)) {
    ce.tokens[ce.tokens.length - 3].identifierRole = jt.ExportAccess;
    return;
  }
  $t(), ce.tokens[ce.tokens.length - 3].identifierRole = jt.ExportAccess, ce.tokens[ce.tokens.length - 4].isType = !0, ce.tokens[ce.tokens.length - 3].isType = !0, ce.tokens[ce.tokens.length - 2].isType = !0, ce.tokens[ce.tokens.length - 1].isType = !0;
}
function LG() {
  if (Dt(Fe._abstract) && kr() === L._class)
    return ce.type = L._abstract, pt(), za(!0, !0), !0;
  if (Dt(Fe._interface)) {
    const t = Kt(2);
    return xp(Fe._interface, !0), zt(t), !0;
  }
  return !1;
}
function jG() {
  if (ce.type === L._const) {
    const t = ec();
    if (t.type === L.name && t.contextualKeyword === Fe._enum)
      return dt(L._const), Br(Fe._enum), ce.tokens[ce.tokens.length - 1].type = L._enum, Hb(), !0;
  }
  return !1;
}
function FG(t) {
  const e = ce.tokens.length;
  Vb([
    Fe._abstract,
    Fe._readonly,
    Fe._declare,
    Fe._static,
    Fe._override
  ]);
  const n = ce.tokens.length;
  if (yC()) {
    const c = t ? e - 1 : e;
    for (let u = c; u < n; u++)
      ce.tokens[u].isType = !0;
    return !0;
  }
  return !1;
}
function BG(t) {
  IG(t) || Tr();
}
function $G() {
  const t = Jr(Fe._declare);
  t && (ce.tokens[ce.tokens.length - 1].type = L._declare);
  let e = !1;
  if (ke(L.name))
    if (t) {
      const n = Kt(2);
      e = mS(), zt(n);
    } else
      e = mS();
  if (!e)
    if (t) {
      const n = Kt(2);
      Zn(!0), zt(n);
    } else
      Zn(!0);
}
function UG(t) {
  if (t && (ke(L.lessThan) || ke(L.bitShiftL)) && Gb(), Jr(Fe._implements)) {
    ce.tokens[ce.tokens.length - 1].type = L._implements;
    const e = Kt(1);
    gC(), zt(e);
  }
}
function VG() {
  to();
}
function WG() {
  to();
}
function HG() {
  const t = Kt(0);
  Rn() || it(L.bang), dl(), zt(t);
}
function qG() {
  ke(L.colon) && rc();
}
function GG(t, e) {
  return Sp ? zG(t, e) : KG(t, e);
}
function zG(t, e) {
  if (!ke(L.lessThan))
    return fs(t, e);
  const n = ce.snapshot();
  let a = fs(t, e);
  if (ce.error)
    ce.restoreFromSnapshot(n);
  else
    return a;
  return ce.type = L.typeParameterStart, Ap(), a = fs(t, e), a || Gt(), a;
}
function KG(t, e) {
  if (!ke(L.lessThan))
    return fs(t, e);
  const n = ce.snapshot();
  Ap();
  const a = fs(t, e);
  if (a || Gt(), ce.error)
    ce.restoreFromSnapshot(n);
  else
    return a;
  return fs(t, e);
}
function YG() {
  if (ke(L.colon)) {
    const t = ce.snapshot();
    mu(L.colon), Yn() && Gt(), ke(L.arrow) || Gt(), ce.error && ce.restoreFromSnapshot(t);
  }
  return it(L.arrow);
}
function XG() {
  const t = Kt(0);
  it(L.question), dl(), zt(t);
}
function JG() {
  (ke(L.lessThan) || ke(L.bitShiftL)) && Gb(), $C();
}
function QG() {
  let t = !1, e = !1;
  for (; ; ) {
    if (ce.pos >= _t.length) {
      Gt("Unterminated JSX contents");
      return;
    }
    const n = _t.charCodeAt(ce.pos);
    if (n === Ge.lessThan || n === Ge.leftCurlyBrace) {
      if (ce.pos === ce.start) {
        if (n === Ge.lessThan) {
          ce.pos++, qt(L.jsxTagStart);
          return;
        }
        tC(n);
        return;
      }
      qt(t && !e ? L.jsxEmptyText : L.jsxText);
      return;
    }
    n === Ge.lineFeed ? t = !0 : n !== Ge.space && n !== Ge.carriageReturn && n !== Ge.tab && (e = !0), ce.pos++;
  }
}
function ZG(t) {
  for (ce.pos++; ; ) {
    if (ce.pos >= _t.length) {
      Gt("Unterminated string constant");
      return;
    }
    if (_t.charCodeAt(ce.pos) === t) {
      ce.pos++;
      break;
    }
    ce.pos++;
  }
  qt(L.string);
}
function ez() {
  let t;
  do {
    if (ce.pos > _t.length) {
      Gt("Unexpectedly reached the end of input.");
      return;
    }
    t = _t.charCodeAt(++ce.pos);
  } while (Fi[t] || t === Ge.dash);
  qt(L.jsxName);
}
function _0() {
  hi();
}
function _C(t) {
  if (_0(), !it(L.colon)) {
    ce.tokens[ce.tokens.length - 1].identifierRole = t;
    return;
  }
  _0();
}
function SC() {
  const t = ce.tokens.length;
  _C(jt.Access);
  let e = !1;
  for (; ke(L.dot); )
    e = !0, hi(), _0();
  if (!e) {
    const n = ce.tokens[t], a = _t.charCodeAt(n.start);
    a >= Ge.lowercaseA && a <= Ge.lowercaseZ && (n.identifierRole = null);
  }
}
function tz() {
  switch (ce.type) {
    case L.braceL:
      pt(), fn(), hi();
      return;
    case L.jsxTagStart:
      TC(), hi();
      return;
    case L.string:
      hi();
      return;
    default:
      Gt("JSX value should be either an expression or a quoted JSX text");
  }
}
function rz() {
  dt(L.ellipsis), fn();
}
function nz(t) {
  if (ke(L.jsxTagEnd))
    return !1;
  SC(), rr && EG();
  let e = !1;
  for (; !ke(L.slash) && !ke(L.jsxTagEnd) && !ce.error; ) {
    if (it(L.braceL)) {
      e = !0, dt(L.ellipsis), dn(), hi();
      continue;
    }
    e && ce.end - ce.start === 3 && _t.charCodeAt(ce.start) === Ge.lowercaseK && _t.charCodeAt(ce.start + 1) === Ge.lowercaseE && _t.charCodeAt(ce.start + 2) === Ge.lowercaseY && (ce.tokens[t].jsxRole = Ri.KeyAfterPropSpread), _C(jt.ObjectKey), ke(L.eq) && (hi(), tz());
  }
  const n = ke(L.slash);
  return n && hi(), n;
}
function iz() {
  ke(L.jsxTagEnd) || SC();
}
function wC() {
  const t = ce.tokens.length - 1;
  ce.tokens[t].jsxRole = Ri.NoChildren;
  let e = 0;
  if (!nz(t))
    for (bo(); ; )
      switch (ce.type) {
        case L.jsxTagStart:
          if (hi(), ke(L.slash)) {
            hi(), iz(), ce.tokens[t].jsxRole !== Ri.KeyAfterPropSpread && (e === 1 ? ce.tokens[t].jsxRole = Ri.OneChild : e > 1 && (ce.tokens[t].jsxRole = Ri.StaticChildren));
            return;
          }
          e++, wC(), bo();
          break;
        case L.jsxText:
          e++, bo();
          break;
        case L.jsxEmptyText:
          bo();
          break;
        case L.braceL:
          pt(), ke(L.ellipsis) ? (rz(), bo(), e += 2) : (ke(L.braceR) || (e++, fn()), bo());
          break;
        default:
          Gt();
          return;
      }
}
function TC() {
  hi(), wC();
}
function hi() {
  ce.tokens.push(new wp()), QP(), ce.start = ce.pos;
  const t = _t.charCodeAt(ce.pos);
  if (Zu[t])
    ez();
  else if (t === Ge.quotationMark || t === Ge.apostrophe)
    ZG(t);
  else
    switch (++ce.pos, t) {
      case Ge.greaterThan:
        qt(L.jsxTagEnd);
        break;
      case Ge.lessThan:
        qt(L.jsxTagStart);
        break;
      case Ge.slash:
        qt(L.slash);
        break;
      case Ge.equalsTo:
        qt(L.eq);
        break;
      case Ge.leftCurlyBrace:
        qt(L.braceL);
        break;
      case Ge.dot:
        qt(L.dot);
        break;
      case Ge.colon:
        qt(L.colon);
        break;
      default:
        Gt();
    }
}
function bo() {
  ce.tokens.push(new wp()), ce.start = ce.pos, QG();
}
function sz(t) {
  if (ke(L.question)) {
    const e = kr();
    if (e === L.colon || e === L.comma || e === L.parenR)
      return;
  }
  AC(t);
}
function az() {
  zP(L.question), ke(L.colon) && (rr ? rc() : or && ro());
}
class oz {
  constructor(e) {
    this.stop = e;
  }
}
function fn(t = !1) {
  if (dn(t), ke(L.comma))
    for (; it(L.comma); )
      dn(t);
}
function dn(t = !1, e = !1) {
  return rr ? GG(t, e) : or ? dK(t, e) : fs(t, e);
}
function fs(t, e) {
  if (ke(L._yield))
    return wz(), !1;
  (ke(L.parenL) || ke(L.name) || ke(L._yield)) && (ce.potentialArrowAt = ce.start);
  const n = lz(t);
  return e && Xb(), ce.type & L.IS_ASSIGN ? (pt(), dn(t), !1) : n;
}
function lz(t) {
  return cz(t) ? !0 : (uz(t), !1);
}
function uz(t) {
  rr || or ? sz(t) : AC(t);
}
function AC(t) {
  it(L.question) && (dn(), dt(L.colon), dn(t));
}
function cz(t) {
  const e = ce.tokens.length;
  return nc() ? !0 : (yf(e, -1, t), !1);
}
function yf(t, e, n) {
  if (rr && (L._in & L.PRECEDENCE_MASK) > e && !Rn() && (Jr(Fe._as) || Jr(Fe._satisfies))) {
    const c = Kt(1);
    Dr(), zt(c), eC(), yf(t, e, n);
    return;
  }
  const a = ce.type & L.PRECEDENCE_MASK;
  if (a > 0 && (!n || !ke(L._in)) && a > e) {
    const c = ce.type;
    pt(), c === L.nullishCoalescing && (ce.tokens[ce.tokens.length - 1].nullishStartIndex = t);
    const u = ce.tokens.length;
    nc(), yf(u, c & L.IS_RIGHT_ASSOCIATIVE ? a - 1 : a, n), c === L.nullishCoalescing && (ce.tokens[t].numNullishCoalesceStarts++, ce.tokens[ce.tokens.length - 1].numNullishCoalesceEnds++), yf(t, e, n);
  }
}
function nc() {
  if (rr && !Sp && it(L.lessThan))
    return vG(), !1;
  if (Dt(Fe._module) && YP() === Ge.leftCurlyBrace && !VP())
    return Tz(), !1;
  if (ce.type & L.IS_PREFIX)
    return pt(), nc(), !1;
  if (xC())
    return !0;
  for (; ce.type & L.IS_POSTFIX && !Yn(); )
    ce.type === L.preIncDec && (ce.type = L.postIncDec), pt();
  return !1;
}
function xC() {
  const t = ce.tokens.length;
  return Us() ? !0 : (zb(t), ce.tokens.length > t && ce.tokens[t].isOptionalChainStart && (ce.tokens[ce.tokens.length - 1].isOptionalChainEnd = !0), !1);
}
function zb(t, e = !1) {
  or ? hK(t, e) : PC(t, e);
}
function PC(t, e = !1) {
  const n = new oz(!1);
  do
    fz(t, e, n);
  while (!n.stop && !ce.error);
}
function fz(t, e, n) {
  rr ? DG(t, e, n) : or ? Kz(t, e, n) : Kb(t, e, n);
}
function Kb(t, e, n) {
  if (!e && it(L.doubleColon))
    Yb(), n.stop = !0, zb(t, e);
  else if (ke(L.questionDot)) {
    if (ce.tokens[t].isOptionalChainStart = !0, e && kr() === L.parenL) {
      n.stop = !0;
      return;
    }
    pt(), ce.tokens[ce.tokens.length - 1].subscriptStartIndex = t, it(L.bracketL) ? (fn(), dt(L.bracketR)) : it(L.parenL) ? sa() : Xf();
  } else if (it(L.dot))
    ce.tokens[ce.tokens.length - 1].subscriptStartIndex = t, Xf();
  else if (it(L.bracketL))
    ce.tokens[ce.tokens.length - 1].subscriptStartIndex = t, fn(), dt(L.bracketR);
  else if (!e && ke(L.parenL))
    if (CC()) {
      const a = ce.snapshot(), c = ce.tokens.length;
      pt(), ce.tokens[ce.tokens.length - 1].subscriptStartIndex = t;
      const u = pu();
      ce.tokens[ce.tokens.length - 1].contextId = u, sa(), ce.tokens[ce.tokens.length - 1].contextId = u, dz() && (ce.restoreFromSnapshot(a), n.stop = !0, ce.scopeDepth++, hl(), pz(c));
    } else {
      pt(), ce.tokens[ce.tokens.length - 1].subscriptStartIndex = t;
      const a = pu();
      ce.tokens[ce.tokens.length - 1].contextId = a, sa(), ce.tokens[ce.tokens.length - 1].contextId = a;
    }
  else
    ke(L.backQuote) ? Jb() : n.stop = !0;
}
function CC() {
  return ce.tokens[ce.tokens.length - 1].contextualKeyword === Fe._async && !Yn();
}
function sa() {
  let t = !0;
  for (; !it(L.parenR) && !ce.error; ) {
    if (t)
      t = !1;
    else if (dt(L.comma), it(L.parenR))
      break;
    DC(!1);
  }
}
function dz() {
  return ke(L.colon) || ke(L.arrow);
}
function pz(t) {
  rr ? qG() : or && fK(), dt(L.arrow), bu(t);
}
function Yb() {
  const t = ce.tokens.length;
  Us(), zb(t, !0);
}
function Us() {
  if (it(L.modulo))
    return $t(), !1;
  if (ke(L.jsxText) || ke(L.jsxEmptyText))
    return Xo(), !1;
  if (ke(L.lessThan) && Sp)
    return ce.type = L.jsxTagStart, TC(), pt(), !1;
  const t = ce.potentialArrowAt === ce.start;
  switch (ce.type) {
    case L.slash:
    case L.assign:
      tq();
    case L._super:
    case L._this:
    case L.regexp:
    case L.num:
    case L.bigint:
    case L.decimal:
    case L.string:
    case L._null:
    case L._true:
    case L._false:
      return pt(), !1;
    case L._import:
      return pt(), ke(L.dot) && (ce.tokens[ce.tokens.length - 1].type = L.name, pt(), $t()), !1;
    case L.name: {
      const e = ce.tokens.length, n = ce.start, a = ce.contextualKeyword;
      return $t(), a === Fe._await ? (Sz(), !1) : a === Fe._async && ke(L._function) && !Yn() ? (pt(), Ga(n, !1), !1) : t && a === Fe._async && !Yn() && ke(L.name) ? (ce.scopeDepth++, ba(!1), dt(L.arrow), bu(e), !0) : ke(L._do) && !Yn() ? (pt(), aa(), !1) : t && !Yn() && ke(L.arrow) ? (ce.scopeDepth++, $b(!1), dt(L.arrow), bu(e), !0) : (ce.tokens[ce.tokens.length - 1].identifierRole = jt.Access, !1);
    }
    case L._do:
      return pt(), aa(), !1;
    case L.parenL:
      return IC(t);
    case L.bracketL:
      return pt(), kC(L.bracketR, !0), !1;
    case L.braceL:
      return Qb(!1, !1), !1;
    case L._function:
      return hz(), !1;
    case L.at:
      og();
    case L._class:
      return za(!1), !1;
    case L._new:
      return yz(), !1;
    case L.backQuote:
      return Jb(), !1;
    case L.doubleColon:
      return pt(), Yb(), !1;
    case L.hash: {
      const e = YP();
      return Zu[e] || e === Ge.backslash ? Xf() : pt(), !1;
    }
    default:
      return Gt(), !1;
  }
}
function Xf() {
  it(L.hash), $t();
}
function hz() {
  const t = ce.start;
  $t(), it(L.dot) && $t(), Ga(t, !1);
}
function Xo() {
  pt();
}
function Pp() {
  dt(L.parenL), fn(), dt(L.parenR);
}
function IC(t) {
  const e = ce.snapshot(), n = ce.tokens.length;
  dt(L.parenL);
  let a = !0;
  for (; !ke(L.parenR) && !ce.error; ) {
    if (a)
      a = !1;
    else if (dt(L.comma), ke(L.parenR))
      break;
    if (ke(L.ellipsis)) {
      fC(
        !1
        /* isBlockScope */
      ), Xb();
      break;
    } else
      dn(!1, !0);
  }
  return dt(L.parenR), t && mz() && S0() ? (ce.restoreFromSnapshot(e), ce.scopeDepth++, hl(), S0(), bu(n), ce.error ? (ce.restoreFromSnapshot(e), IC(!1), !1) : !0) : !1;
}
function mz() {
  return ke(L.colon) || !Yn();
}
function S0() {
  return rr ? YG() : or ? pK() : it(L.arrow);
}
function Xb() {
  (rr || or) && az();
}
function yz() {
  if (dt(L._new), it(L.dot)) {
    $t();
    return;
  }
  bz(), or && Yz(), it(L.parenL) && kC(L.parenR);
}
function bz() {
  Yb(), it(L.questionDot);
}
function Jb() {
  for (ea(), ea(); !ke(L.backQuote) && !ce.error; )
    dt(L.dollarBraceL), fn(), ea(), ea();
  pt();
}
function Qb(t, e) {
  const n = pu();
  let a = !0;
  for (pt(), ce.tokens[ce.tokens.length - 1].contextId = n; !it(L.braceR) && !ce.error; ) {
    if (a)
      a = !1;
    else if (dt(L.comma), it(L.braceR))
      break;
    let c = !1;
    if (ke(L.ellipsis)) {
      const u = ce.tokens.length;
      if (cC(), t && (ce.tokens.length === u + 2 && $b(e), it(L.braceR)))
        break;
      continue;
    }
    t || (c = it(L.star)), !t && Dt(Fe._async) ? (c && Gt(), $t(), ke(L.colon) || ke(L.parenL) || ke(L.braceR) || ke(L.eq) || ke(L.comma) || (ke(L.star) && (pt(), c = !0), yu(n))) : yu(n), _z(t, e, n);
  }
  ce.tokens[ce.tokens.length - 1].contextId = n;
}
function gz(t) {
  return !t && (ke(L.string) || // get "string"() {}
  ke(L.num) || // get 1() {}
  ke(L.bracketL) || // get ["string"]() {}
  ke(L.name) || // get foo() {}
  !!(ce.type & L.IS_KEYWORD));
}
function vz(t, e) {
  const n = ce.start;
  return ke(L.parenL) ? (t && Gt(), w0(
    n,
    /* isConstructor */
    !1
  ), !0) : gz(t) ? (yu(e), w0(
    n,
    /* isConstructor */
    !1
  ), !0) : !1;
}
function Ez(t, e) {
  if (it(L.colon)) {
    t ? Kf(e) : dn(!1);
    return;
  }
  let n;
  t ? ce.scopeDepth === 0 ? n = jt.ObjectShorthandTopLevelDeclaration : e ? n = jt.ObjectShorthandBlockScopedDeclaration : n = jt.ObjectShorthandFunctionScopedDeclaration : n = jt.ObjectShorthand, ce.tokens[ce.tokens.length - 1].identifierRole = n, Kf(e, !0);
}
function _z(t, e, n) {
  rr ? VG() : or && sK(), vz(t, n) || Ez(t, e);
}
function yu(t) {
  or && ag(), it(L.bracketL) ? (ce.tokens[ce.tokens.length - 1].contextId = t, dn(), dt(L.bracketR), ce.tokens[ce.tokens.length - 1].contextId = t) : (ke(L.num) || ke(L.string) || ke(L.bigint) || ke(L.decimal) ? Us() : Xf(), ce.tokens[ce.tokens.length - 1].identifierRole = jt.ObjectKey, ce.tokens[ce.tokens.length - 1].contextId = t);
}
function w0(t, e) {
  const n = pu();
  ce.scopeDepth++;
  const a = ce.tokens.length;
  hl(e, n), OC(t, n);
  const u = ce.tokens.length;
  ce.scopes.push(new gs(a, u, !0)), ce.scopeDepth--;
}
function bu(t) {
  ic(!0);
  const e = ce.tokens.length;
  ce.scopes.push(new gs(t, e, !0)), ce.scopeDepth--;
}
function OC(t, e = 0) {
  rr ? kG(t, e) : or ? zz(e) : ic(!1, e);
}
function ic(t, e = 0) {
  t && !ke(L.braceL) ? dn() : aa(!0, e);
}
function kC(t, e = !1) {
  let n = !0;
  for (; !it(t) && !ce.error; ) {
    if (n)
      n = !1;
    else if (dt(L.comma), it(t))
      break;
    DC(e);
  }
}
function DC(t) {
  t && ke(L.comma) || (ke(L.ellipsis) ? (cC(), Xb()) : ke(L.question) ? pt() : dn(!1, !0));
}
function $t() {
  pt(), ce.tokens[ce.tokens.length - 1].type = L.name;
}
function Sz() {
  nc();
}
function wz() {
  pt(), !ke(L.semi) && !Yn() && (it(L.star), dn());
}
function Tz() {
  Br(Fe._module), dt(L.braceL), Ip(L.braceR);
}
function Az(t) {
  return (t.type === L.name || !!(t.type & L.IS_KEYWORD)) && t.contextualKeyword !== Fe._from;
}
function vs(t) {
  const e = Kt(0);
  dt(t || L.colon), Vn(), zt(e);
}
function yS() {
  dt(L.modulo), Br(Fe._checks), it(L.parenL) && (fn(), dt(L.parenR));
}
function Zb() {
  const t = Kt(0);
  dt(L.colon), ke(L.modulo) ? yS() : (Vn(), ke(L.modulo) && yS()), zt(t);
}
function xz() {
  pt(), eg(
    /* isClass */
    !0
  );
}
function Pz() {
  pt(), $t(), ke(L.lessThan) && Gi(), dt(L.parenL), A0(), dt(L.parenR), Zb(), Tr();
}
function T0() {
  ke(L._class) ? xz() : ke(L._function) ? Pz() : ke(L._var) ? Cz() : Jr(Fe._module) ? it(L.dot) ? kz() : Iz() : Dt(Fe._type) ? Dz() : Dt(Fe._opaque) ? Nz() : Dt(Fe._interface) ? Rz() : ke(L._export) ? Oz() : Gt();
}
function Cz() {
  pt(), LC(), Tr();
}
function Iz() {
  for (ke(L.string) ? Us() : $t(), dt(L.braceL); !ke(L.braceR) && !ce.error; )
    ke(L._import) ? (pt(), GC()) : Gt();
  dt(L.braceR);
}
function Oz() {
  dt(L._export), it(L._default) ? ke(L._function) || ke(L._class) ? T0() : (Vn(), Tr()) : ke(L._var) || // declare export var ...
  ke(L._function) || // declare export function ...
  ke(L._class) || // declare export class ...
  Dt(Fe._opaque) ? T0() : ke(L.star) || // declare export * from ''
  ke(L.braceL) || // declare export {} ...
  Dt(Fe._interface) || // declare export interface ...
  Dt(Fe._type) || // declare export type ...
  Dt(Fe._opaque) ? HC() : Gt();
}
function kz() {
  Br(Fe._exports), ro(), Tr();
}
function Dz() {
  pt(), rg();
}
function Nz() {
  pt(), ng(!0);
}
function Rz() {
  pt(), eg();
}
function eg(t = !1) {
  if (Cp(), ke(L.lessThan) && Gi(), it(L._extends))
    do
      bf();
    while (!t && it(L.comma));
  if (Dt(Fe._mixins)) {
    pt();
    do
      bf();
    while (it(L.comma));
  }
  if (Dt(Fe._implements)) {
    pt();
    do
      bf();
    while (it(L.comma));
  }
  Jf(t, !1, t);
}
function bf() {
  NC(!1), ke(L.lessThan) && qa();
}
function tg() {
  eg();
}
function Cp() {
  $t();
}
function rg() {
  Cp(), ke(L.lessThan) && Gi(), vs(L.eq), Tr();
}
function ng(t) {
  Br(Fe._type), Cp(), ke(L.lessThan) && Gi(), ke(L.colon) && vs(L.colon), t || vs(L.eq), Tr();
}
function Mz() {
  ag(), LC(), it(L.eq) && Vn();
}
function Gi() {
  const t = Kt(0);
  ke(L.lessThan) || ke(L.typeParameterStart) ? pt() : Gt();
  do
    Mz(), ke(L.greaterThan) || dt(L.comma);
  while (!ke(L.greaterThan) && !ce.error);
  dt(L.greaterThan), zt(t);
}
function qa() {
  const t = Kt(0);
  for (dt(L.lessThan); !ke(L.greaterThan) && !ce.error; )
    Vn(), ke(L.greaterThan) || dt(L.comma);
  dt(L.greaterThan), zt(t);
}
function Lz() {
  if (Br(Fe._interface), it(L._extends))
    do
      bf();
    while (it(L.comma));
  Jf(!1, !1, !1);
}
function ig() {
  ke(L.num) || ke(L.string) ? Us() : $t();
}
function jz() {
  kr() === L.colon ? (ig(), vs()) : Vn(), dt(L.bracketR), vs();
}
function Fz() {
  ig(), dt(L.bracketR), dt(L.bracketR), ke(L.lessThan) || ke(L.parenL) ? sg() : (it(L.question), vs());
}
function sg() {
  for (ke(L.lessThan) && Gi(), dt(L.parenL); !ke(L.parenR) && !ke(L.ellipsis) && !ce.error; )
    Qf(), ke(L.parenR) || dt(L.comma);
  it(L.ellipsis) && Qf(), dt(L.parenR), vs();
}
function Bz() {
  sg();
}
function Jf(t, e, n) {
  let a;
  for (e && ke(L.braceBarL) ? (dt(L.braceBarL), a = L.braceBarR) : (dt(L.braceL), a = L.braceR); !ke(a) && !ce.error; ) {
    if (n && Dt(Fe._proto)) {
      const c = kr();
      c !== L.colon && c !== L.question && (pt(), t = !1);
    }
    if (t && Dt(Fe._static)) {
      const c = kr();
      c !== L.colon && c !== L.question && pt();
    }
    if (ag(), it(L.bracketL))
      it(L.bracketL) ? Fz() : jz();
    else if (ke(L.parenL) || ke(L.lessThan))
      Bz();
    else {
      if (Dt(Fe._get) || Dt(Fe._set)) {
        const c = kr();
        (c === L.name || c === L.string || c === L.num) && pt();
      }
      $z();
    }
    Uz();
  }
  dt(a);
}
function $z() {
  if (ke(L.ellipsis)) {
    if (dt(L.ellipsis), it(L.comma) || it(L.semi), ke(L.braceR))
      return;
    Vn();
  } else
    ig(), ke(L.lessThan) || ke(L.parenL) ? sg() : (it(L.question), vs());
}
function Uz() {
  !it(L.semi) && !it(L.comma) && !ke(L.braceR) && !ke(L.braceBarR) && Gt();
}
function NC(t) {
  for (t || $t(); it(L.dot); )
    $t();
}
function Vz() {
  NC(!0), ke(L.lessThan) && qa();
}
function Wz() {
  dt(L._typeof), RC();
}
function Hz() {
  for (dt(L.bracketL); ce.pos < _t.length && !ke(L.bracketR) && (Vn(), !ke(L.bracketR)); )
    dt(L.comma);
  dt(L.bracketR);
}
function Qf() {
  const t = kr();
  t === L.colon || t === L.question ? ($t(), it(L.question), vs()) : Vn();
}
function A0() {
  for (; !ke(L.parenR) && !ke(L.ellipsis) && !ce.error; )
    Qf(), ke(L.parenR) || dt(L.comma);
  it(L.ellipsis) && Qf();
}
function RC() {
  let t = !1;
  const e = ce.noAnonFunctionType;
  switch (ce.type) {
    case L.name: {
      if (Dt(Fe._interface)) {
        Lz();
        return;
      }
      $t(), Vz();
      return;
    }
    case L.braceL:
      Jf(!1, !1, !1);
      return;
    case L.braceBarL:
      Jf(!1, !0, !1);
      return;
    case L.bracketL:
      Hz();
      return;
    case L.lessThan:
      Gi(), dt(L.parenL), A0(), dt(L.parenR), dt(L.arrow), Vn();
      return;
    case L.parenL:
      if (pt(), !ke(L.parenR) && !ke(L.ellipsis))
        if (ke(L.name)) {
          const n = kr();
          t = n !== L.question && n !== L.colon;
        } else
          t = !0;
      if (t)
        if (ce.noAnonFunctionType = !1, Vn(), ce.noAnonFunctionType = e, ce.noAnonFunctionType || !(ke(L.comma) || ke(L.parenR) && kr() === L.arrow)) {
          dt(L.parenR);
          return;
        } else
          it(L.comma);
      A0(), dt(L.parenR), dt(L.arrow), Vn();
      return;
    case L.minus:
      pt(), Xo();
      return;
    case L.string:
    case L.num:
    case L._true:
    case L._false:
    case L._null:
    case L._this:
    case L._void:
    case L.star:
      pt();
      return;
    default:
      if (ce.type === L._typeof) {
        Wz();
        return;
      } else if (ce.type & L.IS_KEYWORD) {
        pt(), ce.tokens[ce.tokens.length - 1].type = L.name;
        return;
      }
  }
  Gt();
}
function qz() {
  for (RC(); !Yn() && (ke(L.bracketL) || ke(L.questionDot)); )
    it(L.questionDot), dt(L.bracketL), it(L.bracketR) || (Vn(), dt(L.bracketR));
}
function MC() {
  it(L.question) ? MC() : qz();
}
function bS() {
  MC(), !ce.noAnonFunctionType && it(L.arrow) && Vn();
}
function gS() {
  for (it(L.bitwiseAND), bS(); it(L.bitwiseAND); )
    bS();
}
function Gz() {
  for (it(L.bitwiseOR), gS(); it(L.bitwiseOR); )
    gS();
}
function Vn() {
  Gz();
}
function ro() {
  vs();
}
function LC() {
  $t(), ke(L.colon) && ro();
}
function ag() {
  (ke(L.plus) || ke(L.minus)) && (pt(), ce.tokens[ce.tokens.length - 1].isType = !0);
}
function zz(t) {
  ke(L.colon) && Zb(), ic(!1, t);
}
function Kz(t, e, n) {
  if (ke(L.questionDot) && kr() === L.lessThan) {
    if (e) {
      n.stop = !0;
      return;
    }
    pt(), qa(), dt(L.parenL), sa();
    return;
  } else if (!e && ke(L.lessThan)) {
    const a = ce.snapshot();
    if (qa(), dt(L.parenL), sa(), ce.error)
      ce.restoreFromSnapshot(a);
    else
      return;
  }
  Kb(t, e, n);
}
function Yz() {
  if (ke(L.lessThan)) {
    const t = ce.snapshot();
    qa(), ce.error && ce.restoreFromSnapshot(t);
  }
}
function Xz() {
  if (ke(L.name) && ce.contextualKeyword === Fe._interface) {
    const t = Kt(0);
    return pt(), tg(), zt(t), !0;
  } else if (Dt(Fe._enum))
    return jC(), !0;
  return !1;
}
function Jz() {
  return Dt(Fe._enum) ? (jC(), !0) : !1;
}
function Qz(t) {
  if (t === Fe._declare) {
    if (ke(L._class) || ke(L.name) || ke(L._function) || ke(L._var) || ke(L._export)) {
      const e = Kt(1);
      T0(), zt(e);
    }
  } else if (ke(L.name)) {
    if (t === Fe._interface) {
      const e = Kt(1);
      tg(), zt(e);
    } else if (t === Fe._type) {
      const e = Kt(1);
      rg(), zt(e);
    } else if (t === Fe._opaque) {
      const e = Kt(1);
      ng(!1), zt(e);
    }
  }
  Tr();
}
function Zz() {
  return Dt(Fe._type) || Dt(Fe._interface) || Dt(Fe._opaque) || Dt(Fe._enum);
}
function eK() {
  return ke(L.name) && (ce.contextualKeyword === Fe._type || ce.contextualKeyword === Fe._interface || ce.contextualKeyword === Fe._opaque || ce.contextualKeyword === Fe._enum);
}
function tK() {
  if (Dt(Fe._type)) {
    const t = Kt(1);
    pt(), ke(L.braceL) ? (lg(), gu()) : rg(), zt(t);
  } else if (Dt(Fe._opaque)) {
    const t = Kt(1);
    pt(), ng(!1), zt(t);
  } else if (Dt(Fe._interface)) {
    const t = Kt(1);
    pt(), tg(), zt(t);
  } else
    Zn(!0);
}
function rK() {
  return ke(L.star) || Dt(Fe._type) && kr() === L.star;
}
function nK() {
  if (Jr(Fe._type)) {
    const t = Kt(2);
    x0(), zt(t);
  } else
    x0();
}
function iK(t) {
  if (t && ke(L.lessThan) && qa(), Dt(Fe._implements)) {
    const e = Kt(0);
    pt(), ce.tokens[ce.tokens.length - 1].type = L._implements;
    do
      Cp(), ke(L.lessThan) && qa();
    while (it(L.comma));
    zt(e);
  }
}
function sK() {
  ke(L.lessThan) && (Gi(), ke(L.parenL) || Gt());
}
function aK() {
  const t = Kt(0);
  it(L.question), ke(L.colon) && ro(), zt(t);
}
function oK() {
  if (ke(L._typeof) || Dt(Fe._type)) {
    const t = ec();
    (Az(t) || t.type === L.braceL || t.type === L.star) && pt();
  }
}
function lK() {
  const t = ce.contextualKeyword === Fe._type || ce.type === L._typeof;
  t ? pt() : $t(), Dt(Fe._as) && !jb(Fe._as) ? ($t(), t && !ke(L.name) && !(ce.type & L.IS_KEYWORD) || $t()) : (t && (ke(L.name) || ce.type & L.IS_KEYWORD) && $t(), Jr(Fe._as) && $t());
}
function uK() {
  if (ke(L.lessThan)) {
    const t = Kt(0);
    Gi(), zt(t);
  }
}
function cK() {
  ke(L.colon) && ro();
}
function fK() {
  if (ke(L.colon)) {
    const t = ce.noAnonFunctionType;
    ce.noAnonFunctionType = !0, ro(), ce.noAnonFunctionType = t;
  }
}
function dK(t, e) {
  if (ke(L.lessThan)) {
    const n = ce.snapshot();
    let a = fs(t, e);
    if (ce.error)
      ce.restoreFromSnapshot(n), ce.type = L.typeParameterStart;
    else
      return a;
    const c = Kt(0);
    if (Gi(), zt(c), a = fs(t, e), a)
      return !0;
    Gt();
  }
  return fs(t, e);
}
function pK() {
  if (ke(L.colon)) {
    const t = Kt(0), e = ce.snapshot(), n = ce.noAnonFunctionType;
    ce.noAnonFunctionType = !0, Zb(), ce.noAnonFunctionType = n, Yn() && Gt(), ke(L.arrow) || Gt(), ce.error && ce.restoreFromSnapshot(e), zt(t);
  }
  return it(L.arrow);
}
function hK(t, e = !1) {
  if (ce.tokens[ce.tokens.length - 1].contextualKeyword === Fe._async && ke(L.lessThan)) {
    const n = ce.snapshot();
    if (mK() && !ce.error)
      return;
    ce.restoreFromSnapshot(n);
  }
  PC(t, e);
}
function mK() {
  ce.scopeDepth++;
  const t = ce.tokens.length;
  return hl(), S0() ? (bu(t), !0) : !1;
}
function jC() {
  Br(Fe._enum), ce.tokens[ce.tokens.length - 1].type = L._enum, $t(), yK();
}
function yK() {
  Jr(Fe._of) && pt(), dt(L.braceL), bK(), dt(L.braceR);
}
function bK() {
  for (; !ke(L.braceR) && !ce.error && !it(L.ellipsis); )
    gK(), ke(L.braceR) || dt(L.comma);
}
function gK() {
  $t(), it(L.eq) && pt();
}
function vK() {
  if (Ip(L.eof), ce.scopes.push(new gs(0, ce.tokens.length, !0)), ce.scopeDepth !== 0)
    throw new Error(`Invalid scope depth at end of file: ${ce.scopeDepth}`);
  return new sY(ce.tokens, ce.scopes);
}
function Zn(t) {
  or && Xz() || (ke(L.at) && og(), EK(t));
}
function EK(t) {
  if (rr && jG())
    return;
  const e = ce.type;
  switch (e) {
    case L._break:
    case L._continue:
      SK();
      return;
    case L._debugger:
      wK();
      return;
    case L._do:
      TK();
      return;
    case L._for:
      AK();
      return;
    case L._function:
      if (kr() === L.dot)
        break;
      t || Gt(), CK();
      return;
    case L._class:
      t || Gt(), za(!0);
      return;
    case L._if:
      IK();
      return;
    case L._return:
      OK();
      return;
    case L._switch:
      kK();
      return;
    case L._throw:
      DK();
      return;
    case L._try:
      RK();
      return;
    case L._let:
    case L._const:
      t || Gt();
    case L._var:
      gf(e !== L._var);
      return;
    case L._while:
      MK();
      return;
    case L.braceL:
      aa();
      return;
    case L.semi:
      LK();
      return;
    case L._export:
    case L._import: {
      const c = kr();
      if (c === L.parenL || c === L.dot)
        break;
      pt(), e === L._import ? GC() : HC();
      return;
    }
    case L.name:
      if (ce.contextualKeyword === Fe._async) {
        const c = ce.start, u = ce.snapshot();
        if (pt(), ke(L._function) && !Yn()) {
          dt(L._function), Ga(c, !0);
          return;
        } else
          ce.restoreFromSnapshot(u);
      } else if (ce.contextualKeyword === Fe._using && !VP() && // Statements like `using[0]` and `using in foo` aren't actual using
      // declarations.
      kr() === L.name) {
        gf(!0);
        return;
      } else if (FC()) {
        Br(Fe._await), gf(!0);
        return;
      }
  }
  const n = ce.tokens.length;
  fn();
  let a = null;
  if (ce.tokens.length === n + 1) {
    const c = ce.tokens[ce.tokens.length - 1];
    c.type === L.name && (a = c.contextualKeyword);
  }
  if (a == null) {
    Tr();
    return;
  }
  it(L.colon) ? jK() : FK(a);
}
function FC() {
  if (!Dt(Fe._await))
    return !1;
  const t = ce.snapshot();
  return pt(), !Dt(Fe._using) || Rn() || (pt(), !ke(L.name) || Rn()) ? (ce.restoreFromSnapshot(t), !1) : (ce.restoreFromSnapshot(t), !0);
}
function og() {
  for (; ke(L.at); )
    BC();
}
function BC() {
  if (pt(), it(L.parenL))
    fn(), dt(L.parenR);
  else {
    for ($t(); it(L.dot); )
      $t();
    _K();
  }
}
function _K() {
  rr ? JG() : $C();
}
function $C() {
  it(L.parenL) && sa();
}
function SK() {
  pt(), ss() || ($t(), Tr());
}
function wK() {
  pt(), Tr();
}
function TK() {
  pt(), Zn(!1), dt(L._while), Pp(), it(L.semi);
}
function AK() {
  ce.scopeDepth++;
  const t = ce.tokens.length;
  PK();
  const e = ce.tokens.length;
  ce.scopes.push(new gs(t, e, !1)), ce.scopeDepth--;
}
function xK() {
  return !(!Dt(Fe._using) || jb(Fe._of));
}
function PK() {
  pt();
  let t = !1;
  if (Dt(Fe._await) && (t = !0, pt()), dt(L.parenL), ke(L.semi)) {
    t && Gt(), xm();
    return;
  }
  const e = FC();
  if (e || ke(L._var) || ke(L._let) || ke(L._const) || xK()) {
    if (e && Br(Fe._await), pt(), UC(!0, ce.type !== L._var), ke(L._in) || Dt(Fe._of)) {
      vS(t);
      return;
    }
    xm();
    return;
  }
  if (fn(!0), ke(L._in) || Dt(Fe._of)) {
    vS(t);
    return;
  }
  t && Gt(), xm();
}
function CK() {
  const t = ce.start;
  pt(), Ga(t, !0);
}
function IK() {
  pt(), Pp(), Zn(!1), it(L._else) && Zn(!1);
}
function OK() {
  pt(), ss() || (fn(), Tr());
}
function kK() {
  pt(), Pp(), ce.scopeDepth++;
  const t = ce.tokens.length;
  for (dt(L.braceL); !ke(L.braceR) && !ce.error; )
    if (ke(L._case) || ke(L._default)) {
      const n = ke(L._case);
      pt(), n && fn(), dt(L.colon);
    } else
      Zn(!0);
  pt();
  const e = ce.tokens.length;
  ce.scopes.push(new gs(t, e, !1)), ce.scopeDepth--;
}
function DK() {
  pt(), fn(), Tr();
}
function NK() {
  Tp(
    !0
    /* isBlockScope */
  ), rr && dl();
}
function RK() {
  if (pt(), aa(), ke(L._catch)) {
    pt();
    let t = null;
    if (ke(L.parenL) && (ce.scopeDepth++, t = ce.tokens.length, dt(L.parenL), NK(), dt(L.parenR)), aa(), t != null) {
      const e = ce.tokens.length;
      ce.scopes.push(new gs(t, e, !1)), ce.scopeDepth--;
    }
  }
  it(L._finally) && aa();
}
function gf(t) {
  pt(), UC(!1, t), Tr();
}
function MK() {
  pt(), Pp(), Zn(!1);
}
function LK() {
  pt();
}
function jK() {
  Zn(!0);
}
function FK(t) {
  rr ? BG(t) : or ? Qz(t) : Tr();
}
function aa(t = !1, e = 0) {
  const n = ce.tokens.length;
  ce.scopeDepth++, dt(L.braceL), e && (ce.tokens[ce.tokens.length - 1].contextId = e), Ip(L.braceR), e && (ce.tokens[ce.tokens.length - 1].contextId = e);
  const a = ce.tokens.length;
  ce.scopes.push(new gs(n, a, t)), ce.scopeDepth--;
}
function Ip(t) {
  for (; !it(t) && !ce.error; )
    Zn(!0);
}
function xm() {
  dt(L.semi), ke(L.semi) || fn(), dt(L.semi), ke(L.parenR) || fn(), dt(L.parenR), Zn(!1);
}
function vS(t) {
  t ? Jr(Fe._of) : pt(), fn(), dt(L.parenR), Zn(!1);
}
function UC(t, e) {
  for (; ; ) {
    if (BK(e), it(L.eq)) {
      const n = ce.tokens.length - 1;
      dn(t), ce.tokens[n].rhsEndIndex = ce.tokens.length;
    }
    if (!it(L.comma))
      break;
  }
}
function BK(t) {
  Tp(t), rr ? HG() : or && cK();
}
function Ga(t, e, n = !1) {
  ke(L.star) && pt(), e && !n && !ke(L.name) && !ke(L._yield) && Gt();
  let a = null;
  ke(L.name) && (e || (a = ce.tokens.length, ce.scopeDepth++), ba(!1));
  const c = ce.tokens.length;
  ce.scopeDepth++, hl(), OC(t);
  const u = ce.tokens.length;
  ce.scopes.push(new gs(c, u, !0)), ce.scopeDepth--, a !== null && (ce.scopes.push(new gs(a, u, !0)), ce.scopeDepth--);
}
function hl(t = !1, e = 0) {
  rr ? WG() : or && uK(), dt(L.parenL), e && (ce.tokens[ce.tokens.length - 1].contextId = e), Ub(
    L.parenR,
    !1,
    !1,
    t,
    e
  ), e && (ce.tokens[ce.tokens.length - 1].contextId = e);
}
function za(t, e = !1) {
  const n = pu();
  pt(), ce.tokens[ce.tokens.length - 1].contextId = n, ce.tokens[ce.tokens.length - 1].isExpression = !t;
  let a = null;
  t || (a = ce.tokens.length, ce.scopeDepth++), WK(t, e), HK();
  const c = ce.tokens.length;
  if ($K(n), !ce.error && (ce.tokens[c].contextId = n, ce.tokens[ce.tokens.length - 1].contextId = n, a !== null)) {
    const u = ce.tokens.length;
    ce.scopes.push(new gs(a, u, !1)), ce.scopeDepth--;
  }
}
function VC() {
  return ke(L.eq) || ke(L.semi) || ke(L.braceR) || ke(L.bang) || ke(L.colon);
}
function WC() {
  return ke(L.parenL) || ke(L.lessThan);
}
function $K(t) {
  for (dt(L.braceL); !it(L.braceR) && !ce.error; ) {
    if (it(L.semi))
      continue;
    if (ke(L.at)) {
      BC();
      continue;
    }
    const e = ce.start;
    UK(e, t);
  }
}
function UK(t, e) {
  rr && Vb([
    Fe._declare,
    Fe._public,
    Fe._protected,
    Fe._private,
    Fe._override
  ]);
  let n = !1;
  if (ke(L.name) && ce.contextualKeyword === Fe._static) {
    if ($t(), WC()) {
      ql(
        t,
        /* isConstructor */
        !1
      );
      return;
    } else if (VC()) {
      vf();
      return;
    }
    if (ce.tokens[ce.tokens.length - 1].type = L._static, n = !0, ke(L.braceL)) {
      ce.tokens[ce.tokens.length - 1].contextId = e, aa();
      return;
    }
  }
  VK(t, n, e);
}
function VK(t, e, n) {
  if (rr && FG(e))
    return;
  if (it(L.star)) {
    Bl(n), ql(
      t,
      /* isConstructor */
      !1
    );
    return;
  }
  Bl(n);
  let a = !1;
  const c = ce.tokens[ce.tokens.length - 1];
  c.contextualKeyword === Fe._constructor && (a = !0), ES(), WC() ? ql(t, a) : VC() ? vf() : c.contextualKeyword === Fe._async && !ss() ? (ce.tokens[ce.tokens.length - 1].type = L._async, ke(L.star) && pt(), Bl(n), ES(), ql(
    t,
    !1
    /* isConstructor */
  )) : (c.contextualKeyword === Fe._get || c.contextualKeyword === Fe._set) && !(ss() && ke(L.star)) ? (c.contextualKeyword === Fe._get ? ce.tokens[ce.tokens.length - 1].type = L._get : ce.tokens[ce.tokens.length - 1].type = L._set, Bl(n), ql(
    t,
    /* isConstructor */
    !1
  )) : c.contextualKeyword === Fe._accessor && !ss() ? (Bl(n), vf()) : ss() ? vf() : Gt();
}
function ql(t, e) {
  rr ? to() : or && ke(L.lessThan) && Gi(), w0(t, e);
}
function Bl(t) {
  yu(t);
}
function ES() {
  if (rr) {
    const t = Kt(0);
    it(L.question), zt(t);
  }
}
function vf() {
  if (rr ? (zP(L.bang), dl()) : or && ke(L.colon) && ro(), ke(L.eq)) {
    const t = ce.tokens.length;
    pt(), dn(), ce.tokens[t].rhsEndIndex = ce.tokens.length;
  }
  Tr();
}
function WK(t, e = !1) {
  rr && (!t || e) && Dt(Fe._implements) || (ke(L.name) && ba(!0), rr ? to() : or && ke(L.lessThan) && Gi());
}
function HK() {
  let t = !1;
  it(L._extends) ? (xC(), t = !0) : t = !1, rr ? UG(t) : or && iK(t);
}
function HC() {
  const t = ce.tokens.length - 1;
  rr && NG() || (KK() ? YK() : zK() ? ($t(), ke(L.comma) && kr() === L.star ? (dt(L.comma), dt(L.star), Br(Fe._as), $t()) : qC(), gu()) : it(L._default) ? qK() : JK() ? GK() : (lg(), gu()), ce.tokens[t].rhsEndIndex = ce.tokens.length);
}
function qK() {
  if (rr && LG() || or && Jz())
    return;
  const t = ce.start;
  it(L._function) ? Ga(t, !0, !0) : Dt(Fe._async) && kr() === L._function ? (Jr(Fe._async), it(L._function), Ga(t, !0, !0)) : ke(L._class) ? za(!0, !0) : ke(L.at) ? (og(), za(!0, !0)) : (dn(), Tr());
}
function GK() {
  rr ? $G() : or ? tK() : Zn(!0);
}
function zK() {
  if (rr && EC())
    return !1;
  if (or && eK())
    return !1;
  if (ke(L.name))
    return ce.contextualKeyword !== Fe._async;
  if (!ke(L._default))
    return !1;
  const t = Fb(), e = ec(), n = e.type === L.name && e.contextualKeyword === Fe._from;
  if (e.type === L.comma)
    return !0;
  if (n) {
    const a = _t.charCodeAt(KP(t + 4));
    return a === Ge.quotationMark || a === Ge.apostrophe;
  }
  return !1;
}
function qC() {
  it(L.comma) && lg();
}
function gu() {
  Jr(Fe._from) && (Us(), zC()), Tr();
}
function KK() {
  return or ? rK() : ke(L.star);
}
function YK() {
  or ? nK() : x0();
}
function x0() {
  dt(L.star), Dt(Fe._as) ? XK() : gu();
}
function XK() {
  pt(), ce.tokens[ce.tokens.length - 1].type = L._as, $t(), qC(), gu();
}
function JK() {
  return rr && EC() || or && Zz() || ce.type === L._var || ce.type === L._const || ce.type === L._let || ce.type === L._function || ce.type === L._class || Dt(Fe._async) || ke(L.at);
}
function lg() {
  let t = !0;
  for (dt(L.braceL); !it(L.braceR) && !ce.error; ) {
    if (t)
      t = !1;
    else if (dt(L.comma), it(L.braceR))
      break;
    QK();
  }
}
function QK() {
  if (rr) {
    MG();
    return;
  }
  $t(), ce.tokens[ce.tokens.length - 1].identifierRole = jt.ExportAccess, Jr(Fe._as) && $t();
}
function ZK() {
  const t = ce.snapshot();
  return Br(Fe._module), Jr(Fe._from) ? Dt(Fe._from) ? (ce.restoreFromSnapshot(t), !0) : (ce.restoreFromSnapshot(t), !1) : ke(L.comma) ? (ce.restoreFromSnapshot(t), !1) : (ce.restoreFromSnapshot(t), !0);
}
function eY() {
  Dt(Fe._module) && ZK() && pt();
}
function GC() {
  if (rr && ke(L.name) && kr() === L.eq) {
    E0();
    return;
  }
  if (rr && Dt(Fe._type)) {
    const t = ec();
    if (t.type === L.name && t.contextualKeyword !== Fe._from) {
      if (Br(Fe._type), kr() === L.eq) {
        E0();
        return;
      }
    } else
      (t.type === L.star || t.type === L.braceL) && Br(Fe._type);
  }
  ke(L.string) || (eY(), rY(), Br(Fe._from)), Us(), zC(), Tr();
}
function tY() {
  return ke(L.name);
}
function _S() {
  zf();
}
function rY() {
  or && oK();
  let t = !0;
  if (!(tY() && (_S(), !it(L.comma)))) {
    if (ke(L.star)) {
      pt(), Br(Fe._as), _S();
      return;
    }
    for (dt(L.braceL); !it(L.braceR) && !ce.error; ) {
      if (t)
        t = !1;
      else if (it(L.colon) && Gt(
        "ES2015 named imports do not destructure. Use another statement for destructuring after the import."
      ), dt(L.comma), it(L.braceR))
        break;
      nY();
    }
  }
}
function nY() {
  if (rr) {
    RG();
    return;
  }
  if (or) {
    lK();
    return;
  }
  zf(), Dt(Fe._as) && (ce.tokens[ce.tokens.length - 1].identifierRole = jt.ImportAccess, pt(), zf());
}
function zC() {
  (ke(L._with) || Dt(Fe._assert) && !Rn()) && (pt(), Qb(!1, !1));
}
function iY() {
  return ce.pos === 0 && _t.charCodeAt(0) === Ge.numberSign && _t.charCodeAt(1) === Ge.exclamationMark && JP(2), XP(), vK();
}
class sY {
  constructor(e, n) {
    this.tokens = e, this.scopes = n;
  }
}
function aY(t, e, n, a) {
  if (a && n)
    throw new Error("Cannot combine flow and typescript plugins.");
  KH(t, e, n, a);
  const c = iY();
  if (ce.error)
    throw qH(ce.error);
  return c;
}
function oY(t) {
  let e = t.currentIndex(), n = 0;
  const a = t.currentToken();
  do {
    const c = t.tokens[e];
    if (c.isOptionalChainStart && n++, c.isOptionalChainEnd && n--, n += c.numNullishCoalesceStarts, n -= c.numNullishCoalesceEnds, c.contextualKeyword === Fe._await && c.identifierRole == null && c.scopeDepth === a.scopeDepth)
      return !0;
    e += 1;
  } while (n > 0 && e < t.tokens.length);
  return !1;
}
class eu {
  __init() {
    this.resultCode = "";
  }
  // Array mapping input token index to optional string index position in the
  // output code.
  __init2() {
    this.resultMappings = new Array(this.tokens.length);
  }
  __init3() {
    this.tokenIndex = 0;
  }
  constructor(e, n, a, c, u) {
    this.code = e, this.tokens = n, this.isFlowEnabled = a, this.disableESTransforms = c, this.helperManager = u, eu.prototype.__init.call(this), eu.prototype.__init2.call(this), eu.prototype.__init3.call(this);
  }
  /**
   * Snapshot the token state in a way that can be restored later, useful for
   * things like lookahead.
   *
   * resultMappings do not need to be copied since in all use cases, they will
   * be overwritten anyway after restore.
   */
  snapshot() {
    return {
      resultCode: this.resultCode,
      tokenIndex: this.tokenIndex
    };
  }
  restoreToSnapshot(e) {
    this.resultCode = e.resultCode, this.tokenIndex = e.tokenIndex;
  }
  /**
   * Remove and return the code generated since the snapshot, leaving the
   * current token position in-place. Unlike most TokenProcessor operations,
   * this operation can result in input/output line number mismatches because
   * the removed code may contain newlines, so this operation should be used
   * sparingly.
   */
  dangerouslyGetAndRemoveCodeSinceSnapshot(e) {
    const n = this.resultCode.slice(e.resultCode.length);
    return this.resultCode = e.resultCode, n;
  }
  reset() {
    this.resultCode = "", this.resultMappings = new Array(this.tokens.length), this.tokenIndex = 0;
  }
  matchesContextualAtIndex(e, n) {
    return this.matches1AtIndex(e, L.name) && this.tokens[e].contextualKeyword === n;
  }
  identifierNameAtIndex(e) {
    return this.identifierNameForToken(this.tokens[e]);
  }
  identifierNameAtRelativeIndex(e) {
    return this.identifierNameForToken(this.tokenAtRelativeIndex(e));
  }
  identifierName() {
    return this.identifierNameForToken(this.currentToken());
  }
  identifierNameForToken(e) {
    return this.code.slice(e.start, e.end);
  }
  rawCodeForToken(e) {
    return this.code.slice(e.start, e.end);
  }
  stringValueAtIndex(e) {
    return this.stringValueForToken(this.tokens[e]);
  }
  stringValue() {
    return this.stringValueForToken(this.currentToken());
  }
  stringValueForToken(e) {
    return this.code.slice(e.start + 1, e.end - 1);
  }
  matches1AtIndex(e, n) {
    return this.tokens[e].type === n;
  }
  matches2AtIndex(e, n, a) {
    return this.tokens[e].type === n && this.tokens[e + 1].type === a;
  }
  matches3AtIndex(e, n, a, c) {
    return this.tokens[e].type === n && this.tokens[e + 1].type === a && this.tokens[e + 2].type === c;
  }
  matches1(e) {
    return this.tokens[this.tokenIndex].type === e;
  }
  matches2(e, n) {
    return this.tokens[this.tokenIndex].type === e && this.tokens[this.tokenIndex + 1].type === n;
  }
  matches3(e, n, a) {
    return this.tokens[this.tokenIndex].type === e && this.tokens[this.tokenIndex + 1].type === n && this.tokens[this.tokenIndex + 2].type === a;
  }
  matches4(e, n, a, c) {
    return this.tokens[this.tokenIndex].type === e && this.tokens[this.tokenIndex + 1].type === n && this.tokens[this.tokenIndex + 2].type === a && this.tokens[this.tokenIndex + 3].type === c;
  }
  matches5(e, n, a, c, u) {
    return this.tokens[this.tokenIndex].type === e && this.tokens[this.tokenIndex + 1].type === n && this.tokens[this.tokenIndex + 2].type === a && this.tokens[this.tokenIndex + 3].type === c && this.tokens[this.tokenIndex + 4].type === u;
  }
  matchesContextual(e) {
    return this.matchesContextualAtIndex(this.tokenIndex, e);
  }
  matchesContextIdAndLabel(e, n) {
    return this.matches1(e) && this.currentToken().contextId === n;
  }
  previousWhitespaceAndComments() {
    let e = this.code.slice(
      this.tokenIndex > 0 ? this.tokens[this.tokenIndex - 1].end : 0,
      this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex].start : this.code.length
    );
    return this.isFlowEnabled && (e = e.replace(/@flow/g, "")), e;
  }
  replaceToken(e) {
    this.resultCode += this.previousWhitespaceAndComments(), this.appendTokenPrefix(), this.resultMappings[this.tokenIndex] = this.resultCode.length, this.resultCode += e, this.appendTokenSuffix(), this.tokenIndex++;
  }
  replaceTokenTrimmingLeftWhitespace(e) {
    this.resultCode += this.previousWhitespaceAndComments().replace(/[^\r\n]/g, ""), this.appendTokenPrefix(), this.resultMappings[this.tokenIndex] = this.resultCode.length, this.resultCode += e, this.appendTokenSuffix(), this.tokenIndex++;
  }
  removeInitialToken() {
    this.replaceToken("");
  }
  removeToken() {
    this.replaceTokenTrimmingLeftWhitespace("");
  }
  /**
   * Remove all code until the next }, accounting for balanced braces.
   */
  removeBalancedCode() {
    let e = 0;
    for (; !this.isAtEnd(); ) {
      if (this.matches1(L.braceL))
        e++;
      else if (this.matches1(L.braceR)) {
        if (e === 0)
          return;
        e--;
      }
      this.removeToken();
    }
  }
  copyExpectedToken(e) {
    if (this.tokens[this.tokenIndex].type !== e)
      throw new Error(`Expected token ${e}`);
    this.copyToken();
  }
  copyToken() {
    this.resultCode += this.previousWhitespaceAndComments(), this.appendTokenPrefix(), this.resultMappings[this.tokenIndex] = this.resultCode.length, this.resultCode += this.code.slice(
      this.tokens[this.tokenIndex].start,
      this.tokens[this.tokenIndex].end
    ), this.appendTokenSuffix(), this.tokenIndex++;
  }
  copyTokenWithPrefix(e) {
    this.resultCode += this.previousWhitespaceAndComments(), this.appendTokenPrefix(), this.resultCode += e, this.resultMappings[this.tokenIndex] = this.resultCode.length, this.resultCode += this.code.slice(
      this.tokens[this.tokenIndex].start,
      this.tokens[this.tokenIndex].end
    ), this.appendTokenSuffix(), this.tokenIndex++;
  }
  appendTokenPrefix() {
    const e = this.currentToken();
    if ((e.numNullishCoalesceStarts || e.isOptionalChainStart) && (e.isAsyncOperation = oY(this)), !this.disableESTransforms) {
      if (e.numNullishCoalesceStarts)
        for (let n = 0; n < e.numNullishCoalesceStarts; n++)
          e.isAsyncOperation ? (this.resultCode += "await ", this.resultCode += this.helperManager.getHelperName("asyncNullishCoalesce")) : this.resultCode += this.helperManager.getHelperName("nullishCoalesce"), this.resultCode += "(";
      e.isOptionalChainStart && (e.isAsyncOperation && (this.resultCode += "await "), this.tokenIndex > 0 && this.tokenAtRelativeIndex(-1).type === L._delete ? e.isAsyncOperation ? this.resultCode += this.helperManager.getHelperName("asyncOptionalChainDelete") : this.resultCode += this.helperManager.getHelperName("optionalChainDelete") : e.isAsyncOperation ? this.resultCode += this.helperManager.getHelperName("asyncOptionalChain") : this.resultCode += this.helperManager.getHelperName("optionalChain"), this.resultCode += "([");
    }
  }
  appendTokenSuffix() {
    const e = this.currentToken();
    if (e.isOptionalChainEnd && !this.disableESTransforms && (this.resultCode += "])"), e.numNullishCoalesceEnds && !this.disableESTransforms)
      for (let n = 0; n < e.numNullishCoalesceEnds; n++)
        this.resultCode += "))";
  }
  appendCode(e) {
    this.resultCode += e;
  }
  currentToken() {
    return this.tokens[this.tokenIndex];
  }
  currentTokenCode() {
    const e = this.currentToken();
    return this.code.slice(e.start, e.end);
  }
  tokenAtRelativeIndex(e) {
    return this.tokens[this.tokenIndex + e];
  }
  currentIndex() {
    return this.tokenIndex;
  }
  /**
   * Move to the next token. Only suitable in preprocessing steps. When
   * generating new code, you should use copyToken or removeToken.
   */
  nextToken() {
    if (this.tokenIndex === this.tokens.length)
      throw new Error("Unexpectedly reached end of input.");
    this.tokenIndex++;
  }
  previousToken() {
    this.tokenIndex--;
  }
  finish() {
    if (this.tokenIndex !== this.tokens.length)
      throw new Error("Tried to finish processing tokens before reaching the end.");
    return this.resultCode += this.previousWhitespaceAndComments(), { code: this.resultCode, mappings: this.resultMappings };
  }
  isAtEnd() {
    return this.tokenIndex === this.tokens.length;
  }
}
function lY(t, e, n, a) {
  const c = e.snapshot(), u = uY(e);
  let r = [];
  const l = [], i = [];
  let f = null;
  const d = [], s = [], o = e.currentToken().contextId;
  if (o == null)
    throw new Error("Expected non-null class context ID on class open-brace.");
  for (e.nextToken(); !e.matchesContextIdAndLabel(L.braceR, o); )
    if (e.matchesContextual(Fe._constructor) && !e.currentToken().isType)
      ({ constructorInitializerStatements: r, constructorInsertPos: f } = SS(e));
    else if (e.matches1(L.semi))
      a || s.push({ start: e.currentIndex(), end: e.currentIndex() + 1 }), e.nextToken();
    else if (e.currentToken().isType)
      e.nextToken();
    else {
      const m = e.currentIndex();
      let h = !1, y = !1, b = !1;
      for (; Zf(e.currentToken()); )
        e.matches1(L._static) && (h = !0), e.matches1(L.hash) && (y = !0), (e.matches1(L._declare) || e.matches1(L._abstract)) && (b = !0), e.nextToken();
      if (h && e.matches1(L.braceL)) {
        Pm(e, o);
        continue;
      }
      if (y) {
        Pm(e, o);
        continue;
      }
      if (e.matchesContextual(Fe._constructor) && !e.currentToken().isType) {
        ({ constructorInitializerStatements: r, constructorInsertPos: f } = SS(e));
        continue;
      }
      const E = e.currentIndex();
      if (cY(e), e.matches1(L.lessThan) || e.matches1(L.parenL)) {
        Pm(e, o);
        continue;
      }
      for (; e.currentToken().isType; )
        e.nextToken();
      if (e.matches1(L.eq)) {
        const S = e.currentIndex(), g = e.currentToken().rhsEndIndex;
        if (g == null)
          throw new Error("Expected rhsEndIndex on class field assignment.");
        for (e.nextToken(); e.currentIndex() < g; )
          t.processToken();
        let P;
        h ? (P = n.claimFreeName("__initStatic"), i.push(P)) : (P = n.claimFreeName("__init"), l.push(P)), d.push({
          initializerName: P,
          equalsIndex: S,
          start: E,
          end: e.currentIndex()
        });
      } else
        (!a || b) && s.push({ start: m, end: e.currentIndex() });
    }
  return e.restoreToSnapshot(c), a ? {
    headerInfo: u,
    constructorInitializerStatements: r,
    instanceInitializerNames: [],
    staticInitializerNames: [],
    constructorInsertPos: f,
    fields: [],
    rangesToRemove: s
  } : {
    headerInfo: u,
    constructorInitializerStatements: r,
    instanceInitializerNames: l,
    staticInitializerNames: i,
    constructorInsertPos: f,
    fields: d,
    rangesToRemove: s
  };
}
function Pm(t, e) {
  for (t.nextToken(); t.currentToken().contextId !== e; )
    t.nextToken();
  for (; Zf(t.tokenAtRelativeIndex(-1)); )
    t.previousToken();
}
function uY(t) {
  const e = t.currentToken(), n = e.contextId;
  if (n == null)
    throw new Error("Expected context ID on class token.");
  const a = e.isExpression;
  if (a == null)
    throw new Error("Expected isExpression on class token.");
  let c = null, u = !1;
  for (t.nextToken(), t.matches1(L.name) && (c = t.identifierName()); !t.matchesContextIdAndLabel(L.braceL, n); )
    t.matches1(L._extends) && !t.currentToken().isType && (u = !0), t.nextToken();
  return { isExpression: a, className: c, hasSuperclass: u };
}
function SS(t) {
  const e = [];
  t.nextToken();
  const n = t.currentToken().contextId;
  if (n == null)
    throw new Error("Expected context ID on open-paren starting constructor params.");
  for (; !t.matchesContextIdAndLabel(L.parenR, n); )
    if (t.currentToken().contextId === n) {
      if (t.nextToken(), Zf(t.currentToken())) {
        for (t.nextToken(); Zf(t.currentToken()); )
          t.nextToken();
        const u = t.currentToken();
        if (u.type !== L.name)
          throw new Error("Expected identifier after access modifiers in constructor arg.");
        const r = t.identifierNameForToken(u);
        e.push(`this.${r} = ${r}`);
      }
    } else
      t.nextToken();
  for (t.nextToken(); t.currentToken().isType; )
    t.nextToken();
  let a = t.currentIndex(), c = !1;
  for (; !t.matchesContextIdAndLabel(L.braceR, n); ) {
    if (!c && t.matches2(L._super, L.parenL)) {
      t.nextToken();
      const u = t.currentToken().contextId;
      if (u == null)
        throw new Error("Expected a context ID on the super call");
      for (; !t.matchesContextIdAndLabel(L.parenR, u); )
        t.nextToken();
      a = t.currentIndex(), c = !0;
    }
    t.nextToken();
  }
  return t.nextToken(), { constructorInitializerStatements: e, constructorInsertPos: a };
}
function Zf(t) {
  return [
    L._async,
    L._get,
    L._set,
    L.plus,
    L.minus,
    L._readonly,
    L._static,
    L._public,
    L._private,
    L._protected,
    L._override,
    L._abstract,
    L.star,
    L._declare,
    L.hash
  ].includes(t.type);
}
function cY(t) {
  if (t.matches1(L.bracketL)) {
    const n = t.currentToken().contextId;
    if (n == null)
      throw new Error("Expected class context ID on computed name open bracket.");
    for (; !t.matchesContextIdAndLabel(L.bracketR, n); )
      t.nextToken();
    t.nextToken();
  } else
    t.nextToken();
}
function KC(t) {
  if (t.removeInitialToken(), t.removeToken(), t.removeToken(), t.removeToken(), t.matches1(L.parenL))
    t.removeToken(), t.removeToken(), t.removeToken();
  else
    for (; t.matches1(L.dot); )
      t.removeToken(), t.removeToken();
}
const YC = {
  typeDeclarations: /* @__PURE__ */ new Set(),
  valueDeclarations: /* @__PURE__ */ new Set()
};
function XC(t) {
  const e = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set();
  for (let a = 0; a < t.tokens.length; a++) {
    const c = t.tokens[a];
    c.type === L.name && GP(c) && (c.isType ? e.add(t.identifierNameForToken(c)) : n.add(t.identifierNameForToken(c)));
  }
  return { typeDeclarations: e, valueDeclarations: n };
}
function JC(t) {
  let e = t.currentIndex();
  for (; !t.matches1AtIndex(e, L.braceR); )
    e++;
  return t.matchesContextualAtIndex(e + 1, Fe._from) && t.matches1AtIndex(e + 2, L.string);
}
function La(t) {
  (t.matches2(L._with, L.braceL) || t.matches2(L.name, L.braceL) && t.matchesContextual(Fe._assert)) && (t.removeToken(), t.removeToken(), t.removeBalancedCode(), t.removeToken());
}
function QC(t, e, n, a) {
  if (!t || e)
    return !1;
  const c = n.currentToken();
  if (c.rhsEndIndex == null)
    throw new Error("Expected non-null rhsEndIndex on export token.");
  const u = c.rhsEndIndex - n.currentIndex();
  if (u !== 3 && !(u === 4 && n.matches1AtIndex(c.rhsEndIndex - 1, L.semi)))
    return !1;
  const r = n.tokenAtRelativeIndex(2);
  if (r.type !== L.name)
    return !1;
  const l = n.identifierNameForToken(r);
  return a.typeDeclarations.has(l) && !a.valueDeclarations.has(l);
}
class tu extends qi {
  __init() {
    this.hadExport = !1;
  }
  __init2() {
    this.hadNamedExport = !1;
  }
  __init3() {
    this.hadDefaultExport = !1;
  }
  constructor(e, n, a, c, u, r, l, i, f, d, s, o) {
    super(), this.rootTransformer = e, this.tokens = n, this.importProcessor = a, this.nameManager = c, this.helperManager = u, this.reactHotLoaderTransformer = r, this.enableLegacyBabel5ModuleInterop = l, this.enableLegacyTypeScriptModuleInterop = i, this.isTypeScriptTransformEnabled = f, this.isFlowTransformEnabled = d, this.preserveDynamicImport = s, this.keepUnusedImports = o, tu.prototype.__init.call(this), tu.prototype.__init2.call(this), tu.prototype.__init3.call(this), this.declarationInfo = f ? XC(n) : YC;
  }
  getPrefixCode() {
    let e = "";
    return this.hadExport && (e += 'Object.defineProperty(exports, "__esModule", {value: true});'), e;
  }
  getSuffixCode() {
    return this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport ? `
module.exports = exports.default;
` : "";
  }
  process() {
    return this.tokens.matches3(L._import, L.name, L.eq) ? this.processImportEquals() : this.tokens.matches1(L._import) ? (this.processImport(), !0) : this.tokens.matches2(L._export, L.eq) ? (this.tokens.replaceToken("module.exports"), !0) : this.tokens.matches1(L._export) && !this.tokens.currentToken().isType ? (this.hadExport = !0, this.processExport()) : this.tokens.matches2(L.name, L.postIncDec) && this.processPostIncDec() ? !0 : this.tokens.matches1(L.name) || this.tokens.matches1(L.jsxName) ? this.processIdentifier() : this.tokens.matches1(L.eq) ? this.processAssignment() : this.tokens.matches1(L.assign) ? this.processComplexAssignment() : this.tokens.matches1(L.preIncDec) ? this.processPreIncDec() : !1;
  }
  processImportEquals() {
    const e = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    return this.importProcessor.shouldAutomaticallyElideImportedName(e) ? KC(this.tokens) : this.tokens.replaceToken("const"), !0;
  }
  /**
   * Transform this:
   * import foo, {bar} from 'baz';
   * into
   * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);
   *
   * The import code was already generated in the import preprocessing step, so
   * we just need to look it up.
   */
  processImport() {
    if (this.tokens.matches2(L._import, L.parenL)) {
      if (this.preserveDynamicImport) {
        this.tokens.copyToken();
        return;
      }
      const n = this.enableLegacyTypeScriptModuleInterop ? "" : `${this.helperManager.getHelperName("interopRequireWildcard")}(`;
      this.tokens.replaceToken(`Promise.resolve().then(() => ${n}require`);
      const a = this.tokens.currentToken().contextId;
      if (a == null)
        throw new Error("Expected context ID on dynamic import invocation.");
      for (this.tokens.copyToken(); !this.tokens.matchesContextIdAndLabel(L.parenR, a); )
        this.rootTransformer.processToken();
      this.tokens.replaceToken(n ? ")))" : "))");
      return;
    }
    if (this.removeImportAndDetectIfShouldElide())
      this.tokens.removeToken();
    else {
      const n = this.tokens.stringValue();
      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(n)), this.tokens.appendCode(this.importProcessor.claimImportCode(n));
    }
    La(this.tokens), this.tokens.matches1(L.semi) && this.tokens.removeToken();
  }
  /**
   * Erase this import (since any CJS output would be completely different), and
   * return true if this import is should be elided due to being a type-only
   * import. Such imports will not be emitted at all to avoid side effects.
   *
   * Import elision only happens with the TypeScript or Flow transforms enabled.
   *
   * TODO: This function has some awkward overlap with
   *  CJSImportProcessor.pruneTypeOnlyImports , and the two should be unified.
   *  That function handles TypeScript implicit import name elision, and removes
   *  an import if all typical imported names (without `type`) are removed due
   *  to being type-only imports. This function handles Flow import removal and
   *  properly distinguishes `import 'foo'` from `import {} from 'foo'` for TS
   *  purposes.
   *
   * The position should end at the import string.
   */
  removeImportAndDetectIfShouldElide() {
    if (this.tokens.removeInitialToken(), this.tokens.matchesContextual(Fe._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, L.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, Fe._from))
      return this.removeRemainingImport(), !0;
    if (this.tokens.matches1(L.name) || this.tokens.matches1(L.star))
      return this.removeRemainingImport(), !1;
    if (this.tokens.matches1(L.string))
      return !1;
    let e = !1, n = !1;
    for (; !this.tokens.matches1(L.string); )
      (!e && this.tokens.matches1(L.braceL) || this.tokens.matches1(L.comma)) && (this.tokens.removeToken(), this.tokens.matches1(L.braceR) || (n = !0), (this.tokens.matches2(L.name, L.comma) || this.tokens.matches2(L.name, L.braceR) || this.tokens.matches4(L.name, L.name, L.name, L.comma) || this.tokens.matches4(L.name, L.name, L.name, L.braceR)) && (e = !0)), this.tokens.removeToken();
    return this.keepUnusedImports ? !1 : this.isTypeScriptTransformEnabled ? !e : this.isFlowTransformEnabled ? n && !e : !1;
  }
  removeRemainingImport() {
    for (; !this.tokens.matches1(L.string); )
      this.tokens.removeToken();
  }
  processIdentifier() {
    const e = this.tokens.currentToken();
    if (e.shadowsGlobal)
      return !1;
    if (e.identifierRole === jt.ObjectShorthand)
      return this.processObjectShorthand();
    if (e.identifierRole !== jt.Access)
      return !1;
    const n = this.importProcessor.getIdentifierReplacement(
      this.tokens.identifierNameForToken(e)
    );
    if (!n)
      return !1;
    let a = this.tokens.currentIndex() + 1;
    for (; a < this.tokens.tokens.length && this.tokens.tokens[a].type === L.parenR; )
      a++;
    return this.tokens.tokens[a].type === L.parenL ? this.tokens.tokenAtRelativeIndex(1).type === L.parenL && this.tokens.tokenAtRelativeIndex(-1).type !== L._new ? (this.tokens.replaceToken(`${n}.call(void 0, `), this.tokens.removeToken(), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(L.parenR)) : this.tokens.replaceToken(`(0, ${n})`) : this.tokens.replaceToken(n), !0;
  }
  processObjectShorthand() {
    const e = this.tokens.identifierName(), n = this.importProcessor.getIdentifierReplacement(e);
    return n ? (this.tokens.replaceToken(`${e}: ${n}`), !0) : !1;
  }
  processExport() {
    if (this.tokens.matches2(L._export, L._enum) || this.tokens.matches3(L._export, L._const, L._enum))
      return this.hadNamedExport = !0, !1;
    if (this.tokens.matches2(L._export, L._default))
      return this.tokens.matches3(L._export, L._default, L._enum) ? (this.hadDefaultExport = !0, !1) : (this.processExportDefault(), !0);
    if (this.tokens.matches2(L._export, L.braceL))
      return this.processExportBindings(), !0;
    if (this.tokens.matches2(L._export, L.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, Fe._type)) {
      if (this.tokens.removeInitialToken(), this.tokens.removeToken(), this.tokens.matches1(L.braceL)) {
        for (; !this.tokens.matches1(L.braceR); )
          this.tokens.removeToken();
        this.tokens.removeToken();
      } else
        this.tokens.removeToken(), this.tokens.matches1(L._as) && (this.tokens.removeToken(), this.tokens.removeToken());
      return this.tokens.matchesContextual(Fe._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, L.string) && (this.tokens.removeToken(), this.tokens.removeToken(), La(this.tokens)), !0;
    }
    if (this.hadNamedExport = !0, this.tokens.matches2(L._export, L._var) || this.tokens.matches2(L._export, L._let) || this.tokens.matches2(L._export, L._const))
      return this.processExportVar(), !0;
    if (this.tokens.matches2(L._export, L._function) || // export async function
    this.tokens.matches3(L._export, L.name, L._function))
      return this.processExportFunction(), !0;
    if (this.tokens.matches2(L._export, L._class) || this.tokens.matches3(L._export, L._abstract, L._class) || this.tokens.matches2(L._export, L.at))
      return this.processExportClass(), !0;
    if (this.tokens.matches2(L._export, L.star))
      return this.processExportStar(), !0;
    throw new Error("Unrecognized export syntax.");
  }
  processAssignment() {
    const e = this.tokens.currentIndex(), n = this.tokens.tokens[e - 1];
    if (n.isType || n.type !== L.name || n.shadowsGlobal || e >= 2 && this.tokens.matches1AtIndex(e - 2, L.dot) || e >= 2 && [L._var, L._let, L._const].includes(this.tokens.tokens[e - 2].type))
      return !1;
    const a = this.importProcessor.resolveExportBinding(
      this.tokens.identifierNameForToken(n)
    );
    return a ? (this.tokens.copyToken(), this.tokens.appendCode(` ${a} =`), !0) : !1;
  }
  /**
   * Process something like `a += 3`, where `a` might be an exported value.
   */
  processComplexAssignment() {
    const e = this.tokens.currentIndex(), n = this.tokens.tokens[e - 1];
    if (n.type !== L.name || n.shadowsGlobal || e >= 2 && this.tokens.matches1AtIndex(e - 2, L.dot))
      return !1;
    const a = this.importProcessor.resolveExportBinding(
      this.tokens.identifierNameForToken(n)
    );
    return a ? (this.tokens.appendCode(` = ${a}`), this.tokens.copyToken(), !0) : !1;
  }
  /**
   * Process something like `++a`, where `a` might be an exported value.
   */
  processPreIncDec() {
    const e = this.tokens.currentIndex(), n = this.tokens.tokens[e + 1];
    if (n.type !== L.name || n.shadowsGlobal || e + 2 < this.tokens.tokens.length && (this.tokens.matches1AtIndex(e + 2, L.dot) || this.tokens.matches1AtIndex(e + 2, L.bracketL) || this.tokens.matches1AtIndex(e + 2, L.parenL)))
      return !1;
    const a = this.tokens.identifierNameForToken(n), c = this.importProcessor.resolveExportBinding(a);
    return c ? (this.tokens.appendCode(`${c} = `), this.tokens.copyToken(), !0) : !1;
  }
  /**
   * Process something like `a++`, where `a` might be an exported value.
   * This starts at the `a`, not at the `++`.
   */
  processPostIncDec() {
    const e = this.tokens.currentIndex(), n = this.tokens.tokens[e], a = this.tokens.tokens[e + 1];
    if (n.type !== L.name || n.shadowsGlobal || e >= 1 && this.tokens.matches1AtIndex(e - 1, L.dot))
      return !1;
    const c = this.tokens.identifierNameForToken(n), u = this.importProcessor.resolveExportBinding(c);
    if (!u)
      return !1;
    const r = this.tokens.rawCodeForToken(a), l = this.importProcessor.getIdentifierReplacement(c) || c;
    if (r === "++")
      this.tokens.replaceToken(`(${l} = ${u} = ${l} + 1, ${l} - 1)`);
    else if (r === "--")
      this.tokens.replaceToken(`(${l} = ${u} = ${l} - 1, ${l} + 1)`);
    else
      throw new Error(`Unexpected operator: ${r}`);
    return this.tokens.removeToken(), !0;
  }
  processExportDefault() {
    let e = !0;
    if (this.tokens.matches4(L._export, L._default, L._function, L.name) || // export default async function
    this.tokens.matches5(L._export, L._default, L.name, L._function, L.name) && this.tokens.matchesContextualAtIndex(
      this.tokens.currentIndex() + 2,
      Fe._async
    )) {
      this.tokens.removeInitialToken(), this.tokens.removeToken();
      const n = this.processNamedFunction();
      this.tokens.appendCode(` exports.default = ${n};`);
    } else if (this.tokens.matches4(L._export, L._default, L._class, L.name) || this.tokens.matches5(L._export, L._default, L._abstract, L._class, L.name) || this.tokens.matches3(L._export, L._default, L.at)) {
      this.tokens.removeInitialToken(), this.tokens.removeToken(), this.copyDecorators(), this.tokens.matches1(L._abstract) && this.tokens.removeToken();
      const n = this.rootTransformer.processNamedClass();
      this.tokens.appendCode(` exports.default = ${n};`);
    } else if (QC(
      this.isTypeScriptTransformEnabled,
      this.keepUnusedImports,
      this.tokens,
      this.declarationInfo
    ))
      e = !1, this.tokens.removeInitialToken(), this.tokens.removeToken(), this.tokens.removeToken();
    else if (this.reactHotLoaderTransformer) {
      const n = this.nameManager.claimFreeName("_default");
      this.tokens.replaceToken(`let ${n}; exports.`), this.tokens.copyToken(), this.tokens.appendCode(` = ${n} =`), this.reactHotLoaderTransformer.setExtractedDefaultExportName(n);
    } else
      this.tokens.replaceToken("exports."), this.tokens.copyToken(), this.tokens.appendCode(" =");
    e && (this.hadDefaultExport = !0);
  }
  copyDecorators() {
    for (; this.tokens.matches1(L.at); )
      if (this.tokens.copyToken(), this.tokens.matches1(L.parenL))
        this.tokens.copyExpectedToken(L.parenL), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(L.parenR);
      else {
        for (this.tokens.copyExpectedToken(L.name); this.tokens.matches1(L.dot); )
          this.tokens.copyExpectedToken(L.dot), this.tokens.copyExpectedToken(L.name);
        this.tokens.matches1(L.parenL) && (this.tokens.copyExpectedToken(L.parenL), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(L.parenR));
      }
  }
  /**
   * Transform a declaration like `export var`, `export let`, or `export const`.
   */
  processExportVar() {
    this.isSimpleExportVar() ? this.processSimpleExportVar() : this.processComplexExportVar();
  }
  /**
   * Determine if the export is of the form:
   * export var/let/const [varName] = [expr];
   * In other words, determine if function name inference might apply.
   */
  isSimpleExportVar() {
    let e = this.tokens.currentIndex();
    if (e++, e++, !this.tokens.matches1AtIndex(e, L.name))
      return !1;
    for (e++; e < this.tokens.tokens.length && this.tokens.tokens[e].isType; )
      e++;
    return !!this.tokens.matches1AtIndex(e, L.eq);
  }
  /**
   * Transform an `export var` declaration initializing a single variable.
   *
   * For example, this:
   * export const f = () => {};
   * becomes this:
   * const f = () => {}; exports.f = f;
   *
   * The variable is unused (e.g. exports.f has the true value of the export).
   * We need to produce an assignment of this form so that the function will
   * have an inferred name of "f", which wouldn't happen in the more general
   * case below.
   */
  processSimpleExportVar() {
    this.tokens.removeInitialToken(), this.tokens.copyToken();
    const e = this.tokens.identifierName();
    for (; !this.tokens.matches1(L.eq); )
      this.rootTransformer.processToken();
    const n = this.tokens.currentToken().rhsEndIndex;
    if (n == null)
      throw new Error("Expected = token with an end index.");
    for (; this.tokens.currentIndex() < n; )
      this.rootTransformer.processToken();
    this.tokens.appendCode(`; exports.${e} = ${e}`);
  }
  /**
   * Transform normal declaration exports, including handling destructuring.
   * For example, this:
   * export const {x: [a = 2, b], c} = d;
   * becomes this:
   * ({x: [exports.a = 2, exports.b], c: exports.c} = d;)
   */
  processComplexExportVar() {
    this.tokens.removeInitialToken(), this.tokens.removeToken();
    const e = this.tokens.matches1(L.braceL);
    e && this.tokens.appendCode("(");
    let n = 0;
    for (; ; )
      if (this.tokens.matches1(L.braceL) || this.tokens.matches1(L.dollarBraceL) || this.tokens.matches1(L.bracketL))
        n++, this.tokens.copyToken();
      else if (this.tokens.matches1(L.braceR) || this.tokens.matches1(L.bracketR))
        n--, this.tokens.copyToken();
      else {
        if (n === 0 && !this.tokens.matches1(L.name) && !this.tokens.currentToken().isType)
          break;
        if (this.tokens.matches1(L.eq)) {
          const a = this.tokens.currentToken().rhsEndIndex;
          if (a == null)
            throw new Error("Expected = token with an end index.");
          for (; this.tokens.currentIndex() < a; )
            this.rootTransformer.processToken();
        } else {
          const a = this.tokens.currentToken();
          if (qP(a)) {
            const c = this.tokens.identifierName();
            let u = this.importProcessor.getIdentifierReplacement(c);
            if (u === null)
              throw new Error(`Expected a replacement for ${c} in \`export var\` syntax.`);
            eq(a) && (u = `${c}: ${u}`), this.tokens.replaceToken(u);
          } else
            this.rootTransformer.processToken();
        }
      }
    if (e) {
      const a = this.tokens.currentToken().rhsEndIndex;
      if (a == null)
        throw new Error("Expected = token with an end index.");
      for (; this.tokens.currentIndex() < a; )
        this.rootTransformer.processToken();
      this.tokens.appendCode(")");
    }
  }
  /**
   * Transform this:
   * export function foo() {}
   * into this:
   * function foo() {} exports.foo = foo;
   */
  processExportFunction() {
    this.tokens.replaceToken("");
    const e = this.processNamedFunction();
    this.tokens.appendCode(` exports.${e} = ${e};`);
  }
  /**
   * Skip past a function with a name and return that name.
   */
  processNamedFunction() {
    if (this.tokens.matches1(L._function))
      this.tokens.copyToken();
    else if (this.tokens.matches2(L.name, L._function)) {
      if (!this.tokens.matchesContextual(Fe._async))
        throw new Error("Expected async keyword in function export.");
      this.tokens.copyToken(), this.tokens.copyToken();
    }
    if (this.tokens.matches1(L.star) && this.tokens.copyToken(), !this.tokens.matches1(L.name))
      throw new Error("Expected identifier for exported function name.");
    const e = this.tokens.identifierName();
    if (this.tokens.copyToken(), this.tokens.currentToken().isType)
      for (this.tokens.removeInitialToken(); this.tokens.currentToken().isType; )
        this.tokens.removeToken();
    return this.tokens.copyExpectedToken(L.parenL), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(L.parenR), this.rootTransformer.processPossibleTypeRange(), this.tokens.copyExpectedToken(L.braceL), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(L.braceR), e;
  }
  /**
   * Transform this:
   * export class A {}
   * into this:
   * class A {} exports.A = A;
   */
  processExportClass() {
    this.tokens.removeInitialToken(), this.copyDecorators(), this.tokens.matches1(L._abstract) && this.tokens.removeToken();
    const e = this.rootTransformer.processNamedClass();
    this.tokens.appendCode(` exports.${e} = ${e};`);
  }
  /**
   * Transform this:
   * export {a, b as c};
   * into this:
   * exports.a = a; exports.c = b;
   *
   * OR
   *
   * Transform this:
   * export {a, b as c} from './foo';
   * into the pre-generated Object.defineProperty code from the ImportProcessor.
   *
   * For the first case, if the TypeScript transform is enabled, we need to skip
   * exports that are only defined as types.
   */
  processExportBindings() {
    this.tokens.removeInitialToken(), this.tokens.removeToken();
    const e = JC(this.tokens), n = [];
    for (; ; ) {
      if (this.tokens.matches1(L.braceR)) {
        this.tokens.removeToken();
        break;
      }
      const a = hu(this.tokens);
      for (; this.tokens.currentIndex() < a.endIndex; )
        this.tokens.removeToken();
      if (!(a.isType || !e && this.shouldElideExportedIdentifier(a.leftName))) {
        const u = a.rightName;
        u === "default" ? this.hadDefaultExport = !0 : this.hadNamedExport = !0;
        const r = a.leftName, l = this.importProcessor.getIdentifierReplacement(r);
        n.push(`exports.${u} = ${l || r};`);
      }
      if (this.tokens.matches1(L.braceR)) {
        this.tokens.removeToken();
        break;
      }
      if (this.tokens.matches2(L.comma, L.braceR)) {
        this.tokens.removeToken(), this.tokens.removeToken();
        break;
      } else if (this.tokens.matches1(L.comma))
        this.tokens.removeToken();
      else
        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.currentToken())}`);
    }
    if (this.tokens.matchesContextual(Fe._from)) {
      this.tokens.removeToken();
      const a = this.tokens.stringValue();
      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(a)), La(this.tokens);
    } else
      this.tokens.appendCode(n.join(" "));
    this.tokens.matches1(L.semi) && this.tokens.removeToken();
  }
  processExportStar() {
    for (this.tokens.removeInitialToken(); !this.tokens.matches1(L.string); )
      this.tokens.removeToken();
    const e = this.tokens.stringValue();
    this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(e)), La(this.tokens), this.tokens.matches1(L.semi) && this.tokens.removeToken();
  }
  shouldElideExportedIdentifier(e) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.declarationInfo.valueDeclarations.has(e);
  }
}
class fY extends qi {
  constructor(e, n, a, c, u, r, l, i) {
    super(), this.tokens = e, this.nameManager = n, this.helperManager = a, this.reactHotLoaderTransformer = c, this.isTypeScriptTransformEnabled = u, this.isFlowTransformEnabled = r, this.keepUnusedImports = l, this.nonTypeIdentifiers = u && !l ? aC(e, i) : /* @__PURE__ */ new Set(), this.declarationInfo = u && !l ? XC(e) : YC, this.injectCreateRequireForImportRequire = !!i.injectCreateRequireForImportRequire;
  }
  process() {
    if (this.tokens.matches3(L._import, L.name, L.eq))
      return this.processImportEquals();
    if (this.tokens.matches4(L._import, L.name, L.name, L.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, Fe._type)) {
      this.tokens.removeInitialToken();
      for (let e = 0; e < 7; e++)
        this.tokens.removeToken();
      return !0;
    }
    if (this.tokens.matches2(L._export, L.eq))
      return this.tokens.replaceToken("module.exports"), !0;
    if (this.tokens.matches5(L._export, L._import, L.name, L.name, L.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, Fe._type)) {
      this.tokens.removeInitialToken();
      for (let e = 0; e < 8; e++)
        this.tokens.removeToken();
      return !0;
    }
    if (this.tokens.matches1(L._import))
      return this.processImport();
    if (this.tokens.matches2(L._export, L._default))
      return this.processExportDefault();
    if (this.tokens.matches2(L._export, L.braceL))
      return this.processNamedExports();
    if (this.tokens.matches2(L._export, L.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, Fe._type)) {
      if (this.tokens.removeInitialToken(), this.tokens.removeToken(), this.tokens.matches1(L.braceL)) {
        for (; !this.tokens.matches1(L.braceR); )
          this.tokens.removeToken();
        this.tokens.removeToken();
      } else
        this.tokens.removeToken(), this.tokens.matches1(L._as) && (this.tokens.removeToken(), this.tokens.removeToken());
      return this.tokens.matchesContextual(Fe._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, L.string) && (this.tokens.removeToken(), this.tokens.removeToken(), La(this.tokens)), !0;
    }
    return !1;
  }
  processImportEquals() {
    const e = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    return this.shouldAutomaticallyElideImportedName(e) ? KC(this.tokens) : this.injectCreateRequireForImportRequire ? (this.tokens.replaceToken("const"), this.tokens.copyToken(), this.tokens.copyToken(), this.tokens.replaceToken(this.helperManager.getHelperName("require"))) : this.tokens.replaceToken("const"), !0;
  }
  processImport() {
    if (this.tokens.matches2(L._import, L.parenL))
      return !1;
    const e = this.tokens.snapshot();
    if (this.removeImportTypeBindings()) {
      for (this.tokens.restoreToSnapshot(e); !this.tokens.matches1(L.string); )
        this.tokens.removeToken();
      this.tokens.removeToken(), La(this.tokens), this.tokens.matches1(L.semi) && this.tokens.removeToken();
    }
    return !0;
  }
  /**
   * Remove type bindings from this import, leaving the rest of the import intact.
   *
   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out
   * of the replacement operation, so we can return early here.
   */
  removeImportTypeBindings() {
    if (this.tokens.copyExpectedToken(L._import), this.tokens.matchesContextual(Fe._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, L.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, Fe._from))
      return !0;
    if (this.tokens.matches1(L.string))
      return this.tokens.copyToken(), !1;
    this.tokens.matchesContextual(Fe._module) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, Fe._from) && this.tokens.copyToken();
    let e = !1, n = !1, a = !1;
    if (this.tokens.matches1(L.name) && (this.shouldAutomaticallyElideImportedName(this.tokens.identifierName()) ? (this.tokens.removeToken(), this.tokens.matches1(L.comma) && this.tokens.removeToken()) : (e = !0, this.tokens.copyToken(), this.tokens.matches1(L.comma) && (a = !0, this.tokens.removeToken()))), this.tokens.matches1(L.star))
      this.shouldAutomaticallyElideImportedName(this.tokens.identifierNameAtRelativeIndex(2)) ? (this.tokens.removeToken(), this.tokens.removeToken(), this.tokens.removeToken()) : (a && this.tokens.appendCode(","), e = !0, this.tokens.copyExpectedToken(L.star), this.tokens.copyExpectedToken(L.name), this.tokens.copyExpectedToken(L.name));
    else if (this.tokens.matches1(L.braceL)) {
      for (a && this.tokens.appendCode(","), this.tokens.copyToken(); !this.tokens.matches1(L.braceR); ) {
        n = !0;
        const c = hu(this.tokens);
        if (c.isType || this.shouldAutomaticallyElideImportedName(c.rightName)) {
          for (; this.tokens.currentIndex() < c.endIndex; )
            this.tokens.removeToken();
          this.tokens.matches1(L.comma) && this.tokens.removeToken();
        } else {
          for (e = !0; this.tokens.currentIndex() < c.endIndex; )
            this.tokens.copyToken();
          this.tokens.matches1(L.comma) && this.tokens.copyToken();
        }
      }
      this.tokens.copyExpectedToken(L.braceR);
    }
    return this.keepUnusedImports ? !1 : this.isTypeScriptTransformEnabled ? !e : this.isFlowTransformEnabled ? n && !e : !1;
  }
  shouldAutomaticallyElideImportedName(e) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.nonTypeIdentifiers.has(e);
  }
  processExportDefault() {
    if (QC(
      this.isTypeScriptTransformEnabled,
      this.keepUnusedImports,
      this.tokens,
      this.declarationInfo
    ))
      return this.tokens.removeInitialToken(), this.tokens.removeToken(), this.tokens.removeToken(), !0;
    if (!(this.tokens.matches4(L._export, L._default, L._function, L.name) || // export default async function
    this.tokens.matches5(L._export, L._default, L.name, L._function, L.name) && this.tokens.matchesContextualAtIndex(
      this.tokens.currentIndex() + 2,
      Fe._async
    ) || this.tokens.matches4(L._export, L._default, L._class, L.name) || this.tokens.matches5(L._export, L._default, L._abstract, L._class, L.name)) && this.reactHotLoaderTransformer) {
      const n = this.nameManager.claimFreeName("_default");
      return this.tokens.replaceToken(`let ${n}; export`), this.tokens.copyToken(), this.tokens.appendCode(` ${n} =`), this.reactHotLoaderTransformer.setExtractedDefaultExportName(n), !0;
    }
    return !1;
  }
  /**
   * Handle a statement with one of these forms:
   * export {a, type b};
   * export {c, type d} from 'foo';
   *
   * In both cases, any explicit type exports should be removed. In the first
   * case, we also need to handle implicit export elision for names declared as
   * types. In the second case, we must NOT do implicit named export elision,
   * but we must remove the runtime import if all exports are type exports.
   */
  processNamedExports() {
    if (!this.isTypeScriptTransformEnabled)
      return !1;
    this.tokens.copyExpectedToken(L._export), this.tokens.copyExpectedToken(L.braceL);
    const e = JC(this.tokens);
    let n = !1;
    for (; !this.tokens.matches1(L.braceR); ) {
      const a = hu(this.tokens);
      if (a.isType || !e && this.shouldElideExportedName(a.leftName)) {
        for (; this.tokens.currentIndex() < a.endIndex; )
          this.tokens.removeToken();
        this.tokens.matches1(L.comma) && this.tokens.removeToken();
      } else {
        for (n = !0; this.tokens.currentIndex() < a.endIndex; )
          this.tokens.copyToken();
        this.tokens.matches1(L.comma) && this.tokens.copyToken();
      }
    }
    return this.tokens.copyExpectedToken(L.braceR), !this.keepUnusedImports && e && !n && (this.tokens.removeToken(), this.tokens.removeToken(), La(this.tokens)), !0;
  }
  /**
   * ESM elides all imports with the rule that we only elide if we see that it's
   * a type and never see it as a value. This is in contrast to CJS, which
   * elides imports that are completely unknown.
   */
  shouldElideExportedName(e) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && this.declarationInfo.typeDeclarations.has(e) && !this.declarationInfo.valueDeclarations.has(e);
  }
}
class dY extends qi {
  constructor(e, n, a) {
    super(), this.rootTransformer = e, this.tokens = n, this.isImportsTransformEnabled = a;
  }
  process() {
    return this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange() ? !0 : this.tokens.matches1(L._enum) ? (this.processEnum(), !0) : this.tokens.matches2(L._export, L._enum) ? (this.processNamedExportEnum(), !0) : this.tokens.matches3(L._export, L._default, L._enum) ? (this.processDefaultExportEnum(), !0) : !1;
  }
  /**
   * Handle a declaration like:
   * export enum E ...
   *
   * With this imports transform, this becomes:
   * const E = [[enum]]; exports.E = E;
   *
   * otherwise, it becomes:
   * export const E = [[enum]];
   */
  processNamedExportEnum() {
    if (this.isImportsTransformEnabled) {
      this.tokens.removeInitialToken();
      const e = this.tokens.identifierNameAtRelativeIndex(1);
      this.processEnum(), this.tokens.appendCode(` exports.${e} = ${e};`);
    } else
      this.tokens.copyToken(), this.processEnum();
  }
  /**
   * Handle a declaration like:
   * export default enum E
   *
   * With the imports transform, this becomes:
   * const E = [[enum]]; exports.default = E;
   *
   * otherwise, it becomes:
   * const E = [[enum]]; export default E;
   */
  processDefaultExportEnum() {
    this.tokens.removeInitialToken(), this.tokens.removeToken();
    const e = this.tokens.identifierNameAtRelativeIndex(1);
    this.processEnum(), this.isImportsTransformEnabled ? this.tokens.appendCode(` exports.default = ${e};`) : this.tokens.appendCode(` export default ${e};`);
  }
  /**
   * Transpile flow enums to invoke the "flow-enums-runtime" library.
   *
   * Currently, the transpiled code always uses `require("flow-enums-runtime")`,
   * but if future flexibility is needed, we could expose a config option for
   * this string (similar to configurable JSX). Even when targeting ESM, the
   * default behavior of babel-plugin-transform-flow-enums is to use require
   * rather than injecting an import.
   *
   * Flow enums are quite a bit simpler than TS enums and have some convenient
   * constraints:
   * - Element initializers must be either always present or always absent. That
   *   means that we can use fixed lookahead on the first element (if any) and
   *   assume that all elements are like that.
   * - The right-hand side of an element initializer must be a literal value,
   *   not a complex expression and not referencing other elements. That means
   *   we can simply copy a single token.
   *
   * Enums can be broken up into three basic cases:
   *
   * Mirrored enums:
   * enum E {A, B}
   *   ->
   * const E = require("flow-enums-runtime").Mirrored(["A", "B"]);
   *
   * Initializer enums:
   * enum E {A = 1, B = 2}
   *   ->
   * const E = require("flow-enums-runtime")({A: 1, B: 2});
   *
   * Symbol enums:
   * enum E of symbol {A, B}
   *   ->
   * const E = require("flow-enums-runtime")({A: Symbol("A"), B: Symbol("B")});
   *
   * We can statically detect which of the three cases this is by looking at the
   * "of" declaration (if any) and seeing if the first element has an initializer.
   * Since the other transform details are so similar between the three cases, we
   * use a single implementation and vary the transform within processEnumElement
   * based on case.
   */
  processEnum() {
    this.tokens.replaceToken("const"), this.tokens.copyExpectedToken(L.name);
    let e = !1;
    this.tokens.matchesContextual(Fe._of) && (this.tokens.removeToken(), e = this.tokens.matchesContextual(Fe._symbol), this.tokens.removeToken());
    const n = this.tokens.matches3(L.braceL, L.name, L.eq);
    this.tokens.appendCode(' = require("flow-enums-runtime")');
    const a = !e && !n;
    for (this.tokens.replaceTokenTrimmingLeftWhitespace(a ? ".Mirrored([" : "({"); !this.tokens.matches1(L.braceR); ) {
      if (this.tokens.matches1(L.ellipsis)) {
        this.tokens.removeToken();
        break;
      }
      this.processEnumElement(e, n), this.tokens.matches1(L.comma) && this.tokens.copyToken();
    }
    this.tokens.replaceToken(a ? "]);" : "});");
  }
  /**
   * Process an individual enum element, producing either an array element or an
   * object element based on what type of enum this is.
   */
  processEnumElement(e, n) {
    if (e) {
      const a = this.tokens.identifierName();
      this.tokens.copyToken(), this.tokens.appendCode(`: Symbol("${a}")`);
    } else
      n ? (this.tokens.copyToken(), this.tokens.replaceTokenTrimmingLeftWhitespace(":"), this.tokens.copyToken()) : this.tokens.replaceToken(`"${this.tokens.identifierName()}"`);
  }
}
function pY(t) {
  let e, n = t[0], a = 1;
  for (; a < t.length; ) {
    const c = t[a], u = t[a + 1];
    if (a += 2, (c === "optionalAccess" || c === "optionalCall") && n == null)
      return;
    c === "access" || c === "optionalAccess" ? (e = n, n = u(n)) : (c === "call" || c === "optionalCall") && (n = u((...r) => n.call(e, ...r)), e = void 0);
  }
  return n;
}
const zc = "jest", hY = ["mock", "unmock", "enableAutomock", "disableAutomock"];
class ug extends qi {
  __init() {
    this.hoistedFunctionNames = [];
  }
  constructor(e, n, a, c) {
    super(), this.rootTransformer = e, this.tokens = n, this.nameManager = a, this.importProcessor = c, ug.prototype.__init.call(this);
  }
  process() {
    return this.tokens.currentToken().scopeDepth === 0 && this.tokens.matches4(L.name, L.dot, L.name, L.parenL) && this.tokens.identifierName() === zc ? pY([this, "access", (e) => e.importProcessor, "optionalAccess", (e) => e.getGlobalNames, "call", (e) => e(), "optionalAccess", (e) => e.has, "call", (e) => e(zc)]) ? !1 : this.extractHoistedCalls() : !1;
  }
  getHoistedCode() {
    return this.hoistedFunctionNames.length > 0 ? this.hoistedFunctionNames.map((e) => `${e}();`).join("") : "";
  }
  /**
   * Extracts any methods calls on the jest-object that should be hoisted.
   *
   * According to the jest docs, https://jestjs.io/docs/en/jest-object#jestmockmodulename-factory-options,
   * mock, unmock, enableAutomock, disableAutomock, are the methods that should be hoisted.
   *
   * We do not apply the same checks of the arguments as babel-plugin-jest-hoist does.
   */
  extractHoistedCalls() {
    this.tokens.removeToken();
    let e = !1;
    for (; this.tokens.matches3(L.dot, L.name, L.parenL); ) {
      const n = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
      if (hY.includes(n)) {
        const c = this.nameManager.claimFreeName("__jestHoist");
        this.hoistedFunctionNames.push(c), this.tokens.replaceToken(`function ${c}(){${zc}.`), this.tokens.copyToken(), this.tokens.copyToken(), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(L.parenR), this.tokens.appendCode(";}"), e = !1;
      } else
        e ? this.tokens.copyToken() : this.tokens.replaceToken(`${zc}.`), this.tokens.copyToken(), this.tokens.copyToken(), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(L.parenR), e = !0;
    }
    return !0;
  }
}
class mY extends qi {
  constructor(e) {
    super(), this.tokens = e;
  }
  process() {
    if (this.tokens.matches1(L.num)) {
      const e = this.tokens.currentTokenCode();
      if (e.includes("_"))
        return this.tokens.replaceToken(e.replace(/_/g, "")), !0;
    }
    return !1;
  }
}
class yY extends qi {
  constructor(e, n) {
    super(), this.tokens = e, this.nameManager = n;
  }
  process() {
    return this.tokens.matches2(L._catch, L.braceL) ? (this.tokens.copyToken(), this.tokens.appendCode(` (${this.nameManager.claimFreeName("e")})`), !0) : !1;
  }
}
class bY extends qi {
  constructor(e, n) {
    super(), this.tokens = e, this.nameManager = n;
  }
  process() {
    if (this.tokens.matches1(L.nullishCoalescing)) {
      const a = this.tokens.currentToken();
      return this.tokens.tokens[a.nullishStartIndex].isAsyncOperation ? this.tokens.replaceTokenTrimmingLeftWhitespace(", async () => (") : this.tokens.replaceTokenTrimmingLeftWhitespace(", () => ("), !0;
    }
    if (this.tokens.matches1(L._delete) && this.tokens.tokenAtRelativeIndex(1).isOptionalChainStart)
      return this.tokens.removeInitialToken(), !0;
    const n = this.tokens.currentToken().subscriptStartIndex;
    if (n != null && this.tokens.tokens[n].isOptionalChainStart && // Super subscripts can't be optional (since super is never null/undefined), and the syntax
    // relies on the subscript being intact, so leave this token alone.
    this.tokens.tokenAtRelativeIndex(-1).type !== L._super) {
      const a = this.nameManager.claimFreeName("_");
      let c;
      if (n > 0 && this.tokens.matches1AtIndex(n - 1, L._delete) && this.isLastSubscriptInChain() ? c = `${a} => delete ${a}` : c = `${a} => ${a}`, this.tokens.tokens[n].isAsyncOperation && (c = `async ${c}`), this.tokens.matches2(L.questionDot, L.parenL) || this.tokens.matches2(L.questionDot, L.lessThan))
        this.justSkippedSuper() && this.tokens.appendCode(".bind(this)"), this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalCall', ${c}`);
      else if (this.tokens.matches2(L.questionDot, L.bracketL))
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${c}`);
      else if (this.tokens.matches1(L.questionDot))
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${c}.`);
      else if (this.tokens.matches1(L.dot))
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${c}.`);
      else if (this.tokens.matches1(L.bracketL))
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${c}[`);
      else if (this.tokens.matches1(L.parenL))
        this.justSkippedSuper() && this.tokens.appendCode(".bind(this)"), this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'call', ${c}(`);
      else
        throw new Error("Unexpected subscript operator in optional chain.");
      return !0;
    }
    return !1;
  }
  /**
   * Determine if the current token is the last of its chain, so that we know whether it's eligible
   * to have a delete op inserted.
   *
   * We can do this by walking forward until we determine one way or another. Each
   * isOptionalChainStart token must be paired with exactly one isOptionalChainEnd token after it in
   * a nesting way, so we can track depth and walk to the end of the chain (the point where the
   * depth goes negative) and see if any other subscript token is after us in the chain.
   */
  isLastSubscriptInChain() {
    let e = 0;
    for (let n = this.tokens.currentIndex() + 1; ; n++) {
      if (n >= this.tokens.tokens.length)
        throw new Error("Reached the end of the code while finding the end of the access chain.");
      if (this.tokens.tokens[n].isOptionalChainStart ? e++ : this.tokens.tokens[n].isOptionalChainEnd && e--, e < 0)
        return !0;
      if (e === 0 && this.tokens.tokens[n].subscriptStartIndex != null)
        return !1;
    }
  }
  /**
   * Determine if we are the open-paren in an expression like super.a()?.b.
   *
   * We can do this by walking backward to find the previous subscript. If that subscript was
   * preceded by a super, then we must be the subscript after it, so if this is a call expression,
   * we'll need to attach the right context.
   */
  justSkippedSuper() {
    let e = 0, n = this.tokens.currentIndex() - 1;
    for (; ; ) {
      if (n < 0)
        throw new Error(
          "Reached the start of the code while finding the start of the access chain."
        );
      if (this.tokens.tokens[n].isOptionalChainStart ? e-- : this.tokens.tokens[n].isOptionalChainEnd && e++, e < 0)
        return !1;
      if (e === 0 && this.tokens.tokens[n].subscriptStartIndex != null)
        return this.tokens.tokens[n - 1].type === L._super;
      n--;
    }
  }
}
class gY extends qi {
  constructor(e, n, a, c) {
    super(), this.rootTransformer = e, this.tokens = n, this.importProcessor = a, this.options = c;
  }
  process() {
    const e = this.tokens.currentIndex();
    if (this.tokens.identifierName() === "createReactClass") {
      const n = this.importProcessor && this.importProcessor.getIdentifierReplacement("createReactClass");
      return n ? this.tokens.replaceToken(`(0, ${n})`) : this.tokens.copyToken(), this.tryProcessCreateClassCall(e), !0;
    }
    if (this.tokens.matches3(L.name, L.dot, L.name) && this.tokens.identifierName() === "React" && this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 2) === "createClass") {
      const n = this.importProcessor && this.importProcessor.getIdentifierReplacement("React") || "React";
      return n ? (this.tokens.replaceToken(n), this.tokens.copyToken(), this.tokens.copyToken()) : (this.tokens.copyToken(), this.tokens.copyToken(), this.tokens.copyToken()), this.tryProcessCreateClassCall(e), !0;
    }
    return !1;
  }
  /**
   * This is called with the token position at the open-paren.
   */
  tryProcessCreateClassCall(e) {
    const n = this.findDisplayName(e);
    n && this.classNeedsDisplayName() && (this.tokens.copyExpectedToken(L.parenL), this.tokens.copyExpectedToken(L.braceL), this.tokens.appendCode(`displayName: '${n}',`), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(L.braceR), this.tokens.copyExpectedToken(L.parenR));
  }
  findDisplayName(e) {
    return e < 2 ? null : this.tokens.matches2AtIndex(e - 2, L.name, L.eq) ? this.tokens.identifierNameAtIndex(e - 2) : e >= 2 && this.tokens.tokens[e - 2].identifierRole === jt.ObjectKey ? this.tokens.identifierNameAtIndex(e - 2) : this.tokens.matches2AtIndex(e - 2, L._export, L._default) ? this.getDisplayNameFromFilename() : null;
  }
  getDisplayNameFromFilename() {
    const n = (this.options.filePath || "unknown").split("/"), a = n[n.length - 1], c = a.lastIndexOf("."), u = c === -1 ? a : a.slice(0, c);
    return u === "index" && n[n.length - 2] ? n[n.length - 2] : u;
  }
  /**
   * We only want to add a display name when this is a function call containing
   * one argument, which is an object literal without `displayName` as an
   * existing key.
   */
  classNeedsDisplayName() {
    let e = this.tokens.currentIndex();
    if (!this.tokens.matches2(L.parenL, L.braceL))
      return !1;
    const n = e + 1, a = this.tokens.tokens[n].contextId;
    if (a == null)
      throw new Error("Expected non-null context ID on object open-brace.");
    for (; e < this.tokens.tokens.length; e++) {
      const c = this.tokens.tokens[e];
      if (c.type === L.braceR && c.contextId === a) {
        e++;
        break;
      }
      if (this.tokens.identifierNameAtIndex(e) === "displayName" && this.tokens.tokens[e].identifierRole === jt.ObjectKey && c.contextId === a)
        return !1;
    }
    if (e === this.tokens.tokens.length)
      throw new Error("Unexpected end of input when processing React class.");
    return this.tokens.matches1AtIndex(e, L.parenR) || this.tokens.matches2AtIndex(e, L.comma, L.parenR);
  }
}
class cg extends qi {
  __init() {
    this.extractedDefaultExportName = null;
  }
  constructor(e, n) {
    super(), this.tokens = e, this.filePath = n, cg.prototype.__init.call(this);
  }
  setExtractedDefaultExportName(e) {
    this.extractedDefaultExportName = e;
  }
  getPrefixCode() {
    return `
      (function () {
        var enterModule = require('react-hot-loader').enterModule;
        enterModule && enterModule(module);
      })();`.replace(/\s+/g, " ").trim();
  }
  getSuffixCode() {
    const e = /* @__PURE__ */ new Set();
    for (const a of this.tokens.tokens)
      !a.isType && GP(a) && a.identifierRole !== jt.ImportDeclaration && e.add(this.tokens.identifierNameForToken(a));
    const n = Array.from(e).map((a) => ({
      variableName: a,
      uniqueLocalName: a
    }));
    return this.extractedDefaultExportName && n.push({
      variableName: this.extractedDefaultExportName,
      uniqueLocalName: "default"
    }), `
;(function () {
  var reactHotLoader = require('react-hot-loader').default;
  var leaveModule = require('react-hot-loader').leaveModule;
  if (!reactHotLoader) {
    return;
  }
${n.map(
      ({ variableName: a, uniqueLocalName: c }) => `  reactHotLoader.register(${a}, "${c}", ${JSON.stringify(
        this.filePath || ""
      )});`
    ).join(`
`)}
  leaveModule(module);
})();`;
  }
  process() {
    return !1;
  }
}
const vY = /* @__PURE__ */ new Set([
  // Reserved keywords as of ECMAScript 2015
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "export",
  "extends",
  "finally",
  "for",
  "function",
  "if",
  "import",
  "in",
  "instanceof",
  "new",
  "return",
  "super",
  "switch",
  "this",
  "throw",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield",
  // Future reserved keywords
  "enum",
  "implements",
  "interface",
  "let",
  "package",
  "private",
  "protected",
  "public",
  "static",
  "await",
  // Literals that cannot be used as identifiers
  "false",
  "null",
  "true"
]);
function wS(t) {
  if (t.length === 0 || !Zu[t.charCodeAt(0)])
    return !1;
  for (let e = 1; e < t.length; e++)
    if (!Fi[t.charCodeAt(e)])
      return !1;
  return !vY.has(t);
}
class EY extends qi {
  constructor(e, n, a) {
    super(), this.rootTransformer = e, this.tokens = n, this.isImportsTransformEnabled = a;
  }
  process() {
    return this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange() ? !0 : this.tokens.matches1(L._public) || this.tokens.matches1(L._protected) || this.tokens.matches1(L._private) || this.tokens.matches1(L._abstract) || this.tokens.matches1(L._readonly) || this.tokens.matches1(L._override) || this.tokens.matches1(L.nonNullAssertion) ? (this.tokens.removeInitialToken(), !0) : this.tokens.matches1(L._enum) || this.tokens.matches2(L._const, L._enum) ? (this.processEnum(), !0) : this.tokens.matches2(L._export, L._enum) || this.tokens.matches3(L._export, L._const, L._enum) ? (this.processEnum(!0), !0) : !1;
  }
  processEnum(e = !1) {
    for (this.tokens.removeInitialToken(); this.tokens.matches1(L._const) || this.tokens.matches1(L._enum); )
      this.tokens.removeToken();
    const n = this.tokens.identifierName();
    this.tokens.removeToken(), e && !this.isImportsTransformEnabled && this.tokens.appendCode("export "), this.tokens.appendCode(`var ${n}; (function (${n})`), this.tokens.copyExpectedToken(L.braceL), this.processEnumBody(n), this.tokens.copyExpectedToken(L.braceR), e && this.isImportsTransformEnabled ? this.tokens.appendCode(`)(${n} || (exports.${n} = ${n} = {}));`) : this.tokens.appendCode(`)(${n} || (${n} = {}));`);
  }
  /**
   * Transform an enum into equivalent JS. This has complexity in a few places:
   * - TS allows string enums, numeric enums, and a mix of the two styles within an enum.
   * - Enum keys are allowed to be referenced in later enum values.
   * - Enum keys are allowed to be strings.
   * - When enum values are omitted, they should follow an auto-increment behavior.
   */
  processEnumBody(e) {
    let n = null;
    for (; !this.tokens.matches1(L.braceR); ) {
      const { nameStringCode: a, variableName: c } = this.extractEnumKeyInfo(this.tokens.currentToken());
      this.tokens.removeInitialToken(), this.tokens.matches3(L.eq, L.string, L.comma) || this.tokens.matches3(L.eq, L.string, L.braceR) ? this.processStringLiteralEnumMember(e, a, c) : this.tokens.matches1(L.eq) ? this.processExplicitValueEnumMember(e, a, c) : this.processImplicitValueEnumMember(
        e,
        a,
        c,
        n
      ), this.tokens.matches1(L.comma) && this.tokens.removeToken(), c != null ? n = c : n = `${e}[${a}]`;
    }
  }
  /**
   * Detect name information about this enum key, which will be used to determine which code to emit
   * and whether we should declare a variable as part of this declaration.
   *
   * Some cases to keep in mind:
   * - Enum keys can be implicitly referenced later, e.g. `X = 1, Y = X`. In Sucrase, we implement
   *   this by declaring a variable `X` so that later expressions can use it.
   * - In addition to the usual identifier key syntax, enum keys are allowed to be string literals,
   *   e.g. `"hello world" = 3,`. Template literal syntax is NOT allowed.
   * - Even if the enum key is defined as a string literal, it may still be referenced by identifier
   *   later, e.g. `"X" = 1, Y = X`. That means that we need to detect whether or not a string
   *   literal is identifier-like and emit a variable if so, even if the declaration did not use an
   *   identifier.
   * - Reserved keywords like `break` are valid enum keys, but are not valid to be referenced later
   *   and would be a syntax error if we emitted a variable, so we need to skip the variable
   *   declaration in those cases.
   *
   * The variableName return value captures these nuances: if non-null, we can and must emit a
   * variable declaration, and if null, we can't and shouldn't.
   */
  extractEnumKeyInfo(e) {
    if (e.type === L.name) {
      const n = this.tokens.identifierNameForToken(e);
      return {
        nameStringCode: `"${n}"`,
        variableName: wS(n) ? n : null
      };
    } else if (e.type === L.string) {
      const n = this.tokens.stringValueForToken(e);
      return {
        nameStringCode: this.tokens.code.slice(e.start, e.end),
        variableName: wS(n) ? n : null
      };
    } else
      throw new Error("Expected name or string at beginning of enum element.");
  }
  /**
   * Handle an enum member where the RHS is just a string literal (not omitted, not a number, and
   * not a complex expression). This is the typical form for TS string enums, and in this case, we
   * do *not* create a reverse mapping.
   *
   * This is called after deleting the key token, when the token processor is at the equals sign.
   *
   * Example 1:
   * someKey = "some value"
   * ->
   * const someKey = "some value"; MyEnum["someKey"] = someKey;
   *
   * Example 2:
   * "some key" = "some value"
   * ->
   * MyEnum["some key"] = "some value";
   */
  processStringLiteralEnumMember(e, n, a) {
    a != null ? (this.tokens.appendCode(`const ${a}`), this.tokens.copyToken(), this.tokens.copyToken(), this.tokens.appendCode(`; ${e}[${n}] = ${a};`)) : (this.tokens.appendCode(`${e}[${n}]`), this.tokens.copyToken(), this.tokens.copyToken(), this.tokens.appendCode(";"));
  }
  /**
   * Handle an enum member initialized with an expression on the right-hand side (other than a
   * string literal). In these cases, we should transform the expression and emit code that sets up
   * a reverse mapping.
   *
   * The TypeScript implementation of this operation distinguishes between expressions that can be
   * "constant folded" at compile time (i.e. consist of number literals and simple math operations
   * on those numbers) and ones that are dynamic. For constant expressions, it emits the resolved
   * numeric value, and auto-incrementing is only allowed in that case. Evaluating expressions at
   * compile time would add significant complexity to Sucrase, so Sucrase instead leaves the
   * expression as-is, and will later emit something like `MyEnum["previousKey"] + 1` to implement
   * auto-incrementing.
   *
   * This is called after deleting the key token, when the token processor is at the equals sign.
   *
   * Example 1:
   * someKey = 1 + 1
   * ->
   * const someKey = 1 + 1; MyEnum[MyEnum["someKey"] = someKey] = "someKey";
   *
   * Example 2:
   * "some key" = 1 + 1
   * ->
   * MyEnum[MyEnum["some key"] = 1 + 1] = "some key";
   */
  processExplicitValueEnumMember(e, n, a) {
    const c = this.tokens.currentToken().rhsEndIndex;
    if (c == null)
      throw new Error("Expected rhsEndIndex on enum assign.");
    if (a != null) {
      for (this.tokens.appendCode(`const ${a}`), this.tokens.copyToken(); this.tokens.currentIndex() < c; )
        this.rootTransformer.processToken();
      this.tokens.appendCode(
        `; ${e}[${e}[${n}] = ${a}] = ${n};`
      );
    } else {
      for (this.tokens.appendCode(`${e}[${e}[${n}]`), this.tokens.copyToken(); this.tokens.currentIndex() < c; )
        this.rootTransformer.processToken();
      this.tokens.appendCode(`] = ${n};`);
    }
  }
  /**
   * Handle an enum member with no right-hand side expression. In this case, the value is the
   * previous value plus 1, or 0 if there was no previous value. We should also always emit a
   * reverse mapping.
   *
   * Example 1:
   * someKey2
   * ->
   * const someKey2 = someKey1 + 1; MyEnum[MyEnum["someKey2"] = someKey2] = "someKey2";
   *
   * Example 2:
   * "some key 2"
   * ->
   * MyEnum[MyEnum["some key 2"] = someKey1 + 1] = "some key 2";
   */
  processImplicitValueEnumMember(e, n, a, c) {
    let u = c != null ? `${c} + 1` : "0";
    a != null && (this.tokens.appendCode(`const ${a} = ${u}; `), u = a), this.tokens.appendCode(
      `${e}[${e}[${n}] = ${u}] = ${n};`
    );
  }
}
class ed {
  __init() {
    this.transformers = [];
  }
  __init2() {
    this.generatedVariables = [];
  }
  constructor(e, n, a, c) {
    ed.prototype.__init.call(this), ed.prototype.__init2.call(this), this.nameManager = e.nameManager, this.helperManager = e.helperManager;
    const { tokenProcessor: u, importProcessor: r } = e;
    this.tokens = u, this.isImportsTransformEnabled = n.includes("imports"), this.isReactHotLoaderTransformEnabled = n.includes("react-hot-loader"), this.disableESTransforms = !!c.disableESTransforms, c.disableESTransforms || (this.transformers.push(
      new bY(u, this.nameManager)
    ), this.transformers.push(new mY(u)), this.transformers.push(new yY(u, this.nameManager))), n.includes("jsx") && (c.jsxRuntime !== "preserve" && this.transformers.push(
      new ka(this, u, r, this.nameManager, c)
    ), this.transformers.push(
      new gY(this, u, r, c)
    ));
    let l = null;
    if (n.includes("react-hot-loader")) {
      if (!c.filePath)
        throw new Error("filePath is required when using the react-hot-loader transform.");
      l = new cg(u, c.filePath), this.transformers.push(l);
    }
    if (n.includes("imports")) {
      if (r === null)
        throw new Error("Expected non-null importProcessor with imports transform enabled.");
      this.transformers.push(
        new tu(
          this,
          u,
          r,
          this.nameManager,
          this.helperManager,
          l,
          a,
          !!c.enableLegacyTypeScriptModuleInterop,
          n.includes("typescript"),
          n.includes("flow"),
          !!c.preserveDynamicImport,
          !!c.keepUnusedImports
        )
      );
    } else
      this.transformers.push(
        new fY(
          u,
          this.nameManager,
          this.helperManager,
          l,
          n.includes("typescript"),
          n.includes("flow"),
          !!c.keepUnusedImports,
          c
        )
      );
    n.includes("flow") && this.transformers.push(
      new dY(this, u, n.includes("imports"))
    ), n.includes("typescript") && this.transformers.push(
      new EY(this, u, n.includes("imports"))
    ), n.includes("jest") && this.transformers.push(
      new ug(this, u, this.nameManager, r)
    );
  }
  transform() {
    this.tokens.reset(), this.processBalancedCode();
    let n = this.isImportsTransformEnabled ? '"use strict";' : "";
    for (const r of this.transformers)
      n += r.getPrefixCode();
    n += this.helperManager.emitHelpers(), n += this.generatedVariables.map((r) => ` var ${r};`).join("");
    for (const r of this.transformers)
      n += r.getHoistedCode();
    let a = "";
    for (const r of this.transformers)
      a += r.getSuffixCode();
    const c = this.tokens.finish();
    let { code: u } = c;
    if (u.startsWith("#!")) {
      let r = u.indexOf(`
`);
      return r === -1 && (r = u.length, u += `
`), {
        code: u.slice(0, r + 1) + n + u.slice(r + 1) + a,
        // The hashbang line has no tokens, so shifting the tokens to account
        // for prefix can happen normally.
        mappings: this.shiftMappings(c.mappings, n.length)
      };
    } else
      return {
        code: n + u + a,
        mappings: this.shiftMappings(c.mappings, n.length)
      };
  }
  processBalancedCode() {
    let e = 0, n = 0;
    for (; !this.tokens.isAtEnd(); ) {
      if (this.tokens.matches1(L.braceL) || this.tokens.matches1(L.dollarBraceL))
        e++;
      else if (this.tokens.matches1(L.braceR)) {
        if (e === 0)
          return;
        e--;
      }
      if (this.tokens.matches1(L.parenL))
        n++;
      else if (this.tokens.matches1(L.parenR)) {
        if (n === 0)
          return;
        n--;
      }
      this.processToken();
    }
  }
  processToken() {
    if (this.tokens.matches1(L._class)) {
      this.processClass();
      return;
    }
    for (const e of this.transformers)
      if (e.process())
        return;
    this.tokens.copyToken();
  }
  /**
   * Skip past a class with a name and return that name.
   */
  processNamedClass() {
    if (!this.tokens.matches2(L._class, L.name))
      throw new Error("Expected identifier for exported class name.");
    const e = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    return this.processClass(), e;
  }
  processClass() {
    const e = lY(this, this.tokens, this.nameManager, this.disableESTransforms), n = (e.headerInfo.isExpression || !e.headerInfo.className) && e.staticInitializerNames.length + e.instanceInitializerNames.length > 0;
    let a = e.headerInfo.className;
    n && (a = this.nameManager.claimFreeName("_class"), this.generatedVariables.push(a), this.tokens.appendCode(` (${a} =`));
    const u = this.tokens.currentToken().contextId;
    if (u == null)
      throw new Error("Expected class to have a context ID.");
    for (this.tokens.copyExpectedToken(L._class); !this.tokens.matchesContextIdAndLabel(L.braceL, u); )
      this.processToken();
    this.processClassBody(e, a);
    const r = e.staticInitializerNames.map(
      (l) => `${a}.${l}()`
    );
    n ? this.tokens.appendCode(
      `, ${r.map((l) => `${l}, `).join("")}${a})`
    ) : e.staticInitializerNames.length > 0 && this.tokens.appendCode(` ${r.map((l) => `${l};`).join(" ")}`);
  }
  /**
   * We want to just handle class fields in all contexts, since TypeScript supports them. Later,
   * when some JS implementations support class fields, this should be made optional.
   */
  processClassBody(e, n) {
    const {
      headerInfo: a,
      constructorInsertPos: c,
      constructorInitializerStatements: u,
      fields: r,
      instanceInitializerNames: l,
      rangesToRemove: i
    } = e;
    let f = 0, d = 0;
    const s = this.tokens.currentToken().contextId;
    if (s == null)
      throw new Error("Expected non-null context ID on class.");
    this.tokens.copyExpectedToken(L.braceL), this.isReactHotLoaderTransformEnabled && this.tokens.appendCode(
      "__reactstandin__regenerateByEval(key, code) {this[key] = eval(code);}"
    );
    const o = u.length + l.length > 0;
    if (c === null && o) {
      const m = this.makeConstructorInitCode(
        u,
        l,
        n
      );
      if (a.hasSuperclass) {
        const h = this.nameManager.claimFreeName("args");
        this.tokens.appendCode(
          `constructor(...${h}) { super(...${h}); ${m}; }`
        );
      } else
        this.tokens.appendCode(`constructor() { ${m}; }`);
    }
    for (; !this.tokens.matchesContextIdAndLabel(L.braceR, s); )
      if (f < r.length && this.tokens.currentIndex() === r[f].start) {
        let m = !1;
        for (this.tokens.matches1(L.bracketL) ? this.tokens.copyTokenWithPrefix(`${r[f].initializerName}() {this`) : this.tokens.matches1(L.string) || this.tokens.matches1(L.num) ? (this.tokens.copyTokenWithPrefix(`${r[f].initializerName}() {this[`), m = !0) : this.tokens.copyTokenWithPrefix(`${r[f].initializerName}() {this.`); this.tokens.currentIndex() < r[f].end; )
          m && this.tokens.currentIndex() === r[f].equalsIndex && this.tokens.appendCode("]"), this.processToken();
        this.tokens.appendCode("}"), f++;
      } else if (d < i.length && this.tokens.currentIndex() >= i[d].start) {
        for (this.tokens.currentIndex() < i[d].end && this.tokens.removeInitialToken(); this.tokens.currentIndex() < i[d].end; )
          this.tokens.removeToken();
        d++;
      } else
        this.tokens.currentIndex() === c ? (this.tokens.copyToken(), o && this.tokens.appendCode(
          `;${this.makeConstructorInitCode(
            u,
            l,
            n
          )};`
        ), this.processToken()) : this.processToken();
    this.tokens.copyExpectedToken(L.braceR);
  }
  makeConstructorInitCode(e, n, a) {
    return [
      ...e,
      ...n.map((c) => `${a}.prototype.${c}.call(this)`)
    ].join(";");
  }
  /**
   * Normally it's ok to simply remove type tokens, but we need to be more careful when dealing with
   * arrow function return types since they can confuse the parser. In that case, we want to move
   * the close-paren to the same line as the arrow.
   *
   * See https://github.com/alangpierce/sucrase/issues/391 for more details.
   */
  processPossibleArrowParamEnd() {
    if (this.tokens.matches2(L.parenR, L.colon) && this.tokens.tokenAtRelativeIndex(1).isType) {
      let e = this.tokens.currentIndex() + 1;
      for (; this.tokens.tokens[e].isType; )
        e++;
      if (this.tokens.matches1AtIndex(e, L.arrow)) {
        for (this.tokens.removeInitialToken(); this.tokens.currentIndex() < e; )
          this.tokens.removeToken();
        return this.tokens.replaceTokenTrimmingLeftWhitespace(") =>"), !0;
      }
    }
    return !1;
  }
  /**
   * An async arrow function might be of the form:
   *
   * async <
   *   T
   * >() => {}
   *
   * in which case, removing the type parameters will cause a syntax error. Detect this case and
   * move the open-paren earlier.
   */
  processPossibleAsyncArrowWithTypeParams() {
    if (!this.tokens.matchesContextual(Fe._async) && !this.tokens.matches1(L._async))
      return !1;
    const e = this.tokens.tokenAtRelativeIndex(1);
    if (e.type !== L.lessThan || !e.isType)
      return !1;
    let n = this.tokens.currentIndex() + 1;
    for (; this.tokens.tokens[n].isType; )
      n++;
    if (this.tokens.matches1AtIndex(n, L.parenL)) {
      for (this.tokens.replaceToken("async ("), this.tokens.removeInitialToken(); this.tokens.currentIndex() < n; )
        this.tokens.removeToken();
      return this.tokens.removeToken(), this.processBalancedCode(), this.processToken(), !0;
    }
    return !1;
  }
  processPossibleTypeRange() {
    if (this.tokens.currentToken().isType) {
      for (this.tokens.removeInitialToken(); this.tokens.currentToken().isType; )
        this.tokens.removeToken();
      return !0;
    }
    return !1;
  }
  shiftMappings(e, n) {
    for (let a = 0; a < e.length; a++) {
      const c = e[a];
      c !== void 0 && (e[a] = c + n);
    }
    return e;
  }
}
var ZC = {};
(function(t) {
  t.__esModule = !0, t.LinesAndColumns = void 0;
  var e = `
`, n = "\r", a = (
    /** @class */
    function() {
      function c(u) {
        this.string = u;
        for (var r = [0], l = 0; l < u.length; )
          switch (u[l]) {
            case e:
              l += e.length, r.push(l);
              break;
            case n:
              l += n.length, u[l] === e && (l += e.length), r.push(l);
              break;
            default:
              l++;
              break;
          }
        this.offsets = r;
      }
      return c.prototype.locationForIndex = function(u) {
        if (u < 0 || u > this.string.length)
          return null;
        for (var r = 0, l = this.offsets; l[r + 1] <= u; )
          r++;
        var i = u - l[r];
        return { line: r, column: i };
      }, c.prototype.indexForLocation = function(u) {
        var r = u.line, l = u.column;
        return r < 0 || r >= this.offsets.length || l < 0 || l > this.lengthOfLine(r) ? null : this.offsets[r] + l;
      }, c.prototype.lengthOfLine = function(u) {
        var r = this.offsets[u], l = u === this.offsets.length - 1 ? this.string.length : this.offsets[u + 1];
        return l - r;
      }, c;
    }()
  );
  t.LinesAndColumns = a, t.default = a;
})(ZC);
const _Y = /* @__PURE__ */ nd(ZC);
function SY(t, e) {
  if (e.length === 0)
    return "";
  const n = Object.keys(e[0]).filter(
    (o) => o !== "type" && o !== "value" && o !== "start" && o !== "end" && o !== "loc"
  ), a = Object.keys(e[0].type).filter((o) => o !== "label" && o !== "keyword"), c = ["Location", "Label", "Raw", ...n, ...a], u = new _Y(t), r = [c, ...e.map(i)], l = c.map(() => 0);
  for (const o of r)
    for (let m = 0; m < o.length; m++)
      l[m] = Math.max(l[m], o[m].length);
  return r.map((o) => o.map((m, h) => m.padEnd(l[h])).join(" ")).join(`
`);
  function i(o) {
    const m = t.slice(o.start, o.end);
    return [
      d(o.start, o.end),
      $P(o.type),
      wY(String(m), 14),
      // @ts-ignore: Intentional dynamic access by key.
      ...n.map((h) => f(o[h], h)),
      // @ts-ignore: Intentional dynamic access by key.
      ...a.map((h) => f(o.type[h], h))
    ];
  }
  function f(o, m) {
    return o === !0 ? m : o === !1 || o === null ? "" : String(o);
  }
  function d(o, m) {
    return `${s(o)}-${s(m)}`;
  }
  function s(o) {
    const m = u.locationForIndex(o);
    return m ? `${m.line + 1}:${m.column + 1}` : "Unknown";
  }
}
function wY(t, e) {
  return t.length > e ? `${t.slice(0, e - 3)}...` : t;
}
function TY(t) {
  const e = /* @__PURE__ */ new Set();
  for (let n = 0; n < t.tokens.length; n++)
    t.matches1AtIndex(n, L._import) && !t.matches3AtIndex(n, L._import, L.name, L.eq) && AY(t, n, e);
  return e;
}
function AY(t, e, n) {
  e++, !t.matches1AtIndex(e, L.parenL) && (t.matches1AtIndex(e, L.name) && (n.add(t.identifierNameAtIndex(e)), e++, t.matches1AtIndex(e, L.comma) && e++), t.matches1AtIndex(e, L.star) && (e += 2, n.add(t.identifierNameAtIndex(e)), e++), t.matches1AtIndex(e, L.braceL) && (e++, xY(t, e, n)));
}
function xY(t, e, n) {
  for (; ; ) {
    if (t.matches1AtIndex(e, L.braceR))
      return;
    const a = hu(t, e);
    if (e = a.endIndex, a.isType || n.add(a.rightName), t.matches2AtIndex(e, L.comma, L.braceR))
      return;
    if (t.matches1AtIndex(e, L.braceR))
      return;
    if (t.matches1AtIndex(e, L.comma))
      e++;
    else
      throw new Error(`Unexpected token: ${JSON.stringify(t.tokens[e])}`);
  }
}
function PY() {
  return "3.34.0";
}
function CY(t, e) {
  Uq(e);
  try {
    const n = eI(t, e), c = new ed(
      n,
      e.transforms,
      !!e.enableLegacyBabel5ModuleInterop,
      e
    ).transform();
    let u = { code: c.code };
    if (e.sourceMapOptions) {
      if (!e.filePath)
        throw new Error("filePath must be specified when generating a source map.");
      u = {
        ...u,
        sourceMap: Pq(
          c,
          e.filePath,
          e.sourceMapOptions,
          t,
          n.tokenProcessor.tokens
        )
      };
    }
    return u;
  } catch (n) {
    throw e.filePath && (n.message = `Error transforming ${e.filePath}: ${n.message}`), n;
  }
}
function IY(t, e) {
  const n = eI(t, e).tokenProcessor.tokens;
  return SY(t, n);
}
function eI(t, e) {
  const n = e.transforms.includes("jsx"), a = e.transforms.includes("typescript"), c = e.transforms.includes("flow"), u = e.disableESTransforms === !0, r = aY(t, n, a, c), l = r.tokens, i = r.scopes, f = new Bb(t, l), d = new Gf(f), s = new eu(
    t,
    l,
    c,
    u,
    d
  ), o = !!e.enableLegacyTypeScriptModuleInterop;
  let m = null;
  return e.transforms.includes("imports") ? (m = new Da(
    f,
    s,
    o,
    e,
    e.transforms.includes("typescript"),
    !!e.keepUnusedImports,
    d
  ), m.preprocessTokens(), uS(s, i, m.getGlobalNames()), e.transforms.includes("typescript") && !e.keepUnusedImports && m.pruneTypeOnlyImports()) : e.transforms.includes("typescript") && !e.keepUnusedImports && uS(s, i, TY(s)), { tokenProcessor: s, scopes: i, nameManager: f, importProcessor: m, helperManager: d };
}
const OY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getFormattedTokens: IY,
  getVersion: PY,
  transform: CY
}, Symbol.toStringTag, { value: "Module" })), kY = /* @__PURE__ */ GS(OY);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "loadConfig", {
    enumerable: !0,
    get: function() {
      return r;
    }
  });
  const e = /* @__PURE__ */ a(WH), n = kY;
  function a(l) {
    return l && l.__esModule ? l : {
      default: l
    };
  }
  let c = null;
  function u() {
    return c ?? (c = (0, e.default)(__filename, {
      interopDefault: !0,
      transform: (l) => (0, n.transform)(l.source, {
        transforms: [
          "typescript",
          "imports"
        ]
      })
    }));
  }
  function r(l) {
    let i = function() {
      try {
        return l ? $l(l) : {};
      } catch {
        return u()(l);
      }
    }();
    var f;
    return (f = i.default) !== null && f !== void 0 ? f : i;
  }
})(BP);
var tI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return f;
    }
  });
  const e = /* @__PURE__ */ a(Dn), n = /* @__PURE__ */ a(Lr);
  function a(d) {
    return d && d.__esModule ? d : {
      default: d
    };
  }
  let c = [
    ".js",
    ".cjs",
    ".mjs"
  ], u = [
    "",
    ".js",
    ".cjs",
    ".mjs",
    ".ts",
    ".cts",
    ".mts",
    ".jsx",
    ".tsx"
  ], r = [
    "",
    ".ts",
    ".cts",
    ".mts",
    ".tsx",
    ".js",
    ".cjs",
    ".mjs",
    ".jsx"
  ];
  function l(d, s) {
    for (let o of s) {
      let m = `${d}${o}`;
      if (e.default.existsSync(m) && e.default.statSync(m).isFile())
        return m;
    }
    for (let o of s) {
      let m = `${d}/index${o}`;
      if (e.default.existsSync(m))
        return m;
    }
    return null;
  }
  function* i(d, s, o, m = n.default.extname(d)) {
    let h = l(n.default.resolve(s, d), c.includes(m) ? u : r);
    if (h === null || o.has(h))
      return;
    o.add(h), yield h, s = n.default.dirname(h), m = n.default.extname(h);
    let y = e.default.readFileSync(h, "utf-8");
    for (let b of [
      ...y.matchAll(/import[\s\S]*?['"](.{3,}?)['"]/gi),
      ...y.matchAll(/import[\s\S]*from[\s\S]*?['"](.{3,}?)['"]/gi),
      ...y.matchAll(/require\(['"`](.+)['"`]\)/gi)
    ])
      b[1].startsWith(".") && (yield* i(b[1], s, o, m));
  }
  function f(d) {
    return d === null ? /* @__PURE__ */ new Set() : new Set(i(d, n.default.dirname(d), /* @__PURE__ */ new Set()));
  }
})(tI);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(
    t,
    // DISABLE_TOUCH = TRUE
    // Retrieve an existing context from cache if possible (since contexts are unique per
    // source path), or set up a new one (including setting up watchers and registering
    // plugins) then return it
    "default",
    {
      enumerable: !0,
      get: function() {
        return E;
      }
    }
  );
  const e = /* @__PURE__ */ o(Dn), n = /* @__PURE__ */ o(Kw), a = /* @__PURE__ */ o(Yw), c = /* @__PURE__ */ o(Jw), u = /* @__PURE__ */ o(u2), r = ab(), l = /* @__PURE__ */ o(qx), i = Gx, f = zx, d = BP, s = /* @__PURE__ */ o(tI);
  function o(S) {
    return S && S.__esModule ? S : {
      default: S
    };
  }
  let m = new n.default({
    maxSize: 100
  }), h = /* @__PURE__ */ new WeakMap();
  function y(S, g) {
    if (h.has(S))
      return h.get(S);
    let P = (0, f.parseCandidateFiles)(S, g);
    return h.set(S, P).get(S);
  }
  function b(S) {
    let g = (0, u.default)(S);
    if (g !== null) {
      let [R, N, C, I] = m.get(g) || [], D = (0, s.default)(g), j = !1, F = /* @__PURE__ */ new Map();
      for (let v of D) {
        let w = e.default.statSync(v).mtimeMs;
        F.set(v, w), (!I || !I.has(v) || w > I.get(v)) && (j = !0);
      }
      if (!j)
        return [
          R,
          g,
          N,
          C
        ];
      for (let v of D)
        delete require.cache[v];
      let _ = (0, i.validateConfig)((0, c.default)((0, d.loadConfig)(g))), T = (0, a.default)(_);
      return m.set(g, [
        _,
        T,
        D,
        F
      ]), [
        _,
        g,
        T,
        D
      ];
    }
    let P = (0, c.default)(S.config === void 0 ? S : S.config);
    return P = (0, i.validateConfig)(P), [
      P,
      null,
      (0, a.default)(P),
      []
    ];
  }
  function E(S) {
    return ({ tailwindDirectives: g, registerDependency: P }) => (R, N) => {
      let [C, I, D, j] = b(S), F = new Set(j);
      if (g.size > 0) {
        F.add(N.opts.from);
        for (let O of N.messages)
          O.type === "dependency" && F.add(O.file);
      }
      let [_, , T] = (0, r.getContext)(R, N, C, I, D, F), v = (0, r.getFileModifiedMap)(_), w = y(_, C);
      if (g.size > 0) {
        for (let W of w)
          for (let U of (0, l.default)(W))
            P(U);
        let [O, G] = (0, f.resolvedChangedContent)(_, w, v);
        for (let W of O)
          _.changedContent.push(W);
        for (let [W, U] of G.entries())
          T.set(W, U);
      }
      for (let O of j)
        P({
          type: "dependency",
          file: O
        });
      for (let [O, G] of T.entries())
        v.set(O, G);
      return _;
    };
  }
})(ZS);
var rI = {}, nI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return a;
    }
  });
  const e = /* @__PURE__ */ n(Bi);
  function n(c) {
    return c && c.__esModule ? c : {
      default: c
    };
  }
  function a(c) {
    let u = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
    if (c.walkAtRules((i) => {
      i.name === "apply" && l.add(i), i.name === "import" && (i.params === '"tailwindcss/base"' || i.params === "'tailwindcss/base'" ? (i.name = "tailwind", i.params = "base") : i.params === '"tailwindcss/components"' || i.params === "'tailwindcss/components'" ? (i.name = "tailwind", i.params = "components") : i.params === '"tailwindcss/utilities"' || i.params === "'tailwindcss/utilities'" ? (i.name = "tailwind", i.params = "utilities") : (i.params === '"tailwindcss/screens"' || i.params === "'tailwindcss/screens'" || i.params === '"tailwindcss/variants"' || i.params === "'tailwindcss/variants'") && (i.name = "tailwind", i.params = "variants")), i.name === "tailwind" && (i.params === "screens" && (i.params = "variants"), u.add(i.params)), [
        "layer",
        "responsive",
        "variants"
      ].includes(i.name) && ([
        "responsive",
        "variants"
      ].includes(i.name) && e.default.warn(`${i.name}-at-rule-deprecated`, [
        `The \`@${i.name}\` directive has been deprecated in Tailwind CSS v3.0.`,
        "Use `@layer utilities` or `@layer components` instead.",
        "https://tailwindcss.com/docs/upgrade-guide#replace-variants-with-layer"
      ]), r.add(i));
    }), !u.has("base") || !u.has("components") || !u.has("utilities")) {
      for (let i of r)
        if (i.name === "layer" && [
          "base",
          "components",
          "utilities"
        ].includes(i.params)) {
          if (!u.has(i.params))
            throw i.error(`\`@layer ${i.params}\` is used but no matching \`@tailwind ${i.params}\` directive is present.`);
        } else if (i.name === "responsive") {
          if (!u.has("utilities"))
            throw i.error("`@responsive` is used but `@tailwind utilities` is missing.");
        } else if (i.name === "variants" && !u.has("utilities"))
          throw i.error("`@variants` is used but `@tailwind utilities` is missing.");
    }
    return {
      tailwindDirectives: u,
      applyDirectives: l
    };
  }
})(nI);
var iI = {}, sI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(n, a = void 0, c = void 0) {
    return n.map((u) => {
      var r;
      let l = u.clone(), i = ((r = u.raws.tailwind) === null || r === void 0 ? void 0 : r.preserveSource) !== !0 || !l.source;
      return a !== void 0 && i && (l.source = a, "walk" in l && l.walk((f) => {
        f.source = a;
      })), c !== void 0 && (l.raws.tailwind = {
        ...l.raws.tailwind,
        ...c
      }), l;
    });
  }
})(sI);
var aI = {}, oI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(o, m) {
    for (var h in m)
      Object.defineProperty(o, h, {
        enumerable: !0,
        get: m[h]
      });
  }
  e(t, {
    pattern: function() {
      return u;
    },
    withoutCapturing: function() {
      return r;
    },
    any: function() {
      return l;
    },
    optional: function() {
      return i;
    },
    zeroOrMore: function() {
      return f;
    },
    nestedBrackets: function() {
      return d;
    },
    escape: function() {
      return s;
    }
  });
  const n = /[\\^$.*+?()[\]{}|]/g, a = RegExp(n.source);
  function c(o) {
    return o = Array.isArray(o) ? o : [
      o
    ], o = o.map((m) => m instanceof RegExp ? m.source : m), o.join("");
  }
  function u(o) {
    return new RegExp(c(o), "g");
  }
  function r(o) {
    return new RegExp(`(?:${c(o)})`, "g");
  }
  function l(o) {
    return `(?:${o.map(c).join("|")})`;
  }
  function i(o) {
    return `(?:${c(o)})?`;
  }
  function f(o) {
    return `(?:${c(o)})*`;
  }
  function d(o, m, h = 1) {
    return r([
      s(o),
      /[^\s]*/,
      h === 1 ? `[^${s(o)}${s(m)}s]*` : l([
        `[^${s(o)}${s(m)}s]*`,
        d(o, m, h - 1)
      ]),
      /[^\s]*/,
      s(m)
    ]);
  }
  function s(o) {
    return o && a.test(o) ? o.replace(n, "\\$&") : o || "";
  }
})(oI);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "defaultExtractor", {
    enumerable: !0,
    get: function() {
      return u;
    }
  });
  const e = _s, n = /* @__PURE__ */ c(oI);
  function a(d) {
    if (typeof WeakMap != "function")
      return null;
    var s = /* @__PURE__ */ new WeakMap(), o = /* @__PURE__ */ new WeakMap();
    return (a = function(m) {
      return m ? o : s;
    })(d);
  }
  function c(d, s) {
    if (!s && d && d.__esModule)
      return d;
    if (d === null || typeof d != "object" && typeof d != "function")
      return {
        default: d
      };
    var o = a(s);
    if (o && o.has(d))
      return o.get(d);
    var m = {}, h = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var y in d)
      if (y !== "default" && Object.prototype.hasOwnProperty.call(d, y)) {
        var b = h ? Object.getOwnPropertyDescriptor(d, y) : null;
        b && (b.get || b.set) ? Object.defineProperty(m, y, b) : m[y] = d[y];
      }
    return m.default = d, o && o.set(d, m), m;
  }
  function u(d) {
    let s = Array.from(r(d));
    return (o) => {
      let m = [];
      for (let y of s) {
        var h;
        m = [
          ...m,
          ...(h = o.match(y)) !== null && h !== void 0 ? h : []
        ];
      }
      return m.filter((y) => y !== void 0).map(f);
    };
  }
  function* r(d) {
    let s = d.tailwindConfig.separator, o = (0, e.flagEnabled)(d.tailwindConfig, "variantGrouping"), m = d.tailwindConfig.prefix !== "" ? n.optional(n.pattern([
      /-?/,
      n.escape(d.tailwindConfig.prefix)
    ])) : "", h = n.any([
      // Arbitrary properties (without square brackets)
      /\[[^\s:'"`]+:[^\s\[\]]+\]/,
      // Arbitrary properties with balanced square brackets
      // This is a targeted fix to continue to allow theme()
      // with square brackets to work in arbitrary properties
      // while fixing a problem with the regex matching too much
      /\[[^\s:'"`]+:[^\s]+?\[[^\s]+\][^\s]+?\]/,
      // Utilities
      n.pattern([
        // Utility Name / Group Name
        /-?(?:\w+)/,
        // Normal/Arbitrary values
        n.optional(n.any([
          n.pattern([
            // Arbitrary values
            /-(?:\w+-)*\[[^\s:]+\]/,
            // Not immediately followed by an `{[(`
            /(?![{([]])/,
            // optionally followed by an opacity modifier
            /(?:\/[^\s'"`\\><$]*)?/
          ]),
          n.pattern([
            // Arbitrary values
            /-(?:\w+-)*\[[^\s]+\]/,
            // Not immediately followed by an `{[(`
            /(?![{([]])/,
            // optionally followed by an opacity modifier
            /(?:\/[^\s'"`\\$]*)?/
          ]),
          // Normal values w/o quotes  may include an opacity modifier
          /[-\/][^\s'"`\\$={><]*/
        ]))
      ])
    ]), y = [
      // Without quotes
      n.any([
        // This is here to provide special support for the `@` variant
        n.pattern([
          /@\[[^\s"'`]+\](\/[^\s"'`]+)?/,
          s
        ]),
        n.pattern([
          /([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/,
          s
        ]),
        n.pattern([
          /[^\s"'`\[\\]+/,
          s
        ])
      ]),
      // With quotes allowed
      n.any([
        n.pattern([
          /([^\s"'`\[\\]+-)?\[[^\s`]+\]/,
          s
        ]),
        n.pattern([
          /[^\s`\[\\]+/,
          s
        ])
      ])
    ];
    for (const b of y)
      yield n.pattern([
        // Variants
        "((?=((",
        b,
        ")+))\\2)?",
        // Important (optional)
        /!?/,
        m,
        o ? n.any([
          // Or any of those things but grouped separated by commas
          n.pattern([
            /\(/,
            h,
            n.zeroOrMore([
              /,/,
              h
            ]),
            /\)/
          ]),
          // Arbitrary properties, constrained utilities, arbitrary values, etc
          h
        ]) : h
      ]);
    yield /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
  }
  let l = /([\[\]'"`])([^\[\]'"`])?/g, i = /[^"'`\s<>\]]+/;
  function f(d) {
    if (!d.includes("-["))
      return d;
    let s = 0, o = [], m = d.matchAll(l);
    m = Array.from(m).flatMap((h) => {
      const [, ...y] = h;
      return y.map((b, E) => Object.assign([], h, {
        index: h.index + E,
        0: b
      }));
    });
    for (let h of m) {
      let y = h[0], b = o[o.length - 1];
      if (y === b ? o.pop() : (y === "'" || y === '"' || y === "`") && o.push(y), !b) {
        if (y === "[") {
          s++;
          continue;
        } else if (y === "]") {
          s--;
          continue;
        }
        if (s < 0)
          return d.substring(0, h.index - 1);
        if (s === 0 && !i.test(y))
          return d.substring(0, h.index);
      }
    }
    return d;
  }
})(aI);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return g;
    }
  });
  const e = /* @__PURE__ */ i(Dn), n = /* @__PURE__ */ i(Kw), a = /* @__PURE__ */ d(Xa), c = wy(), u = /* @__PURE__ */ i(Bi), r = /* @__PURE__ */ i(sI), l = aI;
  function i(P) {
    return P && P.__esModule ? P : {
      default: P
    };
  }
  function f(P) {
    if (typeof WeakMap != "function")
      return null;
    var R = /* @__PURE__ */ new WeakMap(), N = /* @__PURE__ */ new WeakMap();
    return (f = function(C) {
      return C ? N : R;
    })(P);
  }
  function d(P, R) {
    if (!R && P && P.__esModule)
      return P;
    if (P === null || typeof P != "object" && typeof P != "function")
      return {
        default: P
      };
    var N = f(R);
    if (N && N.has(P))
      return N.get(P);
    var C = {}, I = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var D in P)
      if (D !== "default" && Object.prototype.hasOwnProperty.call(P, D)) {
        var j = I ? Object.getOwnPropertyDescriptor(P, D) : null;
        j && (j.get || j.set) ? Object.defineProperty(C, D, j) : C[D] = P[D];
      }
    return C.default = P, N && N.set(P, C), C;
  }
  let s = a.env;
  const o = {
    DEFAULT: l.defaultExtractor
  }, m = {
    DEFAULT: (P) => P,
    svelte: (P) => P.replace(/(?:^|\s)class:/g, " ")
  };
  function h(P, R) {
    let N = P.tailwindConfig.content.extract;
    return N[R] || N.DEFAULT || o[R] || o.DEFAULT(P);
  }
  function y(P, R) {
    let N = P.content.transform;
    return N[R] || N.DEFAULT || m[R] || m.DEFAULT;
  }
  let b = /* @__PURE__ */ new WeakMap();
  function E(P, R, N, C) {
    b.has(R) || b.set(R, new n.default({
      maxSize: 25e3
    }));
    for (let I of P.split(`
`))
      if (I = I.trim(), !C.has(I))
        if (C.add(I), b.get(R).has(I))
          for (let D of b.get(R).get(I))
            N.add(D);
        else {
          let D = R(I).filter((F) => F !== "!*"), j = new Set(D);
          for (let F of j)
            N.add(F);
          b.get(R).set(I, j);
        }
  }
  function S(P, R) {
    let N = R.offsets.sort(P), C = {
      base: /* @__PURE__ */ new Set(),
      defaults: /* @__PURE__ */ new Set(),
      components: /* @__PURE__ */ new Set(),
      utilities: /* @__PURE__ */ new Set(),
      variants: /* @__PURE__ */ new Set()
    };
    for (let [I, D] of N)
      C[I.layer].add(D);
    return C;
  }
  function g(P) {
    return (R) => {
      let N = {
        base: null,
        components: null,
        utilities: null,
        variants: null
      };
      if (R.walkAtRules((U) => {
        U.name === "tailwind" && Object.keys(N).includes(U.params) && (N[U.params] = U);
      }), Object.values(N).every((U) => U === null))
        return R;
      var C;
      let I = /* @__PURE__ */ new Set([
        ...(C = P.candidates) !== null && C !== void 0 ? C : [],
        a.NOT_ON_DEMAND
      ]), D = /* @__PURE__ */ new Set();
      s.DEBUG && console.time("Reading changed files");
      for (let { file: U, content: M, extension: B } of P.changedContent) {
        let k = y(P.tailwindConfig, B), K = h(P, B);
        M = U ? e.default.readFileSync(U, "utf8") : M, E(k(M), K, I, D);
      }
      s.DEBUG && console.timeEnd("Reading changed files");
      let j = P.classCache.size;
      s.DEBUG && console.time("Generate rules"), s.DEBUG && console.time("Sorting candidates");
      let F = new Set([
        ...I
      ].sort((U, M) => U === M ? 0 : U < M ? -1 : 1));
      s.DEBUG && console.timeEnd("Sorting candidates"), (0, c.generateRules)(F, P), s.DEBUG && console.timeEnd("Generate rules"), s.DEBUG && console.time("Build stylesheet"), (P.stylesheetCache === null || P.classCache.size !== j) && (P.stylesheetCache = S([
        ...P.ruleCache
      ], P)), s.DEBUG && console.timeEnd("Build stylesheet");
      let { defaults: _, base: T, components: v, utilities: w, variants: O } = P.stylesheetCache;
      N.base && (N.base.before((0, r.default)([
        ...T,
        ..._
      ], N.base.source, {
        layer: "base"
      })), N.base.remove()), N.components && (N.components.before((0, r.default)([
        ...v
      ], N.components.source, {
        layer: "components"
      })), N.components.remove()), N.utilities && (N.utilities.before((0, r.default)([
        ...w
      ], N.utilities.source, {
        layer: "utilities"
      })), N.utilities.remove());
      const G = Array.from(O).filter((U) => {
        var M;
        const B = (M = U.raws.tailwind) === null || M === void 0 ? void 0 : M.parentLayer;
        return B === "components" ? N.components !== null : B === "utilities" ? N.utilities !== null : !0;
      });
      N.variants ? (N.variants.before((0, r.default)(G, N.variants.source, {
        layer: "variants"
      })), N.variants.remove()) : G.length > 0 && R.append((0, r.default)(G, R.source, {
        layer: "variants"
      }));
      const W = G.some((U) => {
        var M;
        return ((M = U.raws.tailwind) === null || M === void 0 ? void 0 : M.parentLayer) === "utilities";
      });
      N.utilities && w.size === 0 && !W && u.default.warn("content-problems", [
        "No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.",
        "https://tailwindcss.com/docs/content-configuration"
      ]), s.DEBUG && (console.log("Potential classes: ", I.size), console.log("Active contexts: ", a.contextSourcesMap.size)), P.changedContent = [], R.walkAtRules("layer", (U) => {
        Object.keys(N).includes(U.params) && U.remove();
      });
    };
  }
})(iI);
var lI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return N;
    }
  });
  const e = /* @__PURE__ */ l(vi), n = /* @__PURE__ */ l(Ws), a = wy(), c = /* @__PURE__ */ l(rl), u = Sy, r = Nd;
  function l(C) {
    return C && C.__esModule ? C : {
      default: C
    };
  }
  function i(C) {
    let I = /* @__PURE__ */ new Map();
    e.default.root({
      nodes: [
        C.clone()
      ]
    }).walkRules((_) => {
      (0, n.default)((T) => {
        T.walkClasses((v) => {
          let w = v.parent.toString(), O = I.get(w);
          O || I.set(w, O = /* @__PURE__ */ new Set()), O.add(v.value);
        });
      }).processSync(_.selector);
    });
    let j = Array.from(I.values(), (_) => Array.from(_)), F = j.flat();
    return Object.assign(F, {
      groups: j
    });
  }
  let f = (0, n.default)();
  function d(C) {
    return f.astSync(C);
  }
  function s(C, I) {
    let D = /* @__PURE__ */ new Set();
    for (let j of C)
      D.add(j.split(I).pop());
    return Array.from(D);
  }
  function o(C, I) {
    let D = C.tailwindConfig.prefix;
    return typeof D == "function" ? D(I) : D + I;
  }
  function* m(C) {
    for (yield C; C.parent; )
      yield C.parent, C = C.parent;
  }
  function h(C, I = {}) {
    let D = C.nodes;
    C.nodes = [];
    let j = C.clone(I);
    return C.nodes = D, j;
  }
  function y(C) {
    for (let I of m(C))
      if (C !== I) {
        if (I.type === "root")
          break;
        C = h(I, {
          nodes: [
            C
          ]
        });
      }
    return C;
  }
  function b(C, I) {
    let D = /* @__PURE__ */ new Map();
    return C.walkRules((j) => {
      for (let v of m(j)) {
        var F;
        if (((F = v.raws.tailwind) === null || F === void 0 ? void 0 : F.layer) !== void 0)
          return;
      }
      let _ = y(j), T = I.offsets.create("user");
      for (let v of i(j)) {
        let w = D.get(v) || [];
        D.set(v, w), w.push([
          {
            layer: "user",
            sort: T,
            important: !1
          },
          _
        ]);
      }
    }), D;
  }
  function E(C, I) {
    for (let D of C) {
      if (I.notClassCache.has(D) || I.applyClassCache.has(D))
        continue;
      if (I.classCache.has(D)) {
        I.applyClassCache.set(D, I.classCache.get(D).map(([F, _]) => [
          F,
          _.clone()
        ]));
        continue;
      }
      let j = Array.from((0, a.resolveMatches)(D, I));
      if (j.length === 0) {
        I.notClassCache.add(D);
        continue;
      }
      I.applyClassCache.set(D, j);
    }
    return I.applyClassCache;
  }
  function S(C) {
    let I = null;
    return {
      get: (D) => (I = I || C(), I.get(D)),
      has: (D) => (I = I || C(), I.has(D))
    };
  }
  function g(C) {
    return {
      get: (I) => C.flatMap((D) => D.get(I) || []),
      has: (I) => C.some((D) => D.has(I))
    };
  }
  function P(C) {
    let I = C.split(/[\s\t\n]+/g);
    return I[I.length - 1] === "!important" ? [
      I.slice(0, -1),
      !0
    ] : [
      I,
      !1
    ];
  }
  function R(C, I, D) {
    let j = /* @__PURE__ */ new Set(), F = [];
    if (C.walkAtRules("apply", (w) => {
      let [O] = P(w.params);
      for (let G of O)
        j.add(G);
      F.push(w);
    }), F.length === 0)
      return;
    let _ = g([
      D,
      E(j, I)
    ]);
    function T(w, O, G) {
      let W = d(w), U = d(O), B = d(`.${(0, c.default)(G)}`).nodes[0].nodes[0];
      return W.each((k) => {
        let K = /* @__PURE__ */ new Set();
        U.each((te) => {
          let z = !1;
          te = te.clone(), te.walkClasses((q) => {
            q.value === B.value && (z || (q.replaceWith(...k.nodes.map(($) => $.clone())), K.add(te), z = !0));
          });
        });
        for (let te of K) {
          let z = [
            []
          ];
          for (let q of te.nodes)
            q.type === "combinator" ? (z.push(q), z.push([])) : z[z.length - 1].push(q);
          te.nodes = [];
          for (let q of z)
            Array.isArray(q) && q.sort(($, Y) => $.type === "tag" && Y.type === "class" ? -1 : $.type === "class" && Y.type === "tag" ? 1 : $.type === "class" && Y.type === "pseudo" && Y.value.startsWith("::") ? -1 : $.type === "pseudo" && $.value.startsWith("::") && Y.type === "class" ? 1 : 0), te.nodes = te.nodes.concat(q);
        }
        k.replaceWith(...K);
      }), W.toString();
    }
    let v = /* @__PURE__ */ new Map();
    for (let w of F) {
      let [O] = v.get(w.parent) || [
        [],
        w.source
      ];
      v.set(w.parent, [
        O,
        w.source
      ]);
      let [G, W] = P(w.params);
      if (w.parent.type === "atrule") {
        if (w.parent.name === "screen") {
          let U = w.parent.params;
          throw w.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${G.map((M) => `${U}:${M}`).join(" ")} instead.`);
        }
        throw w.error(`@apply is not supported within nested at-rules like @${w.parent.name}. You can fix this by un-nesting @${w.parent.name}.`);
      }
      for (let U of G) {
        if ([
          o(I, "group"),
          o(I, "peer")
        ].includes(U))
          throw w.error(`@apply should not be used with the '${U}' utility`);
        if (!_.has(U))
          throw w.error(`The \`${U}\` class does not exist. If \`${U}\` is a custom class, make sure it is defined within a \`@layer\` directive.`);
        let M = _.get(U);
        O.push([
          U,
          W,
          M
        ]);
      }
    }
    for (let [w, [O, G]] of v) {
      let W = [];
      for (let [M, B, k] of O) {
        let K = [
          M,
          ...s([
            M
          ], I.tailwindConfig.separator)
        ];
        for (let [te, z] of k) {
          let q = i(w), $ = i(z);
          if ($ = $.groups.filter((X) => X.some((ne) => K.includes(ne))).flat(), $ = $.concat(s($, I.tailwindConfig.separator)), q.some((X) => $.includes(X)))
            throw z.error(`You cannot \`@apply\` the \`${M}\` utility here because it creates a circular dependency.`);
          let H = e.default.root({
            nodes: [
              z.clone()
            ]
          });
          H.walk((X) => {
            X.source = G;
          }), (z.type !== "atrule" || z.type === "atrule" && z.name !== "keyframes") && H.walkRules((X) => {
            if (!i(X).some((oe) => oe === M)) {
              X.remove();
              return;
            }
            let ne = typeof I.tailwindConfig.important == "string" ? I.tailwindConfig.important : null, ve = w.raws.tailwind !== void 0 && ne && w.selector.indexOf(ne) === 0 ? w.selector.slice(ne.length) : w.selector;
            X.selector = T(ve, X.selector, M), ne && ve !== w.selector && (X.selector = (0, u.applyImportantSelector)(X.selector, ne)), X.walkDecls((oe) => {
              oe.important = te.important || B;
            });
            let de = (0, n.default)().astSync(X.selector);
            de.each((oe) => (0, r.movePseudos)(oe)), X.selector = de.toString();
          }), H.nodes[0] && W.push([
            te.sort,
            H.nodes[0]
          ]);
        }
      }
      let U = I.offsets.sort(W).map((M) => M[1]);
      w.after(U);
    }
    for (let w of F)
      w.parent.nodes.length > 1 ? w.remove() : w.parent.remove();
    R(C, I, D);
  }
  function N(C) {
    return (I) => {
      let D = S(() => b(I, C));
      R(I, C, D);
    };
  }
})(lI);
var uI = {}, cI = { exports: {} };
(function(t) {
  (function() {
    function e(c, u, r) {
      if (!c)
        return null;
      e.caseSensitive || (c = c.toLowerCase());
      var l = e.threshold === null ? null : e.threshold * c.length, i = e.thresholdAbsolute, f;
      l !== null && i !== null ? f = Math.min(l, i) : l !== null ? f = l : i !== null ? f = i : f = null;
      var d, s, o, m, h, y = u.length;
      for (h = 0; h < y; h++)
        if (s = u[h], r && (s = s[r]), !!s && (e.caseSensitive ? o = s : o = s.toLowerCase(), m = a(c, o, f), (f === null || m < f) && (f = m, r && e.returnWinningObject ? d = u[h] : d = s, e.returnFirstMatch)))
          return d;
      return d || e.nullResultValue;
    }
    e.threshold = 0.4, e.thresholdAbsolute = 20, e.caseSensitive = !1, e.nullResultValue = null, e.returnWinningObject = null, e.returnFirstMatch = !1, t.exports ? t.exports = e : window.didYouMean = e;
    var n = Math.pow(2, 32) - 1;
    function a(c, u, r) {
      r = r || r === 0 ? r : n;
      var l = c.length, i = u.length;
      if (l === 0)
        return Math.min(r + 1, i);
      if (i === 0)
        return Math.min(r + 1, l);
      if (Math.abs(l - i) > r)
        return r + 1;
      var f = [], d, s, o, m, h;
      for (d = 0; d <= i; d++)
        f[d] = [d];
      for (s = 0; s <= l; s++)
        f[0][s] = s;
      for (d = 1; d <= i; d++) {
        for (o = n, m = 1, d > r && (m = d - r), h = i + 1, h > r + d && (h = r + d), s = 1; s <= l; s++)
          s < m || s > h ? f[d][s] = r + 1 : u.charAt(d - 1) === c.charAt(s - 1) ? f[d][s] = f[d - 1][s - 1] : f[d][s] = Math.min(
            f[d - 1][s - 1] + 1,
            // Substitute
            Math.min(
              f[d][s - 1] + 1,
              // Insert
              f[d - 1][s] + 1
            )
          ), f[d][s] < o && (o = f[d][s]);
        if (o > r)
          return r + 1;
      }
      return f[i][l];
    }
  })();
})(cI);
var DY = cI.exports, Cm = "(".charCodeAt(0), Im = ")".charCodeAt(0), Kc = "'".charCodeAt(0), Om = '"'.charCodeAt(0), km = "\\".charCodeAt(0), go = "/".charCodeAt(0), Dm = ",".charCodeAt(0), Nm = ":".charCodeAt(0), Yc = "*".charCodeAt(0), NY = "u".charCodeAt(0), RY = "U".charCodeAt(0), MY = "+".charCodeAt(0), LY = /^[a-f0-9?-]+$/i, jY = function(t) {
  for (var e = [], n = t, a, c, u, r, l, i, f, d, s = 0, o = n.charCodeAt(s), m = n.length, h = [{ nodes: e }], y = 0, b, E = "", S = "", g = ""; s < m; )
    if (o <= 32) {
      a = s;
      do
        a += 1, o = n.charCodeAt(a);
      while (o <= 32);
      r = n.slice(s, a), u = e[e.length - 1], o === Im && y ? g = r : u && u.type === "div" ? (u.after = r, u.sourceEndIndex += r.length) : o === Dm || o === Nm || o === go && n.charCodeAt(a + 1) !== Yc && (!b || b && b.type === "function" && b.value !== "calc") ? S = r : e.push({
        type: "space",
        sourceIndex: s,
        sourceEndIndex: a,
        value: r
      }), s = a;
    } else if (o === Kc || o === Om) {
      a = s, c = o === Kc ? "'" : '"', r = {
        type: "string",
        sourceIndex: s,
        quote: c
      };
      do
        if (l = !1, a = n.indexOf(c, a + 1), ~a)
          for (i = a; n.charCodeAt(i - 1) === km; )
            i -= 1, l = !l;
        else
          n += c, a = n.length - 1, r.unclosed = !0;
      while (l);
      r.value = n.slice(s + 1, a), r.sourceEndIndex = r.unclosed ? a : a + 1, e.push(r), s = a + 1, o = n.charCodeAt(s);
    } else if (o === go && n.charCodeAt(s + 1) === Yc)
      a = n.indexOf("*/", s), r = {
        type: "comment",
        sourceIndex: s,
        sourceEndIndex: a + 2
      }, a === -1 && (r.unclosed = !0, a = n.length, r.sourceEndIndex = a), r.value = n.slice(s + 2, a), e.push(r), s = a + 2, o = n.charCodeAt(s);
    else if ((o === go || o === Yc) && b && b.type === "function" && b.value === "calc")
      r = n[s], e.push({
        type: "word",
        sourceIndex: s - S.length,
        sourceEndIndex: s + r.length,
        value: r
      }), s += 1, o = n.charCodeAt(s);
    else if (o === go || o === Dm || o === Nm)
      r = n[s], e.push({
        type: "div",
        sourceIndex: s - S.length,
        sourceEndIndex: s + r.length,
        value: r,
        before: S,
        after: ""
      }), S = "", s += 1, o = n.charCodeAt(s);
    else if (Cm === o) {
      a = s;
      do
        a += 1, o = n.charCodeAt(a);
      while (o <= 32);
      if (d = s, r = {
        type: "function",
        sourceIndex: s - E.length,
        value: E,
        before: n.slice(d + 1, a)
      }, s = a, E === "url" && o !== Kc && o !== Om) {
        a -= 1;
        do
          if (l = !1, a = n.indexOf(")", a + 1), ~a)
            for (i = a; n.charCodeAt(i - 1) === km; )
              i -= 1, l = !l;
          else
            n += ")", a = n.length - 1, r.unclosed = !0;
        while (l);
        f = a;
        do
          f -= 1, o = n.charCodeAt(f);
        while (o <= 32);
        d < f ? (s !== f + 1 ? r.nodes = [
          {
            type: "word",
            sourceIndex: s,
            sourceEndIndex: f + 1,
            value: n.slice(s, f + 1)
          }
        ] : r.nodes = [], r.unclosed && f + 1 !== a ? (r.after = "", r.nodes.push({
          type: "space",
          sourceIndex: f + 1,
          sourceEndIndex: a,
          value: n.slice(f + 1, a)
        })) : (r.after = n.slice(f + 1, a), r.sourceEndIndex = a)) : (r.after = "", r.nodes = []), s = a + 1, r.sourceEndIndex = r.unclosed ? a : s, o = n.charCodeAt(s), e.push(r);
      } else
        y += 1, r.after = "", r.sourceEndIndex = s + 1, e.push(r), h.push(r), e = r.nodes = [], b = r;
      E = "";
    } else if (Im === o && y)
      s += 1, o = n.charCodeAt(s), b.after = g, b.sourceEndIndex += g.length, g = "", y -= 1, h[h.length - 1].sourceEndIndex = s, h.pop(), b = h[y], e = b.nodes;
    else {
      a = s;
      do
        o === km && (a += 1), a += 1, o = n.charCodeAt(a);
      while (a < m && !(o <= 32 || o === Kc || o === Om || o === Dm || o === Nm || o === go || o === Cm || o === Yc && b && b.type === "function" && b.value === "calc" || o === go && b.type === "function" && b.value === "calc" || o === Im && y));
      r = n.slice(s, a), Cm === o ? E = r : (NY === r.charCodeAt(0) || RY === r.charCodeAt(0)) && MY === r.charCodeAt(1) && LY.test(r.slice(2)) ? e.push({
        type: "unicode-range",
        sourceIndex: s,
        sourceEndIndex: a,
        value: r
      }) : e.push({
        type: "word",
        sourceIndex: s,
        sourceEndIndex: a,
        value: r
      }), s = a;
    }
  for (s = h.length - 1; s; s -= 1)
    h[s].unclosed = !0, h[s].sourceEndIndex = n.length;
  return h[0].nodes;
}, FY = function t(e, n, a) {
  var c, u, r, l;
  for (c = 0, u = e.length; c < u; c += 1)
    r = e[c], a || (l = n(r, c, e)), l !== !1 && r.type === "function" && Array.isArray(r.nodes) && t(r.nodes, n, a), a && n(r, c, e);
};
function TS(t, e) {
  var n = t.type, a = t.value, c, u;
  return e && (u = e(t)) !== void 0 ? u : n === "word" || n === "space" ? a : n === "string" ? (c = t.quote || "", c + a + (t.unclosed ? "" : c)) : n === "comment" ? "/*" + a + (t.unclosed ? "" : "*/") : n === "div" ? (t.before || "") + a + (t.after || "") : Array.isArray(t.nodes) ? (c = fI(t.nodes, e), n !== "function" ? c : a + "(" + (t.before || "") + c + (t.after || "") + (t.unclosed ? "" : ")")) : a;
}
function fI(t, e) {
  var n, a;
  if (Array.isArray(t)) {
    for (n = "", a = t.length - 1; ~a; a -= 1)
      n = TS(t[a], e) + n;
    return n;
  }
  return TS(t, e);
}
var BY = fI, Rm, AS;
function $Y() {
  if (AS)
    return Rm;
  AS = 1;
  var t = "-".charCodeAt(0), e = "+".charCodeAt(0), n = ".".charCodeAt(0), a = "e".charCodeAt(0), c = "E".charCodeAt(0);
  function u(r) {
    var l = r.charCodeAt(0), i;
    if (l === e || l === t) {
      if (i = r.charCodeAt(1), i >= 48 && i <= 57)
        return !0;
      var f = r.charCodeAt(2);
      return i === n && f >= 48 && f <= 57;
    }
    return l === n ? (i = r.charCodeAt(1), i >= 48 && i <= 57) : l >= 48 && l <= 57;
  }
  return Rm = function(r) {
    var l = 0, i = r.length, f, d, s;
    if (i === 0 || !u(r))
      return !1;
    for (f = r.charCodeAt(l), (f === e || f === t) && l++; l < i && (f = r.charCodeAt(l), !(f < 48 || f > 57)); )
      l += 1;
    if (f = r.charCodeAt(l), d = r.charCodeAt(l + 1), f === n && d >= 48 && d <= 57)
      for (l += 2; l < i && (f = r.charCodeAt(l), !(f < 48 || f > 57)); )
        l += 1;
    if (f = r.charCodeAt(l), d = r.charCodeAt(l + 1), s = r.charCodeAt(l + 2), (f === a || f === c) && (d >= 48 && d <= 57 || (d === e || d === t) && s >= 48 && s <= 57))
      for (l += d === e || d === t ? 3 : 2; l < i && (f = r.charCodeAt(l), !(f < 48 || f > 57)); )
        l += 1;
    return {
      number: r.slice(0, l),
      unit: r.slice(l)
    };
  }, Rm;
}
var UY = jY, dI = FY, pI = BY;
function ca(t) {
  return this instanceof ca ? (this.nodes = UY(t), this) : new ca(t);
}
ca.prototype.toString = function() {
  return Array.isArray(this.nodes) ? pI(this.nodes) : "";
};
ca.prototype.walk = function(t, e) {
  return dI(this.nodes, t, e), this;
};
ca.unit = $Y();
ca.walk = dI;
ca.stringify = pI;
var VY = ca;
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return I;
    }
  });
  const e = /* @__PURE__ */ s(z2), n = /* @__PURE__ */ s(DY), a = /* @__PURE__ */ s(Nu), c = /* @__PURE__ */ s(VY), u = Dd, r = /* @__PURE__ */ s(kd), l = Sd, i = Cu, f = Pu, d = /* @__PURE__ */ s(Bi);
  function s(D) {
    return D && D.__esModule ? D : {
      default: D
    };
  }
  function o(D) {
    return typeof D == "object" && D !== null;
  }
  function m(D, j) {
    let F = (0, l.toPath)(j);
    do
      if (F.pop(), (0, e.default)(D, F) !== void 0)
        break;
    while (F.length);
    return F.length ? F : void 0;
  }
  function h(D) {
    return typeof D == "string" ? D : D.reduce((j, F, _) => F.includes(".") ? `${j}[${F}]` : _ === 0 ? F : `${j}.${F}`, "");
  }
  function y(D) {
    return D.map((j) => `'${j}'`).join(", ");
  }
  function b(D) {
    return y(Object.keys(D));
  }
  function E(D, j, F, _ = {}) {
    const T = Array.isArray(j) ? h(j) : j.replace(/^['"]+|['"]+$/g, ""), v = Array.isArray(j) ? j : (0, l.toPath)(T), w = (0, e.default)(D.theme, v, F);
    if (w === void 0) {
      let G = `'${T}' does not exist in your theme config.`;
      const W = v.slice(0, -1), U = (0, e.default)(D.theme, W);
      if (o(U)) {
        const M = Object.keys(U).filter((k) => E(D, [
          ...W,
          k
        ]).isValid), B = (0, n.default)(v[v.length - 1], M);
        B ? G += ` Did you mean '${h([
          ...W,
          B
        ])}'?` : M.length > 0 && (G += ` '${h(W)}' has the following valid keys: ${y(M)}`);
      } else {
        const M = m(D.theme, T);
        if (M) {
          const B = (0, e.default)(D.theme, M);
          o(B) ? G += ` '${h(M)}' has the following keys: ${b(B)}` : G += ` '${h(M)}' is not an object.`;
        } else
          G += ` Your theme has the following top-level keys: ${b(D.theme)}`;
      }
      return {
        isValid: !1,
        error: G
      };
    }
    if (!(typeof w == "string" || typeof w == "number" || typeof w == "function" || w instanceof String || w instanceof Number || Array.isArray(w))) {
      let G = `'${T}' was found but does not resolve to a string.`;
      if (o(w)) {
        let W = Object.keys(w).filter((U) => E(D, [
          ...v,
          U
        ]).isValid);
        W.length && (G += ` Did you mean something like '${h([
          ...v,
          W[0]
        ])}'?`);
      }
      return {
        isValid: !1,
        error: G
      };
    }
    const [O] = v;
    return {
      isValid: !0,
      value: (0, a.default)(O)(w, _)
    };
  }
  function S(D, j, F) {
    j = j.map((T) => g(D, T, F));
    let _ = [
      ""
    ];
    for (let T of j)
      T.type === "div" && T.value === "," ? _.push("") : _[_.length - 1] += c.default.stringify(T);
    return _;
  }
  function g(D, j, F) {
    if (j.type === "function" && F[j.value] !== void 0) {
      let _ = S(D, j.nodes, F);
      j.type = "word", j.value = F[j.value](D, ..._);
    }
    return j;
  }
  function P(D, j, F) {
    return (0, c.default)(j).walk((_) => {
      g(D, _, F);
    }).toString();
  }
  let R = {
    atrule: "params",
    decl: "value"
  };
  function* N(D) {
    D = D.replace(/^['"]+|['"]+$/g, "");
    let j = D.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/), F;
    yield [
      D,
      void 0
    ], j && (D = j[1], F = j[2], yield [
      D,
      F
    ]);
  }
  function C(D, j, F) {
    const _ = Array.from(N(j)).map(([v, w]) => Object.assign(E(D, v, F, {
      opacityValue: w
    }), {
      resolvedPath: v,
      alpha: w
    }));
    var T;
    return (T = _.find((v) => v.isValid)) !== null && T !== void 0 ? T : _[0];
  }
  function I(D) {
    let j = D.tailwindConfig, F = {
      theme: (_, T, ...v) => {
        let { isValid: w, value: O, error: G, alpha: W } = C(j, T, v.length ? v : void 0);
        if (!w) {
          var U;
          let k = _.parent, K = (U = k == null ? void 0 : k.raws.tailwind) === null || U === void 0 ? void 0 : U.candidate;
          if (k && K !== void 0) {
            D.markInvalidUtilityNode(k), k.remove(), d.default.warn("invalid-theme-key-in-class", [
              `The utility \`${K}\` contains an invalid theme value and was not generated.`
            ]);
            return;
          }
          throw _.error(G);
        }
        let M = (0, f.parseColorFormat)(O);
        return (W !== void 0 || M !== void 0 && typeof M == "function") && (W === void 0 && (W = 1), O = (0, i.withAlphaValue)(M, W, M)), O;
      },
      screen: (_, T) => {
        T = T.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
        let w = (0, u.normalizeScreens)(j.theme.screens).find(({ name: O }) => O === T);
        if (!w)
          throw _.error(`The '${T}' screen does not exist in your theme.`);
        return (0, r.default)(w);
      }
    };
    return (_) => {
      _.walk((T) => {
        let v = R[T.type];
        v !== void 0 && (T[v] = P(T, T[v], F));
      });
    };
  }
})(uI);
var hI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return c;
    }
  });
  const e = Dd, n = /* @__PURE__ */ a(kd);
  function a(u) {
    return u && u.__esModule ? u : {
      default: u
    };
  }
  function c({ tailwindConfig: { theme: u } }) {
    return function(r) {
      r.walkAtRules("screen", (l) => {
        let i = l.params, d = (0, e.normalizeScreens)(u.screens).find(({ name: s }) => s === i);
        if (!d)
          throw l.error(`No \`${i}\` screen found.`);
        l.name = "media", l.params = (0, n.default)(d);
      });
    };
  }
})(hI);
var mI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(o, m) {
    for (var h in m)
      Object.defineProperty(o, h, {
        enumerable: !0,
        get: m[h]
      });
  }
  e(t, {
    elementSelectorParser: function() {
      return i;
    },
    default: function() {
      return s;
    }
  });
  const n = /* @__PURE__ */ u(vi), a = /* @__PURE__ */ u(Ws), c = _s;
  function u(o) {
    return o && o.__esModule ? o : {
      default: o
    };
  }
  let r = {
    id(o) {
      return a.default.attribute({
        attribute: "id",
        operator: "=",
        value: o.value,
        quoteMark: '"'
      });
    }
  };
  function l(o) {
    let m = o.filter((g) => g.type !== "pseudo" || g.nodes.length > 0 ? !0 : g.value.startsWith("::") || [
      ":before",
      ":after",
      ":first-line",
      ":first-letter"
    ].includes(g.value)).reverse(), h = /* @__PURE__ */ new Set([
      "tag",
      "class",
      "id",
      "attribute"
    ]), y = m.findIndex((g) => h.has(g.type));
    if (y === -1)
      return m.reverse().join("").trim();
    let b = m[y], E = r[b.type] ? r[b.type](b) : b;
    m = m.slice(0, y);
    let S = m.findIndex((g) => g.type === "combinator" && g.value === ">");
    return S !== -1 && (m.splice(0, S), m.unshift(a.default.universal())), [
      E,
      ...m.reverse()
    ].join("").trim();
  }
  let i = (0, a.default)((o) => o.map((m) => {
    let h = m.split((y) => y.type === "combinator" && y.value === " ").pop();
    return l(h);
  })), f = /* @__PURE__ */ new Map();
  function d(o) {
    return f.has(o) || f.set(o, i.transformSync(o)), f.get(o);
  }
  function s({ tailwindConfig: o }) {
    return (m) => {
      let h = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Set();
      if (m.walkAtRules("defaults", (S) => {
        if (S.nodes && S.nodes.length > 0) {
          y.add(S);
          return;
        }
        let g = S.params;
        h.has(g) || h.set(g, /* @__PURE__ */ new Set()), h.get(g).add(S.parent), S.remove();
      }), (0, c.flagEnabled)(o, "optimizeUniversalDefaults"))
        for (let S of y) {
          let g = /* @__PURE__ */ new Map();
          var b;
          let P = (b = h.get(S.params)) !== null && b !== void 0 ? b : [];
          for (let R of P)
            for (let N of d(R.selector)) {
              let C = N.includes(":-") || N.includes("::-") ? N : "__DEFAULT__";
              var E;
              let I = (E = g.get(C)) !== null && E !== void 0 ? E : /* @__PURE__ */ new Set();
              g.set(C, I), I.add(N);
            }
          if ((0, c.flagEnabled)(o, "optimizeUniversalDefaults")) {
            if (g.size === 0) {
              S.remove();
              continue;
            }
            for (let [, R] of g) {
              let N = n.default.rule({
                source: S.source
              });
              N.selectors = [
                ...R
              ], N.append(S.nodes.map((C) => C.clone())), S.before(N);
            }
          }
          S.remove();
        }
      else if (y.size) {
        let S = n.default.rule({
          selectors: [
            "*",
            "::before",
            "::after"
          ]
        });
        for (let P of y)
          S.append(P.nodes), S.parent || P.before(S), S.source || (S.source = P.source), P.remove();
        let g = S.clone({
          selectors: [
            "::backdrop"
          ]
        });
        S.after(g);
      }
    };
  }
})(mI);
var yI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return a;
    }
  });
  let e = {
    atrule: [
      "name",
      "params"
    ],
    rule: [
      "selector"
    ]
  }, n = new Set(Object.keys(e));
  function a() {
    function c(u) {
      let r = null;
      u.each((l) => {
        if (!n.has(l.type)) {
          r = null;
          return;
        }
        if (r === null) {
          r = l;
          return;
        }
        let i = e[l.type];
        var f, d;
        l.type === "atrule" && l.name === "font-face" ? r = l : i.every((s) => ((f = l[s]) !== null && f !== void 0 ? f : "").replace(/\s+/g, " ") === ((d = r[s]) !== null && d !== void 0 ? d : "").replace(/\s+/g, " ")) ? (l.nodes && r.append(l.nodes), l.remove()) : r = l;
      }), u.each((l) => {
        l.type === "atrule" && c(l);
      });
    }
    return (u) => {
      c(u);
    };
  }
})(yI);
var bI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e() {
    return (c) => {
      c.walkRules((u) => {
        let r = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Set([]), i = /* @__PURE__ */ new Map();
        u.walkDecls((f) => {
          if (f.parent === u) {
            if (r.has(f.prop)) {
              if (r.get(f.prop).value === f.value) {
                l.add(r.get(f.prop)), r.set(f.prop, f);
                return;
              }
              i.has(f.prop) || i.set(f.prop, /* @__PURE__ */ new Set()), i.get(f.prop).add(r.get(f.prop)), i.get(f.prop).add(f);
            }
            r.set(f.prop, f);
          }
        });
        for (let f of l)
          f.remove();
        for (let f of i.values()) {
          let d = /* @__PURE__ */ new Map();
          for (let s of f) {
            let o = a(s.value);
            o !== null && (d.has(o) || d.set(o, /* @__PURE__ */ new Set()), d.get(o).add(s));
          }
          for (let s of d.values()) {
            let o = Array.from(s).slice(0, -1);
            for (let m of o)
              m.remove();
          }
        }
      });
    };
  }
  let n = Symbol("unitless-number");
  function a(c) {
    let u = /^-?\d*.?\d+([\w%]+)?$/g.exec(c);
    if (u) {
      var r;
      return (r = u[1]) !== null && r !== void 0 ? r : n;
    }
    return null;
  }
})(bI);
var gI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return n;
    }
  });
  function e(a) {
    if (!a.walkAtRules)
      return;
    let c = /* @__PURE__ */ new Set();
    if (a.walkAtRules("apply", (u) => {
      c.add(u.parent);
    }), c.size !== 0)
      for (let u of c) {
        let r = [], l = [];
        for (let i of u.nodes)
          i.type === "atrule" && i.name === "apply" ? (l.length > 0 && (r.push(l), l = []), r.push([
            i
          ])) : l.push(i);
        if (l.length > 0 && r.push(l), r.length !== 1) {
          for (let i of [
            ...r
          ].reverse()) {
            let f = u.clone({
              nodes: []
            });
            f.append(i), u.after(f);
          }
          u.remove();
        }
      }
  }
  function n() {
    return (a) => {
      e(a);
    };
  }
})(gI);
var vI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return a;
    }
  });
  function e(c) {
    return c.type === "root";
  }
  function n(c) {
    return c.type === "atrule" && c.name === "layer";
  }
  function a(c) {
    return (u, r) => {
      let l = !1;
      u.walkAtRules("tailwind", (i) => {
        if (l)
          return !1;
        if (i.parent && !(e(i.parent) || n(i.parent)))
          return l = !0, i.warn(r, [
            "Nested @tailwind rules were detected, but are not supported.",
            "Consider using a prefix to scope Tailwind's classes: https://tailwindcss.com/docs/configuration#prefix",
            "Alternatively, use the important selector strategy: https://tailwindcss.com/docs/configuration#selector-strategy"
          ].join(`
`)), !1;
      }), u.walkRules((i) => {
        if (l)
          return !1;
        i.walkRules((f) => (l = !0, f.warn(r, [
          "Nested CSS was detected, but CSS nesting has not been configured correctly.",
          "Please enable a CSS nesting plugin *before* Tailwind in your configuration.",
          "See how here: https://tailwindcss.com/docs/using-with-preprocessors#nesting"
        ].join(`
`)), !1));
      });
    };
  }
})(vI);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return h;
    }
  });
  const e = /* @__PURE__ */ m(nI), n = /* @__PURE__ */ m(iI), a = /* @__PURE__ */ m(lI), c = /* @__PURE__ */ m(uI), u = /* @__PURE__ */ m(hI), r = /* @__PURE__ */ m(mI), l = /* @__PURE__ */ m(yI), i = /* @__PURE__ */ m(bI), f = /* @__PURE__ */ m(gI), d = /* @__PURE__ */ m(vI), s = ab(), o = _s;
  function m(y) {
    return y && y.__esModule ? y : {
      default: y
    };
  }
  function h(y) {
    return function(b, E) {
      let { tailwindDirectives: S, applyDirectives: g } = (0, e.default)(b);
      (0, d.default)()(b, E), (0, f.default)()(b, E);
      let P = y({
        tailwindDirectives: S,
        applyDirectives: g,
        registerDependency(R) {
          E.messages.push({
            plugin: "tailwindcss",
            parent: E.opts.from,
            ...R
          });
        },
        createContext(R, N) {
          return (0, s.createContext)(R, N, b);
        }
      })(b, E);
      if (P.tailwindConfig.separator === "-")
        throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.");
      (0, o.issueFlagNotices)(P.tailwindConfig), (0, n.default)(P)(b, E), (0, f.default)()(b, E), (0, a.default)(P)(b, E), (0, c.default)(P)(b, E), (0, u.default)(P)(b, E), (0, r.default)(P)(b, E), (0, l.default)(P)(b, E), (0, i.default)(P)(b, E);
    };
  }
})(rI);
var EI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "findAtConfigPath", {
    enumerable: !0,
    get: function() {
      return c;
    }
  });
  const e = /* @__PURE__ */ a(Dn), n = /* @__PURE__ */ a(Lr);
  function a(u) {
    return u && u.__esModule ? u : {
      default: u
    };
  }
  function c(u, r) {
    let l = null, i = null;
    return u.walkAtRules("config", (f) => {
      var d, s, o;
      if (i = (o = (s = (d = f.source) === null || d === void 0 ? void 0 : d.input.file) !== null && s !== void 0 ? s : r.opts.from) !== null && o !== void 0 ? o : null, i === null)
        throw f.error("The `@config` directive cannot be used without setting `from` in your PostCSS config.");
      if (l)
        throw f.error("Only one `@config` directive is allowed per file.");
      let m = f.params.match(/(['"])(.*?)\1/);
      if (!m)
        throw f.error("A path is required when using the `@config` directive.");
      let h = m[2];
      if (n.default.isAbsolute(h))
        throw f.error("The `@config` directive cannot be used with an absolute path.");
      if (l = n.default.resolve(n.default.dirname(i), h), !e.default.existsSync(l))
        throw f.error(`The config file at "${h}" does not exist. Make sure the path is correct and the file exists.`);
      f.remove();
    }), l || null;
  }
})(EI);
var WY = ad.exports;
Object.defineProperty(WY, "__esModule", {
  value: !0
});
const HY = /* @__PURE__ */ _I(ZS), xS = /* @__PURE__ */ _I(rI), PS = Xa, qY = EI;
function _I(t) {
  return t && t.__esModule ? t : {
    default: t
  };
}
ad.exports = function(e) {
  return {
    postcssPlugin: "tailwindcss",
    plugins: [
      PS.env.DEBUG && function(n) {
        return console.log(`
`), console.time("JIT TOTAL"), n;
      },
      function(n, a) {
        var c;
        e = (c = (0, qY.findAtConfigPath)(n, a)) !== null && c !== void 0 ? c : e;
        let u = (0, HY.default)(e);
        if (n.type === "document") {
          let r = n.nodes.filter((l) => l.type === "root");
          for (const l of r)
            l.type === "root" && (0, xS.default)(u)(l, a);
          return;
        }
        (0, xS.default)(u)(n, a);
      },
      !1,
      PS.env.DEBUG && function(n) {
        return console.timeEnd("JIT TOTAL"), console.log(`
`), n;
      }
    ].filter(Boolean)
  };
};
ad.exports.postcss = !0;
var GY = ad.exports, zY = GY;
const KY = /* @__PURE__ */ nd(zY);
var fg = { exports: {} }, Ef = Object.prototype.hasOwnProperty, SI = Object.prototype.toString, CS = Object.defineProperty, IS = Object.getOwnPropertyDescriptor, OS = function(e) {
  return typeof Array.isArray == "function" ? Array.isArray(e) : SI.call(e) === "[object Array]";
}, kS = function(e) {
  if (!e || SI.call(e) !== "[object Object]")
    return !1;
  var n = Ef.call(e, "constructor"), a = e.constructor && e.constructor.prototype && Ef.call(e.constructor.prototype, "isPrototypeOf");
  if (e.constructor && !n && !a)
    return !1;
  var c;
  for (c in e)
    ;
  return typeof c > "u" || Ef.call(e, c);
}, DS = function(e, n) {
  CS && n.name === "__proto__" ? CS(e, n.name, {
    enumerable: !0,
    configurable: !0,
    value: n.newValue,
    writable: !0
  }) : e[n.name] = n.newValue;
}, NS = function(e, n) {
  if (n === "__proto__")
    if (Ef.call(e, n)) {
      if (IS)
        return IS(e, n).value;
    } else
      return;
  return e[n];
}, YY = function t() {
  var e, n, a, c, u, r, l = arguments[0], i = 1, f = arguments.length, d = !1;
  for (typeof l == "boolean" && (d = l, l = arguments[1] || {}, i = 2), (l == null || typeof l != "object" && typeof l != "function") && (l = {}); i < f; ++i)
    if (e = arguments[i], e != null)
      for (n in e)
        a = NS(l, n), c = NS(e, n), l !== c && (d && c && (kS(c) || (u = OS(c))) ? (u ? (u = !1, r = a && OS(a) ? a : []) : r = a && kS(a) ? a : {}, DS(l, { name: n, newValue: t(d, r, c) })) : typeof c < "u" && DS(l, { name: n, newValue: c }));
  return l;
}, P0 = function(t, e) {
  var n = new t.constructor();
  return Object.keys(t).forEach(function(a) {
    if (t.hasOwnProperty(a)) {
      var c = t[a], u = typeof c;
      a === "parent" && u === "object" ? e && (n[a] = e) : a === "source" ? n[a] = c : c instanceof Array ? a === "nodes" ? n[a] = [] : n[a] = c.map(function(r) {
        P0(r, n);
      }) : a !== "before" && a !== "after" && a !== "between" && a !== "semicolon" && (u === "object" && (c = P0(c)), n[a] = c);
    }
  }), n;
}, dg = P0, XY = wI;
function wI(t, e, n) {
  t instanceof RegExp && (t = RS(t, n)), e instanceof RegExp && (e = RS(e, n));
  var a = TI(t, e, n);
  return a && {
    start: a[0],
    end: a[1],
    pre: n.slice(0, a[0]),
    body: n.slice(a[0] + t.length, a[1]),
    post: n.slice(a[1] + e.length)
  };
}
function RS(t, e) {
  var n = e.match(t);
  return n ? n[0] : null;
}
wI.range = TI;
function TI(t, e, n) {
  var a, c, u, r, l, i = n.indexOf(t), f = n.indexOf(e, i + 1), d = i;
  if (i >= 0 && f > 0) {
    if (t === e)
      return [i, f];
    for (a = [], u = n.length; d >= 0 && !l; )
      d == i ? (a.push(d), i = n.indexOf(t, d + 1)) : a.length == 1 ? l = [a.pop(), f] : (c = a.pop(), c < u && (u = c, r = f), f = n.indexOf(e, d + 1)), d = i < f && i >= 0 ? i : f;
    a.length && (l = [u, r]);
  }
  return l;
}
var JY = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?![><+~\s]).)+)(?:(?:(?:\s(?!>>))|(?:\t(?!>>))|(?:\s?>>\s?))(?!\s+))(?![><+~][\s]+?))/, QY = function(t) {
  return t.split(JY).filter(function(e) {
    return e.length > 0;
  }).map(function(e) {
    return e.trim().replace(/\s*?>>\s*?/g, "");
  });
}, ZY = QY, eX = ZY, tX = function(t, e) {
  e = e || !1;
  for (var n = [
    // Start off with one branch
    []
  ], a = e ? t : t.parent; a; ) {
    var c = (a.selectors || []).map(function(r) {
      return {
        value: r,
        type: "selector"
      };
    });
    a.type === "atrule" && (c = [].concat(a.params).map(function(r) {
      return {
        value: "@" + a.name + " " + r,
        type: "atrule"
      };
    }));
    var u = (c.length > 0 ? c : [1]).map(function() {
      return n.map(function(r) {
        return r.slice(0);
      });
    });
    c.forEach(function(r, l) {
      u[l] = u[l].map(function(i) {
        var f = [r.value];
        return r.type === "selector" && (f = eX(r.value)), i.unshift.apply(i, f), i;
      });
    }), n = [], u.forEach(function(r) {
      n = n.concat(r);
    }), a = a.parent;
  }
  return n;
}, Op = tX, rX = /[|\\{}()[\]^$+*?.]/g, nX = function(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(rX, "\\$&");
}, iX = {
  "*": !0,
  ":root": !0,
  html: !0
}, sX = function(t) {
  return !!iX[t];
}, aX = sX, oX = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?!>>|<|\+|~|\s).)+)(?:(?:(?:>(?!>))|(?:\s?>(?!>)\s?))(?!\s+))(?!(?:>>|<|\+|~)[\s]+?))/, lX = function(t) {
  return t.split(oX).filter(function(e) {
    return e.length > 0;
  }).map(function(e) {
    return e.trim().replace(/\s*?>\s*?/g, "");
  });
}, uX = lX, cX = nX, MS = aX, LS = uX, fX = /^@.*/, AI = new RegExp("([^\\s:]+)(?<!\\\\)((?::|::)[^\\s]*?)(\\s+|$)");
function xI(t, e) {
  var n, a, c = e.some(function(u) {
    return t.some(function(r) {
      n = null;
      var l = !0;
      for (a = 0; a < u.length; a++) {
        for (var i = u[a], f = n || 0, d = -1, s = r.slice(f), o = 0; o < s.length; o++) {
          var m = s[o], h = f + o;
          if (
            // If the part on the end of the piece itself matches:
            //		scopePiece `.bar` matches node `.bar`
            //		scopePiece `.bar` matches node `.foo + .bar`
            new RegExp(cX(i) + "$").test(m)
          ) {
            d = h;
            break;
          }
          if (MS(i) || MS(m)) {
            d = h;
            break;
          }
          var y = LS(m);
          if (y.length > 1) {
            var b = [].concat([y]), E = [].concat([
              u.slice(a).reduce(function(P, R) {
                return P.concat(LS(R));
              }, [])
            ]), S = xI(b, E);
            (S.doesMatchScope || a + 1 < u.length) && (d = h, a += S.scopePieceIndex - 1);
            break;
          }
        }
        var g = d >= f;
        if (n = d + 1, l = l && g, !l)
          break;
      }
      return l;
    });
  });
  return {
    doesMatchScope: c,
    nodeScopePieceIndex: n - 1,
    scopePieceIndex: a
  };
}
var jS = function(t) {
  return t.map(function(e) {
    return e.map(function(n) {
      return fX.test(n) ? n : n.replace(new RegExp(AI.source, "g"), function(a, c, u, r) {
        return c + r;
      });
    });
  });
}, PI = function(t, e, n) {
  return t = jS(t), n && (e = jS(e)), xI(t, e).doesMatchScope;
};
PI.RE_PSEUDO_SELECTOR = AI;
var CI = PI, dX = CI, FS = Op, pX = function(t, e, n) {
  var a = FS(t, !0), c = FS(e, !0);
  return dX(a, c, n);
}, II = pX, OI = function(t, e, n) {
  n = n || [];
  var a = !1;
  return t && (n = t.reduce(function(c, u) {
    var r = !!e[u], l = r ? c.some(function(i) {
      return e[u].some(function(f) {
        return i === f;
      });
    }) : !1;
    return a = a || l, r && !a && (c = c.concat(e[u]), (e[u] || []).forEach(function(i) {
      var f = OI(i.variablesUsed, e, c);
      c = f.deps, a = a || f.hasCircularOrSelfReference;
    })), c;
  }, n)), {
    deps: n,
    hasCircularOrSelfReference: a
  };
}, kI = OI, hX = Op, mX = function(t, e) {
  for (var n, a = e; a.parent && !n; ) {
    var c = hX(a.clone(), !0);
    c.some(function(u) {
      return u.some(function(r) {
        return r === t ? (n = a, !0) : !1;
      });
    }), a = a.parent;
  }
  return n;
}, DI = mX, BS = dg, yX = function(t, e, n) {
  n = n || function() {
    return !0;
  };
  for (var a = [], c = t, u = !1; c && !u; )
    c.type === "decl" ? a.push(c.clone()) : a.push(BS(c)), u = n(c), c = c.parent;
  for (var r = [], l = e; l; )
    r.push(BS(l)), l = l.parent;
  return r.forEach(function(i, f, d) {
    f + 1 < d.length && (i.parent = d[f + 1]);
  }), a.forEach(function(i, f, d) {
    f + 1 < d.length ? i.parent = d[f + 1] : (r.slice(-1)[0].parent = c, i.parent = r[0]);
  }), a[0];
}, NI = yX, bX = XY, gX = Op, $S = II, vX = kI, EX = DI, _X = NI, SX = /var\(\s*(--[^,\s)]+)/;
function wX(t) {
  return String(t);
}
function td(t) {
  var e = bX("(", ")", t);
  if (e) {
    if (/(?:^|[^\w-])var$/.test(e.pre))
      return {
        pre: e.pre.slice(0, -3),
        body: e.body,
        post: e.post
      };
    var n = td(e.body);
    if (n)
      return {
        pre: e.pre + "(" + n.pre,
        body: n.body,
        post: n.post + ")" + e.post
      };
    var a = td(e.post);
    if (a)
      return {
        pre: e.pre + "(" + e.body + ")" + a.pre,
        body: a.body,
        post: a.post
      };
  }
}
var rd = function(t, e, n, a) {
  for (var c = void 0, u = wX(t.value), r = [], l = {}, i = u; c = td(i); ) {
    var f = c.body.split(","), d = f[0].trim();
    l[d] = !0, i = (c.pre || "") + c.body.replace(d, "") + (c.post || "");
  }
  i = void 0;
  for (var s = Object.keys(l), o = !1; c = td(u); ) {
    var m = void 0, f = c.body.split(","), d = f[0].trim(), h = f.length > 1 ? f.slice(1).join(",").trim() : void 0;
    (e[d] || []).forEach(function(N) {
      N.parent.type === "root" || N.parent.selectors[0], $S(t.parent, N.parent);
      var C = $S(t.parent, N.parent, n);
      C && // And if the currently matched declaration is `!important`, it will take another `!important` to override it
      (!(m || {}).isImportant || N.isImportant) && (m = N);
    });
    var y = (m || {}).calculatedInPlaceValue || function() {
      var N = h;
      if (h) {
        var C = t.clone({ parent: t.parent, value: h });
        N = rd(C, e, !1).value;
      }
      return N;
    }();
    if (m !== void 0 && !vX(s, e).hasCircularOrSelfReference) {
      var b = gX(t.parent.parent, !0), E = b[0].slice(-1)[0], S = EX(E, m.decl.parent), g = _X(m.decl, t.parent.parent, function(N) {
        return N === S;
      });
      y = rd(g, e, !1).value;
    }
    o = y === void 0, o && r.push(["variable " + d + " is undefined and used without a fallback", { node: t }]), u = (c.pre || "") + y + (c.post || "");
  }
  return {
    // The resolved value
    value: o ? void 0 : u,
    // Array of variable names used in resolving this value
    variablesUsed: s,
    // Any warnings generated from parsing this value
    warnings: r
  };
};
rd.RE_VAR_FUNC = SX;
var RI = rd, US = RI, TX = Op, AX = kI, VS = CI, xX = II, _f = dg, PX = DI, CX = NI;
function IX(t, e, n, a) {
  t.forEach(function(c) {
    AX(t, e).deps.forEach(function(u) {
      var r;
      if (u.isUnderAtRule) {
        var l = TX(u.parent, !0), i = l[0].slice(-1)[0], f = PX(i, n.parent), d = u.parent.parent;
        r = CX(n, d, function(h) {
          return h === f;
        });
      } else if (VS.RE_PSEUDO_SELECTOR.test(u.parent.selector)) {
        var s = _f(n.parent);
        s.parent = n.parent.parent, r = n.clone(), s.append(r);
        var o = u.parent.selector.match(new RegExp(VS.RE_PSEUDO_SELECTOR.source + "$")), m = o ? o[2] : "";
        s.selector += m;
      }
      r && xX(r, u.parent, !0) && a(r, u);
    });
  });
}
function OX(t, e, n, a, c) {
  n = (typeof n == "function" ? n(t) : n) || !1, a = a || !1;
  var u = function(i) {
    return c && c(i), i;
  }, r = u(US(t, e)), l;
  IX(r.variablesUsed, e, t, function(i, f) {
    var d = _f(t.parent), s = t.clone();
    d.append(s);
    let o;
    if (typeof n == "function" ? o = n(t) : o = n, o === !0 && s.cloneAfter(), s.value = u(US(i, e, !0)).value, f.isUnderAtRule) {
      var m = _f(f.parent.parent);
      m.append(d);
      for (var h = m, y = f.parent.parent; y.parent.type === "atrule"; ) {
        var b = _f(y.parent);
        b.append(h), h = b, y = y.parent;
      }
      m !== h && (t.parent.parent.insertAfter(a && l || t.parent, h), l = h);
    } else
      d.selector = i.parent.selector, t.parent.parent.insertAfter(a && l || t.parent, d);
  }), n === !0 && t.value !== r.value && t.cloneAfter(), r.value === void 0 && (r.value = "undefined"), t.value = r.value;
}
var kX = OX, WS = YY, DX = dg, HS = RI, NX = kX, MI = /(--(.+))/;
function RX(t, e) {
  t.walkDecls(function(n) {
    MI.test(n.prop) && e(n);
  });
}
function MX(t) {
  for (var e = t; e && e.nodes.length <= 0; ) {
    var n = e.type !== "root" ? e : null;
    n ? (e = n.parent, n.remove()) : e = null;
  }
}
var LX = {
  // Allows you to preserve custom properties & var() usage in output.
  // `true`, `false`, or `'computed'`
  preserve: !1,
  // Define variables via JS
  // Simple key-value pair
  // or an object with a `value` property and an optional `isImportant` bool property
  variables: {},
  // Preserve variables injected via JS with the `variables` option above
  // before serializing to CSS (`false` will remove these variables from output)
  preserveInjectedVariables: !0,
  // Will write media queries in the same order as in the original file.
  // Currently defaulted to false for legacy behavior. We can update to `true` in a major version
  preserveAtRulesOrder: !1
};
fg.exports = (t = {}) => {
  var e = WS({}, LX, t);
  return {
    postcssPlugin: "postcss-css-variables",
    Once(n, { decl: a, result: c, rule: u }) {
      var r = [], l = [], i = {};
      i = WS(
        i,
        Object.keys(e.variables).reduce(
          function(s, o) {
            var m = e.variables[o];
            o = o.slice(0, 2) === "--" ? o : "--" + o;
            var h = (m || {}).value || m, y = (m || {}).isImportant || !1, b = u({ selector: ":root" });
            n.root().prepend(b);
            var E = a({
              prop: o,
              value: h,
              important: y
            });
            return b.append(E), e.preserveInjectedVariables || l.push(E), s[o] = (s[o] || []).concat({
              decl: E,
              prop: o,
              calculatedInPlaceValue: h,
              isImportant: y,
              variablesUsed: [],
              parent: b,
              isUnderAtRule: !1
            }), s;
          },
          {}
        )
      );
      var f = function(s) {
        var o = [].concat(s.warnings);
        return o.forEach(function(m) {
          m = [].concat(m), c.warn.apply(c, m);
        }), s;
      };
      RX(n, function(s) {
        var o = s.parent, m = f(HS(s, i));
        s.parent.selectors.forEach(function(y) {
          var b = DX(s.parent);
          b.selector = y, b.parent = s.parent.parent;
          var E = s.clone();
          b.append(E);
          var S = s.prop;
          i[S] = (i[S] || []).concat({
            decl: E,
            prop: S,
            calculatedInPlaceValue: m.value,
            isImportant: s.important || !1,
            variablesUsed: m.variablesUsed,
            parent: b,
            // variables inside root or at-rules (eg. @media, @support)
            isUnderAtRule: b.parent.type === "atrule"
          });
        });
        let h;
        typeof e.preserve == "function" ? h = e.preserve(s) : h = e.preserve, h ? h === "computed" && (s.value = m.value) : s.remove(), o.nodes.length <= 0 && r.push(o);
      });
      var d = [];
      n.walk(function(s) {
        if (s.nodes !== void 0) {
          var o = s.nodes.some(function(m) {
            if (m.type === "decl") {
              var h = m;
              if (HS.RE_VAR_FUNC.test(h.value) && !MI.test(h.prop))
                return !0;
            }
            return !1;
          });
          o && (s.type === "rule" && s.selectors.length > 1 ? (s.selectors.reverse().forEach(function(m) {
            var h = s.cloneAfter();
            return h.selector = m, h;
          }), s.remove()) : d.push(s));
        }
      }), d.forEach(function(s) {
        s.nodes.slice(0).forEach(function(o) {
          if (o.type === "decl") {
            var m = o;
            NX(
              m,
              i,
              e.preserve,
              e.preserveAtRulesOrder,
              f
            );
          }
        });
      }), r.forEach(MX), l.forEach(function(s) {
        s.remove();
      });
    }
  };
};
fg.exports.postcss = !0;
var jX = fg.exports;
const FX = /* @__PURE__ */ nd(jX);
Pr.stringify;
Pr.fromJSON;
Pr.plugin;
Pr.parse;
Pr.list;
Pr.document;
Pr.comment;
Pr.atRule;
Pr.rule;
Pr.decl;
Pr.root;
Pr.CssSyntaxError;
Pr.Declaration;
Pr.Container;
Pr.Processor;
Pr.Document;
Pr.Comment;
Pr.Warning;
Pr.AtRule;
Pr.Result;
Pr.Input;
Pr.Rule;
Pr.Root;
Pr.Node;
Ve.global.__OXIDE__ = void 0;
const BX = (t, e) => {
  const n = e == null ? void 0 : e.corePlugins, a = {
    ...e,
    corePlugins: {
      preflight: !1,
      ...n
    }
  };
  return Pr([
    KY({
      ...a,
      content: [{ raw: t, extension: "html" }]
    }),
    FX()
  ]).process(
    String.raw`
        @tailwind base;
        @tailwind components;
        @tailwind utilities;
      `,
    { from: void 0 }
    // no need to use from since the `content` context is sent into tailwind
  ).css;
}, $X = (t) => {
  const e = /rgb\(\s*(\d+)\s*(\d+)\s*(\d+)(?:\s*\/\s*([\d%.]+))?\s*\)/gm;
  return t.replaceAll(e, (n, a, c, u, r) => {
    const l = r === "1" || typeof r > "u" ? "" : `,${r}`;
    return `rgb(${a},${c},${u}${l})`;
  });
}, UX = (t) => t.replace(/-(\w|$)/g, (e, n) => n.toUpperCase()), VX = (t) => {
  let e = t;
  return e = e.toLowerCase(), e === "float" ? "cssFloat" : e.startsWith("--") ? e : (e.startsWith("-ms-") && (e = e.slice(1)), UX(e));
}, WX = (t) => Array.from(
  t.matchAll(
    /([a-zA-Z0-9\-_]+)\s*:\s*('[^']*'[^;]*|"[^"]*"[^;]*|[^;]*?\([^)]*\)[^;]*|[^;(]*);?/gm
  )
).map(([e, n, a]) => ({
  property: n,
  value: a.replaceAll(/[\r\n|\r|\n]+/g, "").replaceAll(/\s+/g, " ")
})), HX = (t) => {
  const e = {}, n = WX(t);
  for (const { property: a, value: c } of n)
    a.length > 0 && c.trim().length > 0 && (e[VX(a)] = c.trim());
  return e;
};
function C0(t) {
  return t.replaceAll(/\\[0-9]|\\/g, "");
}
const LI = (t) => t.replaceAll("+", "plus").replaceAll("[", "").replaceAll("%", "pc").replaceAll("]", "").replaceAll("(", "").replaceAll(")", "").replaceAll("!", "imprtnt").replaceAll(">", "gt").replaceAll("<", "lt").replaceAll("=", "eq").replace(/[^a-zA-Z0-9\-_]/g, "_");
function qX(t) {
  const e = C0(t);
  return LI(e);
}
function GX(t) {
  return t.split(";").map(
    (e) => e.endsWith("!important") ? e.trim() : `${e.trim()}!important`
  ).join(";");
}
function zX(t, e) {
  const n = Jc(/* @__PURE__ */ Gl.jsx(Gl.Fragment, { children: t })), a = $X(BX(n, e)), [c, u] = PO(a), r = {};
  for (const f of Mg(c)) {
    const d = C0(f.selector);
    r[d] = HX(f.content);
  }
  const l = [], i = u.map((f) => {
    let d = f;
    for (const s of Mg(f))
      l.push(C0(s.selector)), d = d.replace(
        s.value,
        s.value.replace(s.selector, qX(s.selector)).replace(s.content, GX(s.content)).trim()
      );
    return d.replace(/(\r\n|\r|\n)+/gm, "").replace(/\s+/gm, " ");
  });
  return {
    stylePerClassMap: r,
    sanitizedMediaQueries: i,
    nonInlinableClasses: l
  };
}
function KX(t) {
  return (e) => {
    const n = e.split(" "), a = [];
    let c = {};
    for (const u of n)
      u in t ? c = {
        ...c,
        ...t[u]
      } : a.push(u);
    return {
      styles: c,
      residualClassName: a.join(" ")
    };
  };
}
const YX = (t) => t.replace(/\/\*[\s\S]*?\*\//gm, "").replace(/;\s+/gm, ";").replace(/:\s+/gm, ":").replace(/\)\s*{/gm, "){").replace(/\s+\(/gm, "(").replace(/{\s+/gm, "{").replace(/}\s+/gm, "}").replace(/\s*{/gm, "{").replace(/;?\s*}/gm, "}"), EJ = ({ children: t, config: e }) => {
  const { stylePerClassMap: n, nonInlinableClasses: a, sanitizedMediaQueries: c } = zX(t, e ?? {}), u = KX(n), r = c.filter(
    (s) => s.trim().length > 0
  ), l = r.length > 0;
  let i = !1;
  function f(s) {
    const o = {};
    if (!i && l && s.type === "head") {
      i = !0;
      const y = /* @__PURE__ */ Gl.jsx("style", { children: YX(r.join("")) });
      return Ys.cloneElement(
        s,
        s.props,
        s.props.children,
        y
      );
    }
    if (s.props.children && (o.children = Ys.Children.map(
      s.props.children,
      (y) => Ys.isValidElement(y) ? f(y) : y
    )), s.props.className) {
      const { styles: y, residualClassName: b } = u(s.props.className);
      if (o.style = {
        ...s.props.style,
        ...y
      }, b.trim().length > 0) {
        o.className = b;
        for (const E of a)
          o.className = o.className.replace(
            E,
            LI(E)
          );
      } else
        o.className = void 0;
    }
    const m = {
      ...s.props,
      ...o
    }, h = o.children ? o.children : s.props.children;
    if (typeof s.type == "function") {
      const y = s.type, b = y({
        ...s.props,
        ...o
      });
      if (Ys.isValidElement(b))
        return f(b);
    }
    return Ys.cloneElement(s, m, h);
  }
  const d = Ys.Children.map(t, (s) => Ys.isValidElement(s) ? f(s) : s) ?? [];
  if (l && !i)
    throw new Error(
      `You are trying to use the following Tailwind classes that have media queries: ${a.join(
        " "
      )}.
For the media queries to work properly on rendering, they need to be added into a <style> tag inside of a <head> tag,
the Tailwind component tried finding a <head> element but just wasn't able to find it.

Make sure that you have either a <head> element at some point inside of the <Tailwind> component at any depth.

If you do already have a <head> element at some depth, please file a bug https://github.com/resend/react-email/issues/new?assignees=&labels=Type%3A+Bug&projects=&template=1.bug_report.yml.`
    );
  return /* @__PURE__ */ Gl.jsx(Gl.Fragment, { children: d });
};
export {
  EJ as Tailwind
};
